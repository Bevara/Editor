/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/html-entities/lib/html4-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html4-entities.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");
var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
var alphaIndex = {};
var numIndex = {};
(function () {
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
        var a = HTML_ALPHA[i];
        var c = HTML_CODES[i];
        alphaIndex[a] = String.fromCharCode(c);
        numIndex[c] = a;
        i++;
    }
})();
var Html4Entities = /** @class */ (function () {
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1).toLowerCase() === 'x' ?
                    parseInt(entity.substr(2), 16) :
                    parseInt(entity.substr(1));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        chr = String.fromCharCode(code);
                    }
                    else {
                        chr = surrogate_pairs_1.fromCodePoint(code);
                    }
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html4Entities.decode = function (str) {
        return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var alpha = numIndex[str.charCodeAt(i)];
            result += alpha ? "&" + alpha + ";" : str.charAt(i);
            i++;
        }
        return result;
    };
    Html4Entities.encode = function (str) {
        return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var cc = str.charCodeAt(i);
            var alpha = numIndex[cc];
            if (alpha) {
                result += "&" + alpha + ";";
            }
            else if (cc < 32 || cc > 126) {
                if (cc >= surrogate_pairs_1.highSurrogateFrom && cc <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + cc + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonUTF = function (str) {
        return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i++;
            }
            else {
                result += '&#' + c + ';';
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonASCII = function (str) {
        return new Html4Entities().encodeNonASCII(str);
    };
    return Html4Entities;
}());
exports.Html4Entities = Html4Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/html5-entities.js":
/*!**********************************************************!*\
  !*** ./node_modules/html-entities/lib/html5-entities.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");
var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
var DECODE_ONLY_ENTITIES = [['NewLine', [10]]];
var alphaIndex = {};
var charIndex = {};
createIndexes(alphaIndex, charIndex);
var Html5Entities = /** @class */ (function () {
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1) === 'x' ?
                    parseInt(entity.substr(2).toLowerCase(), 16) :
                    parseInt(entity.substr(1));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        chr = String.fromCharCode(code);
                    }
                    else {
                        chr = surrogate_pairs_1.fromCodePoint(code);
                    }
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html5Entities.decode = function (str) {
        return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var charInfo = charIndex[str.charCodeAt(i)];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            result += str.charAt(i);
            i++;
        }
        return result;
    };
    Html5Entities.encode = function (str) {
        return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var charInfo = charIndex[c];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            if (c < 32 || c > 126) {
                if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + c + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonUTF = function (str) {
        return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i += 2;
            }
            else {
                result += '&#' + c + ';';
                i++;
            }
        }
        return result;
    };
    Html5Entities.encodeNonASCII = function (str) {
        return new Html5Entities().encodeNonASCII(str);
    };
    return Html5Entities;
}());
exports.Html5Entities = Html5Entities;
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    while (i--) {
        var _a = ENTITIES[i], alpha = _a[0], _b = _a[1], chr = _b[0], chr2 = _b[1];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo = void 0;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chr2) {
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            addChar && (charInfo[chr2] = alpha);
        }
        else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            addChar && (charInfo[''] = alpha);
        }
    }
    i = DECODE_ONLY_ENTITIES.length;
    while (i--) {
        var _c = DECODE_ONLY_ENTITIES[i], alpha = _c[0], _d = _c[1], chr = _d[0], chr2 = _d[1];
        alphaIndex[alpha] = String.fromCharCode(chr) + (chr2 ? String.fromCharCode(chr2) : '');
    }
}


/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var xml_entities_1 = __webpack_require__(/*! ./xml-entities */ "./node_modules/html-entities/lib/xml-entities.js");
exports.XmlEntities = xml_entities_1.XmlEntities;
var html4_entities_1 = __webpack_require__(/*! ./html4-entities */ "./node_modules/html-entities/lib/html4-entities.js");
exports.Html4Entities = html4_entities_1.Html4Entities;
var html5_entities_1 = __webpack_require__(/*! ./html5-entities */ "./node_modules/html-entities/lib/html5-entities.js");
exports.Html5Entities = html5_entities_1.Html5Entities;
exports.AllHtmlEntities = html5_entities_1.Html5Entities;


/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xD800, (astralCodePoint - 0x10000) % 0x400 + 0xDC00);
};
exports.getCodePoint = String.prototype.codePointAt ?
    function (input, position) {
        return input.codePointAt(position);
    } :
    function (input, position) {
        return (input.charCodeAt(position) - 0xD800) * 0x400
            + input.charCodeAt(position + 1) - 0xDC00 + 0x10000;
    };
exports.highSurrogateFrom = 0xD800;
exports.highSurrogateTo = 0xDBFF;


/***/ }),

/***/ "./node_modules/html-entities/lib/xml-entities.js":
/*!********************************************************!*\
  !*** ./node_modules/html-entities/lib/xml-entities.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");
var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};
var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};
var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};
var XmlEntities = /** @class */ (function () {
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/[<>"'&]/g, function (s) {
            return CHAR_S_INDEX[s];
        });
    };
    XmlEntities.encode = function (str) {
        return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
            if (s.charAt(1) === '#') {
                var code = s.charAt(2).toLowerCase() === 'x' ?
                    parseInt(s.substr(3), 16) :
                    parseInt(s.substr(2));
                if (!isNaN(code) || code >= -32768) {
                    if (code <= 65535) {
                        return String.fromCharCode(code);
                    }
                    else {
                        return surrogate_pairs_1.fromCodePoint(code);
                    }
                }
                return '';
            }
            return ALPHA_INDEX[s] || s;
        });
    };
    XmlEntities.decode = function (str) {
        return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var alpha = CHAR_INDEX[c];
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
            if (c < 32 || c > 126) {
                if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                    result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                    i++;
                }
                else {
                    result += '&#' + c + ';';
                }
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonUTF = function (str) {
        return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            if (c >= surrogate_pairs_1.highSurrogateFrom && c <= surrogate_pairs_1.highSurrogateTo) {
                result += '&#' + surrogate_pairs_1.getCodePoint(str, i) + ';';
                i++;
            }
            else {
                result += '&#' + c + ';';
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonASCII = function (str) {
        return new XmlEntities().encodeNonASCII(str);
    };
    return XmlEntities;
}());
exports.XmlEntities = XmlEntities;


/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = level;
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          self.setLevel(defaultLevel, false);
          clearPersistedLevel();
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");


/***/ }),

/***/ "./node_modules/sockjs-client/dist/sockjs.js":
/*!***************************************************!*\
  !*** ./node_modules/sockjs-client/dist/sockjs.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* sockjs-client v1.6.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47}],8:[function(require,module,exports){
(function (process){(function (){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this)}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55}],9:[function(require,module,exports){
(function (process){(function (){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this)}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57}],11:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57}],12:[function(require,module,exports){
(function (process){(function (){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this)}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){(function (){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    // exception is 127.0.0.0/8 and ::1 urls
    if (!urlUtils.isLoopbackAddr(parsedUrl.hostname)) {
      throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
    }
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"url-parse":60}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){(function (){
module.exports = global.EventSource;

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){(function (){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){(function (){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this)}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57}],23:[function(require,module,exports){
(function (global){(function (){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this)}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this)}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){(function (){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this)}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this)}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this)}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){(function (){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this)}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this)}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){(function (){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){(function (){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){(function (){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex, no-misleading-character-class
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{}],46:[function(require,module,exports){
(function (global){(function (){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

var eventUtils = require('./event')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this)}).call(this,{ env: {} },typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55}],48:[function(require,module,exports){
(function (global){(function (){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){(function (){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this)}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){(function (){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }

, isLoopbackAddr: function (addr) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^\[::1\]$/.test(addr);
  }
};

}).call(this)}).call(this,{ env: {} })

},{"debug":55,"url-parse":60}],53:[function(require,module,exports){
module.exports = '1.6.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){(function (){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this)}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],58:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],59:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],60:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":58,"requires-port":59}]},{},[1])(1)
});




/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/BaseClient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/BaseClient.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports = /*#__PURE__*/function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/SockJSClient.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var SockJS = __webpack_require__(/*! sockjs-client/dist/sockjs */ "./node_modules/sockjs-client/dist/sockjs.js");

var BaseClient = __webpack_require__(/*! ./BaseClient */ "./node_modules/webpack-dev-server/client/clients/BaseClient.js");

module.exports = /*#__PURE__*/function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  var _super = _createSuper(SockJSClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _super.call(this);
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(/*! ./SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(/*! ansi-html-community */ "./node_modules/ansi-html-community/index.js");

var _require = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/lib/index.js"),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/SockJSClient.js */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");

/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(/*! ./clients/SockJSClient */ "./node_modules/webpack-dev-server/client/clients/SockJSClient.js");
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketUrl.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global self */

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var getCurrentScriptSource = __webpack_require__(/*! ./getCurrentScriptSource */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var log = (__webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js").getLogger)('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(/*! ./log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(/*! webpack/hot/emitter */ "./node_modules/webpack/hot/emitter.js");

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/webpack-dev-server/node_modules/ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
module.exports = new EventEmitter();


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function (level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function (level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function (level) {
	logLevel = level;
};

module.exports.formatError = function (err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),

/***/ "./node_modules/ws/browser.js":
/*!************************************!*\
  !*** ./node_modules/ws/browser.js ***!
  \************************************/
/***/ ((module) => {

"use strict";


module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};


/***/ }),

/***/ "./webinterface/core-coder.js":
/*!************************************!*\
  !*** ./webinterface/core-coder.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Module": () => (/* binding */ Module),
/* harmony export */   "location": () => (/* binding */ location),
/* harmony export */   "memio": () => (/* binding */ memio)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);

var Module = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(Module) {
  Module = Module || {};



// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};
var filter_entries = Module['filter_entries'] || [];
var module_entries = Module['module_entries'] || [];

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

Object.defineProperty(Module, "filter_entries", { configurable: true, get: function() { return filter_entries } });
Object.defineProperty(Module, "module_entries", { configurable: true, get: function() { return module_entries } });

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_unlock')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_unlock', { configurable: true, get: function() { abort('You are getting _pthread_mutex_unlock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_unlock', { configurable: true, set: function() { abort('You are setting _pthread_mutex_unlock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_lock')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_lock', { configurable: true, get: function() { abort('You are getting _pthread_mutex_lock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_lock', { configurable: true, set: function() { abort('You are setting _pthread_mutex_lock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_self')) {
        Object.defineProperty(Module['ready'], '_pthread_self', { configurable: true, get: function() { abort('You are getting _pthread_self on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_self', { configurable: true, set: function() { abort('You are setting _pthread_self on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sprintf')) {
        Object.defineProperty(Module['ready'], '_sprintf', { configurable: true, get: function() { abort('You are getting _sprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sprintf', { configurable: true, set: function() { abort('You are setting _sprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_vfprintf')) {
        Object.defineProperty(Module['ready'], '_vfprintf', { configurable: true, get: function() { abort('You are getting _vfprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_vfprintf', { configurable: true, set: function() { abort('You are setting _vfprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fprintf')) {
        Object.defineProperty(Module['ready'], '_fprintf', { configurable: true, get: function() { abort('You are getting _fprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fprintf', { configurable: true, set: function() { abort('You are setting _fprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_bsearch')) {
        Object.defineProperty(Module['ready'], '_bsearch', { configurable: true, get: function() { abort('You are getting _bsearch on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_bsearch', { configurable: true, set: function() { abort('You are setting _bsearch on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_frexp')) {
        Object.defineProperty(Module['ready'], '_frexp', { configurable: true, get: function() { abort('You are getting _frexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_frexp', { configurable: true, set: function() { abort('You are setting _frexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_llrint')) {
        Object.defineProperty(Module['ready'], '_llrint', { configurable: true, get: function() { abort('You are getting _llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_llrint', { configurable: true, set: function() { abort('You are setting _llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fwrite')) {
        Object.defineProperty(Module['ready'], '_fwrite', { configurable: true, get: function() { abort('You are getting _fwrite on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fwrite', { configurable: true, set: function() { abort('You are setting _fwrite on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_cos')) {
        Object.defineProperty(Module['ready'], '_cos', { configurable: true, get: function() { abort('You are getting _cos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_cos', { configurable: true, set: function() { abort('You are setting _cos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_cosh')) {
        Object.defineProperty(Module['ready'], '_cosh', { configurable: true, get: function() { abort('You are getting _cosh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_cosh', { configurable: true, set: function() { abort('You are setting _cosh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_acos')) {
        Object.defineProperty(Module['ready'], '_acos', { configurable: true, get: function() { abort('You are getting _acos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_acos', { configurable: true, set: function() { abort('You are setting _acos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sin')) {
        Object.defineProperty(Module['ready'], '_sin', { configurable: true, get: function() { abort('You are getting _sin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sin', { configurable: true, set: function() { abort('You are setting _sin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sinh')) {
        Object.defineProperty(Module['ready'], '_sinh', { configurable: true, get: function() { abort('You are getting _sinh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sinh', { configurable: true, set: function() { abort('You are setting _sinh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_asin')) {
        Object.defineProperty(Module['ready'], '_asin', { configurable: true, get: function() { abort('You are getting _asin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_asin', { configurable: true, set: function() { abort('You are setting _asin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_tan')) {
        Object.defineProperty(Module['ready'], '_tan', { configurable: true, get: function() { abort('You are getting _tan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_tan', { configurable: true, set: function() { abort('You are setting _tan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_tanh')) {
        Object.defineProperty(Module['ready'], '_tanh', { configurable: true, get: function() { abort('You are getting _tanh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_tanh', { configurable: true, set: function() { abort('You are setting _tanh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_atan')) {
        Object.defineProperty(Module['ready'], '_atan', { configurable: true, get: function() { abort('You are getting _atan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_atan', { configurable: true, set: function() { abort('You are setting _atan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_exp')) {
        Object.defineProperty(Module['ready'], '_exp', { configurable: true, get: function() { abort('You are getting _exp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_exp', { configurable: true, set: function() { abort('You are setting _exp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_log')) {
        Object.defineProperty(Module['ready'], '_log', { configurable: true, get: function() { abort('You are getting _log on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_log', { configurable: true, set: function() { abort('You are setting _log on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fabs')) {
        Object.defineProperty(Module['ready'], '_fabs', { configurable: true, get: function() { abort('You are getting _fabs on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fabs', { configurable: true, set: function() { abort('You are setting _fabs on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strncmp')) {
        Object.defineProperty(Module['ready'], '_strncmp', { configurable: true, get: function() { abort('You are getting _strncmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strncmp', { configurable: true, set: function() { abort('You are setting _strncmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strdup')) {
        Object.defineProperty(Module['ready'], '_strdup', { configurable: true, get: function() { abort('You are getting _strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strdup', { configurable: true, set: function() { abort('You are setting _strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_timescale')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_timescale', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_timescale on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_timescale', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_timescale on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_cts')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_cts', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_cts', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_duration')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_duration', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_duration', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_url')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_url', { configurable: true, get: function() { abort('You are getting _gf_fileio_url on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_url', { configurable: true, set: function() { abort('You are setting _gf_fileio_url on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_new')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_new', { configurable: true, get: function() { abort('You are getting _gf_fileio_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_new', { configurable: true, set: function() { abort('You are setting _gf_fileio_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_set_stats_u32')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_set_stats_u32', { configurable: true, get: function() { abort('You are getting _gf_fileio_set_stats_u32 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_set_stats_u32', { configurable: true, set: function() { abort('You are setting _gf_fileio_set_stats_u32 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_ldexp')) {
        Object.defineProperty(Module['ready'], '_ldexp', { configurable: true, get: function() { abort('You are getting _ldexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_ldexp', { configurable: true, set: function() { abort('You are setting _ldexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_destroy')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_destroy', { configurable: true, get: function() { abort('You are getting _pthread_mutex_destroy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_destroy', { configurable: true, set: function() { abort('You are setting _pthread_mutex_destroy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_init')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_init', { configurable: true, get: function() { abort('You are getting _pthread_mutex_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_init', { configurable: true, set: function() { abort('You are setting _pthread_mutex_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_posix_memalign')) {
        Object.defineProperty(Module['ready'], '_posix_memalign', { configurable: true, get: function() { abort('You are getting _posix_memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_posix_memalign', { configurable: true, set: function() { abort('You are setting _posix_memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pow')) {
        Object.defineProperty(Module['ready'], '_pow', { configurable: true, get: function() { abort('You are getting _pow on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pow', { configurable: true, set: function() { abort('You are setting _pow on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_vsnprintf')) {
        Object.defineProperty(Module['ready'], '_vsnprintf', { configurable: true, get: function() { abort('You are getting _vsnprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_vsnprintf', { configurable: true, set: function() { abort('You are setting _vsnprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getenv')) {
        Object.defineProperty(Module['ready'], '_getenv', { configurable: true, get: function() { abort('You are getting _getenv on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_getenv', { configurable: true, set: function() { abort('You are setting _getenv on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcmp')) {
        Object.defineProperty(Module['ready'], '_strcmp', { configurable: true, get: function() { abort('You are getting _strcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcmp', { configurable: true, set: function() { abort('You are setting _strcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strlen')) {
        Object.defineProperty(Module['ready'], '_strlen', { configurable: true, get: function() { abort('You are getting _strlen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strlen', { configurable: true, set: function() { abort('You are setting _strlen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcpy')) {
        Object.defineProperty(Module['ready'], '_strcpy', { configurable: true, get: function() { abort('You are getting _strcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcpy', { configurable: true, set: function() { abort('You are setting _strcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcat')) {
        Object.defineProperty(Module['ready'], '_strcat', { configurable: true, get: function() { abort('You are getting _strcat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcat', { configurable: true, set: function() { abort('You are setting _strcat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strncpy')) {
        Object.defineProperty(Module['ready'], '_strncpy', { configurable: true, get: function() { abort('You are getting _strncpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strncpy', { configurable: true, set: function() { abort('You are setting _strncpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strchr')) {
        Object.defineProperty(Module['ready'], '_strchr', { configurable: true, get: function() { abort('You are getting _strchr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strchr', { configurable: true, set: function() { abort('You are setting _strchr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memset')) {
        Object.defineProperty(Module['ready'], '_memset', { configurable: true, get: function() { abort('You are getting _memset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memset', { configurable: true, set: function() { abort('You are setting _memset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memcpy')) {
        Object.defineProperty(Module['ready'], '_memcpy', { configurable: true, get: function() { abort('You are getting _memcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memcpy', { configurable: true, set: function() { abort('You are setting _memcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memmove')) {
        Object.defineProperty(Module['ready'], '_memmove', { configurable: true, get: function() { abort('You are getting _memmove on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memmove', { configurable: true, set: function() { abort('You are setting _memmove on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memalign')) {
        Object.defineProperty(Module['ready'], '_memalign', { configurable: true, get: function() { abort('You are getting _memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memalign', { configurable: true, set: function() { abort('You are setting _memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memcmp')) {
        Object.defineProperty(Module['ready'], '_memcmp', { configurable: true, get: function() { abort('You are getting _memcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memcmp', { configurable: true, set: function() { abort('You are setting _memcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_calloc')) {
        Object.defineProperty(Module['ready'], '_calloc', { configurable: true, get: function() { abort('You are getting _calloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_calloc', { configurable: true, set: function() { abort('You are setting _calloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_realloc')) {
        Object.defineProperty(Module['ready'], '_realloc', { configurable: true, get: function() { abort('You are getting _realloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_realloc', { configurable: true, set: function() { abort('You are setting _realloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_url_concatenate')) {
        Object.defineProperty(Module['ready'], '_gf_url_concatenate', { configurable: true, get: function() { abort('You are getting _gf_url_concatenate on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_url_concatenate', { configurable: true, set: function() { abort('You are setting _gf_url_concatenate on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_strdup')) {
        Object.defineProperty(Module['ready'], '_gf_strdup', { configurable: true, get: function() { abort('You are getting _gf_strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_strdup', { configurable: true, set: function() { abort('You are setting _gf_strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_get_udta')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_get_udta', { configurable: true, get: function() { abort('You are getting _gf_fileio_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_get_udta', { configurable: true, set: function() { abort('You are setting _gf_fileio_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_new')) {
        Object.defineProperty(Module['ready'], '_gf_bs_new', { configurable: true, get: function() { abort('You are getting _gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_new', { configurable: true, set: function() { abort('You are setting _gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_available')) {
        Object.defineProperty(Module['ready'], '_gf_bs_available', { configurable: true, get: function() { abort('You are getting _gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_available', { configurable: true, set: function() { abort('You are setting _gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_read_int')) {
        Object.defineProperty(Module['ready'], '_gf_bs_read_int', { configurable: true, get: function() { abort('You are getting _gf_bs_read_int on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_read_int', { configurable: true, set: function() { abort('You are setting _gf_bs_read_int on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_get_position')) {
        Object.defineProperty(Module['ready'], '_gf_bs_get_position', { configurable: true, get: function() { abort('You are getting _gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_get_position', { configurable: true, set: function() { abort('You are setting _gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_del')) {
        Object.defineProperty(Module['ready'], '_gf_bs_del', { configurable: true, get: function() { abort('You are getting _gf_bs_del on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_del', { configurable: true, set: function() { abort('You are setting _gf_bs_del on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_get_udta')) {
        Object.defineProperty(Module['ready'], '_gf_filter_get_udta', { configurable: true, get: function() { abort('You are getting _gf_filter_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_get_udta', { configurable: true, set: function() { abort('You are setting _gf_filter_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_get_packet')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_packet', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_get_packet on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_packet', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_get_packet on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_data')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_data', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_data on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_data', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_data on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_set_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_set_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_set_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_new_alloc')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_alloc', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_new_alloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_alloc', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_new_alloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_send')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_send', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_send on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_send', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_send on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_check_caps')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_check_caps', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_check_caps on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_check_caps', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_check_caps on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_get_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_new')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_new', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_new', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_copy_properties')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_copy_properties', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_copy_properties on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_copy_properties', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_copy_properties on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_set_name')) {
        Object.defineProperty(Module['ready'], '_gf_filter_set_name', { configurable: true, get: function() { abort('You are getting _gf_filter_set_name on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_set_name', { configurable: true, set: function() { abort('You are setting _gf_filter_set_name on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_dependency_flags')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_dependency_flags', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_dependency_flags on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_dependency_flags', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_dependency_flags on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_set_framing_mode')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_framing_mode', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_set_framing_mode on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_framing_mode', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_set_framing_mode on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_new_ref')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_ref', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_new_ref on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_ref', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_new_ref on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_cts')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_cts', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_cts', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_sap')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_sap', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_sap on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_sap', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_sap on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_duration')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_duration', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_duration', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_byte_offset')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_byte_offset', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_byte_offset', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_framing')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_framing', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_framing on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_framing', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_framing on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_seek_flag')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_seek_flag', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_seek_flag', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_seek_flag')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_seek_flag', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_seek_flag', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fflush')) {
        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, get: function() { abort('You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, set: function() { abort('You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_siprintf')) {
        Object.defineProperty(Module['ready'], '_siprintf', { configurable: true, get: function() { abort('You are getting _siprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_siprintf', { configurable: true, set: function() { abort('You are setting _siprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_constructor')) {
        Object.defineProperty(Module['ready'], '_constructor', { configurable: true, get: function() { abort('You are getting _constructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_constructor', { configurable: true, set: function() { abort('You are setting _constructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_set')) {
        Object.defineProperty(Module['ready'], '_set', { configurable: true, get: function() { abort('You are getting _set on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_set', { configurable: true, set: function() { abort('You are setting _set on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_get')) {
        Object.defineProperty(Module['ready'], '_get', { configurable: true, get: function() { abort('You are getting _get on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_get', { configurable: true, set: function() { abort('You are setting _get on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_destructor')) {
        Object.defineProperty(Module['ready'], '_destructor', { configurable: true, get: function() { abort('You are getting _destructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_destructor', { configurable: true, set: function() { abort('You are setting _destructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '___stdio_exit')) {
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, get: function() { abort('You are getting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, set: function() { abort('You are setting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_new')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_new', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_new', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_available')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_available', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_available', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_get_position')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_get_position', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_get_position', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_set_cts')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_cts', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_cts', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_get_cts')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_get_cts', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_get_cts', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_set_byte_offset')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_byte_offset', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_byte_offset', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$llrint')) {
        Object.defineProperty(Module['ready'], '_orig$llrint', { configurable: true, get: function() { abort('You are getting _orig$llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$llrint', { configurable: true, set: function() { abort('You are setting _orig$llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], 'onRuntimeInitialized')) {
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, get: function() { abort('You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, set: function() { abort('You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = false;//typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = false;//typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = false;//!ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Normally we don't log exceptions but instead let them bubble out the top
// level where the embedding environment (e.g. the browser) can handle
// them.
// However under v8 and node we sometimes exit the process direcly in which case
// its up to use us to log the exception before exiting.
// If we fix https://github.com/emscripten-core/emscripten/issues/15080
// this may no longer be needed under node.
function logExceptionOnExit(e) {
  if (e instanceof ExitStatus) return;
  let toLog = e;
  if (e && typeof e == 'object' && e.stack) {
    toLog = [e, e.stack];
  }
  err('exiting due to exception: ' + toLog);
}

var fs;

if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && "function" === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    let data;
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = function readAsync(f, onload, onerror) {
    setTimeout(() => onload(readBinary(f)), 0);
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      logExceptionOnExit(toThrow);
      quit(status);
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';


assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.");




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function == "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {
  assert(typeof func != 'undefined');

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


function legacyModuleProp(prop, newName) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get: function() {
        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
  }
}

function unexportedMessage(sym, isFSSybol) {
  var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
  if (isFSSybol) {
    msg += '. Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you';
  }
  return msg;
}

function unexportedRuntimeSymbol(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get: function() {
        abort(unexportedMessage(sym, isFSSybol));
      }
    });
  }
}

function unexportedRuntimeFunction(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Module[sym] = () => abort(unexportedMessage(sym, isFSSybol));
  }
}

// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var dynamicLibraries = Module['dynamicLibraries'] || [];

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');
var noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return Number(HEAPF64[((ptr)>>3)]);
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;
  assert(typeof allocator == 'number', 'allocate no longer takes a type argument')
  assert(typeof slab != 'number', 'allocate no longer takes a number as arg0')

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  ;
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');

assert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js


// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      'maximum': INITIAL_MEMORY / 65536
    });
  }

if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_MEMORY % 65536 === 0);
updateGlobalBufferAndViews(buffer);

// end include: runtime_init_memory.js

// include: runtime_init_table.js
// In RELOCATABLE mode we create the table in JS.
var wasmTable = new WebAssembly.Table({
  'initial': 4374,
  'element': 'anyfunc'
});

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAP32[((max)>>2)] = 0x2135467;
  HEAP32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  /*if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));
  }*/
  // Also test the global address 0 for integrity.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

// end include: runtime_stack_check.js
// include: runtime_assertions.js


// Endianness check
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
SOCKFS.root = FS.mount(SOCKFS, {}, null);
PIPEFS.root = FS.mount(PIPEFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data
Module["preloadedWasm"] = {}; // maps url to wasm instance exports

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.

  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
/** @param {boolean=} fixedasm */
function createExportWrapper(name, fixedasm) {
  return function() {
    var displayName = name;
    var asm = fixedasm;
    if (!fixedasm) {
      asm = Module['asm'];
    }
    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
    if (!asm[name]) {
      assert(asm[name], 'exported native function `' + displayName + '` not found');
    }
    return asm[name].apply(null, arguments);
  };
}

var wasmBinaryFile;
wasmBinaryFile = location.using;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
    'GOT.mem': new Proxy(asmLibraryArg, GOTHandler),
    'GOT.func': new Proxy(asmLibraryArg, GOTHandler),
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    exports = relocateExports(exports, 1024);

    Module['asm'] = exports;

    var metadata = getDylinkMetadata(module);
    if (metadata.neededDynlibs) {
      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);
    }
    mergeLibSymbols(exports, 'main')

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    receiveInstance(result['instance'], result['module']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      // Warn on some common problems.
      if (isFileURI(wasmBinaryFile)) {
        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
      }
      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // If instantiation fails, reject the module ready promise.
  instantiateAsync().catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  var GOT = {};
  var GOTHandler = {get:function(obj, symName) {
        if (!GOT[symName]) {
          GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        return GOT[symName]
      }};

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            getWasmTableEntry(func)();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            getWasmTableEntry(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function getDylinkMetadata(binary) {
      var offset = 0;
      var end = 0;
  
      function getU8() {
        return binary[offset++];
      }
  
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary[offset++];
          ret += ((byte & 0x7f) * mul);
          mul *= 0x80;
          if (!(byte & 0x80)) break;
        }
        return ret;
      }
  
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary, offset - len, len);
      }
  
      /** @param {string=} message */
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
  
      var name = 'dylink.0';
      if (binary instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary, name);
        if (dylinkSection.length === 0) {
          name = 'dylink'
          dylinkSection = WebAssembly.Module.customSections(binary, name);
        }
        failIf(dylinkSection.length === 0, 'need dylink section');
        binary = new Uint8Array(dylinkSection[0]);
        end = binary.length
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 0x6d736100;
        failIf(!magicNumberFound, 'need to see wasm magic number'); // \0asm
        // we should see the dylink custom section right after the magic number and wasm version
        failIf(binary[8] !== 0, 'need the dylink section to be first')
        offset = 9;
        var section_size = getLEB(); //section size
        end = offset + section_size;
        name = getString();
      }
  
      var customSection = { neededDynlibs: [], tlsExports: {} };
      if (name == 'dylink') {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        // shared libraries this module needs. We need to load them first, so that
        // current module could resolve its imports. (see tools/shared.py
        // WebAssembly.make_shared_library() for "dylink" section extension format)
        var neededDynlibsCount = getLEB();
        for (var i = 0; i < neededDynlibsCount; ++i) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name !== 'dylink.0');
        var WASM_DYLINK_MEM_INFO = 0x1;
        var WASM_DYLINK_NEEDED = 0x2;
        var WASM_DYLINK_EXPORT_INFO = 0x3;
        var WASM_SYMBOL_TLS = 0x100;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i = 0; i < neededDynlibsCount; ++i) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags = getLEB();
              if (flags & WASM_SYMBOL_TLS) {
                customSection.tlsExports[symname] = 1;
              }
            }
          } else {
            err('unknown dylink.0 subsection: ' + subsectionType)
            // unknown subsection
            offset += subsectionSize;
          }
        }
      }
  
      var tableAlign = Math.pow(2, customSection.tableAlign);
      assert(tableAlign === 1, 'invalid tableAlign ' + tableAlign);
      assert(offset == end);
  
      return customSection;
    }

  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  function asmjsMangle(x) {
      var unmangledSymbols = ['stackAlloc','stackSave','stackRestore'];
      return x.indexOf('dynCall_') == 0 || unmangledSymbols.includes(x) ? x : '_' + x;
    }
  function mergeLibSymbols(exports, libName) {
      // add symbols into global namespace TODO: weak linking etc.
      for (var sym in exports) {
        if (!exports.hasOwnProperty(sym)) {
          continue;
        }
  
        // When RTLD_GLOBAL is enable, the symbols defined by this shared object will be made
        // available for symbol resolution of subsequently loaded shared objects.
        //
        // We should copy the symbols (which include methods and variables) from SIDE_MODULE to MAIN_MODULE.
  
        if (!asmLibraryArg.hasOwnProperty(sym)) {
          asmLibraryArg[sym] = exports[sym];
        }
  
        // Export native export on the Module object.
        // TODO(sbc): Do all users want this?  Should we skip this by default?
        var module_sym = asmjsMangle(sym);
        if (!Module.hasOwnProperty(module_sym)) {
          Module[module_sym] = exports[sym];
        }
      }
    }

  var LDSO = {loadedLibsByName:{},loadedLibsByHandle:{}};
  
  function dynCallLegacy(sig, ptr, args) {
      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      if (args && args.length) {
        // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
        assert(args.length === sig.substring(1).replace(/j/g, '--').length);
      } else {
        assert(sig.length == 1);
      }
      var f = Module["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
  /** @param {Object=} args */
  function dynCall(sig, ptr, args) {
      // Without WASM_BIGINT support we cannot directly call function with i64 as
      // part of thier signature, so we rely the dynCall functions generated by
      // wasm-emscripten-finalize
      if (sig.includes('j')) {
        return dynCallLegacy(sig, ptr, args);
      }
      assert(getWasmTableEntry(ptr), 'missing table entry in dynCall: ' + ptr);
      return getWasmTableEntry(ptr).apply(null, args)
    }
  function createInvokeFunction(sig) {
      return function() {
        var sp = stackSave();
        try {
          return dynCall(sig, arguments[0], Array.prototype.slice.call(arguments, 1));
        } catch(e) {
          stackRestore(sp);
          // Exceptions thrown from C++ exception will be integer numbers.
          // longjmp will throw the number Infinity. Re-throw other types of
          // exceptions using a compact and fast check.
          if (e !== e+0) throw e;
          _setThrew(1, 0);
        }
      }
    }
  
  var ___heap_base = 6284784;
  function getMemory(size) {
      // After the runtime is initialized, we must only use sbrk() normally.
      if (runtimeInitialized)
        return _malloc(size);
      var ret = ___heap_base;
      var end = (ret + size + 15) & -16;
      assert(end <= HEAP8.length, 'failure to getMemory - memory growth etc. is not supported there, call malloc/sbrk directly or increase INITIAL_MEMORY');
      ___heap_base = end;
      GOT['__heap_base'].value = end;
      return ret;
    }
  
  function isInternalSym(symName) {
      // TODO: find a way to mark these in the binary or avoid exporting them.
      return [
        '__cpp_exception',
        '__c_longjmp',
        '__wasm_apply_data_relocs',
        '__dso_handle',
        '__tls_size',
        '__tls_align',
        '__set_stack_limits',
        'emscripten_tls_init',
        '__wasm_init_tls',
        '__wasm_call_ctors',
      ].includes(symName)
      ;
    }
  function updateGOT(exports, replace) {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }
  
        var value = exports[symName];
        if (symName.startsWith('orig$')) {
          symName = symName.split('$')[1];
          replace = true;
        }
  
        if (!GOT[symName]) {
          GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        if (replace || GOT[symName].value == 0) {
          if (typeof value == 'function') {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else if (typeof value == 'bigint') {
            GOT[symName].value = Number(value);
          } else {
            err("unhandled export type for `" + symName + "`: " + (typeof value));
          }
        }
      }
    }
  /** @param {boolean=} replace */
  function relocateExports(exports, memoryBase, replace) {
      var relocated = {};
  
      for (var e in exports) {
        var value = exports[e];
        if (typeof value == 'object') {
          // a breaking change in the wasm spec, globals are now objects
          // https://github.com/WebAssembly/mutable-global/issues/1
          value = value.value;
        }
        if (typeof value == 'number') {
          value += memoryBase;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    }
  
  function resolveGlobalSymbol(symName, direct) {
      var sym;
      if (direct) {
        // First look for the orig$ symbol which is the symbols without
        // any legalization performed.
        sym = asmLibraryArg['orig$' + symName];
      }
      if (!sym) {
        sym = asmLibraryArg[symName];
      }
  
      // Check for the symbol on the Module object.  This is the only
      // way to dynamically access JS library symbols that were not
      // referenced by the main module (and therefore not part of the
      // initial set of symbols included in asmLibraryArg when it
      // was declared.
      if (!sym) {
        sym = Module[asmjsMangle(symName)];
      }
  
      if (!sym && symName.startsWith('invoke_')) {
        sym = createInvokeFunction(symName.split('_')[1]);
      }
  
      return sym;
    }
  
  function alignMemory(size, alignment) {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    }
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  /** @param {number=} handle */
  function loadWebAssemblyModule(binary, flags, handle) {
      var metadata = getDylinkMetadata(binary);
      var originalTable = wasmTable;
  
      // loadModule loads the wasm module after all its dependencies have been loaded.
      // can be called both sync/async.
      function loadModule() {
        // The first thread to load a given module needs to allocate the static
        // table and memory regions.  Later threads re-use the same table region
        // and can ignore the memory region (since memory is shared between
        // threads already).
        var needsAllocation = !handle || !HEAP8[(((handle)+(24))>>0)];
        if (needsAllocation) {
          // alignments are powers of 2
          var memAlign = Math.pow(2, metadata.memoryAlign);
          // finalize alignments and verify them
          memAlign = Math.max(memAlign, STACK_ALIGN); // we at least need stack alignment
          // prepare memory
          var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0; // TODO: add to cleanups
          var tableBase = metadata.tableSize ? wasmTable.length : 0;
          if (handle) {
            HEAP8[(((handle)+(24))>>0)] = 1;
            HEAP32[(((handle)+(28))>>2)] = memoryBase;
            HEAP32[(((handle)+(32))>>2)] = metadata.memorySize;
            HEAP32[(((handle)+(36))>>2)] = tableBase;
            HEAP32[(((handle)+(40))>>2)] = metadata.tableSize;
          }
        } else {
          memoryBase = HEAP32[(((handle)+(28))>>2)];
          tableBase = HEAP32[(((handle)+(36))>>2)];
        }
  
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        if (tableGrowthNeeded > 0) {
          wasmTable.grow(tableGrowthNeeded);
        }
  
        // This is the export map that we ultimately return.  We declare it here
        // so it can be used within resolveSymbol.  We resolve symbols against
        // this local symbol map in the case there they are not present on the
        // global Module object.  We need this fallback because:
        // a) Modules sometime need to import their own symbols
        // b) Symbols from side modules are not always added to the global namespace.
        var moduleExports;
  
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym, false);
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          assert(resolved, 'undefined symbol `' + sym + '`. perhaps a side module was not linked in? if this global was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment');
          return resolved;
        }
  
        // TODO kill  (except "symbols local to this module", it will likely be
        // not needed if we require that if A wants symbols from B it has to link
        // to B explicitly: similarly to -Wl,--no-undefined)
        //
        // wasm dynamic libraries are pure wasm, so they cannot assist in
        // their own loading. When side module A wants to import something
        // provided by a side module B that is loaded later, we need to
        // add a layer of indirection, but worse, we can't even tell what
        // to add the indirection for, without inspecting what A's imports
        // are. To do that here, we use a JS proxy (another option would
        // be to inspect the binary directly).
        var proxyHandler = {
          'get': function(stubs, prop) {
            // symbols that should be local to this module
            switch (prop) {
              case '__memory_base':
                return memoryBase;
              case '__table_base':
                return tableBase;
            }
            if (prop in asmLibraryArg) {
              // No stub needed, symbol already exists in symbol table
              return asmLibraryArg[prop];
            }
            // Return a stub function that will resolve the symbol
            // when first called.
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = function() {
                if (!resolved) resolved = resolveSymbol(prop);
                return resolved.apply(null, arguments);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          'GOT.mem': new Proxy({}, GOTHandler),
          'GOT.func': new Proxy({}, GOTHandler),
          'env': proxy,
          wasi_snapshot_preview1: proxy,
        };
  
        function postInstantiation(instance) {
          //FIXME : Set this information in custom section
          const filter_entry = Object.keys(instance.exports).filter(fn => fn.endsWith("_register"));
          filter_entries = filter_entries.concat(filter_entry);
          const module_entry = Object.keys(instance.exports).filter(fn => fn.startsWith("gf_register_module_"));
          module_entries = module_entries.concat(module_entry);
          // the table should be unchanged
          assert(wasmTable === originalTable);
          // add new entries to functionsInTableMap
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
  
          // initialize the module
            var init = moduleExports['__wasm_call_ctors'];
            if (init) {
              if (runtimeInitialized) {
                init();
              } else {
                // we aren't ready to run compiled code yet
                __ATINIT__.push(init);
              }
            }
          return moduleExports;
        }
  
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(instance));
          }
          return WebAssembly.instantiate(binary, info).then(function(result) {
            return postInstantiation(result.instance);
          });
        }
  
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(instance);
      }
  
      // now load needed libraries and the module itself.
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce(function(chain, dynNeeded) {
          return chain.then(function() {
            return loadDynamicLibrary(dynNeeded, flags);
          });
        }, Promise.resolve()).then(function() {
          return loadModule();
        });
      }
  
      metadata.neededDynlibs.forEach(function(dynNeeded) {
        loadDynamicLibrary(dynNeeded, flags);
      });
      return loadModule();
    }
  /** @param {number=} handle */
  function loadDynamicLibrary(lib, flags, handle) {
      if (lib == '__main__' && !LDSO.loadedLibsByName[lib]) {
        LDSO.loadedLibsByName[lib] = {
          refcount: Infinity,   // = nodelete
          name:     '__main__',
          module:   Module['asm'],
          global:   true
        };
      }
  
      // when loadDynamicLibrary did not have flags, libraries were loaded
      // globally & permanently
      flags = flags || {global: true, nodelete: true}
  
      var dso = LDSO.loadedLibsByName[lib];
      if (dso) {
        // the library is being loaded or has been loaded already.
        //
        // however it could be previously loaded only locally and if we get
        // load request with global=true we have to make it globally visible now.
        if (flags.global && !dso.global) {
          dso.global = true;
          if (dso.module !== 'loading') {
            // ^^^ if module is 'loading' - symbols merging will be eventually done by the loader.
            mergeLibSymbols(dso.module, lib)
          }
        }
        // same for "nodelete"
        if (flags.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++
        if (handle) {
          LDSO.loadedLibsByHandle[handle] = dso;
        }
        return flags.loadAsync ? Promise.resolve(true) : true;
      }
  
      // allocate new DSO
      dso = {
        refcount: flags.nodelete ? Infinity : 1,
        name:     lib,
        module:   'loading',
        global:   flags.global,
      };
      LDSO.loadedLibsByName[lib] = dso;
      if (handle) {
        LDSO.loadedLibsByHandle[handle] = dso;
      }
  
      // libData <- libFile
      function loadLibData(libFile) {
        // for wasm, we can use fetch for async, but for fs mode we can only imitate it
        if (flags.fs && flags.fs.findObject(libFile)) {
          var libData = flags.fs.readFile(libFile, {encoding: 'binary'});
          if (!(libData instanceof Uint8Array)) {
            libData = new Uint8Array(libData);
          }
          return flags.loadAsync ? Promise.resolve(libData) : libData;
        }
  
        if (flags.loadAsync) {
          return new Promise(function(resolve, reject) {
            readAsync(libFile, function(data) { resolve(new Uint8Array(data)); }, reject);
          });
        }
  
        // load the binary synchronously
        if (!readBinary) {
          throw new Error(libFile + ': file not found, and synchronous loading of external files is not available');
        }
        return readBinary(libFile);
      }
  
      // libModule <- lib
      function getLibModule() {
        // lookup preloaded cache first
        if (Module['preloadedWasm'] !== undefined &&
            Module['preloadedWasm'][lib] !== undefined) {
          var libModule = Module['preloadedWasm'][lib];
          return flags.loadAsync ? Promise.resolve(libModule) : libModule;
        }
  
        // module not preloaded - load lib data and create new module from it
        if (flags.loadAsync) {
          return loadLibData(lib).then(function(libData) {
            return loadWebAssemblyModule(libData, flags, handle);
          });
        }
  
        return loadWebAssemblyModule(loadLibData(lib), flags, handle);
      }
  
      // module for lib is loaded - update the dso & global namespace
      function moduleLoaded(libModule) {
        if (dso.global) {
          mergeLibSymbols(libModule, lib);
        }
        dso.module = libModule;
      }
  
      if (flags.loadAsync) {
        return getLibModule().then(function(libModule) {
          moduleLoaded(libModule);
          return true;
        });
      }
  
      moduleLoaded(getLibModule());
      return true;
    }
  
  function reportUndefinedSymbols() {
      for (var symName in GOT) {
        if (GOT[symName].value == 0) {
          var value = resolveGlobalSymbol(symName, true)
          assert(value, 'undefined symbol `' + symName + '`. perhaps a side module was not linked in? if this global was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment');
          if (typeof value == 'function') {
            /** @suppress {checkTypes} */
            GOT[symName].value = addFunction(value, value.sig);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else {
            throw new Error('bad export type for `' + symName + '`: ' + (typeof value));
          }
        }
      }
    }

    function add_file_io(){
      memio.forEach(x => {
        x.value = addFunction(x, x.sig);
      })
    }

  function preloadDylibs() {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
  
      // Load binaries asynchronously
      addRunDependency('preloadDylibs');
      dynamicLibraries.reduce(function(chain, lib) {
        return chain.then(function() {
          return loadDynamicLibrary(scriptDirectory + lib, {loadAsync: true, global: true, nodelete: true, allowUndefined: true});
        });
      }, Promise.resolve()).then(function() {
        // we got them all, wonderful
        reportUndefinedSymbols();
        add_file_io();
        removeRunDependency('preloadDylibs');
      });
    }



  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
      wasmTableMirror[idx] = func;
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }
  ___assert_fail.sig = 'viiii';

  function ___call_sighandler(fp, sig) {
      getWasmTableEntry(fp)(sig);
    }


  var ___memory_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1024);

  var ___stack_pointer = new WebAssembly.Global({'value': 'i32', 'mutable': true}, 6284784);

  var PATH = {splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      // if (ENVIRONMENT_IS_NODE) {
      //   // for nodejs with or without crypto support included
      //   try {
      //     var crypto_module = require('crypto');
      //     // nodejs has crypto support
      //     return function() { return crypto_module['randomBytes'](1)[0]; };
      //   } catch (e) {
      //     // nodejs doesn't have crypto support
      //   }
      // }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function mmapAlloc(size) {
      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            // We don't currently support location hints for the address of the mapping
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var ERRNO_MESSAGES = {0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};
  
  var ERRNO_CODES = {};
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        assert(typeof parent == 'object')
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        if (typeof type == 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode, fd_start, fd_end) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, address, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // Call musl-internal function to close all stdio streams, so nothing is
        // left in internal buffers.
        ___stdio_exit();
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },absolutePath:() => {
        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');
      },createFolder:() => {
        abort('FS.createFolder has been removed; use FS.mkdir instead');
      },createLink:() => {
        abort('FS.createLink has been removed; use FS.symlink instead');
      },joinPath:() => {
        abort('FS.joinPath has been removed; use PATH.join instead');
      },mmapAlloc:() => {
        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');
      },standardizePath:() => {
        abort('FS.standardizePath has been removed; use PATH.normalize instead');
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (path[0] === '/') {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      }};
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
  try {
  
      // readfds are supported,
      // writefds checks socket open status
      // exceptfds not supported
      // timeout is always 0 - fully async
      assert(nfds <= 64, 'nfds must be less than or equal to 64');  // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
      assert(!exceptfds, 'exceptfds not supported');
  
      var total = 0;
      
      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;
  
      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var check = function(fd, low, high, val) {
        return (fd < 32 ? (low & val) : (high & val));
      };
  
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }
  
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
  
        var flags = SYSCALLS.DEFAULT_POLLMASK;
  
        if (stream.stream_ops.poll) {
          flags = stream.stream_ops.poll(stream);
        }
  
        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }
  
      if (readfds) {
        HEAP32[((readfds)>>2)] = dstReadLow;
        HEAP32[(((readfds)+(4))>>2)] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)] = dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)] = dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)] = dstExceptHigh;
      }
  
      return total;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var SOCKFS = {mount:function(mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = /** @this{Object} */ function(event, callback) {
          if ('function' === typeof callback) {
            this._callbacks[event] = callback;
          }
          return this;
        };
  
        Module['websocket'].emit = /** @this{Object} */ function(event, param) {
          if ('function' === typeof this._callbacks[event]) {
            this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function(family, type, protocol) {
        type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function(sock, addr, port) {
          var ws;
  
          if (typeof addr == 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The default WebSocket options
              var opts = undefined;
  
              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
                // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
                opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
              }
  
              // some webservers (azure) does not support subprotocol header
              if (runtimeConfig && null === Module['websocket']['subprotocol']) {
                subProtocols = 'null';
                opts = undefined;
              }
  
              // If node we use the ws library.
              var WebSocketConstructor;
              if (ENVIRONMENT_IS_NODE) {
                WebSocketConstructor = /** @type{(typeof WebSocket)} */(__webpack_require__(/*! ws */ "./node_modules/ws/browser.js"));
              } else
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport != 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function(sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            if (typeof data == 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              } else {
                data = new Uint8Array(data); // make a typed array view on the array buffer
              }
            }
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)] = bytes;
              return 0;
            default:
              return 28;
          }
        },close:function(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function(sock, addr, port) {
          if (typeof sock.saddr != 'undefined' || typeof sock.sport != 'undefined') {
            throw new FS.ErrnoError(28);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== 138) throw e;
            }
          }
        },connect:function(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr != 'undefined' && typeof sock.dport != 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(26);
        },listen:function(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
          if (sock.server) {
             throw new FS.ErrnoError(28);  // already listening
          }
          var WebSocketServer = (__webpack_require__(/*! ws */ "./node_modules/ws/browser.js").Server);
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = 23; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(53);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(17);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(6);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
  
          var data;
            data = buffer.slice(offset, offset + length);
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },recvmsg:function(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(53);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(53);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(6);
              }
            } else {
              throw new FS.ErrnoError(6);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};
  function getSocketFromFD(fd) {
      var socket = SOCKFS.getSocket(fd);
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    }
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  var Sockets = {BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};
  
  function inetPton4(str) {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    }
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  function inetPton6(str) {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] == 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    }
  /** @param {number=} addrlen */
  function writeSockaddr(sa, family, addr, port, addrlen) {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        case 10:
          addr = inetPton6(addr);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    }
  
  var DNS = {address_map:{id:1,addrs:{},names:{}},lookup_name:function (name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },lookup_addr:function (addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      }};
  function ___syscall_accept4(fd, addr, addrlen, flags) {
  try {
  
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
        assert(!errno);
      }
      return newsock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function inetNtop4(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }
  
  function inetNtop6(ints) {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    }
  function readSockaddr(sa, salen) {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;
  
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = inetNtop4(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = inetNtop6(addr);
          break;
        default:
          return { errno: 5 };
      }
  
      return { family: family, addr: addr, port: port };
    }
  /** @param {boolean=} allowNull */
  function getSocketAddress(addrp, addrlen, allowNull) {
      if (allowNull && addrp === 0) return null;
      var info = readSockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    }
  function ___syscall_bind(fd, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_chdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_connect(fd, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_dup(fd) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.open(old.path, old.flags, 0).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_dup3(fd, suggestFD, flags) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      assert(!flags);
      if (old.fd === suggestFD) return -28;
      var suggest = FS.getStream(suggestFD);
      if (suggest) FS.close(suggest);
      return FS.open(old.path, old.flags, 0, suggestFD, suggestFD).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
        /* case 5: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        /* case 6: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 7: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd);
      if (size < cwdLengthInBytes + 1) return -68;
      stringToUTF8(cwd, buf, size);
      return buf;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getdents64(fd, dirp, count) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
  
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
  
      var idx = Math.floor(off / struct_size);
  
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === '.') {
          id = stream.node.id;
          type = 4; // DT_DIR
        }
        else if (name === '..') {
          var lookup = FS.lookupPath(stream.path, { parent: true });
          id = lookup.node.id;
          type = 4; // DT_DIR
        }
        else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        assert(id);
        (tempI64 = [id>>>0,(tempDouble=id,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((dirp + pos)>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(4))>>2)] = tempI64[1]);
        (tempI64 = [(idx + 1) * struct_size>>>0,(tempDouble=(idx + 1) * struct_size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((dirp + pos)+(8))>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(12))>>2)] = tempI64[1]);
        HEAP16[(((dirp + pos)+(16))>>1)] = 280;
        HEAP8[(((dirp + pos)+(18))>>0)] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getsockname(fd, addr, addrlen) {
  try {
  
      err("__syscall_getsockname " + fd);
      var sock = getSocketFromFD(fd);
      // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport, addrlen);
      assert(!errno);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getsockopt(fd, level, optname, optval, optlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
      // so only supports SOL_SOCKET with SO_ERROR.
      if (level === 1) {
        if (optname === 4) {
          HEAP32[((optval)>>2)] = sock.error;
          HEAP32[((optlen)>>2)] = 4;
          sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
          return 0;
        }
      }
      return -50; // The option is unknown at the level indicated.
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_listen(fd, backlog) {
  try {
  
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdir(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMkdir(path, mode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mknod(path, mode, dev) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMknod(path, mode, dev);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~4352);
      assert(!flags, flags);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var PIPEFS = {BUCKET_BUFFER_SIZE:8192,mount:function (mount) {
        // Do not pollute the real root directory or its child nodes with pipes
        // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createPipe:function () {
        var pipe = {
          buckets: [],
          // refcnt 2 because pipe has a read end and a write end. We need to be
          // able to read from the read end after write end is closed.
          refcnt : 2,
        };
  
        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });
  
        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
  
        rNode.pipe = pipe;
        wNode.pipe = pipe;
  
        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: 0,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;
  
        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: 1,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;
  
        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },stream_ops:{poll:function (stream) {
          var pipe = stream.node.pipe;
  
          if ((stream.flags & 2097155) === 1) {
            return (256 | 4);
          } else {
            if (pipe.buckets.length > 0) {
              for (var i = 0; i < pipe.buckets.length; i++) {
                var bucket = pipe.buckets[i];
                if (bucket.offset - bucket.roffset > 0) {
                  return (64 | 1);
                }
              }
            }
          }
  
          return 0;
        },ioctl:function (stream, request, varargs) {
          return 28;
        },fsync:function (stream) {
          return 28;
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
          var currentLength = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            currentLength += bucket.offset - bucket.roffset;
          }
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            // Behave as if the read end is always non-blocking
            throw new FS.ErrnoError(6);
          }
          var toRead = Math.min(currentLength, length);
  
          var totalRead = toRead;
          var toRemove = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var currBucket = pipe.buckets[i];
            var bucketSize = currBucket.offset - currBucket.roffset;
  
            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }
  
          if (toRemove && toRemove == pipe.buckets.length) {
            // Do not generate excessive garbage in use cases such as
            // write several bytes, read everything, write several bytes, read everything...
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }
  
          pipe.buckets.splice(0, toRemove);
  
          return totalRead;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }
  
          var currBucket = null;
  
          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }
  
          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
  
          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }
  
          var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
  
          for (var i = 0; i < numBuckets; i++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }
  
          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }
  
          return dataLen;
        },close:function (stream) {
          var pipe = stream.node.pipe;
          pipe.refcnt--;
          if (pipe.refcnt === 0) {
            pipe.buckets = null;
          }
        }},nextname:function () {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return 'pipe[' + (PIPEFS.nextname.current++) + ']';
      }};
  function ___syscall_pipe(fdPtr) {
  try {
  
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
  
      var res = PIPEFS.createPipe();
  
      HEAP32[((fdPtr)>>2)] = res.readable_fd;
      HEAP32[(((fdPtr)+(4))>>2)] = res.writable_fd;
  
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len);
      if (!msg) return 0; // socket is closed
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
        assert(!errno);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {
  
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
  try {
  
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        // send, no address provided
        return FS.write(sock.stream, HEAP8,message, length);
      } else {
        // sendto an address
        return sock.sock_ops.sendmsg(sock, HEAP8,message, length, dest.addr, dest.port);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_socket(domain, type, protocol) {
  try {
  
      var sock = SOCKFS.createSocket(domain, type, protocol);
      assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
      return sock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_symlink(target, linkpath) {
  try {
  
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = HEAP32[((times)>>2)];
        var nanoseconds = HEAP32[(((times)+(4))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 8;
        seconds = HEAP32[((times)>>2)];
        nanoseconds = HEAP32[(((times)+(4))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var ___table_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1);

  var ENV = {};
  
  function dlSetError(msg) {
      withStackSave(function() {
        var cmsg = allocateUTF8OnStack(msg);
        ___dl_seterr(cmsg);
      });
    }
  function dlopenInternal(handle, jsflags) {
      // void *dlopen(const char *file, int mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
      var filename = UTF8ToString(handle + 44);
      var flags = HEAP32[(((handle)+(20))>>2)];
      filename = PATH.normalize(filename);
      var searchpaths = [];
  
      var isValidFile = (filename) => {
        var target = FS.findObject(filename);
        return target && !target.isFolder && !target.isDevice;
      };
  
      if (!isValidFile(filename)) {
        if (ENV['LD_LIBRARY_PATH']) {
          searchpaths = ENV['LD_LIBRARY_PATH'].split(':');
        }
  
        for (var ident in searchpaths) {
          var searchfile = PATH.join2(searchpaths[ident], filename);
          if (isValidFile(searchfile)) {
            filename = searchfile;
            break;
          }
        }
      }
  
      // We don't care about RTLD_NOW and RTLD_LAZY.
      var combinedFlags = {
        global:    Boolean(flags & 256),
        nodelete:  Boolean(flags & 4096),
        loadAsync: jsflags.loadAsync,
        fs:        jsflags.fs,
      }
  
      if (jsflags.loadAsync) {
        return loadDynamicLibrary(filename, combinedFlags, handle);
      }
  
      try {
        return loadDynamicLibrary(filename, combinedFlags, handle)
      } catch (e) {
        err('Error in loading dynamic library ' + filename + ": " + e);
        dlSetError('Could not load dynamic lib: ' + filename + '\n' + e);
        return 0;
      }
    }
  function __dlopen_js(handle) {
      var jsflags = {
        loadAsync: false,
        fs: FS, // load libraries from provided filesystem
      }
      return dlopenInternal(handle, jsflags);
    }
  __dlopen_js.sig = 'iiii';

  function __dlsym_js(handle, symbol) {
      // void *dlsym(void *restrict handle, const char *restrict name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
      symbol = UTF8ToString(symbol);
      var result;
  
      if (handle == 0) {
        result = resolveGlobalSymbol(symbol, true);
        if (!result) {
          dlSetError('Tried to lookup unknown symbol "' + symbol + '" in dynamic lib: RTLD_DEFAULT');
          return 0;
        }
      } else {
        var lib = LDSO.loadedLibsByHandle[handle];
        assert(lib, 'Tried to dlsym() from an unopened handle: ' + handle);
        if (!lib.module.hasOwnProperty(symbol)) {
          dlSetError('Tried to lookup unknown symbol "' + symbol + '" in dynamic lib: ' + lib.name)
          return 0;
        }
        result = lib.module['orig$' + symbol];
        if (!result)
        result = lib.module[symbol];
      }
  
      if (typeof result == 'function') {
        // Insert the function into the wasm table.  If its a direct wasm function
        // the second argument will not be needed.  If its a JS function we rely
        // on the `sig` attribute being set based on the `<func>__sig` specified
        // in library JS file.
        result = addFunction(result, result.sig);
      }
      return result;
    }
  __dlsym_js.sig = 'iii';

  function __emscripten_date_now() {
      return Date.now();
    }
  __emscripten_date_now.sig = 'j';

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  function __emscripten_throw_longjmp() { throw Infinity; }
  __emscripten_throw_longjmp.sig = 'v';

  function __gmtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
    }
  __gmtime_js.sig = 'iii';

  function __localtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }
  __localtime_js.sig = 'iii';

  function __mktime_js(tmPtr) {
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      // To match expected behavior, update fields from date
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
  
      return (date.getTime() / 1000)|0;
    }
  __mktime_js.sig = 'ii';

  function __timegm_js(tmPtr) {
      var time = Date.UTC(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
      var date = new Date(time);
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
  
      return (date.getTime() / 1000)|0;
    }
  __timegm_js.sig = 'ii';

  function _tzset_impl(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
      // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        HEAP32[((tzname)>>2)] = winterNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAP32[((tzname)>>2)] = summerNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }
  _tzset_impl.sig = 'viii';
  function __tzset_js(timezone, daylight, tzname) {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (__tzset_js.called) return;
      __tzset_js.called = true;
      _tzset_impl(timezone, daylight, tzname);
    }
  __tzset_js.sig = 'viii';

  function _abort() {
      abort('native code called abort()');
    }
  _abort.sig = 'v';

  function _emscripten_console_error(str) {
      assert(typeof str == 'number');
      console.error(UTF8ToString(str));
    }
  _emscripten_console_error.sig = 'vi';

  function _emscripten_get_heap_max() {
      return HEAPU8.length;
    }

  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = () => {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else _emscripten_get_now = () => performance.now();
  ;

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function abortOnCannotGrowMemory(requestedSize) {
      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }

  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAP32[(((__environ)+(i * 4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
  _environ_get.sig = 'iii';

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAP32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAP32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }
  _environ_sizes_get.sig = 'iii';

  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }
  _exit.sig = 'vi';

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_close.sig = 'ii';

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      // TODO HEAP16[(((pbuf)+(2))>>1)] = ?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)] = tempI64[0],HEAP32[(((pbuf)+(12))>>2)] = tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)] = tempI64[0],HEAP32[(((pbuf)+(20))>>2)] = tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_fdstat_get.sig = 'iii';

  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_read.sig = 'iiiii';

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      ;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_write.sig = 'iiiii';

  function _getTempRet0() {
      return getTempRet0();
    }
  _getTempRet0.sig = 'i';

  function _getaddrinfo(node, service, hint, out) {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;
  
      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var errno;
  
        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          inetNtop6(addr) :
          inetNtop4(addr);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family, addr, port);
        assert(!errno);
  
        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)] = family;
        HEAP32[(((ai)+(8))>>2)] = type;
        HEAP32[(((ai)+(12))>>2)] = proto;
        HEAP32[(((ai)+(24))>>2)] = canon;
        HEAP32[(((ai)+(20))>>2)] = sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)] = 28;
        } else {
          HEAP32[(((ai)+(16))>>2)] = 16;
        }
        HEAP32[(((ai)+(28))>>2)] = 0;
  
        return ai;
      }
  
      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
  
      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
  
      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
  
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
  
        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }
  
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
  
      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = inetPton4(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = inetPton6(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }
  
      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAP32[((out)>>2)] = ai;
      return 0;
    }
  _getaddrinfo.sig = 'iiiii';

  function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
      var info = readSockaddr(sa, salen);
      if (info.errno) {
        return -6;
      }
      var port = info.port;
      var addr = info.addr;
  
      var overflowed = false;
  
      if (node && nodelen) {
        var lookup;
        if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
          if (flags & 8) {
            return -2;
          }
        } else {
          addr = lookup;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
  
        if (numBytesWrittenExclNull+1 >= nodelen) {
          overflowed = true;
        }
      }
  
      if (serv && servlen) {
        port = '' + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
  
        if (numBytesWrittenExclNull+1 >= servlen) {
          overflowed = true;
        }
      }
  
      if (overflowed) {
        // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
        return -12;
      }
  
      return 0;
    }

  function _proc_exit(code) {
      procExit(code);
    }
  _proc_exit.sig = 'vi';

  function _pthread_setschedparam(
  ) {
  if (!Module['_pthread_setschedparam']) abort("external symbol 'pthread_setschedparam' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_pthread_setschedparam'].apply(null, arguments);
  }

  function _sem_timedwait(
  ) {
  if (!Module['_sem_timedwait']) abort("external symbol 'sem_timedwait' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_sem_timedwait'].apply(null, arguments);
  }

  function _setTempRet0(val) {
      setTempRet0(val);
    }
  _setTempRet0.sig = 'vi';

  function _system(command) {
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      setErrNo(52);
      return -1;
    }

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };;
var ASSERTIONS = true;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var asmLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__call_sighandler": ___call_sighandler,
  "__heap_base": ___heap_base,
  "__indirect_function_table": wasmTable,
  "__memory_base": ___memory_base,
  "__stack_pointer": ___stack_pointer,
  "__syscall__newselect": ___syscall__newselect,
  "__syscall_accept4": ___syscall_accept4,
  "__syscall_bind": ___syscall_bind,
  "__syscall_chdir": ___syscall_chdir,
  "__syscall_connect": ___syscall_connect,
  "__syscall_dup": ___syscall_dup,
  "__syscall_dup3": ___syscall_dup3,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_getdents64": ___syscall_getdents64,
  "__syscall_getsockname": ___syscall_getsockname,
  "__syscall_getsockopt": ___syscall_getsockopt,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_listen": ___syscall_listen,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdir": ___syscall_mkdir,
  "__syscall_mknod": ___syscall_mknod,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_pipe": ___syscall_pipe,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_recvfrom": ___syscall_recvfrom,
  "__syscall_renameat": ___syscall_renameat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_sendto": ___syscall_sendto,
  "__syscall_socket": ___syscall_socket,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_symlink": ___syscall_symlink,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "__table_base": ___table_base,
  "_dlopen_js": __dlopen_js,
  "_dlsym_js": __dlsym_js,
  "_emscripten_date_now": __emscripten_date_now,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_emscripten_throw_longjmp": __emscripten_throw_longjmp,
  "_gmtime_js": __gmtime_js,
  "_localtime_js": __localtime_js,
  "_mktime_js": __mktime_js,
  "_timegm_js": __timegm_js,
  "_tzset_js": __tzset_js,
  "abort": _abort,
  "emscripten_console_error": _emscripten_console_error,
  "emscripten_get_heap_max": _emscripten_get_heap_max,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "exit": _exit,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "getTempRet0": _getTempRet0,
  "getaddrinfo": _getaddrinfo,
  "getnameinfo": _getnameinfo,
  "invoke_ii": invoke_ii,
  "invoke_iii": invoke_iii,
  "invoke_iiii": invoke_iiii,
  "invoke_iiiii": invoke_iiiii,
  "invoke_iiiiii": invoke_iiiiii,
  "invoke_vi": invoke_vi,
  "invoke_vii": invoke_vii,
  "invoke_viii": invoke_viii,
  "invoke_viiii": invoke_viiii,
  "invoke_viiiiiiiii": invoke_viiiiiiiii,
  "memory": wasmMemory,
  "proc_exit": _proc_exit,
  "pthread_setschedparam": _pthread_setschedparam,
  "sem_timedwait": _sem_timedwait,
  "setTempRet0": _setTempRet0,
  "system": _system
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = createExportWrapper("__wasm_call_ctors");

/** @type {function(...*):?} */
var _constructor = Module["_constructor"] = createExportWrapper("constructor");

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = createExportWrapper("malloc");

/** @type {function(...*):?} */
var _set = Module["_set"] = createExportWrapper("set");

/** @type {function(...*):?} */
var _get = Module["_get"] = createExportWrapper("get");

/** @type {function(...*):?} */
var _destructor = Module["_destructor"] = createExportWrapper("destructor");

/** @type {function(...*):?} */
var _fprintf = Module["_fprintf"] = createExportWrapper("fprintf");

/** @type {function(...*):?} */
var _strcmp = Module["_strcmp"] = createExportWrapper("strcmp");

/** @type {function(...*):?} */
var _gf_fileio_set_stats_u32 = Module["_gf_fileio_set_stats_u32"] = createExportWrapper("gf_fileio_set_stats_u32");

/** @type {function(...*):?} */
var _free = Module["_free"] = createExportWrapper("free");

/** @type {function(...*):?} */
var _realloc = Module["_realloc"] = createExportWrapper("realloc");

/** @type {function(...*):?} */
var _memcpy = Module["_memcpy"] = createExportWrapper("memcpy");

/** @type {function(...*):?} */
var _strlen = Module["_strlen"] = createExportWrapper("strlen");

/** @type {function(...*):?} */
var _memcmp = Module["_memcmp"] = createExportWrapper("memcmp");

/** @type {function(...*):?} */
var _memmove = Module["_memmove"] = createExportWrapper("memmove");

/** @type {function(...*):?} */
var _gf_fileio_new = Module["_gf_fileio_new"] = createExportWrapper("gf_fileio_new");

/** @type {function(...*):?} */
var _gf_fileio_url = Module["_gf_fileio_url"] = createExportWrapper("gf_fileio_url");

/** @type {function(...*):?} */
var _gf_fileio_get_udta = Module["_gf_fileio_get_udta"] = createExportWrapper("gf_fileio_get_udta");

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = createExportWrapper("__errno_location");

/** @type {function(...*):?} */
var _strcpy = Module["_strcpy"] = createExportWrapper("strcpy");

/** @type {function(...*):?} */
var _strcat = Module["_strcat"] = createExportWrapper("strcat");

/** @type {function(...*):?} */
var _strchr = Module["_strchr"] = createExportWrapper("strchr");

/** @type {function(...*):?} */
var _strncmp = Module["_strncmp"] = createExportWrapper("strncmp");

/** @type {function(...*):?} */
var _sprintf = Module["_sprintf"] = createExportWrapper("sprintf");

/** @type {function(...*):?} */
var _gf_strdup = Module["_gf_strdup"] = createExportWrapper("gf_strdup");

/** @type {function(...*):?} */
var _vsnprintf = Module["_vsnprintf"] = createExportWrapper("vsnprintf");

/** @type {function(...*):?} */
var _fwrite = Module["_fwrite"] = createExportWrapper("fwrite");

/** @type {function(...*):?} */
var _vfprintf = Module["_vfprintf"] = createExportWrapper("vfprintf");

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = createExportWrapper("fflush");

/** @type {function(...*):?} */
var _gf_bs_new = Module["_gf_bs_new"] = createExportWrapper("gf_bs_new");

/** @type {function(...*):?} */
var _gf_bs_del = Module["_gf_bs_del"] = createExportWrapper("gf_bs_del");

/** @type {function(...*):?} */
var _gf_bs_read_int = Module["_gf_bs_read_int"] = createExportWrapper("gf_bs_read_int");

/** @type {function(...*):?} */
var _gf_bs_available = Module["_gf_bs_available"] = createExportWrapper("gf_bs_available");

/** @type {function(...*):?} */
var _gf_bs_get_position = Module["_gf_bs_get_position"] = createExportWrapper("gf_bs_get_position");

/** @type {function(...*):?} */
var _strncpy = Module["_strncpy"] = createExportWrapper("strncpy");

/** @type {function(...*):?} */
var _calloc = Module["_calloc"] = createExportWrapper("calloc");

/** @type {function(...*):?} */
var _strdup = Module["_strdup"] = createExportWrapper("strdup");

/** @type {function(...*):?} */
var _gf_url_concatenate = Module["_gf_url_concatenate"] = createExportWrapper("gf_url_concatenate");

/** @type {function(...*):?} */
var _pthread_self = Module["_pthread_self"] = createExportWrapper("pthread_self");

/** @type {function(...*):?} */
var _pthread_mutex_init = Module["_pthread_mutex_init"] = createExportWrapper("pthread_mutex_init");

/** @type {function(...*):?} */
var _pthread_mutex_destroy = Module["_pthread_mutex_destroy"] = createExportWrapper("pthread_mutex_destroy");

/** @type {function(...*):?} */
var _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = createExportWrapper("pthread_mutex_unlock");

/** @type {function(...*):?} */
var _pthread_mutex_lock = Module["_pthread_mutex_lock"] = createExportWrapper("pthread_mutex_lock");

/** @type {function(...*):?} */
var _getenv = Module["_getenv"] = createExportWrapper("getenv");

/** @type {function(...*):?} */
var _gf_filter_pck_new_alloc = Module["_gf_filter_pck_new_alloc"] = createExportWrapper("gf_filter_pck_new_alloc");

/** @type {function(...*):?} */
var _gf_filter_pck_new_ref = Module["_gf_filter_pck_new_ref"] = createExportWrapper("gf_filter_pck_new_ref");

/** @type {function(...*):?} */
var _gf_filter_pck_send = Module["_gf_filter_pck_send"] = createExportWrapper("gf_filter_pck_send");

/** @type {function(...*):?} */
var _gf_filter_pck_get_data = Module["_gf_filter_pck_get_data"] = createExportWrapper("gf_filter_pck_get_data");

/** @type {function(...*):?} */
var _gf_filter_pck_get_property = Module["_gf_filter_pck_get_property"] = createExportWrapper("gf_filter_pck_get_property");

/** @type {function(...*):?} */
var _gf_filter_pck_set_framing = Module["_gf_filter_pck_set_framing"] = createExportWrapper("gf_filter_pck_set_framing");

/** @type {function(...*):?} */
var _gf_filter_pck_set_cts = Module["_gf_filter_pck_set_cts"] = createExportWrapper("gf_filter_pck_set_cts");

/** @type {function(...*):?} */
var _gf_filter_pck_get_cts = Module["_gf_filter_pck_get_cts"] = createExportWrapper("gf_filter_pck_get_cts");

/** @type {function(...*):?} */
var _gf_filter_pck_get_timescale = Module["_gf_filter_pck_get_timescale"] = createExportWrapper("gf_filter_pck_get_timescale");

/** @type {function(...*):?} */
var _gf_filter_pck_set_sap = Module["_gf_filter_pck_set_sap"] = createExportWrapper("gf_filter_pck_set_sap");

/** @type {function(...*):?} */
var _gf_filter_pck_set_duration = Module["_gf_filter_pck_set_duration"] = createExportWrapper("gf_filter_pck_set_duration");

/** @type {function(...*):?} */
var _gf_filter_pck_get_duration = Module["_gf_filter_pck_get_duration"] = createExportWrapper("gf_filter_pck_get_duration");

/** @type {function(...*):?} */
var _gf_filter_pck_set_seek_flag = Module["_gf_filter_pck_set_seek_flag"] = createExportWrapper("gf_filter_pck_set_seek_flag");

/** @type {function(...*):?} */
var _gf_filter_pck_get_seek_flag = Module["_gf_filter_pck_get_seek_flag"] = createExportWrapper("gf_filter_pck_get_seek_flag");

/** @type {function(...*):?} */
var _gf_filter_pck_set_dependency_flags = Module["_gf_filter_pck_set_dependency_flags"] = createExportWrapper("gf_filter_pck_set_dependency_flags");

/** @type {function(...*):?} */
var _gf_filter_pck_set_byte_offset = Module["_gf_filter_pck_set_byte_offset"] = createExportWrapper("gf_filter_pck_set_byte_offset");

/** @type {function(...*):?} */
var _gf_filter_pid_get_packet = Module["_gf_filter_pid_get_packet"] = createExportWrapper("gf_filter_pid_get_packet");

/** @type {function(...*):?} */
var _gf_filter_pid_check_caps = Module["_gf_filter_pid_check_caps"] = createExportWrapper("gf_filter_pid_check_caps");

/** @type {function(...*):?} */
var _gf_filter_pid_set_property = Module["_gf_filter_pid_set_property"] = createExportWrapper("gf_filter_pid_set_property");

/** @type {function(...*):?} */
var _gf_filter_pid_get_property = Module["_gf_filter_pid_get_property"] = createExportWrapper("gf_filter_pid_get_property");

/** @type {function(...*):?} */
var _gf_filter_pid_set_framing_mode = Module["_gf_filter_pid_set_framing_mode"] = createExportWrapper("gf_filter_pid_set_framing_mode");

/** @type {function(...*):?} */
var _gf_filter_pid_new = Module["_gf_filter_pid_new"] = createExportWrapper("gf_filter_pid_new");

/** @type {function(...*):?} */
var _gf_filter_pid_copy_properties = Module["_gf_filter_pid_copy_properties"] = createExportWrapper("gf_filter_pid_copy_properties");

/** @type {function(...*):?} */
var _cos = Module["_cos"] = createExportWrapper("cos");

/** @type {function(...*):?} */
var _sin = Module["_sin"] = createExportWrapper("sin");

/** @type {function(...*):?} */
var _tan = Module["_tan"] = createExportWrapper("tan");

/** @type {function(...*):?} */
var _atan = Module["_atan"] = createExportWrapper("atan");

/** @type {function(...*):?} */
var _pow = Module["_pow"] = createExportWrapper("pow");

/** @type {function(...*):?} */
var _acos = Module["_acos"] = createExportWrapper("acos");

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = createExportWrapper("htonl");

/** @type {function(...*):?} */
var _htons = Module["_htons"] = createExportWrapper("htons");

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = createExportWrapper("ntohs");

/** @type {function(...*):?} */
var _asin = Module["_asin"] = createExportWrapper("asin");

/** @type {function(...*):?} */
var _log = Module["_log"] = createExportWrapper("log");

/** @type {function(...*):?} */
var _saveSetjmp = Module["_saveSetjmp"] = createExportWrapper("saveSetjmp");

/** @type {function(...*):?} */
var _gf_filter_get_udta = Module["_gf_filter_get_udta"] = createExportWrapper("gf_filter_get_udta");

/** @type {function(...*):?} */
var _gf_filter_set_name = Module["_gf_filter_set_name"] = createExportWrapper("gf_filter_set_name");

/** @type {function(...*):?} */
var _fabs = Module["_fabs"] = createExportWrapper("fabs");

/** @type {function(...*):?} */
var _exp = Module["_exp"] = createExportWrapper("exp");

/** @type {function(...*):?} */
var _cosh = Module["_cosh"] = createExportWrapper("cosh");

/** @type {function(...*):?} */
var _sinh = Module["_sinh"] = createExportWrapper("sinh");

/** @type {function(...*):?} */
var _tanh = Module["_tanh"] = createExportWrapper("tanh");

/** @type {function(...*):?} */
var _memset = Module["_memset"] = createExportWrapper("memset");

/** @type {function(...*):?} */
var _siprintf = Module["_siprintf"] = createExportWrapper("siprintf");

/** @type {function(...*):?} */
var _frexp = Module["_frexp"] = createExportWrapper("frexp");

/** @type {function(...*):?} */
var ___stdio_exit = Module["___stdio_exit"] = createExportWrapper("__stdio_exit");

/** @type {function(...*):?} */
var _bsearch = Module["_bsearch"] = createExportWrapper("bsearch");

/** @type {function(...*):?} */
var ___dl_seterr = Module["___dl_seterr"] = createExportWrapper("__dl_seterr");

/** @type {function(...*):?} */
var _ldexp = Module["_ldexp"] = createExportWrapper("ldexp");

/** @type {function(...*):?} */
var _llrint = Module["_llrint"] = createExportWrapper("llrint");

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = createExportWrapper("memalign");

/** @type {function(...*):?} */
var _posix_memalign = Module["_posix_memalign"] = createExportWrapper("posix_memalign");

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = createExportWrapper("setThrew");

/** @type {function(...*):?} */
var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
  return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = function() {
  return (_emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = function() {
  return (_emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = function() {
  return (_emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = createExportWrapper("stackSave");

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = createExportWrapper("stackRestore");

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = createExportWrapper("stackAlloc");

/** @type {function(...*):?} */
var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");

/** @type {function(...*):?} */
var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");

/** @type {function(...*):?} */
var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");

/** @type {function(...*):?} */
var dynCall_iiiiji = Module["dynCall_iiiiji"] = createExportWrapper("dynCall_iiiiji");

/** @type {function(...*):?} */
var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");

/** @type {function(...*):?} */
var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");

/** @type {function(...*):?} */
var dynCall_jijii = Module["dynCall_jijii"] = createExportWrapper("dynCall_jijii");

/** @type {function(...*):?} */
var dynCall_jijji = Module["dynCall_jijji"] = createExportWrapper("dynCall_jijji");

/** @type {function(...*):?} */
var dynCall_jijij = Module["dynCall_jijij"] = createExportWrapper("dynCall_jijij");

/** @type {function(...*):?} */
var dynCall_iijijji = Module["dynCall_iijijji"] = createExportWrapper("dynCall_iijijji");

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");

/** @type {function(...*):?} */
var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");

/** @type {function(...*):?} */
var dynCall_iiiijjjii = Module["dynCall_iiiijjjii"] = createExportWrapper("dynCall_iiiijjjii");

/** @type {function(...*):?} */
var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");

/** @type {function(...*):?} */
var dynCall_iiijji = Module["dynCall_iiijji"] = createExportWrapper("dynCall_iiijji");

/** @type {function(...*):?} */
var dynCall_viiijiii = Module["dynCall_viiijiii"] = createExportWrapper("dynCall_viiijiii");

/** @type {function(...*):?} */
var dynCall_jijjiii = Module["dynCall_jijjiii"] = createExportWrapper("dynCall_jijjiii");

/** @type {function(...*):?} */
var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");

/** @type {function(...*):?} */
var dynCall_jijiiiii = Module["dynCall_jijiiiii"] = createExportWrapper("dynCall_jijiiiii");

/** @type {function(...*):?} */
var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");

/** @type {function(...*):?} */
var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");

/** @type {function(...*):?} */
var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");

/** @type {function(...*):?} */
var dynCall_iijijjji = Module["dynCall_iijijjji"] = createExportWrapper("dynCall_iijijjji");

/** @type {function(...*):?} */
var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");

/** @type {function(...*):?} */
var dynCall_iiiij = Module["dynCall_iiiij"] = createExportWrapper("dynCall_iiiij");

/** @type {function(...*):?} */
var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");

/** @type {function(...*):?} */
var dynCall_vijjii = Module["dynCall_vijjii"] = createExportWrapper("dynCall_vijjii");

/** @type {function(...*):?} */
var _orig$gf_bs_new = Module["_orig$gf_bs_new"] = createExportWrapper("orig$gf_bs_new");

/** @type {function(...*):?} */
var _orig$gf_bs_available = Module["_orig$gf_bs_available"] = createExportWrapper("orig$gf_bs_available");

/** @type {function(...*):?} */
var _orig$gf_bs_get_position = Module["_orig$gf_bs_get_position"] = createExportWrapper("orig$gf_bs_get_position");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_set_cts = Module["_orig$gf_filter_pck_set_cts"] = createExportWrapper("orig$gf_filter_pck_set_cts");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_get_cts = Module["_orig$gf_filter_pck_get_cts"] = createExportWrapper("orig$gf_filter_pck_get_cts");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_set_byte_offset = Module["_orig$gf_filter_pck_set_byte_offset"] = createExportWrapper("orig$gf_filter_pck_set_byte_offset");

/** @type {function(...*):?} */
var _orig$llrint = Module["_orig$llrint"] = createExportWrapper("orig$llrint");


function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}




// === Auto-generated postamble setup entry stuff ===

unexportedRuntimeFunction('intArrayFromString', false);
unexportedRuntimeFunction('intArrayToString', false);
unexportedRuntimeFunction('ccall', false);
unexportedRuntimeFunction('cwrap', false);
unexportedRuntimeFunction('setValue', false);
unexportedRuntimeFunction('getValue', false);
Module["allocate"] = allocate;
unexportedRuntimeFunction('UTF8ArrayToString', false);
Module["UTF8ToString"] = UTF8ToString;
unexportedRuntimeFunction('stringToUTF8Array', false);
Module["stringToUTF8"] = stringToUTF8;
unexportedRuntimeFunction('lengthBytesUTF8', false);
unexportedRuntimeFunction('stackTrace', false);
unexportedRuntimeFunction('addOnPreRun', false);
unexportedRuntimeFunction('addOnInit', false);
unexportedRuntimeFunction('addOnPreMain', false);
unexportedRuntimeFunction('addOnExit', false);
unexportedRuntimeFunction('addOnPostRun', false);
unexportedRuntimeFunction('writeStringToMemory', false);
unexportedRuntimeFunction('writeArrayToMemory', false);
unexportedRuntimeFunction('writeAsciiToMemory', false);
unexportedRuntimeFunction('addRunDependency', true);
unexportedRuntimeFunction('removeRunDependency', true);
unexportedRuntimeFunction('FS_createFolder', false);
unexportedRuntimeFunction('FS_createPath', true);
unexportedRuntimeFunction('FS_createDataFile', true);
unexportedRuntimeFunction('FS_createPreloadedFile', true);
unexportedRuntimeFunction('FS_createLazyFile', true);
unexportedRuntimeFunction('FS_createLink', false);
unexportedRuntimeFunction('FS_createDevice', true);
unexportedRuntimeFunction('FS_unlink', true);
unexportedRuntimeFunction('getLEB', false);
unexportedRuntimeFunction('getFunctionTables', false);
unexportedRuntimeFunction('alignFunctionTables', false);
unexportedRuntimeFunction('registerFunctions', false);
unexportedRuntimeFunction('addFunction', false);
unexportedRuntimeFunction('removeFunction', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('prettyPrint', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('getCompilerSetting', false);
unexportedRuntimeFunction('print', false);
unexportedRuntimeFunction('printErr', false);
unexportedRuntimeFunction('getTempRet0', false);
unexportedRuntimeFunction('setTempRet0', false);
unexportedRuntimeFunction('callMain', false);
unexportedRuntimeFunction('abort', false);
unexportedRuntimeFunction('keepRuntimeAlive', false);
unexportedRuntimeFunction('zeroMemory', false);
unexportedRuntimeFunction('stringToNewUTF8', false);
unexportedRuntimeFunction('abortOnCannotGrowMemory', false);
unexportedRuntimeFunction('emscripten_realloc_buffer', false);
unexportedRuntimeFunction('ENV', false);
unexportedRuntimeFunction('ERRNO_CODES', false);
unexportedRuntimeFunction('ERRNO_MESSAGES', false);
unexportedRuntimeFunction('setErrNo', false);
unexportedRuntimeFunction('inetPton4', false);
unexportedRuntimeFunction('inetNtop4', false);
unexportedRuntimeFunction('inetPton6', false);
unexportedRuntimeFunction('inetNtop6', false);
unexportedRuntimeFunction('readSockaddr', false);
unexportedRuntimeFunction('writeSockaddr', false);
unexportedRuntimeFunction('DNS', false);
unexportedRuntimeFunction('getHostByName', false);
unexportedRuntimeFunction('Protocols', false);
unexportedRuntimeFunction('Sockets', false);
unexportedRuntimeFunction('getRandomDevice', false);
unexportedRuntimeFunction('traverseStack', false);
unexportedRuntimeFunction('UNWIND_CACHE', false);
unexportedRuntimeFunction('convertPCtoSourceLocation', false);
unexportedRuntimeFunction('readAsmConstArgsArray', false);
unexportedRuntimeFunction('readAsmConstArgs', false);
unexportedRuntimeFunction('mainThreadEM_ASM', false);
unexportedRuntimeFunction('jstoi_q', false);
unexportedRuntimeFunction('jstoi_s', false);
unexportedRuntimeFunction('getExecutableName', false);
unexportedRuntimeFunction('listenOnce', false);
unexportedRuntimeFunction('autoResumeAudioContext', false);
unexportedRuntimeFunction('dynCallLegacy', false);
unexportedRuntimeFunction('getDynCaller', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('handleException', false);
unexportedRuntimeFunction('runtimeKeepalivePush', false);
unexportedRuntimeFunction('runtimeKeepalivePop', false);
unexportedRuntimeFunction('callUserCallback', false);
unexportedRuntimeFunction('maybeExit', false);
unexportedRuntimeFunction('safeSetTimeout', false);
unexportedRuntimeFunction('asmjsMangle', false);
unexportedRuntimeFunction('asyncLoad', false);
unexportedRuntimeFunction('alignMemory', false);
unexportedRuntimeFunction('mmapAlloc', false);
unexportedRuntimeFunction('reallyNegative', false);
unexportedRuntimeFunction('unSign', false);
unexportedRuntimeFunction('reSign', false);
unexportedRuntimeFunction('formatString', false);
unexportedRuntimeFunction('PATH', false);
unexportedRuntimeFunction('PATH_FS', false);
unexportedRuntimeFunction('SYSCALLS', false);
unexportedRuntimeFunction('getSocketFromFD', false);
unexportedRuntimeFunction('getSocketAddress', false);
unexportedRuntimeFunction('JSEvents', false);
unexportedRuntimeFunction('registerKeyEventCallback', false);
unexportedRuntimeFunction('specialHTMLTargets', false);
unexportedRuntimeFunction('maybeCStringToJsString', false);
unexportedRuntimeFunction('findEventTarget', false);
unexportedRuntimeFunction('findCanvasEventTarget', false);
unexportedRuntimeFunction('getBoundingClientRect', false);
unexportedRuntimeFunction('fillMouseEventData', false);
unexportedRuntimeFunction('registerMouseEventCallback', false);
unexportedRuntimeFunction('registerWheelEventCallback', false);
unexportedRuntimeFunction('registerUiEventCallback', false);
unexportedRuntimeFunction('registerFocusEventCallback', false);
unexportedRuntimeFunction('fillDeviceOrientationEventData', false);
unexportedRuntimeFunction('registerDeviceOrientationEventCallback', false);
unexportedRuntimeFunction('fillDeviceMotionEventData', false);
unexportedRuntimeFunction('registerDeviceMotionEventCallback', false);
unexportedRuntimeFunction('screenOrientation', false);
unexportedRuntimeFunction('fillOrientationChangeEventData', false);
unexportedRuntimeFunction('registerOrientationChangeEventCallback', false);
unexportedRuntimeFunction('fillFullscreenChangeEventData', false);
unexportedRuntimeFunction('registerFullscreenChangeEventCallback', false);
unexportedRuntimeFunction('registerRestoreOldStyle', false);
unexportedRuntimeFunction('hideEverythingExceptGivenElement', false);
unexportedRuntimeFunction('restoreHiddenElements', false);
unexportedRuntimeFunction('setLetterbox', false);
unexportedRuntimeFunction('currentFullscreenStrategy', false);
unexportedRuntimeFunction('restoreOldWindowedStyle', false);
unexportedRuntimeFunction('softFullscreenResizeWebGLRenderTarget', false);
unexportedRuntimeFunction('doRequestFullscreen', false);
unexportedRuntimeFunction('fillPointerlockChangeEventData', false);
unexportedRuntimeFunction('registerPointerlockChangeEventCallback', false);
unexportedRuntimeFunction('registerPointerlockErrorEventCallback', false);
unexportedRuntimeFunction('requestPointerLock', false);
unexportedRuntimeFunction('fillVisibilityChangeEventData', false);
unexportedRuntimeFunction('registerVisibilityChangeEventCallback', false);
unexportedRuntimeFunction('registerTouchEventCallback', false);
unexportedRuntimeFunction('fillGamepadEventData', false);
unexportedRuntimeFunction('registerGamepadEventCallback', false);
unexportedRuntimeFunction('registerBeforeUnloadEventCallback', false);
unexportedRuntimeFunction('fillBatteryEventData', false);
unexportedRuntimeFunction('battery', false);
unexportedRuntimeFunction('registerBatteryEventCallback', false);
unexportedRuntimeFunction('setCanvasElementSize', false);
unexportedRuntimeFunction('getCanvasElementSize', false);
unexportedRuntimeFunction('demangle', false);
unexportedRuntimeFunction('demangleAll', false);
unexportedRuntimeFunction('jsStackTrace', false);
unexportedRuntimeFunction('stackTrace', false);
unexportedRuntimeFunction('getEnvStrings', false);
unexportedRuntimeFunction('checkWasiClock', false);
unexportedRuntimeFunction('writeI53ToI64', false);
unexportedRuntimeFunction('writeI53ToI64Clamped', false);
unexportedRuntimeFunction('writeI53ToI64Signaling', false);
unexportedRuntimeFunction('writeI53ToU64Clamped', false);
unexportedRuntimeFunction('writeI53ToU64Signaling', false);
unexportedRuntimeFunction('readI53FromI64', false);
unexportedRuntimeFunction('readI53FromU64', false);
unexportedRuntimeFunction('convertI32PairToI53', false);
unexportedRuntimeFunction('convertU32PairToI53', false);
unexportedRuntimeFunction('GOT', false);
unexportedRuntimeFunction('LDSO', false);
unexportedRuntimeFunction('getMemory', false);
unexportedRuntimeFunction('mergeLibSymbols', false);
unexportedRuntimeFunction('loadWebAssemblyModule', false);
unexportedRuntimeFunction('loadDynamicLibrary', false);
unexportedRuntimeFunction('dlopenInternal', false);
unexportedRuntimeFunction('setImmediateWrapped', false);
unexportedRuntimeFunction('clearImmediateWrapped', false);
unexportedRuntimeFunction('polyfillSetImmediate', false);
unexportedRuntimeFunction('uncaughtExceptionCount', false);
unexportedRuntimeFunction('exceptionLast', false);
unexportedRuntimeFunction('exceptionCaught', false);
unexportedRuntimeFunction('ExceptionInfo', false);
unexportedRuntimeFunction('CatchInfo', false);
unexportedRuntimeFunction('exception_addRef', false);
unexportedRuntimeFunction('exception_decRef', false);
unexportedRuntimeFunction('Browser', false);
unexportedRuntimeFunction('funcWrappers', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('setMainLoop', false);
unexportedRuntimeFunction('wget', false);
unexportedRuntimeFunction('FS', false);
unexportedRuntimeFunction('MEMFS', false);
unexportedRuntimeFunction('TTY', false);
unexportedRuntimeFunction('PIPEFS', false);
unexportedRuntimeFunction('SOCKFS', false);
unexportedRuntimeFunction('_setNetworkCallback', false);
unexportedRuntimeFunction('tempFixedLengthArray', false);
unexportedRuntimeFunction('miniTempWebGLFloatBuffers', false);
unexportedRuntimeFunction('heapObjectForWebGLType', false);
unexportedRuntimeFunction('heapAccessShiftForWebGLHeap', false);
unexportedRuntimeFunction('GL', false);
unexportedRuntimeFunction('emscriptenWebGLGet', false);
unexportedRuntimeFunction('computeUnpackAlignedImageSize', false);
unexportedRuntimeFunction('emscriptenWebGLGetTexPixelData', false);
unexportedRuntimeFunction('emscriptenWebGLGetUniform', false);
unexportedRuntimeFunction('webglGetUniformLocation', false);
unexportedRuntimeFunction('webglPrepareUniformLocationsBeforeFirstUse', false);
unexportedRuntimeFunction('webglGetLeftBracePos', false);
unexportedRuntimeFunction('emscriptenWebGLGetVertexAttrib', false);
unexportedRuntimeFunction('writeGLArray', false);
unexportedRuntimeFunction('AL', false);
unexportedRuntimeFunction('SDL_unicode', false);
unexportedRuntimeFunction('SDL_ttfContext', false);
unexportedRuntimeFunction('SDL_audio', false);
unexportedRuntimeFunction('SDL', false);
unexportedRuntimeFunction('SDL_gfx', false);
unexportedRuntimeFunction('GLUT', false);
unexportedRuntimeFunction('EGL', false);
unexportedRuntimeFunction('GLFW_Window', false);
unexportedRuntimeFunction('GLFW', false);
unexportedRuntimeFunction('GLEW', false);
unexportedRuntimeFunction('IDBStore', false);
unexportedRuntimeFunction('runAndAbortIfError', false);
unexportedRuntimeFunction('warnOnce', false);
unexportedRuntimeFunction('stackSave', false);
unexportedRuntimeFunction('stackRestore', false);
unexportedRuntimeFunction('stackAlloc', false);
unexportedRuntimeFunction('AsciiToString', false);
unexportedRuntimeFunction('stringToAscii', false);
unexportedRuntimeFunction('UTF16ToString', false);
unexportedRuntimeFunction('stringToUTF16', false);
unexportedRuntimeFunction('lengthBytesUTF16', false);
unexportedRuntimeFunction('UTF32ToString', false);
unexportedRuntimeFunction('stringToUTF32', false);
unexportedRuntimeFunction('lengthBytesUTF32', false);
unexportedRuntimeFunction('allocateUTF8', false);
unexportedRuntimeFunction('allocateUTF8OnStack', false);
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
unexportedRuntimeSymbol('ALLOC_NORMAL', false);
unexportedRuntimeSymbol('ALLOC_STACK', false);

var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = Module['_main'];

  // Main modules can't tell if they have main() at compile time, since it may
  // arrive from a dynamic library.
  if (!entryFunction) return;

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as
    // execution is asynchronously handed off to a pthread.
    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  } finally {
    calledMain = true;

  }
}

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  _emscripten_stack_set_limits(6284784, 1041904);
  writeStackCookie();
}

var dylibsLoaded = false;

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  stackCheckInit();

  if (!dylibsLoaded) {
  // Loading of dynamic libraries needs to happen on each thread, so we can't
  // use the normal __ATPRERUN__ mechanism.
    preloadDylibs();
    dylibsLoaded = true;

    // Loading dylibs can add run dependencies.
    if (runDependencies > 0) {
      return;
    }
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    ___stdio_exit();
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  checkUnflushedContent();

  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
  if (keepRuntimeAlive() && !implicit) {
    var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';
    readyPromiseReject(msg);
    err(msg);
  }

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();







  return Module.ready
}
);
})();
if (typeof exports === 'object' && "object" === 'object')
  module.exports = Module;
else if (typeof define === 'function' && __webpack_require__.amdO)
  define([], function() { return Module; });
else if (typeof exports === 'object')
  exports["Module"] = Module;

  const location = {};
  const memio = [];
  

/***/ }),

/***/ "./webinterface/core-fetch.js":
/*!************************************!*\
  !*** ./webinterface/core-fetch.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FETCH_MODULE": () => (/* binding */ FETCH_MODULE)
/* harmony export */ });
function FETCH_MODULE(MODULE_HEAP, MODULE, ABORT, EXPORT_WRAPPER, STRINGTOUTF8,UTF8TOSTRING,ALLOCATEUTF8,WASMENTRYTABLE) {

    // Global function
    var HEAP,
        /** @type {!ArrayBuffer} */
        buffer,
        /** @type {!Int8Array} */
        HEAP8,
        /** @type {!Uint8Array} */
        HEAPU8,
        /** @type {!Int16Array} */
        HEAP16,
        /** @type {!Uint16Array} */
        HEAPU16,
        /** @type {!Int32Array} */
        HEAP32,
        /** @type {!Uint32Array} */
        HEAPU32,
        /** @type {!Float32Array} */
        HEAPF32,
        /** @type {!Float64Array} */
        HEAPF64;

    function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        HEAP8 = new Int8Array(buf);
        HEAP16 = new Int16Array(buf);
        HEAP32 = new Int32Array(buf);
        HEAPU8 = new Uint8Array(buf);
        HEAPU16 = new Uint16Array(buf);
        HEAPU32 = new Uint32Array(buf);
        HEAPF32 = new Float32Array(buf);
        HEAPF64 = new Float64Array(buf);
    }
    updateGlobalBufferAndViews(MODULE_HEAP);

    /** @type {function(*, string=)} */
    function assert(condition, text) {
        if (!condition) {
            abort('Assertion failed' + (text ? ': ' + text : ''));
        }
    }

    var Module = MODULE;
    var createExportWrapper = EXPORT_WRAPPER;
    var _malloc = Module["_malloc"] = createExportWrapper("malloc");
    var err = console.warn.bind(console);
    var UTF8ToString = UTF8TOSTRING;
    var stringToUTF8 = STRINGTOUTF8;
    var abort = ABORT;
    var getWasmTableEntry = WASMENTRYTABLE; 

    var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';

    var Fetch = {
        xhrs: [], setu64: function (addr, val) {
            HEAPU32[addr >> 2] = val;
            HEAPU32[addr + 4 >> 2] = (val / 4294967296) | 0;
        }, openDatabase: function (dbname, dbversion, onsuccess, onerror) {
            try {
                var openRequest = indexedDB.open(dbname, dbversion);
            } catch (e) { return onerror(e); }

            openRequest.onupgradeneeded = (event) => {
                var db = /** @type {IDBDatabase} */ (event.target.result);
                if (db.objectStoreNames.contains('FILES')) {
                    db.deleteObjectStore('FILES');
                }
                db.createObjectStore('FILES');
            };
            openRequest.onsuccess = (event) => onsuccess(event.target.result);
            openRequest.onerror = (error) => onerror(error);
        }, staticInit: function () {
            var isMainThread = true;

            var onsuccess = (db) => {
                Fetch.dbInstance = db;

                if (isMainThread) {
                    removeRunDependency('library_fetch_init');
                }
            };
            var onerror = () => {
                Fetch.dbInstance = false;

                if (isMainThread) {
                    removeRunDependency('library_fetch_init');
                }
            };
            Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);

            if (typeof ENVIRONMENT_IS_FETCH_WORKER == 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');
        }
    };

    function __emscripten_fetch_get_response_headers(id, dst, dstSizeBytes) {
        var responseHeaders = Fetch.xhrs[id - 1].getAllResponseHeaders();
        var lengthBytes = lengthBytesUTF8(responseHeaders) + 1;
        stringToUTF8(responseHeaders, dst, dstSizeBytes);
        return Math.min(lengthBytes, dstSizeBytes);
    }

    function __emscripten_fetch_get_response_headers_length(id) {
        return lengthBytesUTF8(Fetch.xhrs[id - 1].getAllResponseHeaders()) + 1;
    }

    function _emscripten_is_main_browser_thread() {
        return !ENVIRONMENT_IS_WORKER;
    }

    // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
    function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
            // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
            // See http://unicode.org/faq/utf_bom.html#utf16-3
            var u = str.charCodeAt(i); // possibly a lead surrogate
            if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
            if (u <= 0x7F) ++len;
            else if (u <= 0x7FF) len += 2;
            else if (u <= 0xFFFF) len += 3;
            else len += 4;
        }
        return len;
    }

    var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    }

    var quit_ = (status, toThrow) => {
        throw toThrow;
      };

    /**
 * @constructor
 * @this {ExitStatus}
 */
    function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = "Program terminated with exit(" + status + ")";
        this.status = status;
    }

    function handleException(e) {
        // Certain exception types we do not treat as errors since they are used for
        // internal control flow.
        // 1. ExitStatus, which is thrown by exit()
        // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
        //    that wish to return to JS event loop.
        if (e instanceof ExitStatus || e == 'unwind') {
            return EXITSTATUS;
        }
        quit_(1, e);
    }

    /** @param {boolean=} synchronous */
    function callUserCallback(func, synchronous) {
        if (ABORT) {
            err('user callback triggered after runtime exited or application aborted.  Ignoring.');
            return;
        }
        // For synchronous calls, let any exceptions propagate, and don't let the runtime exit.
        if (synchronous) {
            func();
            return;
        }
        try {
            func();
        } catch (e) {
            handleException(e);
        }
    }

    function fetchLoadCachedData(db, fetch, onsuccess, onerror) {
        if (!db) {
            onerror(fetch, 0, 'IndexedDB not available!');
            return;
        }

        var fetch_attr = fetch + 112;
        var path = HEAPU32[fetch_attr + 64 >> 2];
        if (!path) path = HEAPU32[fetch + 8 >> 2];
        var pathStr = UTF8ToString(path);

        try {
            var transaction = db.transaction(['FILES'], 'readonly');
            var packages = transaction.objectStore('FILES');
            var getRequest = packages.get(pathStr);
            getRequest.onsuccess = (event) => {
                if (event.target.result) {
                    var value = event.target.result;
                    var len = value.byteLength || value.length;
                    // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
                    // freed when emscripten_fetch_close() is called.
                    var ptr = _malloc(len);
                    HEAPU8.set(new Uint8Array(value), ptr);
                    HEAPU32[fetch + 12 >> 2] = ptr;
                    Fetch.setu64(fetch + 16, len);
                    Fetch.setu64(fetch + 24, 0);
                    Fetch.setu64(fetch + 32, len);
                    HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
                    HEAPU16[fetch + 42 >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
                    stringToUTF8("OK", fetch + 44, 64);
                    onsuccess(fetch, 0, value);
                } else {
                    // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.
                    HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
                    HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
                    stringToUTF8("Not Found", fetch + 44, 64);
                    onerror(fetch, 0, 'no data');
                }
            };
            getRequest.onerror = (error) => {
                HEAPU16[fetch + 40 >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
                HEAPU16[fetch + 42 >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
                stringToUTF8("Not Found", fetch + 44, 64);
                onerror(fetch, 0, error);
            };
        } catch (e) {
            onerror(fetch, 0, e);
        }
    }

    function fetchXHR(fetch, onsuccess, onerror, onprogress, onreadystatechange) {
        var url = HEAPU32[fetch + 8 >> 2];
        if (!url) {
            onerror(fetch, 0, 'no url specified!');
            return;
        }
        var url_ = UTF8ToString(url);

        var fetch_attr = fetch + 112;
        var requestMethod = UTF8ToString(fetch_attr);
        if (!requestMethod) requestMethod = 'GET';
        var userData = HEAPU32[fetch + 4 >> 2];
        var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
        var timeoutMsecs = HEAPU32[fetch_attr + 56 >> 2];
        var withCredentials = !!HEAPU32[fetch_attr + 60 >> 2];
        var destinationPath = HEAPU32[fetch_attr + 64 >> 2];
        var userName = HEAPU32[fetch_attr + 68 >> 2];
        var password = HEAPU32[fetch_attr + 72 >> 2];
        var requestHeaders = HEAPU32[fetch_attr + 76 >> 2];
        var overriddenMimeType = HEAPU32[fetch_attr + 80 >> 2];
        var dataPtr = HEAPU32[fetch_attr + 84 >> 2];
        var dataLength = HEAPU32[fetch_attr + 88 >> 2];

        var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
        var fetchAttrStreamData = !!(fetchAttributes & 2);
        var fetchAttrPersistFile = !!(fetchAttributes & 4);
        var fetchAttrAppend = !!(fetchAttributes & 8);
        var fetchAttrReplace = !!(fetchAttributes & 16);
        var fetchAttrSynchronous = !!(fetchAttributes & 64);
        var fetchAttrWaitable = !!(fetchAttributes & 128);

        var userNameStr = userName ? UTF8ToString(userName) : undefined;
        var passwordStr = password ? UTF8ToString(password) : undefined;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = withCredentials;
        xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
        if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
        xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
        assert(!fetchAttrStreamData, 'streaming uses moz-chunked-arraybuffer which is no longer supported; TODO: rewrite using fetch()');
        xhr.responseType = 'arraybuffer';

        if (overriddenMimeType) {
            var overriddenMimeTypeStr = UTF8ToString(overriddenMimeType);
            xhr.overrideMimeType(overriddenMimeTypeStr);
        }
        if (requestHeaders) {
            for (; ;) {
                var key = HEAPU32[requestHeaders >> 2];
                if (!key) break;
                var value = HEAPU32[requestHeaders + 4 >> 2];
                if (!value) break;
                requestHeaders += 8;
                var keyStr = UTF8ToString(key);
                var valueStr = UTF8ToString(value);
                xhr.setRequestHeader(keyStr, valueStr);
            }
        }
        Fetch.xhrs.push(xhr);
        var id = Fetch.xhrs.length;
        HEAPU32[fetch + 0 >> 2] = id;
        var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
        // TODO: Support specifying custom headers to the request.

        // Share the code to save the response, as we need to do so both on success
        // and on error (despite an error, there may be a response, like a 404 page).
        // This receives a condition, which determines whether to save the xhr's
        // response, or just 0.
        function saveResponse(condition) {
            var ptr = 0;
            var ptrLen = 0;
            if (condition) {
                ptrLen = xhr.response ? xhr.response.byteLength : 0;
                // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
                // freed when emscripten_fetch_close() is called.
                ptr = _malloc(ptrLen);
                HEAPU8.set(new Uint8Array(/** @type{Array<number>} */(xhr.response)), ptr);
            }
            HEAPU32[fetch + 12 >> 2] = ptr;
            Fetch.setu64(fetch + 16, ptrLen);
        }

        xhr.onload = (e) => {
            saveResponse(fetchAttrLoadToMemory && !fetchAttrStreamData);
            var len = xhr.response ? xhr.response.byteLength : 0;
            Fetch.setu64(fetch + 24, 0);
            if (len) {
                // If the final XHR.onload handler receives the bytedata to compute total length, report that,
                // otherwise don't write anything out here, which will retain the latest byte size reported in
                // the most recent XHR.onprogress handler.
                Fetch.setu64(fetch + 32, len);
            }
            HEAPU16[fetch + 40 >> 1] = xhr.readyState;
            HEAPU16[fetch + 42 >> 1] = xhr.status;
            if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
            if (xhr.status >= 200 && xhr.status < 300) {
                if (onsuccess) onsuccess(fetch, xhr, e);
            } else {
                if (onerror) onerror(fetch, xhr, e);
            }
        };
        xhr.onerror = (e) => {
            saveResponse(fetchAttrLoadToMemory);
            var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
            Fetch.setu64(fetch + 24, 0);
            Fetch.setu64(fetch + 32, xhr.response ? xhr.response.byteLength : 0);
            HEAPU16[fetch + 40 >> 1] = xhr.readyState;
            HEAPU16[fetch + 42 >> 1] = status;
            if (onerror) onerror(fetch, xhr, e);
        };
        xhr.ontimeout = (e) => {
            if (onerror) onerror(fetch, xhr, e);
        };
        xhr.onprogress = (e) => {
            var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
            var ptr = 0;
            if (fetchAttrLoadToMemory && fetchAttrStreamData) {
                assert(onprogress, 'When doing a streaming fetch, you should have an onprogress handler registered to receive the chunks!');
                // Allocate byte data in Emscripten heap for the streamed memory block (freed immediately after onprogress call)
                ptr = _malloc(ptrLen);
                HEAPU8.set(new Uint8Array(/** @type{Array<number>} */(xhr.response)), ptr);
            }
            HEAPU32[fetch + 12 >> 2] = ptr;
            Fetch.setu64(fetch + 16, ptrLen);
            Fetch.setu64(fetch + 24, e.loaded - ptrLen);
            Fetch.setu64(fetch + 32, e.total);
            HEAPU16[fetch + 40 >> 1] = xhr.readyState;
            // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
            if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200;
            HEAPU16[fetch + 42 >> 1] = xhr.status;
            if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
            if (onprogress) onprogress(fetch, xhr, e);
            if (ptr) {
                _free(ptr);
            }
        };
        xhr.onreadystatechange = (e) => {
            HEAPU16[fetch + 40 >> 1] = xhr.readyState;
            if (xhr.readyState >= 2) {
                HEAPU16[fetch + 42 >> 1] = xhr.status;
            }
            if (onreadystatechange) onreadystatechange(fetch, xhr, e);
        };
        try {
            xhr.send(data);
        } catch (e) {
            if (onerror) onerror(fetch, xhr, e);
        }
    }

    function _emscripten_start_fetch(fetch, successcb, errorcb, progresscb, readystatechangecb) {
        // Avoid shutting down the runtime since we want to wait for the async
        // response.


        var fetch_attr = fetch + 112;
        var requestMethod = UTF8ToString(fetch_attr);
        var onsuccess = HEAPU32[fetch_attr + 36 >> 2];
        var onerror = HEAPU32[fetch_attr + 40 >> 2];
        var onprogress = HEAPU32[fetch_attr + 44 >> 2];
        var onreadystatechange = HEAPU32[fetch_attr + 48 >> 2];
        var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
        var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
        var fetchAttrStreamData = !!(fetchAttributes & 2);
        var fetchAttrPersistFile = !!(fetchAttributes & 4);
        var fetchAttrNoDownload = !!(fetchAttributes & 32);
        var fetchAttrAppend = !!(fetchAttributes & 8);
        var fetchAttrReplace = !!(fetchAttributes & 16);
        var fetchAttrSynchronous = !!(fetchAttributes & 64);

        var reportSuccess = (fetch, xhr, e) => {

            callUserCallback(() => {
                if (onsuccess) getWasmTableEntry(onsuccess)(fetch);
                else if (successcb) successcb(fetch);
            }, fetchAttrSynchronous);
        };

        var reportProgress = (fetch, xhr, e) => {
            callUserCallback(() => {
                if (onprogress) getWasmTableEntry(onprogress)(fetch);
                else if (progresscb) progresscb(fetch);
            }, fetchAttrSynchronous);
        };

        var reportError = (fetch, xhr, e) => {

            callUserCallback(() => {
                if (onerror) getWasmTableEntry(onerror)(fetch);
                else if (errorcb) errorcb(fetch);
            }, fetchAttrSynchronous);
        };

        var reportReadyStateChange = (fetch, xhr, e) => {
            callUserCallback(() => {
                if (onreadystatechange) getWasmTableEntry(onreadystatechange)(fetch);
                else if (readystatechangecb) readystatechangecb(fetch);
            }, fetchAttrSynchronous);
        };

        var performUncachedXhr = (fetch, xhr, e) => {
            fetchXHR(fetch, reportSuccess, reportError, reportProgress, reportReadyStateChange);
        };

        var cacheResultAndReportSuccess = (fetch, xhr, e) => {
            var storeSuccess = (fetch, xhr, e) => {

                callUserCallback(() => {
                    if (onsuccess) getWasmTableEntry(onsuccess)(fetch);
                    else if (successcb) successcb(fetch);
                }, fetchAttrSynchronous);
            };
            var storeError = (fetch, xhr, e) => {

                callUserCallback(() => {
                    if (onsuccess) getWasmTableEntry(onsuccess)(fetch);
                    else if (successcb) successcb(fetch);
                }, fetchAttrSynchronous);
            };
            fetchCacheData(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
        };

        var performCachedXhr = (fetch, xhr, e) => {
            fetchXHR(fetch, cacheResultAndReportSuccess, reportError, reportProgress, reportReadyStateChange);
        };

        if (requestMethod === 'EM_IDB_STORE') {
            // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
            var ptr = HEAPU32[fetch_attr + 84 >> 2];
            fetchCacheData(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + HEAPU32[fetch_attr + 88 >> 2]), reportSuccess, reportError);
        } else if (requestMethod === 'EM_IDB_DELETE') {
            fetchDeleteCachedData(Fetch.dbInstance, fetch, reportSuccess, reportError);
        } else if (!fetchAttrReplace) {
            fetchLoadCachedData(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : (fetchAttrPersistFile ? performCachedXhr : performUncachedXhr));
        } else if (!fetchAttrNoDownload) {
            fetchXHR(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress, reportReadyStateChange);
        } else {
            return 0; // todo: free
        }
        return fetch;
    }

    function __emscripten_fetch_free(id) {
        //Note: should just be [id], but indexes off by 1 (see: #8803)
        delete Fetch.xhrs[id - 1];
    }

    var fetch_functions = {
        "emscripten_is_main_browser_thread": _emscripten_is_main_browser_thread,
        "emscripten_start_fetch": _emscripten_start_fetch,
        "_emscripten_fetch_free": __emscripten_fetch_free,
        "_emscripten_fetch_get_response_headers": __emscripten_fetch_get_response_headers,
        "_emscripten_fetch_get_response_headers_length": __emscripten_fetch_get_response_headers_length,
    }


    return fetch_functions;
}



/***/ }),

/***/ "./webinterface/core-player.js":
/*!*************************************!*\
  !*** ./webinterface/core-player.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __filename = "/index.js";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Module": () => (/* binding */ Module),
/* harmony export */   "location": () => (/* binding */ location),
/* harmony export */   "memio": () => (/* binding */ memio)
/* harmony export */ });
/* harmony import */ var _core_sdl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core-sdl.js */ "./webinterface/core-sdl.js");
/* harmony import */ var _core_fetch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core-fetch.js */ "./webinterface/core-fetch.js");
/* module decorator */ module = __webpack_require__.hmd(module);




var Module = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(Module) {
  Module = Module || {};



// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};
var filter_entries = Module['filter_entries'] || [];
var module_entries = Module['module_entries'] || [];

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// Set up the promise that indicates the Module is initialized
var readyPromiseResolve, readyPromiseReject;
Module['ready'] = new Promise(function(resolve, reject) {
  readyPromiseResolve = resolve;
  readyPromiseReject = reject;
});

Object.defineProperty(Module, "filter_entries", { configurable: true, get: function() { return filter_entries } });
Object.defineProperty(Module, "module_entries", { configurable: true, get: function() { return module_entries } });

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_unlock')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_unlock', { configurable: true, get: function() { abort('You are getting _pthread_mutex_unlock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_unlock', { configurable: true, set: function() { abort('You are setting _pthread_mutex_unlock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_lock')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_lock', { configurable: true, get: function() { abort('You are getting _pthread_mutex_lock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_lock', { configurable: true, set: function() { abort('You are setting _pthread_mutex_lock on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_self')) {
        Object.defineProperty(Module['ready'], '_pthread_self', { configurable: true, get: function() { abort('You are getting _pthread_self on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_self', { configurable: true, set: function() { abort('You are setting _pthread_self on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sprintf')) {
        Object.defineProperty(Module['ready'], '_sprintf', { configurable: true, get: function() { abort('You are getting _sprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sprintf', { configurable: true, set: function() { abort('You are setting _sprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_vfprintf')) {
        Object.defineProperty(Module['ready'], '_vfprintf', { configurable: true, get: function() { abort('You are getting _vfprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_vfprintf', { configurable: true, set: function() { abort('You are setting _vfprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fprintf')) {
        Object.defineProperty(Module['ready'], '_fprintf', { configurable: true, get: function() { abort('You are getting _fprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fprintf', { configurable: true, set: function() { abort('You are setting _fprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_bsearch')) {
        Object.defineProperty(Module['ready'], '_bsearch', { configurable: true, get: function() { abort('You are getting _bsearch on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_bsearch', { configurable: true, set: function() { abort('You are setting _bsearch on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_frexp')) {
        Object.defineProperty(Module['ready'], '_frexp', { configurable: true, get: function() { abort('You are getting _frexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_frexp', { configurable: true, set: function() { abort('You are setting _frexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_llrint')) {
        Object.defineProperty(Module['ready'], '_llrint', { configurable: true, get: function() { abort('You are getting _llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_llrint', { configurable: true, set: function() { abort('You are setting _llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fwrite')) {
        Object.defineProperty(Module['ready'], '_fwrite', { configurable: true, get: function() { abort('You are getting _fwrite on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fwrite', { configurable: true, set: function() { abort('You are setting _fwrite on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_cos')) {
        Object.defineProperty(Module['ready'], '_cos', { configurable: true, get: function() { abort('You are getting _cos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_cos', { configurable: true, set: function() { abort('You are setting _cos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_cosh')) {
        Object.defineProperty(Module['ready'], '_cosh', { configurable: true, get: function() { abort('You are getting _cosh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_cosh', { configurable: true, set: function() { abort('You are setting _cosh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_acos')) {
        Object.defineProperty(Module['ready'], '_acos', { configurable: true, get: function() { abort('You are getting _acos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_acos', { configurable: true, set: function() { abort('You are setting _acos on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sin')) {
        Object.defineProperty(Module['ready'], '_sin', { configurable: true, get: function() { abort('You are getting _sin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sin', { configurable: true, set: function() { abort('You are setting _sin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_sinh')) {
        Object.defineProperty(Module['ready'], '_sinh', { configurable: true, get: function() { abort('You are getting _sinh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_sinh', { configurable: true, set: function() { abort('You are setting _sinh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_asin')) {
        Object.defineProperty(Module['ready'], '_asin', { configurable: true, get: function() { abort('You are getting _asin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_asin', { configurable: true, set: function() { abort('You are setting _asin on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_tan')) {
        Object.defineProperty(Module['ready'], '_tan', { configurable: true, get: function() { abort('You are getting _tan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_tan', { configurable: true, set: function() { abort('You are setting _tan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_tanh')) {
        Object.defineProperty(Module['ready'], '_tanh', { configurable: true, get: function() { abort('You are getting _tanh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_tanh', { configurable: true, set: function() { abort('You are setting _tanh on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_atan')) {
        Object.defineProperty(Module['ready'], '_atan', { configurable: true, get: function() { abort('You are getting _atan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_atan', { configurable: true, set: function() { abort('You are setting _atan on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_exp')) {
        Object.defineProperty(Module['ready'], '_exp', { configurable: true, get: function() { abort('You are getting _exp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_exp', { configurable: true, set: function() { abort('You are setting _exp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_log')) {
        Object.defineProperty(Module['ready'], '_log', { configurable: true, get: function() { abort('You are getting _log on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_log', { configurable: true, set: function() { abort('You are setting _log on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fabs')) {
        Object.defineProperty(Module['ready'], '_fabs', { configurable: true, get: function() { abort('You are getting _fabs on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fabs', { configurable: true, set: function() { abort('You are setting _fabs on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strncmp')) {
        Object.defineProperty(Module['ready'], '_strncmp', { configurable: true, get: function() { abort('You are getting _strncmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strncmp', { configurable: true, set: function() { abort('You are setting _strncmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strdup')) {
        Object.defineProperty(Module['ready'], '_strdup', { configurable: true, get: function() { abort('You are getting _strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strdup', { configurable: true, set: function() { abort('You are setting _strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_timescale')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_timescale', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_timescale on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_timescale', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_timescale on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_cts')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_cts', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_cts', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_duration')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_duration', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_duration', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_url')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_url', { configurable: true, get: function() { abort('You are getting _gf_fileio_url on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_url', { configurable: true, set: function() { abort('You are setting _gf_fileio_url on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_new')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_new', { configurable: true, get: function() { abort('You are getting _gf_fileio_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_new', { configurable: true, set: function() { abort('You are setting _gf_fileio_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_set_stats_u32')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_set_stats_u32', { configurable: true, get: function() { abort('You are getting _gf_fileio_set_stats_u32 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_set_stats_u32', { configurable: true, set: function() { abort('You are setting _gf_fileio_set_stats_u32 on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_ldexp')) {
        Object.defineProperty(Module['ready'], '_ldexp', { configurable: true, get: function() { abort('You are getting _ldexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_ldexp', { configurable: true, set: function() { abort('You are setting _ldexp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_destroy')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_destroy', { configurable: true, get: function() { abort('You are getting _pthread_mutex_destroy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_destroy', { configurable: true, set: function() { abort('You are setting _pthread_mutex_destroy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pthread_mutex_init')) {
        Object.defineProperty(Module['ready'], '_pthread_mutex_init', { configurable: true, get: function() { abort('You are getting _pthread_mutex_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pthread_mutex_init', { configurable: true, set: function() { abort('You are setting _pthread_mutex_init on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_posix_memalign')) {
        Object.defineProperty(Module['ready'], '_posix_memalign', { configurable: true, get: function() { abort('You are getting _posix_memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_posix_memalign', { configurable: true, set: function() { abort('You are setting _posix_memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_pow')) {
        Object.defineProperty(Module['ready'], '_pow', { configurable: true, get: function() { abort('You are getting _pow on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_pow', { configurable: true, set: function() { abort('You are setting _pow on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_vsnprintf')) {
        Object.defineProperty(Module['ready'], '_vsnprintf', { configurable: true, get: function() { abort('You are getting _vsnprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_vsnprintf', { configurable: true, set: function() { abort('You are setting _vsnprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_getenv')) {
        Object.defineProperty(Module['ready'], '_getenv', { configurable: true, get: function() { abort('You are getting _getenv on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_getenv', { configurable: true, set: function() { abort('You are setting _getenv on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcmp')) {
        Object.defineProperty(Module['ready'], '_strcmp', { configurable: true, get: function() { abort('You are getting _strcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcmp', { configurable: true, set: function() { abort('You are setting _strcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strlen')) {
        Object.defineProperty(Module['ready'], '_strlen', { configurable: true, get: function() { abort('You are getting _strlen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strlen', { configurable: true, set: function() { abort('You are setting _strlen on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcpy')) {
        Object.defineProperty(Module['ready'], '_strcpy', { configurable: true, get: function() { abort('You are getting _strcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcpy', { configurable: true, set: function() { abort('You are setting _strcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strcat')) {
        Object.defineProperty(Module['ready'], '_strcat', { configurable: true, get: function() { abort('You are getting _strcat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strcat', { configurable: true, set: function() { abort('You are setting _strcat on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strncpy')) {
        Object.defineProperty(Module['ready'], '_strncpy', { configurable: true, get: function() { abort('You are getting _strncpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strncpy', { configurable: true, set: function() { abort('You are setting _strncpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_strchr')) {
        Object.defineProperty(Module['ready'], '_strchr', { configurable: true, get: function() { abort('You are getting _strchr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_strchr', { configurable: true, set: function() { abort('You are setting _strchr on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memset')) {
        Object.defineProperty(Module['ready'], '_memset', { configurable: true, get: function() { abort('You are getting _memset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memset', { configurable: true, set: function() { abort('You are setting _memset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memcpy')) {
        Object.defineProperty(Module['ready'], '_memcpy', { configurable: true, get: function() { abort('You are getting _memcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memcpy', { configurable: true, set: function() { abort('You are setting _memcpy on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memmove')) {
        Object.defineProperty(Module['ready'], '_memmove', { configurable: true, get: function() { abort('You are getting _memmove on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memmove', { configurable: true, set: function() { abort('You are setting _memmove on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memalign')) {
        Object.defineProperty(Module['ready'], '_memalign', { configurable: true, get: function() { abort('You are getting _memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memalign', { configurable: true, set: function() { abort('You are setting _memalign on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_memcmp')) {
        Object.defineProperty(Module['ready'], '_memcmp', { configurable: true, get: function() { abort('You are getting _memcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_memcmp', { configurable: true, set: function() { abort('You are setting _memcmp on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_calloc')) {
        Object.defineProperty(Module['ready'], '_calloc', { configurable: true, get: function() { abort('You are getting _calloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_calloc', { configurable: true, set: function() { abort('You are setting _calloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_realloc')) {
        Object.defineProperty(Module['ready'], '_realloc', { configurable: true, get: function() { abort('You are getting _realloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_realloc', { configurable: true, set: function() { abort('You are setting _realloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_url_concatenate')) {
        Object.defineProperty(Module['ready'], '_gf_url_concatenate', { configurable: true, get: function() { abort('You are getting _gf_url_concatenate on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_url_concatenate', { configurable: true, set: function() { abort('You are setting _gf_url_concatenate on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_strdup')) {
        Object.defineProperty(Module['ready'], '_gf_strdup', { configurable: true, get: function() { abort('You are getting _gf_strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_strdup', { configurable: true, set: function() { abort('You are setting _gf_strdup on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_fileio_get_udta')) {
        Object.defineProperty(Module['ready'], '_gf_fileio_get_udta', { configurable: true, get: function() { abort('You are getting _gf_fileio_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_fileio_get_udta', { configurable: true, set: function() { abort('You are setting _gf_fileio_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_new')) {
        Object.defineProperty(Module['ready'], '_gf_bs_new', { configurable: true, get: function() { abort('You are getting _gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_new', { configurable: true, set: function() { abort('You are setting _gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_available')) {
        Object.defineProperty(Module['ready'], '_gf_bs_available', { configurable: true, get: function() { abort('You are getting _gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_available', { configurable: true, set: function() { abort('You are setting _gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_read_int')) {
        Object.defineProperty(Module['ready'], '_gf_bs_read_int', { configurable: true, get: function() { abort('You are getting _gf_bs_read_int on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_read_int', { configurable: true, set: function() { abort('You are setting _gf_bs_read_int on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_get_position')) {
        Object.defineProperty(Module['ready'], '_gf_bs_get_position', { configurable: true, get: function() { abort('You are getting _gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_get_position', { configurable: true, set: function() { abort('You are setting _gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_bs_del')) {
        Object.defineProperty(Module['ready'], '_gf_bs_del', { configurable: true, get: function() { abort('You are getting _gf_bs_del on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_bs_del', { configurable: true, set: function() { abort('You are setting _gf_bs_del on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_get_udta')) {
        Object.defineProperty(Module['ready'], '_gf_filter_get_udta', { configurable: true, get: function() { abort('You are getting _gf_filter_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_get_udta', { configurable: true, set: function() { abort('You are setting _gf_filter_get_udta on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_get_packet')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_packet', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_get_packet on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_packet', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_get_packet on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_data')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_data', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_data on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_data', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_data on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_set_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_set_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_set_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_new_alloc')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_alloc', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_new_alloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_alloc', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_new_alloc on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_send')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_send', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_send on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_send', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_send on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_check_caps')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_check_caps', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_check_caps on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_check_caps', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_check_caps on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_get_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_get_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_new')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_new', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_new', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_copy_properties')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_copy_properties', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_copy_properties on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_copy_properties', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_copy_properties on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_set_name')) {
        Object.defineProperty(Module['ready'], '_gf_filter_set_name', { configurable: true, get: function() { abort('You are getting _gf_filter_set_name on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_set_name', { configurable: true, set: function() { abort('You are setting _gf_filter_set_name on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_dependency_flags')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_dependency_flags', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_dependency_flags on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_dependency_flags', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_dependency_flags on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pid_set_framing_mode')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_framing_mode', { configurable: true, get: function() { abort('You are getting _gf_filter_pid_set_framing_mode on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pid_set_framing_mode', { configurable: true, set: function() { abort('You are setting _gf_filter_pid_set_framing_mode on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_new_ref')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_ref', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_new_ref on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_new_ref', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_new_ref on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_cts')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_cts', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_cts', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_sap')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_sap', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_sap on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_sap', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_sap on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_duration')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_duration', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_duration', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_duration on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_property')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_property', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_property', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_property on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_byte_offset')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_byte_offset', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_byte_offset', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_framing')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_framing', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_framing on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_framing', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_framing on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_set_seek_flag')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_seek_flag', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_set_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_set_seek_flag', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_set_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_gf_filter_pck_get_seek_flag')) {
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_seek_flag', { configurable: true, get: function() { abort('You are getting _gf_filter_pck_get_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_gf_filter_pck_get_seek_flag', { configurable: true, set: function() { abort('You are setting _gf_filter_pck_get_seek_flag on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_fflush')) {
        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, get: function() { abort('You are getting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_fflush', { configurable: true, set: function() { abort('You are setting _fflush on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_siprintf')) {
        Object.defineProperty(Module['ready'], '_siprintf', { configurable: true, get: function() { abort('You are getting _siprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_siprintf', { configurable: true, set: function() { abort('You are setting _siprintf on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_constructor')) {
        Object.defineProperty(Module['ready'], '_constructor', { configurable: true, get: function() { abort('You are getting _constructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_constructor', { configurable: true, set: function() { abort('You are setting _constructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_set')) {
        Object.defineProperty(Module['ready'], '_set', { configurable: true, get: function() { abort('You are getting _set on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_set', { configurable: true, set: function() { abort('You are setting _set on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_get')) {
        Object.defineProperty(Module['ready'], '_get', { configurable: true, get: function() { abort('You are getting _get on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_get', { configurable: true, set: function() { abort('You are setting _get on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_destructor')) {
        Object.defineProperty(Module['ready'], '_destructor', { configurable: true, get: function() { abort('You are getting _destructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_destructor', { configurable: true, set: function() { abort('You are setting _destructor on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '___stdio_exit')) {
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, get: function() { abort('You are getting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '___stdio_exit', { configurable: true, set: function() { abort('You are setting ___stdio_exit on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_new')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_new', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_new', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_new on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_available')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_available', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_available', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_available on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_bs_get_position')) {
        Object.defineProperty(Module['ready'], '_orig$gf_bs_get_position', { configurable: true, get: function() { abort('You are getting _orig$gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_bs_get_position', { configurable: true, set: function() { abort('You are setting _orig$gf_bs_get_position on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_set_cts')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_cts', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_cts', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_set_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_get_cts')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_get_cts', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_get_cts', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_get_cts on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$gf_filter_pck_set_byte_offset')) {
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_byte_offset', { configurable: true, get: function() { abort('You are getting _orig$gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$gf_filter_pck_set_byte_offset', { configurable: true, set: function() { abort('You are setting _orig$gf_filter_pck_set_byte_offset on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], '_orig$llrint')) {
        Object.defineProperty(Module['ready'], '_orig$llrint', { configurable: true, get: function() { abort('You are getting _orig$llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], '_orig$llrint', { configurable: true, set: function() { abort('You are setting _orig$llrint on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

      if (!Object.getOwnPropertyDescriptor(Module['ready'], 'onRuntimeInitialized')) {
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, get: function() { abort('You are getting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
        Object.defineProperty(Module['ready'], 'onRuntimeInitialized', { configurable: true, set: function() { abort('You are setting onRuntimeInitialized on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js') } });
      }
    

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = false;//typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = false;//typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = false;//!ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Normally we don't log exceptions but instead let them bubble out the top
// level where the embedding environment (e.g. the browser) can handle
// them.
// However under v8 and node we sometimes exit the process direcly in which case
// its up to use us to log the exception before exiting.
// If we fix https://github.com/emscripten-core/emscripten/issues/15080
// this may no longer be needed under node.
function logExceptionOnExit(e) {
  if (e instanceof ExitStatus) return;
  let toLog = e;
  if (e && typeof e == 'object' && e.stack) {
    toLog = [e, e.stack];
  }
  err('exiting due to exception: ' + toLog);
}

var fs;

if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && "function" === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    let data;
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = function readAsync(f, onload, onerror) {
    setTimeout(() => onload(readBinary(f)), 0);
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      logExceptionOnExit(toThrow);
      quit(status);
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';


assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-s ENVIRONMENT` to enable.");




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function == "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {
  assert(typeof func != 'undefined');

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


function legacyModuleProp(prop, newName) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get: function() {
        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
  }
}

function unexportedMessage(sym, isFSSybol) {
  var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
  if (isFSSybol) {
    msg += '. Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you';
  }
  return msg;
}

function unexportedRuntimeSymbol(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get: function() {
        abort(unexportedMessage(sym, isFSSybol));
      }
    });
  }
}

function unexportedRuntimeFunction(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Module[sym] = () => abort(unexportedMessage(sym, isFSSybol));
  }
}

// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var dynamicLibraries = Module['dynamicLibraries'] || [];

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');
var noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');

if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type = 'i8', noSafe) {
  if (type.charAt(type.length-1) === '*') type = 'i32';
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return Number(HEAPF64[((ptr)>>3)]);
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;


//========================================
// SDL functions
//========================================


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;
  assert(typeof allocator == 'number', 'allocate no longer takes a type argument')
  assert(typeof slab != 'number', 'allocate no longer takes a number as arg0')

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  ;
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 134217728;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');

assert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js


// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      'maximum': INITIAL_MEMORY / 65536
    });
  }

if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_MEMORY % 65536 === 0);
updateGlobalBufferAndViews(buffer);

// end include: runtime_init_memory.js

// include: runtime_init_table.js
// In RELOCATABLE mode we create the table in JS.
var wasmTable = new WebAssembly.Table({
  'initial': 4374,
  'element': 'anyfunc'
});

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAP32[((max)>>2)] = 0x2135467;
  HEAP32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  /*if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));
  }*/
  // Also test the global address 0 for integrity.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

// end include: runtime_stack_check.js
// include: runtime_assertions.js


// Endianness check
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -s SUPPORT_BIG_ENDIAN=1 to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
SOCKFS.root = FS.mount(SOCKFS, {}, null);
PIPEFS.root = FS.mount(PIPEFS, {}, null);
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data
Module["preloadedWasm"] = {}; // maps url to wasm instance exports

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.

  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  readyPromiseReject(e);
  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
/** @param {boolean=} fixedasm */
function createExportWrapper(name, fixedasm) {
  return function() {
    var displayName = name;
    var asm = fixedasm;
    if (!fixedasm) {
      asm = Module['asm'];
    }
    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
    if (!asm[name]) {
      assert(asm[name], 'exported native function `' + displayName + '` not found');
    }
    return asm[name].apply(null, arguments);
  };
}

var wasmBinaryFile;
wasmBinaryFile = location.using;
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
    'GOT.mem': new Proxy(asmLibraryArg, GOTHandler),
    'GOT.func': new Proxy(asmLibraryArg, GOTHandler),
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    exports = relocateExports(exports, 1024);

    Module['asm'] = exports;

    var metadata = getDylinkMetadata(module);
    if (metadata.neededDynlibs) {
      dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);
    }
    mergeLibSymbols(exports, 'main')

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    receiveInstance(result['instance'], result['module']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      // Warn on some common problems.
      if (isFileURI(wasmBinaryFile)) {
        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
      }
      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // If instantiation fails, reject the module ready promise.
  instantiateAsync().catch(readyPromiseReject);
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  var GOT = {};
  var GOTHandler = {get:function(obj, symName) {
        if (!GOT[symName]) {
          GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        return GOT[symName]
      }};

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            getWasmTableEntry(func)();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            getWasmTableEntry(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function getDylinkMetadata(binary) {
      var offset = 0;
      var end = 0;
  
      function getU8() {
        return binary[offset++];
      }
  
      function getLEB() {
        var ret = 0;
        var mul = 1;
        while (1) {
          var byte = binary[offset++];
          ret += ((byte & 0x7f) * mul);
          mul *= 0x80;
          if (!(byte & 0x80)) break;
        }
        return ret;
      }
  
      function getString() {
        var len = getLEB();
        offset += len;
        return UTF8ArrayToString(binary, offset - len, len);
      }
  
      /** @param {string=} message */
      function failIf(condition, message) {
        if (condition) throw new Error(message);
      }
  
      var name = 'dylink.0';
      if (binary instanceof WebAssembly.Module) {
        var dylinkSection = WebAssembly.Module.customSections(binary, name);
        if (dylinkSection.length === 0) {
          name = 'dylink'
          dylinkSection = WebAssembly.Module.customSections(binary, name);
        }
        failIf(dylinkSection.length === 0, 'need dylink section');
        binary = new Uint8Array(dylinkSection[0]);
        end = binary.length
      } else {
        var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
        var magicNumberFound = int32View[0] == 0x6d736100;
        failIf(!magicNumberFound, 'need to see wasm magic number'); // \0asm
        // we should see the dylink custom section right after the magic number and wasm version
        failIf(binary[8] !== 0, 'need the dylink section to be first')
        offset = 9;
        var section_size = getLEB(); //section size
        end = offset + section_size;
        name = getString();
      }
  
      var customSection = { neededDynlibs: [], tlsExports: {} };
      if (name == 'dylink') {
        customSection.memorySize = getLEB();
        customSection.memoryAlign = getLEB();
        customSection.tableSize = getLEB();
        customSection.tableAlign = getLEB();
        // shared libraries this module needs. We need to load them first, so that
        // current module could resolve its imports. (see tools/shared.py
        // WebAssembly.make_shared_library() for "dylink" section extension format)
        var neededDynlibsCount = getLEB();
        for (var i = 0; i < neededDynlibsCount; ++i) {
          var libname = getString();
          customSection.neededDynlibs.push(libname);
        }
      } else {
        failIf(name !== 'dylink.0');
        var WASM_DYLINK_MEM_INFO = 0x1;
        var WASM_DYLINK_NEEDED = 0x2;
        var WASM_DYLINK_EXPORT_INFO = 0x3;
        var WASM_SYMBOL_TLS = 0x100;
        while (offset < end) {
          var subsectionType = getU8();
          var subsectionSize = getLEB();
          if (subsectionType === WASM_DYLINK_MEM_INFO) {
            customSection.memorySize = getLEB();
            customSection.memoryAlign = getLEB();
            customSection.tableSize = getLEB();
            customSection.tableAlign = getLEB();
          } else if (subsectionType === WASM_DYLINK_NEEDED) {
            var neededDynlibsCount = getLEB();
            for (var i = 0; i < neededDynlibsCount; ++i) {
              libname = getString();
              customSection.neededDynlibs.push(libname);
            }
          } else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
            var count = getLEB();
            while (count--) {
              var symname = getString();
              var flags = getLEB();
              if (flags & WASM_SYMBOL_TLS) {
                customSection.tlsExports[symname] = 1;
              }
            }
          } else {
            err('unknown dylink.0 subsection: ' + subsectionType)
            // unknown subsection
            offset += subsectionSize;
          }
        }
      }
  
      var tableAlign = Math.pow(2, customSection.tableAlign);
      assert(tableAlign === 1, 'invalid tableAlign ' + tableAlign);
      assert(offset == end);
  
      return customSection;
    }

  var wasmTableMirror = [];
  function getWasmTableEntry(funcPtr) {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
      return func;
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  function asmjsMangle(x) {
      var unmangledSymbols = ['stackAlloc','stackSave','stackRestore'];
      return x.indexOf('dynCall_') == 0 || unmangledSymbols.includes(x) ? x : '_' + x;
    }
  function mergeLibSymbols(exports, libName) {
      // add symbols into global namespace TODO: weak linking etc.
      for (var sym in exports) {
        if (!exports.hasOwnProperty(sym)) {
          continue;
        }
  
        // When RTLD_GLOBAL is enable, the symbols defined by this shared object will be made
        // available for symbol resolution of subsequently loaded shared objects.
        //
        // We should copy the symbols (which include methods and variables) from SIDE_MODULE to MAIN_MODULE.
  
        if (!asmLibraryArg.hasOwnProperty(sym)) {
          asmLibraryArg[sym] = exports[sym];
        }
  
        // Export native export on the Module object.
        // TODO(sbc): Do all users want this?  Should we skip this by default?
        var module_sym = asmjsMangle(sym);
        if (!Module.hasOwnProperty(module_sym)) {
          Module[module_sym] = exports[sym];
        }
      }
    }

  var LDSO = {loadedLibsByName:{},loadedLibsByHandle:{}};
  
  function dynCallLegacy(sig, ptr, args) {
      assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
      if (args && args.length) {
        // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
        assert(args.length === sig.substring(1).replace(/j/g, '--').length);
      } else {
        assert(sig.length == 1);
      }
      var f = Module["dynCall_" + sig];
      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
    }
  /** @param {Object=} args */
  function dynCall(sig, ptr, args) {
      // Without WASM_BIGINT support we cannot directly call function with i64 as
      // part of thier signature, so we rely the dynCall functions generated by
      // wasm-emscripten-finalize
      if (sig.includes('j')) {
        return dynCallLegacy(sig, ptr, args);
      }
      assert(getWasmTableEntry(ptr), 'missing table entry in dynCall: ' + ptr);
      return getWasmTableEntry(ptr).apply(null, args)
    }
  function createInvokeFunction(sig) {
      return function() {
        var sp = stackSave();
        try {
          return dynCall(sig, arguments[0], Array.prototype.slice.call(arguments, 1));
        } catch(e) {
          stackRestore(sp);
          // Exceptions thrown from C++ exception will be integer numbers.
          // longjmp will throw the number Infinity. Re-throw other types of
          // exceptions using a compact and fast check.
          if (e !== e+0) throw e;
          _setThrew(1, 0);
        }
      }
    }
  
  var ___heap_base = 6284784;
  function getMemory(size) {
      // After the runtime is initialized, we must only use sbrk() normally.
      if (runtimeInitialized)
        return _malloc(size);
      var ret = ___heap_base;
      var end = (ret + size + 15) & -16;
      assert(end <= HEAP8.length, 'failure to getMemory - memory growth etc. is not supported there, call malloc/sbrk directly or increase INITIAL_MEMORY');
      ___heap_base = end;
      GOT['__heap_base'].value = end;
      return ret;
    }
  
  function isInternalSym(symName) {
      // TODO: find a way to mark these in the binary or avoid exporting them.
      return [
        '__cpp_exception',
        '__c_longjmp',
        '__wasm_apply_data_relocs',
        '__dso_handle',
        '__tls_size',
        '__tls_align',
        '__set_stack_limits',
        'emscripten_tls_init',
        '__wasm_init_tls',
        '__wasm_call_ctors',
      ].includes(symName)
      ;
    }
  function updateGOT(exports, replace) {
      for (var symName in exports) {
        if (isInternalSym(symName)) {
          continue;
        }
  
        var value = exports[symName];
        if (symName.startsWith('orig$')) {
          symName = symName.split('$')[1];
          replace = true;
        }
  
        if (!GOT[symName]) {
          GOT[symName] = new WebAssembly.Global({'value': 'i32', 'mutable': true});
        }
        if (replace || GOT[symName].value == 0) {
          if (typeof value == 'function') {
            GOT[symName].value = addFunction(value);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else if (typeof value == 'bigint') {
            GOT[symName].value = Number(value);
          } else {
            err("unhandled export type for `" + symName + "`: " + (typeof value));
          }
        }
      }
    }
  /** @param {boolean=} replace */
  function relocateExports(exports, memoryBase, replace) {
      var relocated = {};
  
      for (var e in exports) {
        var value = exports[e];
        if (typeof value == 'object') {
          // a breaking change in the wasm spec, globals are now objects
          // https://github.com/WebAssembly/mutable-global/issues/1
          value = value.value;
        }
        if (typeof value == 'number') {
          value += memoryBase;
        }
        relocated[e] = value;
      }
      updateGOT(relocated, replace);
      return relocated;
    }
  
  function resolveGlobalSymbol(symName, direct) {
      var sym;
      if (direct) {
        // First look for the orig$ symbol which is the symbols without
        // any legalization performed.
        sym = asmLibraryArg['orig$' + symName];
      }
      if (!sym) {
        sym = asmLibraryArg[symName];
      }
  
      // Check for the symbol on the Module object.  This is the only
      // way to dynamically access JS library symbols that were not
      // referenced by the main module (and therefore not part of the
      // initial set of symbols included in asmLibraryArg when it
      // was declared.
      if (!sym) {
        sym = Module[asmjsMangle(symName)];
      }
  
      if (!sym && symName.startsWith('invoke_')) {
        sym = createInvokeFunction(symName.split('_')[1]);
      }
  
      return sym;
    }
  
  function alignMemory(size, alignment) {
      assert(alignment, "alignment argument is required");
      return Math.ceil(size / alignment) * alignment;
    }
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  /** @param {number=} handle */
  function loadWebAssemblyModule(binary, flags, handle) {
      var metadata = getDylinkMetadata(binary);
      var originalTable = wasmTable;
  
      // loadModule loads the wasm module after all its dependencies have been loaded.
      // can be called both sync/async.
      function loadModule() {
        // The first thread to load a given module needs to allocate the static
        // table and memory regions.  Later threads re-use the same table region
        // and can ignore the memory region (since memory is shared between
        // threads already).
        var needsAllocation = !handle || !HEAP8[(((handle)+(24))>>0)];
        if (needsAllocation) {
          // alignments are powers of 2
          var memAlign = Math.pow(2, metadata.memoryAlign);
          // finalize alignments and verify them
          memAlign = Math.max(memAlign, STACK_ALIGN); // we at least need stack alignment
          // prepare memory
          var memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0; // TODO: add to cleanups
          var tableBase = metadata.tableSize ? wasmTable.length : 0;
          if (handle) {
            HEAP8[(((handle)+(24))>>0)] = 1;
            HEAP32[(((handle)+(28))>>2)] = memoryBase;
            HEAP32[(((handle)+(32))>>2)] = metadata.memorySize;
            HEAP32[(((handle)+(36))>>2)] = tableBase;
            HEAP32[(((handle)+(40))>>2)] = metadata.tableSize;
          }
        } else {
          memoryBase = HEAP32[(((handle)+(28))>>2)];
          tableBase = HEAP32[(((handle)+(36))>>2)];
        }
  
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        if (tableGrowthNeeded > 0) {
          wasmTable.grow(tableGrowthNeeded);
        }
  
        // This is the export map that we ultimately return.  We declare it here
        // so it can be used within resolveSymbol.  We resolve symbols against
        // this local symbol map in the case there they are not present on the
        // global Module object.  We need this fallback because:
        // a) Modules sometime need to import their own symbols
        // b) Symbols from side modules are not always added to the global namespace.
        var moduleExports;
  
        function resolveSymbol(sym) {
          var resolved = resolveGlobalSymbol(sym, false);
          if (!resolved) {
            resolved = moduleExports[sym];
          }
          assert(resolved, 'undefined symbol `' + sym + '`. perhaps a side module was not linked in? if this global was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment');
          return resolved;
        }
  
        // TODO kill  (except "symbols local to this module", it will likely be
        // not needed if we require that if A wants symbols from B it has to link
        // to B explicitly: similarly to -Wl,--no-undefined)
        //
        // wasm dynamic libraries are pure wasm, so they cannot assist in
        // their own loading. When side module A wants to import something
        // provided by a side module B that is loaded later, we need to
        // add a layer of indirection, but worse, we can't even tell what
        // to add the indirection for, without inspecting what A's imports
        // are. To do that here, we use a JS proxy (another option would
        // be to inspect the binary directly).
        var proxyHandler = {
          'get': function(stubs, prop) {
            // symbols that should be local to this module
            switch (prop) {
              case '__memory_base':
                return memoryBase;
              case '__table_base':
                return tableBase;
            }
            if (prop in asmLibraryArg) {
              // No stub needed, symbol already exists in symbol table
              return asmLibraryArg[prop];
            }
            // Return a stub function that will resolve the symbol
            // when first called.
            if (!(prop in stubs)) {
              var resolved;
              stubs[prop] = function() {
                if (!resolved) resolved = resolveSymbol(prop);
                return resolved.apply(null, arguments);
              };
            }
            return stubs[prop];
          }
        };
        var proxy = new Proxy({}, proxyHandler);
        var info = {
          'GOT.mem': new Proxy({}, GOTHandler),
          'GOT.func': new Proxy({}, GOTHandler),
          'env': proxy,
          wasi_snapshot_preview1: proxy,
        };
  
        function postInstantiation(instance) {
          //FIXME : Set this information in custom section
          const filter_entry = Object.keys(instance.exports).filter(fn => fn.endsWith("_register"));
          filter_entries = filter_entries.concat(filter_entry);
          const module_entry = Object.keys(instance.exports).filter(fn => fn.startsWith("gf_register_module_"));
          module_entries = module_entries.concat(module_entry);
          // the table should be unchanged
          assert(wasmTable === originalTable);
          // add new entries to functionsInTableMap
          updateTableMap(tableBase, metadata.tableSize);
          moduleExports = relocateExports(instance.exports, memoryBase);
          if (!flags.allowUndefined) {
            reportUndefinedSymbols();
          }
  
          // initialize the module
            var init = moduleExports['__wasm_call_ctors'];
            if (init) {
              if (runtimeInitialized) {
                init();
              } else {
                // we aren't ready to run compiled code yet
                __ATINIT__.push(init);
              }
            }
          return moduleExports;
        }
  
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(instance));
          }
          return WebAssembly.instantiate(binary, info).then(function(result) {
            return postInstantiation(result.instance);
          });
        }
  
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary);
        var instance = new WebAssembly.Instance(module, info);
        return postInstantiation(instance);
      }
  
      // now load needed libraries and the module itself.
      if (flags.loadAsync) {
        return metadata.neededDynlibs.reduce(function(chain, dynNeeded) {
          return chain.then(function() {
            return loadDynamicLibrary(dynNeeded, flags);
          });
        }, Promise.resolve()).then(function() {
          return loadModule();
        });
      }
  
      metadata.neededDynlibs.forEach(function(dynNeeded) {
        loadDynamicLibrary(dynNeeded, flags);
      });
      return loadModule();
    }
  /** @param {number=} handle */
  function loadDynamicLibrary(lib, flags, handle) {
      if (lib == '__main__' && !LDSO.loadedLibsByName[lib]) {
        LDSO.loadedLibsByName[lib] = {
          refcount: Infinity,   // = nodelete
          name:     '__main__',
          module:   Module['asm'],
          global:   true
        };
      }
  
      // when loadDynamicLibrary did not have flags, libraries were loaded
      // globally & permanently
      flags = flags || {global: true, nodelete: true}
  
      var dso = LDSO.loadedLibsByName[lib];
      if (dso) {
        // the library is being loaded or has been loaded already.
        //
        // however it could be previously loaded only locally and if we get
        // load request with global=true we have to make it globally visible now.
        if (flags.global && !dso.global) {
          dso.global = true;
          if (dso.module !== 'loading') {
            // ^^^ if module is 'loading' - symbols merging will be eventually done by the loader.
            mergeLibSymbols(dso.module, lib)
          }
        }
        // same for "nodelete"
        if (flags.nodelete && dso.refcount !== Infinity) {
          dso.refcount = Infinity;
        }
        dso.refcount++
        if (handle) {
          LDSO.loadedLibsByHandle[handle] = dso;
        }
        return flags.loadAsync ? Promise.resolve(true) : true;
      }
  
      // allocate new DSO
      dso = {
        refcount: flags.nodelete ? Infinity : 1,
        name:     lib,
        module:   'loading',
        global:   flags.global,
      };
      LDSO.loadedLibsByName[lib] = dso;
      if (handle) {
        LDSO.loadedLibsByHandle[handle] = dso;
      }
  
      // libData <- libFile
      function loadLibData(libFile) {
        // for wasm, we can use fetch for async, but for fs mode we can only imitate it
        if (flags.fs && flags.fs.findObject(libFile)) {
          var libData = flags.fs.readFile(libFile, {encoding: 'binary'});
          if (!(libData instanceof Uint8Array)) {
            libData = new Uint8Array(libData);
          }
          return flags.loadAsync ? Promise.resolve(libData) : libData;
        }
  
        if (flags.loadAsync) {
          return new Promise(function(resolve, reject) {
            readAsync(libFile, function(data) { resolve(new Uint8Array(data)); }, reject);
          });
        }
  
        // load the binary synchronously
        if (!readBinary) {
          throw new Error(libFile + ': file not found, and synchronous loading of external files is not available');
        }
        return readBinary(libFile);
      }
  
      // libModule <- lib
      function getLibModule() {
        // lookup preloaded cache first
        if (Module['preloadedWasm'] !== undefined &&
            Module['preloadedWasm'][lib] !== undefined) {
          var libModule = Module['preloadedWasm'][lib];
          return flags.loadAsync ? Promise.resolve(libModule) : libModule;
        }
  
        // module not preloaded - load lib data and create new module from it
        if (flags.loadAsync) {
          return loadLibData(lib).then(function(libData) {
            return loadWebAssemblyModule(libData, flags, handle);
          });
        }
  
        return loadWebAssemblyModule(loadLibData(lib), flags, handle);
      }
  
      // module for lib is loaded - update the dso & global namespace
      function moduleLoaded(libModule) {
        if (dso.global) {
          mergeLibSymbols(libModule, lib);
        }
        dso.module = libModule;
      }
  
      if (flags.loadAsync) {
        return getLibModule().then(function(libModule) {
          moduleLoaded(libModule);
          return true;
        });
      }
  
      moduleLoaded(getLibModule());
      return true;
    }
  
  function reportUndefinedSymbols() {
      for (var symName in GOT) {
        if (GOT[symName].value == 0) {
          var value = resolveGlobalSymbol(symName, true)
          assert(value, 'undefined symbol `' + symName + '`. perhaps a side module was not linked in? if this global was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment');
          if (typeof value == 'function') {
            /** @suppress {checkTypes} */
            GOT[symName].value = addFunction(value, value.sig);
          } else if (typeof value == 'number') {
            GOT[symName].value = value;
          } else {
            throw new Error('bad export type for `' + symName + '`: ' + (typeof value));
          }
        }
      }
    }

    function add_file_io(){
      memio.forEach(x => {
        x.value = addFunction(x, x.sig);
      })
    }

  function preloadDylibs() {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
  
      // Load binaries asynchronously
      addRunDependency('preloadDylibs');
      dynamicLibraries.reduce(function(chain, lib) {
        return chain.then(function() {
          return loadDynamicLibrary(scriptDirectory + lib, {loadAsync: true, global: true, nodelete: true, allowUndefined: true});
        });
      }, Promise.resolve()).then(function() {
        // we got them all, wonderful
        reportUndefinedSymbols();
        add_file_io();
        removeRunDependency('preloadDylibs');
      });
    }



  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
      wasmTableMirror[idx] = func;
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }
  ___assert_fail.sig = 'viiii';

  function ___call_sighandler(fp, sig) {
      getWasmTableEntry(fp)(sig);
    }


  var ___memory_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1024);

  var ___stack_pointer = new WebAssembly.Global({'value': 'i32', 'mutable': true}, 6284784);

  var PATH = {splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      // if (ENVIRONMENT_IS_NODE) {
      //   // for nodejs with or without crypto support included
      //   try {
      //     var crypto_module = require('crypto');
      //     // nodejs has crypto support
      //     return function() { return crypto_module['randomBytes'](1)[0]; };
      //   } catch (e) {
      //     // nodejs doesn't have crypto support
      //   }
      // }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function mmapAlloc(size) {
      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            // We don't currently support location hints for the address of the mapping
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  
  var ERRNO_MESSAGES = {0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};
  
  var ERRNO_CODES = {};
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        assert(typeof parent == 'object')
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        if (typeof type == 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode, fd_start, fd_end) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, address, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // Call musl-internal function to close all stdio streams, so nothing is
        // left in internal buffers.
        ___stdio_exit();
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },absolutePath:() => {
        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');
      },createFolder:() => {
        abort('FS.createFolder has been removed; use FS.mkdir instead');
      },createLink:() => {
        abort('FS.createLink has been removed; use FS.symlink instead');
      },joinPath:() => {
        abort('FS.joinPath has been removed; use PATH.join instead');
      },mmapAlloc:() => {
        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');
      },standardizePath:() => {
        abort('FS.standardizePath has been removed; use PATH.normalize instead');
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (path[0] === '/') {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      }};
  function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
  try {
  
      // readfds are supported,
      // writefds checks socket open status
      // exceptfds not supported
      // timeout is always 0 - fully async
      assert(nfds <= 64, 'nfds must be less than or equal to 64');  // fd sets have 64 bits // TODO: this could be 1024 based on current musl headers
      assert(!exceptfds, 'exceptfds not supported');
  
      var total = 0;
      
      var srcReadLow = (readfds ? HEAP32[((readfds)>>2)] : 0),
          srcReadHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0);
      var srcWriteLow = (writefds ? HEAP32[((writefds)>>2)] : 0),
          srcWriteHigh = (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0);
      var srcExceptLow = (exceptfds ? HEAP32[((exceptfds)>>2)] : 0),
          srcExceptHigh = (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var dstReadLow = 0,
          dstReadHigh = 0;
      var dstWriteLow = 0,
          dstWriteHigh = 0;
      var dstExceptLow = 0,
          dstExceptHigh = 0;
  
      var allLow = (readfds ? HEAP32[((readfds)>>2)] : 0) |
                   (writefds ? HEAP32[((writefds)>>2)] : 0) |
                   (exceptfds ? HEAP32[((exceptfds)>>2)] : 0);
      var allHigh = (readfds ? HEAP32[(((readfds)+(4))>>2)] : 0) |
                    (writefds ? HEAP32[(((writefds)+(4))>>2)] : 0) |
                    (exceptfds ? HEAP32[(((exceptfds)+(4))>>2)] : 0);
  
      var check = function(fd, low, high, val) {
        return (fd < 32 ? (low & val) : (high & val));
      };
  
      for (var fd = 0; fd < nfds; fd++) {
        var mask = 1 << (fd % 32);
        if (!(check(fd, allLow, allHigh, mask))) {
          continue;  // index isn't in the set
        }
  
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
  
        var flags = SYSCALLS.DEFAULT_POLLMASK;
  
        if (stream.stream_ops.poll) {
          flags = stream.stream_ops.poll(stream);
        }
  
        if ((flags & 1) && check(fd, srcReadLow, srcReadHigh, mask)) {
          fd < 32 ? (dstReadLow = dstReadLow | mask) : (dstReadHigh = dstReadHigh | mask);
          total++;
        }
        if ((flags & 4) && check(fd, srcWriteLow, srcWriteHigh, mask)) {
          fd < 32 ? (dstWriteLow = dstWriteLow | mask) : (dstWriteHigh = dstWriteHigh | mask);
          total++;
        }
        if ((flags & 2) && check(fd, srcExceptLow, srcExceptHigh, mask)) {
          fd < 32 ? (dstExceptLow = dstExceptLow | mask) : (dstExceptHigh = dstExceptHigh | mask);
          total++;
        }
      }
  
      if (readfds) {
        HEAP32[((readfds)>>2)] = dstReadLow;
        HEAP32[(((readfds)+(4))>>2)] = dstReadHigh;
      }
      if (writefds) {
        HEAP32[((writefds)>>2)] = dstWriteLow;
        HEAP32[(((writefds)+(4))>>2)] = dstWriteHigh;
      }
      if (exceptfds) {
        HEAP32[((exceptfds)>>2)] = dstExceptLow;
        HEAP32[(((exceptfds)+(4))>>2)] = dstExceptHigh;
      }
  
      return total;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var SOCKFS = {mount:function(mount) {
        // If Module['websocket'] has already been defined (e.g. for configuring
        // the subprotocol/url) use that, if not initialise it to a new object.
        Module['websocket'] = (Module['websocket'] && 
                               ('object' === typeof Module['websocket'])) ? Module['websocket'] : {};
  
        // Add the Event registration mechanism to the exported websocket configuration
        // object so we can register network callbacks from native JavaScript too.
        // For more documentation see system/include/emscripten/emscripten.h
        Module['websocket']._callbacks = {};
        Module['websocket']['on'] = /** @this{Object} */ function(event, callback) {
          if ('function' === typeof callback) {
            this._callbacks[event] = callback;
          }
          return this;
        };
  
        Module['websocket'].emit = /** @this{Object} */ function(event, param) {
          if ('function' === typeof this._callbacks[event]) {
            this._callbacks[event].call(this, param);
          }
        };
  
        // If debug is enabled register simple default logging callbacks for each Event.
  
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function(family, type, protocol) {
        type &= ~526336; // Some applications may pass it; it makes no sense for a single process.
        var streaming = type == 1;
        if (streaming && protocol && protocol != 6) {
          throw new FS.ErrnoError(66); // if SOCK_STREAM, must be tcp or 0.
        }
  
        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          error: null, // Used in getsockopt for SOL_SOCKET/SO_ERROR test
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };
  
        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;
  
        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: 2,
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });
  
        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;
  
        return sock;
      },getSocket:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function(stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function(stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function(stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function(stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function() {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function(sock, addr, port) {
          var ws;
  
          if (typeof addr == 'object') {
            ws = addr;
            addr = null;
            port = null;
          }
  
          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));
  
              // The default value is 'ws://' the replace is needed because the compiler replaces '//' comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the '#' for '//' again.
              var url = 'ws:#'.replace('#', '//');
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }
  
              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                var parts = addr.split('/');
                url = url + parts[0] + ":" + port + "/" + parts.slice(1).join('/');
              }
  
              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'
  
              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }
  
              // The default WebSocket options
              var opts = undefined;
  
              if (subProtocols !== 'null') {
                // The regex trims the string (removes spaces at the beginning and end, then splits the string by
                // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
                subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);
  
                // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
                opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;
              }
  
              // some webservers (azure) does not support subprotocol header
              if (runtimeConfig && null === Module['websocket']['subprotocol']) {
                subProtocols = 'null';
                opts = undefined;
              }
  
              // If node we use the ws library.
              var WebSocketConstructor;
              if (ENVIRONMENT_IS_NODE) {
                WebSocketConstructor = /** @type{(typeof WebSocket)} */(__webpack_require__(/*! ws */ "./node_modules/ws/browser.js"));
              } else
              {
                WebSocketConstructor = WebSocket;
              }
              ws = new WebSocketConstructor(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(23);
            }
          }
  
          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };
  
          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);
  
          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport != 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }
  
          return peer;
        },getPeer:function(sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function(sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function(sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function(sock, peer) {
          var first = true;
  
          var handleOpen = function () {
  
            Module['websocket'].emit('open', sock.stream.fd);
  
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };
  
          function handleMessage(data) {
            if (typeof data == 'string') {
              var encoder = new TextEncoder(); // should be utf-8
              data = encoder.encode(data); // make a typed array from the string
            } else {
              assert(data.byteLength !== undefined); // must receive an ArrayBuffer
              if (data.byteLength == 0) {
                // An empty ArrayBuffer will emit a pseudo disconnect event
                // as recv/recvmsg will return zero which indicates that a socket
                // has performed a shutdown although the connection has not been disconnected yet.
                return;
              } else {
                data = new Uint8Array(data); // make a typed array view on the array buffer
              }
            }
  
            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }
  
            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
            Module['websocket'].emit('message', sock.stream.fd);
          };
  
          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('close', function() {
              Module['websocket'].emit('close', sock.stream.fd);
            });
            peer.socket.on('error', function(error) {
              // Although the ws library may pass errors that may be more descriptive than
              // ECONNREFUSED they are not necessarily the expected error code e.g. 
              // ENOTFOUND on getaddrinfo seems to be node.js specific, so using ECONNREFUSED
              // is still probably the most useful thing to do.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onclose = function() {
              Module['websocket'].emit('close', sock.stream.fd);
            };
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
            peer.socket.onerror = function(error) {
              // The WebSocket spec only allows a 'simple event' to be thrown on error,
              // so we only really know as much as ECONNREFUSED.
              sock.error = 14; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
              Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'ECONNREFUSED: Connection refused']);
            };
          }
        },poll:function(sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }
  
          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;
  
          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }
  
          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }
  
          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }
  
          return mask;
        },ioctl:function(sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)] = bytes;
              return 0;
            default:
              return 28;
          }
        },close:function(sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function(sock, addr, port) {
          if (typeof sock.saddr != 'undefined' || typeof sock.sport != 'undefined') {
            throw new FS.ErrnoError(28);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port;
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== 138) throw e;
            }
          }
        },connect:function(sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(138);
          }
  
          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }
  
          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr != 'undefined' && typeof sock.dport != 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(7);
              } else {
                throw new FS.ErrnoError(30);
              }
            }
          }
  
          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;
  
          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(26);
        },listen:function(sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(138);
          }
          if (sock.server) {
             throw new FS.ErrnoError(28);  // already listening
          }
          var WebSocketServer = (__webpack_require__(/*! ws */ "./node_modules/ws/browser.js").Server);
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });
          Module['websocket'].emit('listen', sock.stream.fd); // Send Event with listen fd.
  
          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);
  
              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;
  
              // push to queue for accept to pick up
              sock.pending.push(newsock);
              Module['websocket'].emit('connection', newsock.stream.fd);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
              Module['websocket'].emit('connection', sock.stream.fd);
            }
          });
          sock.server.on('closed', function() {
            Module['websocket'].emit('close', sock.stream.fd);
            sock.server = null;
          });
          sock.server.on('error', function(error) {
            // Although the ws library may pass errors that may be more descriptive than
            // ECONNREFUSED they are not necessarily the expected error code e.g. 
            // ENOTFOUND on getaddrinfo seems to be node.js specific, so using EHOSTUNREACH
            // is still probably the most useful thing to do. This error shouldn't
            // occur in a well written app as errors should get trapped in the compiled
            // app's own getaddrinfo call.
            sock.error = 23; // Used in getsockopt for SOL_SOCKET/SO_ERROR test.
            Module['websocket'].emit('error', [sock.stream.fd, sock.error, 'EHOSTUNREACH: Host is unreachable']);
            // don't throw
          });
        },accept:function(listensock) {
          if (!listensock.server || !listensock.pending.length) {
            throw new FS.ErrnoError(28);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function(sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(53);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function(sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(17);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }
  
          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);
  
          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(53);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(6);
            }
          }
  
          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          if (ArrayBuffer.isView(buffer)) {
            offset += buffer.byteOffset;
            buffer = buffer.buffer;
          }
  
          var data;
            data = buffer.slice(offset, offset + length);
  
          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }
  
          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(28);
          }
        },recvmsg:function(sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(53);
          }
  
          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
  
              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(53);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(6);
              }
            } else {
              throw new FS.ErrnoError(6);
            }
          }
  
          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };
  
          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }
  
          return res;
        }}};
  function getSocketFromFD(fd) {
      var socket = SOCKFS.getSocket(fd);
      if (!socket) throw new FS.ErrnoError(8);
      return socket;
    }
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  var Sockets = {BUFFER_SIZE:10240,MAX_BUFFER_SIZE:10485760,nextFd:1,fds:{},nextport:1,maxport:65535,peer:null,connections:{},portmap:{},localAddr:4261412874,addrPool:[33554442,50331658,67108874,83886090,100663306,117440522,134217738,150994954,167772170,184549386,201326602,218103818,234881034]};
  
  function inetPton4(str) {
      var b = str.split('.');
      for (var i = 0; i < 4; i++) {
        var tmp = Number(b[i]);
        if (isNaN(tmp)) return null;
        b[i] = tmp;
      }
      return (b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)) >>> 0;
    }
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  function inetPton6(str) {
      var words;
      var w, offset, z, i;
      /* http://home.deds.nl/~aeron/regex/ */
      var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i
      var parts = [];
      if (!valid6regx.test(str)) {
        return null;
      }
      if (str === "::") {
        return [0, 0, 0, 0, 0, 0, 0, 0];
      }
      // Z placeholder to keep track of zeros when splitting the string on ":"
      if (str.startsWith("::")) {
        str = str.replace("::", "Z:"); // leading zeros case
      } else {
        str = str.replace("::", ":Z:");
      }
  
      if (str.indexOf(".") > 0) {
        // parse IPv4 embedded stress
        str = str.replace(new RegExp('[.]', 'g'), ":");
        words = str.split(":");
        words[words.length-4] = jstoi_q(words[words.length-4]) + jstoi_q(words[words.length-3])*256;
        words[words.length-3] = jstoi_q(words[words.length-2]) + jstoi_q(words[words.length-1])*256;
        words = words.slice(0, words.length-2);
      } else {
        words = str.split(":");
      }
  
      offset = 0; z = 0;
      for (w=0; w < words.length; w++) {
        if (typeof words[w] == 'string') {
          if (words[w] === 'Z') {
            // compressed zeros - write appropriate number of zero words
            for (z = 0; z < (8 - words.length+1); z++) {
              parts[w+z] = 0;
            }
            offset = z-1;
          } else {
            // parse hex to field to 16-bit value and write it in network byte-order
            parts[w+offset] = _htons(parseInt(words[w],16));
          }
        } else {
          // parsed IPv4 words
          parts[w+offset] = words[w];
        }
      }
      return [
        (parts[1] << 16) | parts[0],
        (parts[3] << 16) | parts[2],
        (parts[5] << 16) | parts[4],
        (parts[7] << 16) | parts[6]
      ];
    }
  /** @param {number=} addrlen */
  function writeSockaddr(sa, family, addr, port, addrlen) {
      switch (family) {
        case 2:
          addr = inetPton4(addr);
          zeroMemory(sa, 16);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 16;
          }
          HEAP16[((sa)>>1)] = family;
          HEAP32[(((sa)+(4))>>2)] = addr;
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        case 10:
          addr = inetPton6(addr);
          zeroMemory(sa, 28);
          if (addrlen) {
            HEAP32[((addrlen)>>2)] = 28;
          }
          HEAP32[((sa)>>2)] = family;
          HEAP32[(((sa)+(8))>>2)] = addr[0];
          HEAP32[(((sa)+(12))>>2)] = addr[1];
          HEAP32[(((sa)+(16))>>2)] = addr[2];
          HEAP32[(((sa)+(20))>>2)] = addr[3];
          HEAP16[(((sa)+(2))>>1)] = _htons(port);
          break;
        default:
          return 5;
      }
      return 0;
    }
  
  var DNS = {address_map:{id:1,addrs:{},names:{}},lookup_name:function (name) {
        // If the name is already a valid ipv4 / ipv6 address, don't generate a fake one.
        var res = inetPton4(name);
        if (res !== null) {
          return name;
        }
        res = inetPton6(name);
        if (res !== null) {
          return name;
        }
  
        // See if this name is already mapped.
        var addr;
  
        if (DNS.address_map.addrs[name]) {
          addr = DNS.address_map.addrs[name];
        } else {
          var id = DNS.address_map.id++;
          assert(id < 65535, 'exceeded max address mappings of 65535');
  
          addr = '172.29.' + (id & 0xff) + '.' + (id & 0xff00);
  
          DNS.address_map.names[addr] = name;
          DNS.address_map.addrs[name] = addr;
        }
  
        return addr;
      },lookup_addr:function (addr) {
        if (DNS.address_map.names[addr]) {
          return DNS.address_map.names[addr];
        }
  
        return null;
      }};
  function ___syscall_accept4(fd, addr, addrlen, flags) {
  try {
  
      var sock = getSocketFromFD(fd);
      var newsock = sock.sock_ops.accept(sock);
      if (addr) {
        var errno = writeSockaddr(addr, newsock.family, DNS.lookup_name(newsock.daddr), newsock.dport, addrlen);
        assert(!errno);
      }
      return newsock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function inetNtop4(addr) {
      return (addr & 0xff) + '.' + ((addr >> 8) & 0xff) + '.' + ((addr >> 16) & 0xff) + '.' + ((addr >> 24) & 0xff)
    }
  
  function inetNtop6(ints) {
      //  ref:  http://www.ietf.org/rfc/rfc2373.txt - section 2.5.4
      //  Format for IPv4 compatible and mapped  128-bit IPv6 Addresses
      //  128-bits are split into eight 16-bit words
      //  stored in network byte order (big-endian)
      //  |                80 bits               | 16 |      32 bits        |
      //  +-----------------------------------------------------------------+
      //  |               10 bytes               |  2 |      4 bytes        |
      //  +--------------------------------------+--------------------------+
      //  +               5 words                |  1 |      2 words        |
      //  +--------------------------------------+--------------------------+
      //  |0000..............................0000|0000|    IPv4 ADDRESS     | (compatible)
      //  +--------------------------------------+----+---------------------+
      //  |0000..............................0000|FFFF|    IPv4 ADDRESS     | (mapped)
      //  +--------------------------------------+----+---------------------+
      var str = "";
      var word = 0;
      var longest = 0;
      var lastzero = 0;
      var zstart = 0;
      var len = 0;
      var i = 0;
      var parts = [
        ints[0] & 0xffff,
        (ints[0] >> 16),
        ints[1] & 0xffff,
        (ints[1] >> 16),
        ints[2] & 0xffff,
        (ints[2] >> 16),
        ints[3] & 0xffff,
        (ints[3] >> 16)
      ];
  
      // Handle IPv4-compatible, IPv4-mapped, loopback and any/unspecified addresses
  
      var hasipv4 = true;
      var v4part = "";
      // check if the 10 high-order bytes are all zeros (first 5 words)
      for (i = 0; i < 5; i++) {
        if (parts[i] !== 0) { hasipv4 = false; break; }
      }
  
      if (hasipv4) {
        // low-order 32-bits store an IPv4 address (bytes 13 to 16) (last 2 words)
        v4part = inetNtop4(parts[6] | (parts[7] << 16));
        // IPv4-mapped IPv6 address if 16-bit value (bytes 11 and 12) == 0xFFFF (6th word)
        if (parts[5] === -1) {
          str = "::ffff:";
          str += v4part;
          return str;
        }
        // IPv4-compatible IPv6 address if 16-bit value (bytes 11 and 12) == 0x0000 (6th word)
        if (parts[5] === 0) {
          str = "::";
          //special case IPv6 addresses
          if (v4part === "0.0.0.0") v4part = ""; // any/unspecified address
          if (v4part === "0.0.0.1") v4part = "1";// loopback address
          str += v4part;
          return str;
        }
      }
  
      // Handle all other IPv6 addresses
  
      // first run to find the longest contiguous zero words
      for (word = 0; word < 8; word++) {
        if (parts[word] === 0) {
          if (word - lastzero > 1) {
            len = 0;
          }
          lastzero = word;
          len++;
        }
        if (len > longest) {
          longest = len;
          zstart = word - longest + 1;
        }
      }
  
      for (word = 0; word < 8; word++) {
        if (longest > 1) {
          // compress contiguous zeros - to produce "::"
          if (parts[word] === 0 && word >= zstart && word < (zstart + longest) ) {
            if (word === zstart) {
              str += ":";
              if (zstart === 0) str += ":"; //leading zeros case
            }
            continue;
          }
        }
        // converts 16-bit words from big-endian to little-endian before converting to hex string
        str += Number(_ntohs(parts[word] & 0xffff)).toString(16);
        str += word < 7 ? ":" : "";
      }
      return str;
    }
  function readSockaddr(sa, salen) {
      // family / port offsets are common to both sockaddr_in and sockaddr_in6
      var family = HEAP16[((sa)>>1)];
      var port = _ntohs(HEAPU16[(((sa)+(2))>>1)]);
      var addr;
  
      switch (family) {
        case 2:
          if (salen !== 16) {
            return { errno: 28 };
          }
          addr = HEAP32[(((sa)+(4))>>2)];
          addr = inetNtop4(addr);
          break;
        case 10:
          if (salen !== 28) {
            return { errno: 28 };
          }
          addr = [
            HEAP32[(((sa)+(8))>>2)],
            HEAP32[(((sa)+(12))>>2)],
            HEAP32[(((sa)+(16))>>2)],
            HEAP32[(((sa)+(20))>>2)]
          ];
          addr = inetNtop6(addr);
          break;
        default:
          return { errno: 5 };
      }
  
      return { family: family, addr: addr, port: port };
    }
  /** @param {boolean=} allowNull */
  function getSocketAddress(addrp, addrlen, allowNull) {
      if (allowNull && addrp === 0) return null;
      var info = readSockaddr(addrp, addrlen);
      if (info.errno) throw new FS.ErrnoError(info.errno);
      info.addr = DNS.lookup_addr(info.addr) || info.addr;
      return info;
    }
  function ___syscall_bind(fd, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.bind(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_chdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_connect(fd, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var info = getSocketAddress(addr, addrlen);
      sock.sock_ops.connect(sock, info.addr, info.port);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_dup(fd) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.open(old.path, old.flags, 0).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_dup3(fd, suggestFD, flags) {
  try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      assert(!flags);
      if (old.fd === suggestFD) return -28;
      var suggest = FS.getStream(suggestFD);
      if (suggest) FS.close(suggest);
      return FS.open(old.path, old.flags, 0, suggestFD, suggestFD).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
        /* case 5: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        /* case 6: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 7: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd);
      if (size < cwdLengthInBytes + 1) return -68;
      stringToUTF8(cwd, buf, size);
      return buf;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getdents64(fd, dirp, count) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd)
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
  
      var struct_size = 280;
      var pos = 0;
      var off = FS.llseek(stream, 0, 1);
  
      var idx = Math.floor(off / struct_size);
  
      while (idx < stream.getdents.length && pos + struct_size <= count) {
        var id;
        var type;
        var name = stream.getdents[idx];
        if (name === '.') {
          id = stream.node.id;
          type = 4; // DT_DIR
        }
        else if (name === '..') {
          var lookup = FS.lookupPath(stream.path, { parent: true });
          id = lookup.node.id;
          type = 4; // DT_DIR
        }
        else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        assert(id);
        (tempI64 = [id>>>0,(tempDouble=id,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((dirp + pos)>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(4))>>2)] = tempI64[1]);
        (tempI64 = [(idx + 1) * struct_size>>>0,(tempDouble=(idx + 1) * struct_size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((dirp + pos)+(8))>>2)] = tempI64[0],HEAP32[(((dirp + pos)+(12))>>2)] = tempI64[1]);
        HEAP16[(((dirp + pos)+(16))>>1)] = 280;
        HEAP8[(((dirp + pos)+(18))>>0)] = type;
        stringToUTF8(name, dirp + pos + 19, 256);
        pos += struct_size;
        idx += 1;
      }
      FS.llseek(stream, idx * struct_size, 0);
      return pos;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getsockname(fd, addr, addrlen) {
  try {
  
      err("__syscall_getsockname " + fd);
      var sock = getSocketFromFD(fd);
      // TODO: sock.saddr should never be undefined, see TODO in websocket_sock_ops.getname
      var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.saddr || '0.0.0.0'), sock.sport, addrlen);
      assert(!errno);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getsockopt(fd, level, optname, optval, optlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      // Minimal getsockopt aimed at resolving https://github.com/emscripten-core/emscripten/issues/2211
      // so only supports SOL_SOCKET with SO_ERROR.
      if (level === 1) {
        if (optname === 4) {
          HEAP32[((optval)>>2)] = sock.error;
          HEAP32[((optlen)>>2)] = 4;
          sock.error = null; // Clear the error (The SO_ERROR option obtains and then clears this field).
          return 0;
        }
      }
      return -50; // The option is unknown at the level indicated.
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_ioctl(fd, op, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_listen(fd, backlog) {
  try {
  
      var sock = getSocketFromFD(fd);
      sock.sock_ops.listen(sock, backlog);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdir(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMkdir(path, mode);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mknod(path, mode, dev) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doMknod(path, mode, dev);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~4352);
      assert(!flags, flags);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var PIPEFS = {BUCKET_BUFFER_SIZE:8192,mount:function (mount) {
        // Do not pollute the real root directory or its child nodes with pipes
        // Looks like it is OK to create another pseudo-root node not linked to the FS.root hierarchy this way
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createPipe:function () {
        var pipe = {
          buckets: [],
          // refcnt 2 because pipe has a read end and a write end. We need to be
          // able to read from the read end after write end is closed.
          refcnt : 2,
        };
  
        pipe.buckets.push({
          buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
          offset: 0,
          roffset: 0
        });
  
        var rName = PIPEFS.nextname();
        var wName = PIPEFS.nextname();
        var rNode = FS.createNode(PIPEFS.root, rName, 4096, 0);
        var wNode = FS.createNode(PIPEFS.root, wName, 4096, 0);
  
        rNode.pipe = pipe;
        wNode.pipe = pipe;
  
        var readableStream = FS.createStream({
          path: rName,
          node: rNode,
          flags: 0,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        rNode.stream = readableStream;
  
        var writableStream = FS.createStream({
          path: wName,
          node: wNode,
          flags: 1,
          seekable: false,
          stream_ops: PIPEFS.stream_ops
        });
        wNode.stream = writableStream;
  
        return {
          readable_fd: readableStream.fd,
          writable_fd: writableStream.fd
        };
      },stream_ops:{poll:function (stream) {
          var pipe = stream.node.pipe;
  
          if ((stream.flags & 2097155) === 1) {
            return (256 | 4);
          } else {
            if (pipe.buckets.length > 0) {
              for (var i = 0; i < pipe.buckets.length; i++) {
                var bucket = pipe.buckets[i];
                if (bucket.offset - bucket.roffset > 0) {
                  return (64 | 1);
                }
              }
            }
          }
  
          return 0;
        },ioctl:function (stream, request, varargs) {
          return 28;
        },fsync:function (stream) {
          return 28;
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
          var currentLength = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var bucket = pipe.buckets[i];
            currentLength += bucket.offset - bucket.roffset;
          }
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          if (length <= 0) {
            return 0;
          }
          if (currentLength == 0) {
            // Behave as if the read end is always non-blocking
            throw new FS.ErrnoError(6);
          }
          var toRead = Math.min(currentLength, length);
  
          var totalRead = toRead;
          var toRemove = 0;
  
          for (var i = 0; i < pipe.buckets.length; i++) {
            var currBucket = pipe.buckets[i];
            var bucketSize = currBucket.offset - currBucket.roffset;
  
            if (toRead <= bucketSize) {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              if (toRead < bucketSize) {
                tmpSlice = tmpSlice.subarray(0, toRead);
                currBucket.roffset += toRead;
              } else {
                toRemove++;
              }
              data.set(tmpSlice);
              break;
            } else {
              var tmpSlice = currBucket.buffer.subarray(currBucket.roffset, currBucket.offset);
              data.set(tmpSlice);
              data = data.subarray(tmpSlice.byteLength);
              toRead -= tmpSlice.byteLength;
              toRemove++;
            }
          }
  
          if (toRemove && toRemove == pipe.buckets.length) {
            // Do not generate excessive garbage in use cases such as
            // write several bytes, read everything, write several bytes, read everything...
            toRemove--;
            pipe.buckets[toRemove].offset = 0;
            pipe.buckets[toRemove].roffset = 0;
          }
  
          pipe.buckets.splice(0, toRemove);
  
          return totalRead;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var pipe = stream.node.pipe;
  
          assert(buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer));
          var data = buffer.subarray(offset, offset + length);
  
          var dataLen = data.byteLength;
          if (dataLen <= 0) {
            return 0;
          }
  
          var currBucket = null;
  
          if (pipe.buckets.length == 0) {
            currBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: 0,
              roffset: 0
            };
            pipe.buckets.push(currBucket);
          } else {
            currBucket = pipe.buckets[pipe.buckets.length - 1];
          }
  
          assert(currBucket.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
  
          var freeBytesInCurrBuffer = PIPEFS.BUCKET_BUFFER_SIZE - currBucket.offset;
          if (freeBytesInCurrBuffer >= dataLen) {
            currBucket.buffer.set(data, currBucket.offset);
            currBucket.offset += dataLen;
            return dataLen;
          } else if (freeBytesInCurrBuffer > 0) {
            currBucket.buffer.set(data.subarray(0, freeBytesInCurrBuffer), currBucket.offset);
            currBucket.offset += freeBytesInCurrBuffer;
            data = data.subarray(freeBytesInCurrBuffer, data.byteLength);
          }
  
          var numBuckets = (data.byteLength / PIPEFS.BUCKET_BUFFER_SIZE) | 0;
          var remElements = data.byteLength % PIPEFS.BUCKET_BUFFER_SIZE;
  
          for (var i = 0; i < numBuckets; i++) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: PIPEFS.BUCKET_BUFFER_SIZE,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE));
            data = data.subarray(PIPEFS.BUCKET_BUFFER_SIZE, data.byteLength);
          }
  
          if (remElements > 0) {
            var newBucket = {
              buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),
              offset: data.byteLength,
              roffset: 0
            };
            pipe.buckets.push(newBucket);
            newBucket.buffer.set(data);
          }
  
          return dataLen;
        },close:function (stream) {
          var pipe = stream.node.pipe;
          pipe.refcnt--;
          if (pipe.refcnt === 0) {
            pipe.buckets = null;
          }
        }},nextname:function () {
        if (!PIPEFS.nextname.current) {
          PIPEFS.nextname.current = 0;
        }
        return 'pipe[' + (PIPEFS.nextname.current++) + ']';
      }};
  function ___syscall_pipe(fdPtr) {
  try {
  
      if (fdPtr == 0) {
        throw new FS.ErrnoError(21);
      }
  
      var res = PIPEFS.createPipe();
  
      HEAP32[((fdPtr)>>2)] = res.readable_fd;
      HEAP32[(((fdPtr)+(4))>>2)] = res.writable_fd;
  
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
  try {
  
      var sock = getSocketFromFD(fd);
      var msg = sock.sock_ops.recvmsg(sock, len);
      if (!msg) return 0; // socket is closed
      if (addr) {
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
        assert(!errno);
      }
      HEAPU8.set(msg.buffer, buf);
      return msg.buffer.byteLength;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
  try {
  
      oldpath = SYSCALLS.getStr(oldpath);
      newpath = SYSCALLS.getStr(newpath);
      oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
      newpath = SYSCALLS.calculateAt(newdirfd, newpath);
      FS.rename(oldpath, newpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
  try {
  
      var sock = getSocketFromFD(fd);
      var dest = getSocketAddress(addr, addr_len, true);
      if (!dest) {
        // send, no address provided
        return FS.write(sock.stream, HEAP8,message, length);
      } else {
        // sendto an address
        return sock.sock_ops.sendmsg(sock, HEAP8,message, length, dest.addr, dest.port);
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_socket(domain, type, protocol) {
  try {
  
      var sock = SOCKFS.createSocket(domain, type, protocol);
      assert(sock.stream.fd < 64); // XXX ? select() assumes socket fd values are in 0..63
      return sock.stream.fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_symlink(target, linkpath) {
  try {
  
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      assert(flags === 0);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = HEAP32[((times)>>2)];
        var nanoseconds = HEAP32[(((times)+(4))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 8;
        seconds = HEAP32[((times)>>2)];
        nanoseconds = HEAP32[(((times)+(4))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  var ___table_base = new WebAssembly.Global({'value': 'i32', 'mutable': false}, 1);

  var ENV = {};
  
  function dlSetError(msg) {
      withStackSave(function() {
        var cmsg = allocateUTF8OnStack(msg);
        ___dl_seterr(cmsg);
      });
    }
  function dlopenInternal(handle, jsflags) {
      // void *dlopen(const char *file, int mode);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlopen.html
      var filename = UTF8ToString(handle + 44);
      var flags = HEAP32[(((handle)+(20))>>2)];
      filename = PATH.normalize(filename);
      var searchpaths = [];
  
      var isValidFile = (filename) => {
        var target = FS.findObject(filename);
        return target && !target.isFolder && !target.isDevice;
      };
  
      if (!isValidFile(filename)) {
        if (ENV['LD_LIBRARY_PATH']) {
          searchpaths = ENV['LD_LIBRARY_PATH'].split(':');
        }
  
        for (var ident in searchpaths) {
          var searchfile = PATH.join2(searchpaths[ident], filename);
          if (isValidFile(searchfile)) {
            filename = searchfile;
            break;
          }
        }
      }
  
      // We don't care about RTLD_NOW and RTLD_LAZY.
      var combinedFlags = {
        global:    Boolean(flags & 256),
        nodelete:  Boolean(flags & 4096),
        loadAsync: jsflags.loadAsync,
        fs:        jsflags.fs,
      }
  
      if (jsflags.loadAsync) {
        return loadDynamicLibrary(filename, combinedFlags, handle);
      }
  
      try {
        return loadDynamicLibrary(filename, combinedFlags, handle)
      } catch (e) {
        err('Error in loading dynamic library ' + filename + ": " + e);
        dlSetError('Could not load dynamic lib: ' + filename + '\n' + e);
        return 0;
      }
    }
  function __dlopen_js(handle) {
      var jsflags = {
        loadAsync: false,
        fs: FS, // load libraries from provided filesystem
      }
      return dlopenInternal(handle, jsflags);
    }
  __dlopen_js.sig = 'iiii';

  function __dlsym_js(handle, symbol) {
      // void *dlsym(void *restrict handle, const char *restrict name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html
      symbol = UTF8ToString(symbol);
      var result;
  
      if (handle == 0) {
        result = resolveGlobalSymbol(symbol, true);
        if (!result) {
          dlSetError('Tried to lookup unknown symbol "' + symbol + '" in dynamic lib: RTLD_DEFAULT');
          return 0;
        }
      } else {
        var lib = LDSO.loadedLibsByHandle[handle];
        assert(lib, 'Tried to dlsym() from an unopened handle: ' + handle);
        if (!lib.module.hasOwnProperty(symbol)) {
          dlSetError('Tried to lookup unknown symbol "' + symbol + '" in dynamic lib: ' + lib.name)
          return 0;
        }
        result = lib.module['orig$' + symbol];
        if (!result)
        result = lib.module[symbol];
      }
  
      if (typeof result == 'function') {
        // Insert the function into the wasm table.  If its a direct wasm function
        // the second argument will not be needed.  If its a JS function we rely
        // on the `sig` attribute being set based on the `<func>__sig` specified
        // in library JS file.
        result = addFunction(result, result.sig);
      }
      return result;
    }
  __dlsym_js.sig = 'iii';

  function __emscripten_date_now() {
      return Date.now();
    }
  __emscripten_date_now.sig = 'j';

  var nowIsMonotonic = true;;
  function __emscripten_get_now_is_monotonic() {
      return nowIsMonotonic;
    }

  function __emscripten_throw_longjmp() { throw Infinity; }
  __emscripten_throw_longjmp.sig = 'v';

  function __gmtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
    }
  __gmtime_js.sig = 'iii';

  function __localtime_js(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }
  __localtime_js.sig = 'iii';

  function __mktime_js(tmPtr) {
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)] = Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      // To match expected behavior, update fields from date
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
  
      return (date.getTime() / 1000)|0;
    }
  __mktime_js.sig = 'ii';

  function __timegm_js(tmPtr) {
      var time = Date.UTC(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
      var date = new Date(time);
  
      HEAP32[(((tmPtr)+(24))>>2)] = date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
  
      return (date.getTime() / 1000)|0;
    }
  __timegm_js.sig = 'ii';

  function _tzset_impl(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
      // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        HEAP32[((tzname)>>2)] = winterNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAP32[((tzname)>>2)] = summerNamePtr;
        HEAP32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }
  _tzset_impl.sig = 'viii';
  function __tzset_js(timezone, daylight, tzname) {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (__tzset_js.called) return;
      __tzset_js.called = true;
      _tzset_impl(timezone, daylight, tzname);
    }
  __tzset_js.sig = 'viii';

  function _abort() {
      abort('native code called abort()');
    }
  _abort.sig = 'v';

  function _emscripten_console_error(str) {
      assert(typeof str == 'number');
      console.error(UTF8ToString(str));
    }
  _emscripten_console_error.sig = 'vi';

  function _emscripten_get_heap_max() {
      return HEAPU8.length;
    }

  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = () => {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else _emscripten_get_now = () => performance.now();
  ;

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function abortOnCannotGrowMemory(requestedSize) {
      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }

  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAP32[(((__environ)+(i * 4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }
  _environ_get.sig = 'iii';

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAP32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAP32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }
  _environ_sizes_get.sig = 'iii';

  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }
  _exit.sig = 'vi';

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_close.sig = 'ii';

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      // TODO HEAP16[(((pbuf)+(2))>>1)] = ?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)] = tempI64[0],HEAP32[(((pbuf)+(12))>>2)] = tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)] = tempI64[0],HEAP32[(((pbuf)+(20))>>2)] = tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_fdstat_get.sig = 'iii';

  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_read.sig = 'iiiii';

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      ;
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }
  _fd_write.sig = 'iiiii';

  function _getTempRet0() {
      return getTempRet0();
    }
  _getTempRet0.sig = 'i';

  function _getaddrinfo(node, service, hint, out) {
      // Note getaddrinfo currently only returns a single addrinfo with ai_next defaulting to NULL. When NULL
      // hints are specified or ai_family set to AF_UNSPEC or ai_socktype or ai_protocol set to 0 then we
      // really should provide a linked list of suitable addrinfo values.
      var addrs = [];
      var canon = null;
      var addr = 0;
      var port = 0;
      var flags = 0;
      var family = 0;
      var type = 0;
      var proto = 0;
      var ai, last;
  
      function allocaddrinfo(family, type, proto, canon, addr, port) {
        var sa, salen, ai;
        var errno;
  
        salen = family === 10 ?
          28 :
          16;
        addr = family === 10 ?
          inetNtop6(addr) :
          inetNtop4(addr);
        sa = _malloc(salen);
        errno = writeSockaddr(sa, family, addr, port);
        assert(!errno);
  
        ai = _malloc(32);
        HEAP32[(((ai)+(4))>>2)] = family;
        HEAP32[(((ai)+(8))>>2)] = type;
        HEAP32[(((ai)+(12))>>2)] = proto;
        HEAP32[(((ai)+(24))>>2)] = canon;
        HEAP32[(((ai)+(20))>>2)] = sa;
        if (family === 10) {
          HEAP32[(((ai)+(16))>>2)] = 28;
        } else {
          HEAP32[(((ai)+(16))>>2)] = 16;
        }
        HEAP32[(((ai)+(28))>>2)] = 0;
  
        return ai;
      }
  
      if (hint) {
        flags = HEAP32[((hint)>>2)];
        family = HEAP32[(((hint)+(4))>>2)];
        type = HEAP32[(((hint)+(8))>>2)];
        proto = HEAP32[(((hint)+(12))>>2)];
      }
      if (type && !proto) {
        proto = type === 2 ? 17 : 6;
      }
      if (!type && proto) {
        type = proto === 17 ? 2 : 1;
      }
  
      // If type or proto are set to zero in hints we should really be returning multiple addrinfo values, but for
      // now default to a TCP STREAM socket so we can at least return a sensible addrinfo given NULL hints.
      if (proto === 0) {
        proto = 6;
      }
      if (type === 0) {
        type = 1;
      }
  
      if (!node && !service) {
        return -2;
      }
      if (flags & ~(1|2|4|
          1024|8|16|32)) {
        return -1;
      }
      if (hint !== 0 && (HEAP32[((hint)>>2)] & 2) && !node) {
        return -1;
      }
      if (flags & 32) {
        // TODO
        return -2;
      }
      if (type !== 0 && type !== 1 && type !== 2) {
        return -7;
      }
      if (family !== 0 && family !== 2 && family !== 10) {
        return -6;
      }
  
      if (service) {
        service = UTF8ToString(service);
        port = parseInt(service, 10);
  
        if (isNaN(port)) {
          if (flags & 1024) {
            return -2;
          }
          // TODO support resolving well-known service names from:
          // http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt
          return -8;
        }
      }
  
      if (!node) {
        if (family === 0) {
          family = 2;
        }
        if ((flags & 1) === 0) {
          if (family === 2) {
            addr = _htonl(2130706433);
          } else {
            addr = [0, 0, 0, 1];
          }
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
  
      //
      // try as a numeric address
      //
      node = UTF8ToString(node);
      addr = inetPton4(node);
      if (addr !== null) {
        // incoming node is a valid ipv4 address
        if (family === 0 || family === 2) {
          family = 2;
        }
        else if (family === 10 && (flags & 8)) {
          addr = [0, 0, _htonl(0xffff), addr];
          family = 10;
        } else {
          return -2;
        }
      } else {
        addr = inetPton6(node);
        if (addr !== null) {
          // incoming node is a valid ipv6 address
          if (family === 0 || family === 10) {
            family = 10;
          } else {
            return -2;
          }
        }
      }
      if (addr != null) {
        ai = allocaddrinfo(family, type, proto, node, addr, port);
        HEAP32[((out)>>2)] = ai;
        return 0;
      }
      if (flags & 4) {
        return -2;
      }
  
      //
      // try as a hostname
      //
      // resolve the hostname to a temporary fake address
      node = DNS.lookup_name(node);
      addr = inetPton4(node);
      if (family === 0) {
        family = 2;
      } else if (family === 10) {
        addr = [0, 0, _htonl(0xffff), addr];
      }
      ai = allocaddrinfo(family, type, proto, null, addr, port);
      HEAP32[((out)>>2)] = ai;
      return 0;
    }
  _getaddrinfo.sig = 'iiiii';

  function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
      var info = readSockaddr(sa, salen);
      if (info.errno) {
        return -6;
      }
      var port = info.port;
      var addr = info.addr;
  
      var overflowed = false;
  
      if (node && nodelen) {
        var lookup;
        if ((flags & 1) || !(lookup = DNS.lookup_addr(addr))) {
          if (flags & 8) {
            return -2;
          }
        } else {
          addr = lookup;
        }
        var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
  
        if (numBytesWrittenExclNull+1 >= nodelen) {
          overflowed = true;
        }
      }
  
      if (serv && servlen) {
        port = '' + port;
        var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
  
        if (numBytesWrittenExclNull+1 >= servlen) {
          overflowed = true;
        }
      }
  
      if (overflowed) {
        // Note: even when we overflow, getnameinfo() is specced to write out the truncated results.
        return -12;
      }
  
      return 0;
    }

  function _proc_exit(code) {
      procExit(code);
    }
  _proc_exit.sig = 'vi';

  function _pthread_setschedparam(
  ) {
  if (!Module['_pthread_setschedparam']) abort("external symbol 'pthread_setschedparam' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_pthread_setschedparam'].apply(null, arguments);
  }

  function _sem_timedwait(
  ) {
  if (!Module['_sem_timedwait']) abort("external symbol 'sem_timedwait' is missing. perhaps a side module was not linked in? if this function was expected to arrive from a system library, try to build the MAIN_MODULE with EMCC_FORCE_STDLIBS=1 in the environment");
  return Module['_sem_timedwait'].apply(null, arguments);
  }

  function _setTempRet0(val) {
      setTempRet0(val);
    }
  _setTempRet0.sig = 'vi';

  function _system(command) {
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      setErrNo(52);
      return -1;
    }

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
ERRNO_CODES = {
      'EPERM': 63,
      'ENOENT': 44,
      'ESRCH': 71,
      'EINTR': 27,
      'EIO': 29,
      'ENXIO': 60,
      'E2BIG': 1,
      'ENOEXEC': 45,
      'EBADF': 8,
      'ECHILD': 12,
      'EAGAIN': 6,
      'EWOULDBLOCK': 6,
      'ENOMEM': 48,
      'EACCES': 2,
      'EFAULT': 21,
      'ENOTBLK': 105,
      'EBUSY': 10,
      'EEXIST': 20,
      'EXDEV': 75,
      'ENODEV': 43,
      'ENOTDIR': 54,
      'EISDIR': 31,
      'EINVAL': 28,
      'ENFILE': 41,
      'EMFILE': 33,
      'ENOTTY': 59,
      'ETXTBSY': 74,
      'EFBIG': 22,
      'ENOSPC': 51,
      'ESPIPE': 70,
      'EROFS': 69,
      'EMLINK': 34,
      'EPIPE': 64,
      'EDOM': 18,
      'ERANGE': 68,
      'ENOMSG': 49,
      'EIDRM': 24,
      'ECHRNG': 106,
      'EL2NSYNC': 156,
      'EL3HLT': 107,
      'EL3RST': 108,
      'ELNRNG': 109,
      'EUNATCH': 110,
      'ENOCSI': 111,
      'EL2HLT': 112,
      'EDEADLK': 16,
      'ENOLCK': 46,
      'EBADE': 113,
      'EBADR': 114,
      'EXFULL': 115,
      'ENOANO': 104,
      'EBADRQC': 103,
      'EBADSLT': 102,
      'EDEADLOCK': 16,
      'EBFONT': 101,
      'ENOSTR': 100,
      'ENODATA': 116,
      'ETIME': 117,
      'ENOSR': 118,
      'ENONET': 119,
      'ENOPKG': 120,
      'EREMOTE': 121,
      'ENOLINK': 47,
      'EADV': 122,
      'ESRMNT': 123,
      'ECOMM': 124,
      'EPROTO': 65,
      'EMULTIHOP': 36,
      'EDOTDOT': 125,
      'EBADMSG': 9,
      'ENOTUNIQ': 126,
      'EBADFD': 127,
      'EREMCHG': 128,
      'ELIBACC': 129,
      'ELIBBAD': 130,
      'ELIBSCN': 131,
      'ELIBMAX': 132,
      'ELIBEXEC': 133,
      'ENOSYS': 52,
      'ENOTEMPTY': 55,
      'ENAMETOOLONG': 37,
      'ELOOP': 32,
      'EOPNOTSUPP': 138,
      'EPFNOSUPPORT': 139,
      'ECONNRESET': 15,
      'ENOBUFS': 42,
      'EAFNOSUPPORT': 5,
      'EPROTOTYPE': 67,
      'ENOTSOCK': 57,
      'ENOPROTOOPT': 50,
      'ESHUTDOWN': 140,
      'ECONNREFUSED': 14,
      'EADDRINUSE': 3,
      'ECONNABORTED': 13,
      'ENETUNREACH': 40,
      'ENETDOWN': 38,
      'ETIMEDOUT': 73,
      'EHOSTDOWN': 142,
      'EHOSTUNREACH': 23,
      'EINPROGRESS': 26,
      'EALREADY': 7,
      'EDESTADDRREQ': 17,
      'EMSGSIZE': 35,
      'EPROTONOSUPPORT': 66,
      'ESOCKTNOSUPPORT': 137,
      'EADDRNOTAVAIL': 4,
      'ENETRESET': 39,
      'EISCONN': 30,
      'ENOTCONN': 53,
      'ETOOMANYREFS': 141,
      'EUSERS': 136,
      'EDQUOT': 19,
      'ESTALE': 72,
      'ENOTSUP': 138,
      'ENOMEDIUM': 148,
      'EILSEQ': 25,
      'EOVERFLOW': 61,
      'ECANCELED': 11,
      'ENOTRECOVERABLE': 56,
      'EOWNERDEAD': 62,
      'ESTRPIPE': 135,
    };;
var ASSERTIONS = true;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var coreLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__call_sighandler": ___call_sighandler,
  "__heap_base": ___heap_base,
  "__indirect_function_table": wasmTable,
  "__memory_base": ___memory_base,
  "__stack_pointer": ___stack_pointer,
  "__syscall__newselect": ___syscall__newselect,
  "__syscall_accept4": ___syscall_accept4,
  "__syscall_bind": ___syscall_bind,
  "__syscall_chdir": ___syscall_chdir,
  "__syscall_connect": ___syscall_connect,
  "__syscall_dup": ___syscall_dup,
  "__syscall_dup3": ___syscall_dup3,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_getdents64": ___syscall_getdents64,
  "__syscall_getsockname": ___syscall_getsockname,
  "__syscall_getsockopt": ___syscall_getsockopt,
  "__syscall_ioctl": ___syscall_ioctl,
  "__syscall_listen": ___syscall_listen,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdir": ___syscall_mkdir,
  "__syscall_mknod": ___syscall_mknod,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_pipe": ___syscall_pipe,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_recvfrom": ___syscall_recvfrom,
  "__syscall_renameat": ___syscall_renameat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_sendto": ___syscall_sendto,
  "__syscall_socket": ___syscall_socket,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_symlink": ___syscall_symlink,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "__table_base": ___table_base,
  "_dlopen_js": __dlopen_js,
  "_dlsym_js": __dlsym_js,
  "_emscripten_date_now": __emscripten_date_now,
  "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
  "_emscripten_throw_longjmp": __emscripten_throw_longjmp,
  "_gmtime_js": __gmtime_js,
  "_localtime_js": __localtime_js,
  "_mktime_js": __mktime_js,
  "_timegm_js": __timegm_js,
  "_tzset_js": __tzset_js,
  "abort": _abort,
  "emscripten_console_error": _emscripten_console_error,
  "emscripten_get_heap_max": _emscripten_get_heap_max,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "exit": _exit,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "getTempRet0": _getTempRet0,
  "getaddrinfo": _getaddrinfo,
  "getnameinfo": _getnameinfo,
  "invoke_ii": invoke_ii,
  "invoke_iii": invoke_iii,
  "invoke_iiii": invoke_iiii,
  "invoke_iiiii": invoke_iiiii,
  "invoke_iiiiii": invoke_iiiiii,
  "invoke_vi": invoke_vi,
  "invoke_vii": invoke_vii,
  "invoke_viii": invoke_viii,
  "invoke_viiii": invoke_viiii,
  "invoke_viiiiiiiii": invoke_viiiiiiiii,
  "memory": wasmMemory,
  "proc_exit": _proc_exit,
  "pthread_setschedparam": _pthread_setschedparam,
  "sem_timedwait": _sem_timedwait,
  "setTempRet0": _setTempRet0,
  "system": _system
};

var asmLibraryArg = Object.assign({},
                                  coreLibraryArg,
                                  (0,_core_sdl_js__WEBPACK_IMPORTED_MODULE_0__.SDL_MODULE)(wasmMemory.buffer, Module, abort,createExportWrapper, stringToUTF8, UTF8ToString,allocateUTF8, getWasmTableEntry),
                                  (0,_core_fetch_js__WEBPACK_IMPORTED_MODULE_1__.FETCH_MODULE)(wasmMemory.buffer, Module, abort,createExportWrapper, stringToUTF8, UTF8ToString,allocateUTF8, getWasmTableEntry)
                                  );

var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = createExportWrapper("__wasm_call_ctors");

/** @type {function(...*):?} */
var _constructor = Module["_constructor"] = createExportWrapper("constructor");

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = createExportWrapper("malloc");

/** @type {function(...*):?} */
var _set = Module["_set"] = createExportWrapper("set");

/** @type {function(...*):?} */
var _get = Module["_get"] = createExportWrapper("get");

/** @type {function(...*):?} */
var _destructor = Module["_destructor"] = createExportWrapper("destructor");

/** @type {function(...*):?} */
var _fprintf = Module["_fprintf"] = createExportWrapper("fprintf");

/** @type {function(...*):?} */
var _strcmp = Module["_strcmp"] = createExportWrapper("strcmp");

/** @type {function(...*):?} */
var _gf_fileio_set_stats_u32 = Module["_gf_fileio_set_stats_u32"] = createExportWrapper("gf_fileio_set_stats_u32");

/** @type {function(...*):?} */
var _free = Module["_free"] = createExportWrapper("free");

/** @type {function(...*):?} */
var _realloc = Module["_realloc"] = createExportWrapper("realloc");

/** @type {function(...*):?} */
var _memcpy = Module["_memcpy"] = createExportWrapper("memcpy");

/** @type {function(...*):?} */
var _strlen = Module["_strlen"] = createExportWrapper("strlen");

/** @type {function(...*):?} */
var _memcmp = Module["_memcmp"] = createExportWrapper("memcmp");

/** @type {function(...*):?} */
var _memmove = Module["_memmove"] = createExportWrapper("memmove");

/** @type {function(...*):?} */
var _gf_fileio_new = Module["_gf_fileio_new"] = createExportWrapper("gf_fileio_new");

/** @type {function(...*):?} */
var _gf_fileio_url = Module["_gf_fileio_url"] = createExportWrapper("gf_fileio_url");

/** @type {function(...*):?} */
var _gf_fileio_get_udta = Module["_gf_fileio_get_udta"] = createExportWrapper("gf_fileio_get_udta");

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = createExportWrapper("__errno_location");

/** @type {function(...*):?} */
var _strcpy = Module["_strcpy"] = createExportWrapper("strcpy");

/** @type {function(...*):?} */
var _strcat = Module["_strcat"] = createExportWrapper("strcat");

/** @type {function(...*):?} */
var _strchr = Module["_strchr"] = createExportWrapper("strchr");

/** @type {function(...*):?} */
var _strncmp = Module["_strncmp"] = createExportWrapper("strncmp");

/** @type {function(...*):?} */
var _sprintf = Module["_sprintf"] = createExportWrapper("sprintf");

/** @type {function(...*):?} */
var _gf_strdup = Module["_gf_strdup"] = createExportWrapper("gf_strdup");

/** @type {function(...*):?} */
var _vsnprintf = Module["_vsnprintf"] = createExportWrapper("vsnprintf");

/** @type {function(...*):?} */
var _fwrite = Module["_fwrite"] = createExportWrapper("fwrite");

/** @type {function(...*):?} */
var _vfprintf = Module["_vfprintf"] = createExportWrapper("vfprintf");

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = createExportWrapper("fflush");

/** @type {function(...*):?} */
var _gf_bs_new = Module["_gf_bs_new"] = createExportWrapper("gf_bs_new");

/** @type {function(...*):?} */
var _gf_bs_del = Module["_gf_bs_del"] = createExportWrapper("gf_bs_del");

/** @type {function(...*):?} */
var _gf_bs_read_int = Module["_gf_bs_read_int"] = createExportWrapper("gf_bs_read_int");

/** @type {function(...*):?} */
var _gf_bs_available = Module["_gf_bs_available"] = createExportWrapper("gf_bs_available");

/** @type {function(...*):?} */
var _gf_bs_get_position = Module["_gf_bs_get_position"] = createExportWrapper("gf_bs_get_position");

/** @type {function(...*):?} */
var _strncpy = Module["_strncpy"] = createExportWrapper("strncpy");

/** @type {function(...*):?} */
var _calloc = Module["_calloc"] = createExportWrapper("calloc");

/** @type {function(...*):?} */
var _strdup = Module["_strdup"] = createExportWrapper("strdup");

/** @type {function(...*):?} */
var _gf_url_concatenate = Module["_gf_url_concatenate"] = createExportWrapper("gf_url_concatenate");

/** @type {function(...*):?} */
var _pthread_self = Module["_pthread_self"] = createExportWrapper("pthread_self");

/** @type {function(...*):?} */
var _pthread_mutex_init = Module["_pthread_mutex_init"] = createExportWrapper("pthread_mutex_init");

/** @type {function(...*):?} */
var _pthread_mutex_destroy = Module["_pthread_mutex_destroy"] = createExportWrapper("pthread_mutex_destroy");

/** @type {function(...*):?} */
var _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = createExportWrapper("pthread_mutex_unlock");

/** @type {function(...*):?} */
var _pthread_mutex_lock = Module["_pthread_mutex_lock"] = createExportWrapper("pthread_mutex_lock");

/** @type {function(...*):?} */
var _getenv = Module["_getenv"] = createExportWrapper("getenv");

/** @type {function(...*):?} */
var _gf_filter_pck_new_alloc = Module["_gf_filter_pck_new_alloc"] = createExportWrapper("gf_filter_pck_new_alloc");

/** @type {function(...*):?} */
var _gf_filter_pck_new_ref = Module["_gf_filter_pck_new_ref"] = createExportWrapper("gf_filter_pck_new_ref");

/** @type {function(...*):?} */
var _gf_filter_pck_send = Module["_gf_filter_pck_send"] = createExportWrapper("gf_filter_pck_send");

/** @type {function(...*):?} */
var _gf_filter_pck_get_data = Module["_gf_filter_pck_get_data"] = createExportWrapper("gf_filter_pck_get_data");

/** @type {function(...*):?} */
var _gf_filter_pck_get_property = Module["_gf_filter_pck_get_property"] = createExportWrapper("gf_filter_pck_get_property");

/** @type {function(...*):?} */
var _gf_filter_pck_set_framing = Module["_gf_filter_pck_set_framing"] = createExportWrapper("gf_filter_pck_set_framing");

/** @type {function(...*):?} */
var _gf_filter_pck_set_cts = Module["_gf_filter_pck_set_cts"] = createExportWrapper("gf_filter_pck_set_cts");

/** @type {function(...*):?} */
var _gf_filter_pck_get_cts = Module["_gf_filter_pck_get_cts"] = createExportWrapper("gf_filter_pck_get_cts");

/** @type {function(...*):?} */
var _gf_filter_pck_get_timescale = Module["_gf_filter_pck_get_timescale"] = createExportWrapper("gf_filter_pck_get_timescale");

/** @type {function(...*):?} */
var _gf_filter_pck_set_sap = Module["_gf_filter_pck_set_sap"] = createExportWrapper("gf_filter_pck_set_sap");

/** @type {function(...*):?} */
var _gf_filter_pck_set_duration = Module["_gf_filter_pck_set_duration"] = createExportWrapper("gf_filter_pck_set_duration");

/** @type {function(...*):?} */
var _gf_filter_pck_get_duration = Module["_gf_filter_pck_get_duration"] = createExportWrapper("gf_filter_pck_get_duration");

/** @type {function(...*):?} */
var _gf_filter_pck_set_seek_flag = Module["_gf_filter_pck_set_seek_flag"] = createExportWrapper("gf_filter_pck_set_seek_flag");

/** @type {function(...*):?} */
var _gf_filter_pck_get_seek_flag = Module["_gf_filter_pck_get_seek_flag"] = createExportWrapper("gf_filter_pck_get_seek_flag");

/** @type {function(...*):?} */
var _gf_filter_pck_set_dependency_flags = Module["_gf_filter_pck_set_dependency_flags"] = createExportWrapper("gf_filter_pck_set_dependency_flags");

/** @type {function(...*):?} */
var _gf_filter_pck_set_byte_offset = Module["_gf_filter_pck_set_byte_offset"] = createExportWrapper("gf_filter_pck_set_byte_offset");

/** @type {function(...*):?} */
var _gf_filter_pid_get_packet = Module["_gf_filter_pid_get_packet"] = createExportWrapper("gf_filter_pid_get_packet");

/** @type {function(...*):?} */
var _gf_filter_pid_check_caps = Module["_gf_filter_pid_check_caps"] = createExportWrapper("gf_filter_pid_check_caps");

/** @type {function(...*):?} */
var _gf_filter_pid_set_property = Module["_gf_filter_pid_set_property"] = createExportWrapper("gf_filter_pid_set_property");

/** @type {function(...*):?} */
var _gf_filter_pid_get_property = Module["_gf_filter_pid_get_property"] = createExportWrapper("gf_filter_pid_get_property");

/** @type {function(...*):?} */
var _gf_filter_pid_set_framing_mode = Module["_gf_filter_pid_set_framing_mode"] = createExportWrapper("gf_filter_pid_set_framing_mode");

/** @type {function(...*):?} */
var _gf_filter_pid_new = Module["_gf_filter_pid_new"] = createExportWrapper("gf_filter_pid_new");

/** @type {function(...*):?} */
var _gf_filter_pid_copy_properties = Module["_gf_filter_pid_copy_properties"] = createExportWrapper("gf_filter_pid_copy_properties");

/** @type {function(...*):?} */
var _cos = Module["_cos"] = createExportWrapper("cos");

/** @type {function(...*):?} */
var _sin = Module["_sin"] = createExportWrapper("sin");

/** @type {function(...*):?} */
var _tan = Module["_tan"] = createExportWrapper("tan");

/** @type {function(...*):?} */
var _atan = Module["_atan"] = createExportWrapper("atan");

/** @type {function(...*):?} */
var _pow = Module["_pow"] = createExportWrapper("pow");

/** @type {function(...*):?} */
var _acos = Module["_acos"] = createExportWrapper("acos");

/** @type {function(...*):?} */
var _htonl = Module["_htonl"] = createExportWrapper("htonl");

/** @type {function(...*):?} */
var _htons = Module["_htons"] = createExportWrapper("htons");

/** @type {function(...*):?} */
var _ntohs = Module["_ntohs"] = createExportWrapper("ntohs");

/** @type {function(...*):?} */
var _asin = Module["_asin"] = createExportWrapper("asin");

/** @type {function(...*):?} */
var _log = Module["_log"] = createExportWrapper("log");

/** @type {function(...*):?} */
var _saveSetjmp = Module["_saveSetjmp"] = createExportWrapper("saveSetjmp");

/** @type {function(...*):?} */
var _gf_filter_get_udta = Module["_gf_filter_get_udta"] = createExportWrapper("gf_filter_get_udta");

/** @type {function(...*):?} */
var _gf_filter_set_name = Module["_gf_filter_set_name"] = createExportWrapper("gf_filter_set_name");

/** @type {function(...*):?} */
var _fabs = Module["_fabs"] = createExportWrapper("fabs");

/** @type {function(...*):?} */
var _exp = Module["_exp"] = createExportWrapper("exp");

/** @type {function(...*):?} */
var _cosh = Module["_cosh"] = createExportWrapper("cosh");

/** @type {function(...*):?} */
var _sinh = Module["_sinh"] = createExportWrapper("sinh");

/** @type {function(...*):?} */
var _tanh = Module["_tanh"] = createExportWrapper("tanh");

/** @type {function(...*):?} */
var _memset = Module["_memset"] = createExportWrapper("memset");

/** @type {function(...*):?} */
var _siprintf = Module["_siprintf"] = createExportWrapper("siprintf");

/** @type {function(...*):?} */
var _frexp = Module["_frexp"] = createExportWrapper("frexp");

/** @type {function(...*):?} */
var ___stdio_exit = Module["___stdio_exit"] = createExportWrapper("__stdio_exit");

/** @type {function(...*):?} */
var _bsearch = Module["_bsearch"] = createExportWrapper("bsearch");

/** @type {function(...*):?} */
var ___dl_seterr = Module["___dl_seterr"] = createExportWrapper("__dl_seterr");

/** @type {function(...*):?} */
var _ldexp = Module["_ldexp"] = createExportWrapper("ldexp");

/** @type {function(...*):?} */
var _llrint = Module["_llrint"] = createExportWrapper("llrint");

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = createExportWrapper("memalign");

/** @type {function(...*):?} */
var _posix_memalign = Module["_posix_memalign"] = createExportWrapper("posix_memalign");

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = createExportWrapper("setThrew");

/** @type {function(...*):?} */
var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
  return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = function() {
  return (_emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = function() {
  return (_emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = function() {
  return (_emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = createExportWrapper("stackSave");

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = createExportWrapper("stackRestore");

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = createExportWrapper("stackAlloc");

/** @type {function(...*):?} */
var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");

/** @type {function(...*):?} */
var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");

/** @type {function(...*):?} */
var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");

/** @type {function(...*):?} */
var dynCall_iiiiji = Module["dynCall_iiiiji"] = createExportWrapper("dynCall_iiiiji");

/** @type {function(...*):?} */
var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");

/** @type {function(...*):?} */
var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");

/** @type {function(...*):?} */
var dynCall_jijii = Module["dynCall_jijii"] = createExportWrapper("dynCall_jijii");

/** @type {function(...*):?} */
var dynCall_jijji = Module["dynCall_jijji"] = createExportWrapper("dynCall_jijji");

/** @type {function(...*):?} */
var dynCall_jijij = Module["dynCall_jijij"] = createExportWrapper("dynCall_jijij");

/** @type {function(...*):?} */
var dynCall_iijijji = Module["dynCall_iijijji"] = createExportWrapper("dynCall_iijijji");

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");

/** @type {function(...*):?} */
var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");

/** @type {function(...*):?} */
var dynCall_iiiijjjii = Module["dynCall_iiiijjjii"] = createExportWrapper("dynCall_iiiijjjii");

/** @type {function(...*):?} */
var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");

/** @type {function(...*):?} */
var dynCall_iiijji = Module["dynCall_iiijji"] = createExportWrapper("dynCall_iiijji");

/** @type {function(...*):?} */
var dynCall_viiijiii = Module["dynCall_viiijiii"] = createExportWrapper("dynCall_viiijiii");

/** @type {function(...*):?} */
var dynCall_jijjiii = Module["dynCall_jijjiii"] = createExportWrapper("dynCall_jijjiii");

/** @type {function(...*):?} */
var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");

/** @type {function(...*):?} */
var dynCall_jijiiiii = Module["dynCall_jijiiiii"] = createExportWrapper("dynCall_jijiiiii");

/** @type {function(...*):?} */
var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");

/** @type {function(...*):?} */
var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");

/** @type {function(...*):?} */
var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");

/** @type {function(...*):?} */
var dynCall_iijijjji = Module["dynCall_iijijjji"] = createExportWrapper("dynCall_iijijjji");

/** @type {function(...*):?} */
var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");

/** @type {function(...*):?} */
var dynCall_iiiij = Module["dynCall_iiiij"] = createExportWrapper("dynCall_iiiij");

/** @type {function(...*):?} */
var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");

/** @type {function(...*):?} */
var dynCall_vijjii = Module["dynCall_vijjii"] = createExportWrapper("dynCall_vijjii");

/** @type {function(...*):?} */
var _orig$gf_bs_new = Module["_orig$gf_bs_new"] = createExportWrapper("orig$gf_bs_new");

/** @type {function(...*):?} */
var _orig$gf_bs_available = Module["_orig$gf_bs_available"] = createExportWrapper("orig$gf_bs_available");

/** @type {function(...*):?} */
var _orig$gf_bs_get_position = Module["_orig$gf_bs_get_position"] = createExportWrapper("orig$gf_bs_get_position");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_set_cts = Module["_orig$gf_filter_pck_set_cts"] = createExportWrapper("orig$gf_filter_pck_set_cts");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_get_cts = Module["_orig$gf_filter_pck_get_cts"] = createExportWrapper("orig$gf_filter_pck_get_cts");

/** @type {function(...*):?} */
var _orig$gf_filter_pck_set_byte_offset = Module["_orig$gf_filter_pck_set_byte_offset"] = createExportWrapper("orig$gf_filter_pck_set_byte_offset");

/** @type {function(...*):?} */
var _orig$llrint = Module["_orig$llrint"] = createExportWrapper("orig$llrint");


function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  var sp = stackSave();
  try {
    return getWasmTableEntry(index)(a1,a2,a3,a4,a5);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9) {
  var sp = stackSave();
  try {
    getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0) throw e;
    _setThrew(1, 0);
  }
}




// === Auto-generated postamble setup entry stuff ===

unexportedRuntimeFunction('intArrayFromString', false);
unexportedRuntimeFunction('intArrayToString', false);
unexportedRuntimeFunction('ccall', false);
unexportedRuntimeFunction('cwrap', false);
unexportedRuntimeFunction('setValue', false);
unexportedRuntimeFunction('getValue', false);
Module["allocate"] = allocate;
unexportedRuntimeFunction('UTF8ArrayToString', false);
Module["UTF8ToString"] = UTF8ToString;
unexportedRuntimeFunction('stringToUTF8Array', false);
Module["stringToUTF8"] = stringToUTF8;
unexportedRuntimeFunction('lengthBytesUTF8', false);
unexportedRuntimeFunction('stackTrace', false);
unexportedRuntimeFunction('addOnPreRun', false);
unexportedRuntimeFunction('addOnInit', false);
unexportedRuntimeFunction('addOnPreMain', false);
unexportedRuntimeFunction('addOnExit', false);
unexportedRuntimeFunction('addOnPostRun', false);
unexportedRuntimeFunction('writeStringToMemory', false);
unexportedRuntimeFunction('writeArrayToMemory', false);
unexportedRuntimeFunction('writeAsciiToMemory', false);
unexportedRuntimeFunction('addRunDependency', true);
unexportedRuntimeFunction('removeRunDependency', true);
unexportedRuntimeFunction('FS_createFolder', false);
unexportedRuntimeFunction('FS_createPath', true);
unexportedRuntimeFunction('FS_createDataFile', true);
unexportedRuntimeFunction('FS_createPreloadedFile', true);
unexportedRuntimeFunction('FS_createLazyFile', true);
unexportedRuntimeFunction('FS_createLink', false);
unexportedRuntimeFunction('FS_createDevice', true);
unexportedRuntimeFunction('FS_unlink', true);
unexportedRuntimeFunction('getLEB', false);
unexportedRuntimeFunction('getFunctionTables', false);
unexportedRuntimeFunction('alignFunctionTables', false);
unexportedRuntimeFunction('registerFunctions', false);
unexportedRuntimeFunction('addFunction', false);
unexportedRuntimeFunction('removeFunction', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('prettyPrint', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('getCompilerSetting', false);
unexportedRuntimeFunction('print', false);
unexportedRuntimeFunction('printErr', false);
unexportedRuntimeFunction('getTempRet0', false);
unexportedRuntimeFunction('setTempRet0', false);
unexportedRuntimeFunction('callMain', false);
unexportedRuntimeFunction('abort', false);
unexportedRuntimeFunction('keepRuntimeAlive', false);
unexportedRuntimeFunction('zeroMemory', false);
unexportedRuntimeFunction('stringToNewUTF8', false);
unexportedRuntimeFunction('abortOnCannotGrowMemory', false);
unexportedRuntimeFunction('emscripten_realloc_buffer', false);
unexportedRuntimeFunction('ENV', false);
unexportedRuntimeFunction('ERRNO_CODES', false);
unexportedRuntimeFunction('ERRNO_MESSAGES', false);
unexportedRuntimeFunction('setErrNo', false);
unexportedRuntimeFunction('inetPton4', false);
unexportedRuntimeFunction('inetNtop4', false);
unexportedRuntimeFunction('inetPton6', false);
unexportedRuntimeFunction('inetNtop6', false);
unexportedRuntimeFunction('readSockaddr', false);
unexportedRuntimeFunction('writeSockaddr', false);
unexportedRuntimeFunction('DNS', false);
unexportedRuntimeFunction('getHostByName', false);
unexportedRuntimeFunction('Protocols', false);
unexportedRuntimeFunction('Sockets', false);
unexportedRuntimeFunction('getRandomDevice', false);
unexportedRuntimeFunction('traverseStack', false);
unexportedRuntimeFunction('UNWIND_CACHE', false);
unexportedRuntimeFunction('convertPCtoSourceLocation', false);
unexportedRuntimeFunction('readAsmConstArgsArray', false);
unexportedRuntimeFunction('readAsmConstArgs', false);
unexportedRuntimeFunction('mainThreadEM_ASM', false);
unexportedRuntimeFunction('jstoi_q', false);
unexportedRuntimeFunction('jstoi_s', false);
unexportedRuntimeFunction('getExecutableName', false);
unexportedRuntimeFunction('listenOnce', false);
unexportedRuntimeFunction('autoResumeAudioContext', false);
unexportedRuntimeFunction('dynCallLegacy', false);
unexportedRuntimeFunction('getDynCaller', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('handleException', false);
unexportedRuntimeFunction('runtimeKeepalivePush', false);
unexportedRuntimeFunction('runtimeKeepalivePop', false);
unexportedRuntimeFunction('callUserCallback', false);
unexportedRuntimeFunction('maybeExit', false);
unexportedRuntimeFunction('safeSetTimeout', false);
unexportedRuntimeFunction('asmjsMangle', false);
unexportedRuntimeFunction('asyncLoad', false);
unexportedRuntimeFunction('alignMemory', false);
unexportedRuntimeFunction('mmapAlloc', false);
unexportedRuntimeFunction('reallyNegative', false);
unexportedRuntimeFunction('unSign', false);
unexportedRuntimeFunction('reSign', false);
unexportedRuntimeFunction('formatString', false);
unexportedRuntimeFunction('PATH', false);
unexportedRuntimeFunction('PATH_FS', false);
unexportedRuntimeFunction('SYSCALLS', false);
unexportedRuntimeFunction('getSocketFromFD', false);
unexportedRuntimeFunction('getSocketAddress', false);
unexportedRuntimeFunction('JSEvents', false);
unexportedRuntimeFunction('registerKeyEventCallback', false);
unexportedRuntimeFunction('specialHTMLTargets', false);
unexportedRuntimeFunction('maybeCStringToJsString', false);
unexportedRuntimeFunction('findEventTarget', false);
unexportedRuntimeFunction('findCanvasEventTarget', false);
unexportedRuntimeFunction('getBoundingClientRect', false);
unexportedRuntimeFunction('fillMouseEventData', false);
unexportedRuntimeFunction('registerMouseEventCallback', false);
unexportedRuntimeFunction('registerWheelEventCallback', false);
unexportedRuntimeFunction('registerUiEventCallback', false);
unexportedRuntimeFunction('registerFocusEventCallback', false);
unexportedRuntimeFunction('fillDeviceOrientationEventData', false);
unexportedRuntimeFunction('registerDeviceOrientationEventCallback', false);
unexportedRuntimeFunction('fillDeviceMotionEventData', false);
unexportedRuntimeFunction('registerDeviceMotionEventCallback', false);
unexportedRuntimeFunction('screenOrientation', false);
unexportedRuntimeFunction('fillOrientationChangeEventData', false);
unexportedRuntimeFunction('registerOrientationChangeEventCallback', false);
unexportedRuntimeFunction('fillFullscreenChangeEventData', false);
unexportedRuntimeFunction('registerFullscreenChangeEventCallback', false);
unexportedRuntimeFunction('registerRestoreOldStyle', false);
unexportedRuntimeFunction('hideEverythingExceptGivenElement', false);
unexportedRuntimeFunction('restoreHiddenElements', false);
unexportedRuntimeFunction('setLetterbox', false);
unexportedRuntimeFunction('currentFullscreenStrategy', false);
unexportedRuntimeFunction('restoreOldWindowedStyle', false);
unexportedRuntimeFunction('softFullscreenResizeWebGLRenderTarget', false);
unexportedRuntimeFunction('doRequestFullscreen', false);
unexportedRuntimeFunction('fillPointerlockChangeEventData', false);
unexportedRuntimeFunction('registerPointerlockChangeEventCallback', false);
unexportedRuntimeFunction('registerPointerlockErrorEventCallback', false);
unexportedRuntimeFunction('requestPointerLock', false);
unexportedRuntimeFunction('fillVisibilityChangeEventData', false);
unexportedRuntimeFunction('registerVisibilityChangeEventCallback', false);
unexportedRuntimeFunction('registerTouchEventCallback', false);
unexportedRuntimeFunction('fillGamepadEventData', false);
unexportedRuntimeFunction('registerGamepadEventCallback', false);
unexportedRuntimeFunction('registerBeforeUnloadEventCallback', false);
unexportedRuntimeFunction('fillBatteryEventData', false);
unexportedRuntimeFunction('battery', false);
unexportedRuntimeFunction('registerBatteryEventCallback', false);
unexportedRuntimeFunction('setCanvasElementSize', false);
unexportedRuntimeFunction('getCanvasElementSize', false);
unexportedRuntimeFunction('demangle', false);
unexportedRuntimeFunction('demangleAll', false);
unexportedRuntimeFunction('jsStackTrace', false);
unexportedRuntimeFunction('stackTrace', false);
unexportedRuntimeFunction('getEnvStrings', false);
unexportedRuntimeFunction('checkWasiClock', false);
unexportedRuntimeFunction('writeI53ToI64', false);
unexportedRuntimeFunction('writeI53ToI64Clamped', false);
unexportedRuntimeFunction('writeI53ToI64Signaling', false);
unexportedRuntimeFunction('writeI53ToU64Clamped', false);
unexportedRuntimeFunction('writeI53ToU64Signaling', false);
unexportedRuntimeFunction('readI53FromI64', false);
unexportedRuntimeFunction('readI53FromU64', false);
unexportedRuntimeFunction('convertI32PairToI53', false);
unexportedRuntimeFunction('convertU32PairToI53', false);
unexportedRuntimeFunction('GOT', false);
unexportedRuntimeFunction('LDSO', false);
unexportedRuntimeFunction('getMemory', false);
unexportedRuntimeFunction('mergeLibSymbols', false);
unexportedRuntimeFunction('loadWebAssemblyModule', false);
unexportedRuntimeFunction('loadDynamicLibrary', false);
unexportedRuntimeFunction('dlopenInternal', false);
unexportedRuntimeFunction('setImmediateWrapped', false);
unexportedRuntimeFunction('clearImmediateWrapped', false);
unexportedRuntimeFunction('polyfillSetImmediate', false);
unexportedRuntimeFunction('uncaughtExceptionCount', false);
unexportedRuntimeFunction('exceptionLast', false);
unexportedRuntimeFunction('exceptionCaught', false);
unexportedRuntimeFunction('ExceptionInfo', false);
unexportedRuntimeFunction('CatchInfo', false);
unexportedRuntimeFunction('exception_addRef', false);
unexportedRuntimeFunction('exception_decRef', false);
unexportedRuntimeFunction('Browser', false);
unexportedRuntimeFunction('funcWrappers', false);
unexportedRuntimeFunction('getFuncWrapper', false);
unexportedRuntimeFunction('setMainLoop', false);
unexportedRuntimeFunction('wget', false);
unexportedRuntimeFunction('FS', false);
unexportedRuntimeFunction('MEMFS', false);
unexportedRuntimeFunction('TTY', false);
unexportedRuntimeFunction('PIPEFS', false);
unexportedRuntimeFunction('SOCKFS', false);
unexportedRuntimeFunction('_setNetworkCallback', false);
unexportedRuntimeFunction('tempFixedLengthArray', false);
unexportedRuntimeFunction('miniTempWebGLFloatBuffers', false);
unexportedRuntimeFunction('heapObjectForWebGLType', false);
unexportedRuntimeFunction('heapAccessShiftForWebGLHeap', false);
unexportedRuntimeFunction('GL', false);
unexportedRuntimeFunction('emscriptenWebGLGet', false);
unexportedRuntimeFunction('computeUnpackAlignedImageSize', false);
unexportedRuntimeFunction('emscriptenWebGLGetTexPixelData', false);
unexportedRuntimeFunction('emscriptenWebGLGetUniform', false);
unexportedRuntimeFunction('webglGetUniformLocation', false);
unexportedRuntimeFunction('webglPrepareUniformLocationsBeforeFirstUse', false);
unexportedRuntimeFunction('webglGetLeftBracePos', false);
unexportedRuntimeFunction('emscriptenWebGLGetVertexAttrib', false);
unexportedRuntimeFunction('writeGLArray', false);
unexportedRuntimeFunction('AL', false);
unexportedRuntimeFunction('SDL_unicode', false);
unexportedRuntimeFunction('SDL_ttfContext', false);
unexportedRuntimeFunction('SDL_audio', false);
unexportedRuntimeFunction('SDL', false);
unexportedRuntimeFunction('SDL_gfx', false);
unexportedRuntimeFunction('GLUT', false);
unexportedRuntimeFunction('EGL', false);
unexportedRuntimeFunction('GLFW_Window', false);
unexportedRuntimeFunction('GLFW', false);
unexportedRuntimeFunction('GLEW', false);
unexportedRuntimeFunction('IDBStore', false);
unexportedRuntimeFunction('runAndAbortIfError', false);
unexportedRuntimeFunction('warnOnce', false);
unexportedRuntimeFunction('stackSave', false);
unexportedRuntimeFunction('stackRestore', false);
unexportedRuntimeFunction('stackAlloc', false);
unexportedRuntimeFunction('AsciiToString', false);
unexportedRuntimeFunction('stringToAscii', false);
unexportedRuntimeFunction('UTF16ToString', false);
unexportedRuntimeFunction('stringToUTF16', false);
unexportedRuntimeFunction('lengthBytesUTF16', false);
unexportedRuntimeFunction('UTF32ToString', false);
unexportedRuntimeFunction('stringToUTF32', false);
unexportedRuntimeFunction('lengthBytesUTF32', false);
unexportedRuntimeFunction('allocateUTF8', false);
unexportedRuntimeFunction('allocateUTF8OnStack', false);
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
unexportedRuntimeSymbol('ALLOC_NORMAL', false);
unexportedRuntimeSymbol('ALLOC_STACK', false);

var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  var entryFunction = Module['_main'];

  // Main modules can't tell if they have main() at compile time, since it may
  // arrive from a dynamic library.
  if (!entryFunction) return;

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as
    // execution is asynchronously handed off to a pthread.
    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
    return ret;
  }
  catch (e) {
    return handleException(e);
  } finally {
    calledMain = true;

  }
}

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  _emscripten_stack_set_limits(6284784, 1041904);
  writeStackCookie();
}

var dylibsLoaded = false;

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  stackCheckInit();

  if (!dylibsLoaded) {
  // Loading of dynamic libraries needs to happen on each thread, so we can't
  // use the normal __ATPRERUN__ mechanism.
    preloadDylibs();
    dylibsLoaded = true;

    // Loading dylibs can add run dependencies.
    if (runDependencies > 0) {
      return;
    }
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    readyPromiseResolve(Module);
    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    ___stdio_exit();
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  checkUnflushedContent();

  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
  if (keepRuntimeAlive() && !implicit) {
    var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';
    readyPromiseReject(msg);
    err(msg);
  }

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();







  return Module.ready
}
);
})();
if (typeof exports === 'object' && "object" === 'object')
  module.exports = Module;
else if (typeof define === 'function' && __webpack_require__.amdO)
  define([], function() { return Module; });
else if (typeof exports === 'object')
  exports["Module"] = Module;

  const location = {};
  const memio = [];
  

/***/ }),

/***/ "./webinterface/core-sdl.js":
/*!**********************************!*\
  !*** ./webinterface/core-sdl.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SDL_MODULE": () => (/* binding */ SDL_MODULE)
/* harmony export */ });
function SDL_MODULE(MODULE_HEAP, MODULE, ABORT, EXPORT_WRAPPER, STRINGTOUTF8,UTF8TOSTRING,ALLOCATEUTF8,WASMENTRYTABLE) {
    // Global function
    var HEAP,
        /** @type {!ArrayBuffer} */
        buffer,
        /** @type {!Int8Array} */
        HEAP8,
        /** @type {!Uint8Array} */
        HEAPU8,
        /** @type {!Int16Array} */
        HEAP16,
        /** @type {!Uint16Array} */
        HEAPU16,
        /** @type {!Int32Array} */
        HEAP32,
        /** @type {!Uint32Array} */
        HEAPU32,
        /** @type {!Float32Array} */
        HEAPF32,
        /** @type {!Float64Array} */
        HEAPF64;
    var Module = MODULE;
    var abort = ABORT;
    var getWasmTableEntry = WASMENTRYTABLE; 
    
    var err = console.warn.bind(console);

    var __ATEXIT__    = []; // functions called during shutdown
    var setWindowTitle = (title) => document.title = title;
    var GLctx;

    function updateGlobalBufferAndViews(buf) {
        buffer = buf;
        HEAP8 = new Int8Array(buf);
        HEAP16 = new Int16Array(buf);
        HEAP32 = new Int32Array(buf);
        HEAPU8 = new Uint8Array(buf);
        HEAPU16 = new Uint16Array(buf);
        HEAPU32 = new Uint32Array(buf);
        HEAPF32 = new Float32Array(buf);
        HEAPF64 = new Float64Array(buf);
    }
    updateGlobalBufferAndViews(MODULE_HEAP);

    /** @type {function(*, string=)} */
    function assert(condition, text) {
        if (!condition) {
            abort('Assertion failed' + (text ? ': ' + text : ''));
        }
    }
    var createExportWrapper = EXPORT_WRAPPER;
    var _malloc = Module["_malloc"] = createExportWrapper("malloc");

    var stringToUTF8 = STRINGTOUTF8;
    var UTF8ToString = UTF8TOSTRING;
    var allocateUTF8 = ALLOCATEUTF8;

    //Specific SDL functions

    function listenOnce(object, event, func) {
        object.addEventListener(event, func, { 'once': true });
      }

    /** @param {Object=} elements */
  function autoResumeAudioContext(ctx, elements) {
    if (!elements) {
      elements = [document, document.getElementById('canvas')];
    }
    ['keydown', 'mousedown', 'touchstart'].forEach(function(event) {
      elements.forEach(function(element) {
        if (element) {
          listenOnce(element, event, function() {
            if (ctx.state === 'suspended') ctx.resume();
          });
        }
      });
    });
  }

    var ASM_CONSTS = {
        291780: function($0, $1, $2) {var w = $0; var h = $1; var pixels = $2; if (!Module['SDL2']) Module['SDL2'] = {}; var SDL2 = Module['SDL2']; if (SDL2.ctxCanvas !== Module['canvas']) { SDL2.ctx = Module['createContext'](Module['canvas'], false, true); SDL2.ctxCanvas = Module['canvas']; } if (SDL2.w !== w || SDL2.h !== h || SDL2.imageCtx !== SDL2.ctx) { SDL2.image = SDL2.ctx.createImageData(w, h); SDL2.w = w; SDL2.h = h; SDL2.imageCtx = SDL2.ctx; } var data = SDL2.image.data; var src = pixels >> 2; var dst = 0; var num; if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) { num = data.length; while (dst < num) { var val = HEAP32[src]; data[dst ] = val & 0xff; data[dst+1] = (val >> 8) & 0xff; data[dst+2] = (val >> 16) & 0xff; data[dst+3] = 0xff; src++; dst += 4; } } else { if (SDL2.data32Data !== data) { SDL2.data32 = new Int32Array(data.buffer); SDL2.data8 = new Uint8Array(data.buffer); SDL2.data32Data = data; } var data32 = SDL2.data32; num = data32.length; data32.set(HEAP32.subarray(src, src + num)); var data8 = SDL2.data8; var i = 3; var j = i + 4*num; if (num % 8 == 0) { while (i < j) { data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; data8[i] = 0xff; i = i + 4 | 0; } } else { while (i < j) { data8[i] = 0xff; i = i + 4 | 0; } } } SDL2.ctx.putImageData(SDL2.image, 0, 0); return 0;},  
        293259: function() {if (typeof(AudioContext) !== 'undefined') { return 1; } else if (typeof(webkitAudioContext) !== 'undefined') { return 1; } return 0;},  
        293396: function() {if ((typeof(navigator.mediaDevices) !== 'undefined') && (typeof(navigator.mediaDevices.getUserMedia) !== 'undefined')) { return 1; } else if (typeof(navigator.webkitGetUserMedia) !== 'undefined') { return 1; } return 0;},  
        293620: function($0) {if(typeof(Module['SDL2']) === 'undefined') { Module['SDL2'] = {}; } var SDL2 = Module['SDL2']; if (!$0) { SDL2.audio = {}; } else { SDL2.capture = {}; } if (!SDL2.audioContext) { if (typeof(AudioContext) !== 'undefined') { SDL2.audioContext = new AudioContext(); } else if (typeof(webkitAudioContext) !== 'undefined') { SDL2.audioContext = new webkitAudioContext(); } if (SDL2.audioContext) { autoResumeAudioContext(SDL2.audioContext); } } return SDL2.audioContext === undefined ? -1 : 0;},  
        294113: function() {var SDL2 = Module['SDL2']; return SDL2.audioContext.sampleRate;},  
        294181: function($0, $1, $2, $3) {var SDL2 = Module['SDL2']; var have_microphone = function(stream) { if (SDL2.capture.silenceTimer !== undefined) { clearTimeout(SDL2.capture.silenceTimer); SDL2.capture.silenceTimer = undefined; } SDL2.capture.mediaStreamNode = SDL2.audioContext.createMediaStreamSource(stream); SDL2.capture.scriptProcessorNode = SDL2.audioContext.createScriptProcessor($1, $0, 1); SDL2.capture.scriptProcessorNode.onaudioprocess = function(audioProcessingEvent) { if ((SDL2 === undefined) || (SDL2.capture === undefined)) { return; } audioProcessingEvent.outputBuffer.getChannelData(0).fill(0.0); SDL2.capture.currentCaptureBuffer = audioProcessingEvent.inputBuffer; dynCall('vi', $2, [$3]); }; SDL2.capture.mediaStreamNode.connect(SDL2.capture.scriptProcessorNode); SDL2.capture.scriptProcessorNode.connect(SDL2.audioContext.destination); SDL2.capture.stream = stream; }; var no_microphone = function(error) { }; SDL2.capture.silenceBuffer = SDL2.audioContext.createBuffer($0, $1, SDL2.audioContext.sampleRate); SDL2.capture.silenceBuffer.getChannelData(0).fill(0.0); var silence_callback = function() { SDL2.capture.currentCaptureBuffer = SDL2.capture.silenceBuffer; dynCall('vi', $2, [$3]); }; SDL2.capture.silenceTimer = setTimeout(silence_callback, ($1 / SDL2.audioContext.sampleRate) * 1000); if ((navigator.mediaDevices !== undefined) && (navigator.mediaDevices.getUserMedia !== undefined)) { navigator.mediaDevices.getUserMedia({ audio: true, video: false }).then(have_microphone).catch(no_microphone); } else if (navigator.webkitGetUserMedia !== undefined) { navigator.webkitGetUserMedia({ audio: true, video: false }, have_microphone, no_microphone); }},  
        295833: function($0, $1, $2, $3) {var SDL2 = Module['SDL2']; SDL2.audio.scriptProcessorNode = SDL2.audioContext['createScriptProcessor']($1, 0, $0); SDL2.audio.scriptProcessorNode['onaudioprocess'] = function (e) { if ((SDL2 === undefined) || (SDL2.audio === undefined)) { return; } SDL2.audio.currentOutputBuffer = e['outputBuffer']; dynCall('vi', $2, [$3]); }; SDL2.audio.scriptProcessorNode['connect'](SDL2.audioContext['destination']);},  
        296243: function($0, $1) {var SDL2 = Module['SDL2']; var numChannels = SDL2.capture.currentCaptureBuffer.numberOfChannels; for (var c = 0; c < numChannels; ++c) { var channelData = SDL2.capture.currentCaptureBuffer.getChannelData(c); if (channelData.length != $1) { throw 'Web Audio capture buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + $1 + ' samples!'; } if (numChannels == 1) { for (var j = 0; j < $1; ++j) { setValue($0 + (j * 4), channelData[j], 'float'); } } else { for (var j = 0; j < $1; ++j) { setValue($0 + (((j * numChannels) + c) * 4), channelData[j], 'float'); } } }},  
        296848: function($0, $1) {var SDL2 = Module['SDL2']; var numChannels = SDL2.audio.currentOutputBuffer['numberOfChannels']; for (var c = 0; c < numChannels; ++c) { var channelData = SDL2.audio.currentOutputBuffer['getChannelData'](c); if (channelData.length != $1) { throw 'Web Audio output buffer length mismatch! Destination size: ' + channelData.length + ' samples vs expected ' + $1 + ' samples!'; } for (var j = 0; j < $1; ++j) { channelData[j] = HEAPF32[$0 + ((j*numChannels + c) << 2) >> 2]; } }},  
        297328: function($0) {var SDL2 = Module['SDL2']; if ($0) { if (SDL2.capture.silenceTimer !== undefined) { clearTimeout(SDL2.capture.silenceTimer); } if (SDL2.capture.stream !== undefined) { var tracks = SDL2.capture.stream.getAudioTracks(); for (var i = 0; i < tracks.length; i++) { SDL2.capture.stream.removeTrack(tracks[i]); } SDL2.capture.stream = undefined; } if (SDL2.capture.scriptProcessorNode !== undefined) { SDL2.capture.scriptProcessorNode.onaudioprocess = function(audioProcessingEvent) {}; SDL2.capture.scriptProcessorNode.disconnect(); SDL2.capture.scriptProcessorNode = undefined; } if (SDL2.capture.mediaStreamNode !== undefined) { SDL2.capture.mediaStreamNode.disconnect(); SDL2.capture.mediaStreamNode = undefined; } if (SDL2.capture.silenceBuffer !== undefined) { SDL2.capture.silenceBuffer = undefined } SDL2.capture = undefined; } else { if (SDL2.audio.scriptProcessorNode != undefined) { SDL2.audio.scriptProcessorNode.disconnect(); SDL2.audio.scriptProcessorNode = undefined; } SDL2.audio = undefined; } if ((SDL2.audioContext !== undefined) && (SDL2.audio === undefined) && (SDL2.capture === undefined)) { SDL2.audioContext.close(); SDL2.audioContext = undefined; }},  
        298500: function($0, $1, $2, $3, $4) {var w = $0; var h = $1; var hot_x = $2; var hot_y = $3; var pixels = $4; var canvas = document.createElement("canvas"); canvas.width = w; canvas.height = h; var ctx = canvas.getContext("2d"); var image = ctx.createImageData(w, h); var data = image.data; var src = pixels >> 2; var dst = 0; var num; if (typeof CanvasPixelArray !== 'undefined' && data instanceof CanvasPixelArray) { num = data.length; while (dst < num) { var val = HEAP32[src]; data[dst ] = val & 0xff; data[dst+1] = (val >> 8) & 0xff; data[dst+2] = (val >> 16) & 0xff; data[dst+3] = (val >> 24) & 0xff; src++; dst += 4; } } else { var data32 = new Int32Array(data.buffer); num = data32.length; data32.set(HEAP32.subarray(src, src + num)); } ctx.putImageData(image, 0, 0); var url = hot_x === 0 && hot_y === 0 ? "url(" + canvas.toDataURL() + "), auto" : "url(" + canvas.toDataURL() + ") " + hot_x + " " + hot_y + ", auto"; var urlBuf = _malloc(url.length + 1); stringToUTF8(url, urlBuf, url.length + 1); return urlBuf;},  
        299489: function($0) {if (Module['canvas']) { Module['canvas'].style['cursor'] = UTF8ToString($0); } return 0;},  
        299582: function() {if (Module['canvas']) { Module['canvas'].style['cursor'] = 'none'; }},  
        299651: function() {return window.innerWidth;},  
        299681: function() {return window.innerHeight;}
    };

    var Browser = {
        mainLoop: {
            running: false, scheduler: null, method: "", currentlyRunningMainloop: 0, func: null, arg: 0, timingMode: 0, timingValue: 0, currentFrameNumber: 0, queue: [], pause: function () {
                Browser.mainLoop.scheduler = null;
                // Incrementing this signals the previous main loop that it's now become old, and it must return.
                Browser.mainLoop.currentlyRunningMainloop++;
            }, resume: function () {
                Browser.mainLoop.currentlyRunningMainloop++;
                var timingMode = Browser.mainLoop.timingMode;
                var timingValue = Browser.mainLoop.timingValue;
                var func = Browser.mainLoop.func;
                Browser.mainLoop.func = null;
                // do not set timing and call scheduler, we will do it on the next lines
                setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
                _emscripten_set_main_loop_timing(timingMode, timingValue);
                Browser.mainLoop.scheduler();
            }, updateStatus: function () {
                if (Module['setStatus']) {
                    var message = Module['statusMessage'] || 'Please wait...';
                    var remaining = Browser.mainLoop.remainingBlockers;
                    var expected = Browser.mainLoop.expectedBlockers;
                    if (remaining) {
                        if (remaining < expected) {
                            Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
                        } else {
                            Module['setStatus'](message);
                        }
                    } else {
                        Module['setStatus']('');
                    }
                }
            }, runIter: function (func) {
                if (ABORT) return;
                if (Module['preMainLoop']) {
                    var preRet = Module['preMainLoop']();
                    if (preRet === false) {
                        return; // |return false| skips a frame
                    }
                }
                callUserCallback(func);
                if (Module['postMainLoop']) Module['postMainLoop']();
            }
        }, isFullscreen: false, pointerLock: false, moduleContextCreatedCallbacks: [], workers: [], init: function () {
            if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers

            if (Browser.initted) return;
            Browser.initted = true;

            try {
                new Blob();
                Browser.hasBlobConstructor = true;
            } catch (e) {
                Browser.hasBlobConstructor = false;
                out("warning: no blob constructor, cannot create blobs with mimetypes");
            }
            Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? out("warning: no BlobBuilder") : null));
            Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
            if (!Module.noImageDecoding && typeof Browser.URLObject == 'undefined') {
                out("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
                Module.noImageDecoding = true;
            }

            // Support for plugins that can process preloaded files. You can add more of these to
            // your app by creating and appending to Module.preloadPlugins.
            //
            // Each plugin is asked if it can handle a file based on the file's name. If it can,
            // it is given the file's raw data. When it is done, it calls a callback with the file's
            // (possibly modified) data. For example, a plugin might decompress a file, or it
            // might create some side data structure for use later (like an Image element, etc.).

            var imagePlugin = {};
            imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
                return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
            };
            imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
                var b = null;
                if (Browser.hasBlobConstructor) {
                    try {
                        b = new Blob([byteArray], { type: Browser.getMimetype(name) });
                        if (b.size !== byteArray.length) { // Safari bug #118630
                            // Safari's Blob can only take an ArrayBuffer
                            b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
                        }
                    } catch (e) {
                        warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
                    }
                }
                if (!b) {
                    var bb = new Browser.BlobBuilder();
                    bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
                    b = bb.getBlob();
                }
                var url = Browser.URLObject.createObjectURL(b);
                assert(typeof url == 'string', 'createObjectURL must return a url as a string');
                var img = new Image();
                img.onload = () => {
                    assert(img.complete, 'Image ' + name + ' could not be decoded');
                    var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
                    canvas.width = img.width;
                    canvas.height = img.height;
                    var ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    Module["preloadedImages"][name] = canvas;
                    Browser.URLObject.revokeObjectURL(url);
                    if (onload) onload(byteArray);
                };
                img.onerror = (event) => {
                    out('Image ' + url + ' could not be decoded');
                    if (onerror) onerror();
                };
                img.src = url;
            };
            Module['preloadPlugins'].push(imagePlugin);

            var audioPlugin = {};
            audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
                return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
            };
            audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
                var done = false;
                function finish(audio) {
                    if (done) return;
                    done = true;
                    Module["preloadedAudios"][name] = audio;
                    if (onload) onload(byteArray);
                }
                function fail() {
                    if (done) return;
                    done = true;
                    Module["preloadedAudios"][name] = new Audio(); // empty shim
                    if (onerror) onerror();
                }
                if (Browser.hasBlobConstructor) {
                    try {
                        var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
                    } catch (e) {
                        return fail();
                    }
                    var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
                    assert(typeof url == 'string', 'createObjectURL must return a url as a string');
                    var audio = new Audio();
                    audio.addEventListener('canplaythrough', function () { finish(audio) }, false); // use addEventListener due to chromium bug 124926
                    audio.onerror = function audio_onerror(event) {
                        if (done) return;
                        out('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
                        function encode64(data) {
                            var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                            var PAD = '=';
                            var ret = '';
                            var leftchar = 0;
                            var leftbits = 0;
                            for (var i = 0; i < data.length; i++) {
                                leftchar = (leftchar << 8) | data[i];
                                leftbits += 8;
                                while (leftbits >= 6) {
                                    var curr = (leftchar >> (leftbits - 6)) & 0x3f;
                                    leftbits -= 6;
                                    ret += BASE[curr];
                                }
                            }
                            if (leftbits == 2) {
                                ret += BASE[(leftchar & 3) << 4];
                                ret += PAD + PAD;
                            } else if (leftbits == 4) {
                                ret += BASE[(leftchar & 0xf) << 2];
                                ret += PAD;
                            }
                            return ret;
                        }
                        audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
                        finish(audio); // we don't wait for confirmation this worked - but it's worth trying
                    };
                    audio.src = url;
                    // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
                    safeSetTimeout(function () {
                        finish(audio); // try to use it even though it is not necessarily ready to play
                    }, 10000);
                } else {
                    return fail();
                }
            };
            Module['preloadPlugins'].push(audioPlugin);

            // Use string keys here to avoid minification since the plugin consumer
            // also uses string keys.
            var wasmPlugin = {
                'asyncWasmLoadPromise': new Promise(function (resolve, reject) { return resolve(); }),
                'canHandle': function (name) {
                    return !Module.noWasmDecoding && name.endsWith('.so')
                },
                'handle': function (byteArray, name, onload, onerror) {
                    // loadWebAssemblyModule can not load modules out-of-order, so rather
                    // than just running the promises in parallel, this makes a chain of
                    // promises to run in series.
                    wasmPlugin['asyncWasmLoadPromise'] = wasmPlugin['asyncWasmLoadPromise'].then(
                        function () {
                            return loadWebAssemblyModule(byteArray, { loadAsync: true, nodelete: true });
                        }).then(
                            function (module) {
                                Module['preloadedWasm'][name] = module;
                                onload();
                            },
                            function (err) {
                                console.warn("Couldn't instantiate wasm: " + name + " '" + err + "'");
                                onerror();
                            });
                }
            };
            Module['preloadPlugins'].push(wasmPlugin);

            // Canvas event setup

            function pointerLockChange() {
                Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                    document['mozPointerLockElement'] === Module['canvas'] ||
                    document['webkitPointerLockElement'] === Module['canvas'] ||
                    document['msPointerLockElement'] === Module['canvas'];
            }
            var canvas = Module['canvas'];
            if (canvas) {
                // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
                // Module['forcedAspectRatio'] = 4 / 3;

                canvas.requestPointerLock = canvas['requestPointerLock'] ||
                    canvas['mozRequestPointerLock'] ||
                    canvas['webkitRequestPointerLock'] ||
                    canvas['msRequestPointerLock'] ||
                    function () { };
                canvas.exitPointerLock = document['exitPointerLock'] ||
                    document['mozExitPointerLock'] ||
                    document['webkitExitPointerLock'] ||
                    document['msExitPointerLock'] ||
                    function () { }; // no-op if function does not exist
                canvas.exitPointerLock = canvas.exitPointerLock.bind(document);

                document.addEventListener('pointerlockchange', pointerLockChange, false);
                document.addEventListener('mozpointerlockchange', pointerLockChange, false);
                document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
                document.addEventListener('mspointerlockchange', pointerLockChange, false);

                if (Module['elementPointerLock']) {
                    canvas.addEventListener("click", function (ev) {
                        if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                            Module['canvas'].requestPointerLock();
                            ev.preventDefault();
                        }
                    }, false);
                }
            }
        }, handledByPreloadPlugin: function (byteArray, fullname, finish, onerror) {
            // Ensure plugins are ready.
            Browser.init();

            var handled = false;
            Module['preloadPlugins'].forEach(function (plugin) {
                if (handled) return;
                if (plugin['canHandle'](fullname)) {
                    plugin['handle'](byteArray, fullname, finish, onerror);
                    handled = true;
                }
            });
            return handled;
        }, createContext: function (/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {
            if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.

            var ctx;
            var contextHandle;
            if (useWebGL) {
                // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
                var contextAttributes = {
                    antialias: false,
                    alpha: false,
                    majorVersion: 1,
                };

                if (webGLContextAttributes) {
                    for (var attribute in webGLContextAttributes) {
                        contextAttributes[attribute] = webGLContextAttributes[attribute];
                    }
                }

                // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
                // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
                // Browser.createContext() should not even be emitted.
                if (typeof GL != 'undefined') {
                    contextHandle = GL.createContext(canvas, contextAttributes);
                    if (contextHandle) {
                        ctx = GL.getContext(contextHandle).GLctx;
                    }
                }
            } else {
                ctx = canvas.getContext('2d');
            }

            if (!ctx) return null;

            if (setInModule) {
                if (!useWebGL) assert(typeof GLctx == 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');

                Module.ctx = ctx;
                if (useWebGL) GL.makeContextCurrent(contextHandle);
                Module.useWebGL = useWebGL;
                Browser.moduleContextCreatedCallbacks.forEach(function (callback) { callback() });
                Browser.init();
            }
            return ctx;
        }, destroyContext: function (canvas, useWebGL, setInModule) { }, fullscreenHandlersInstalled: false, lockPointer: undefined, resizeCanvas: undefined, requestFullscreen: function (lockPointer, resizeCanvas) {
            Browser.lockPointer = lockPointer;
            Browser.resizeCanvas = resizeCanvas;
            if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;
            if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;

            var canvas = Module['canvas'];
            function fullscreenChange() {
                Browser.isFullscreen = false;
                var canvasContainer = canvas.parentNode;
                if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
                    document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
                    document['webkitCurrentFullScreenElement']) === canvasContainer) {
                    canvas.exitFullscreen = Browser.exitFullscreen;
                    if (Browser.lockPointer) canvas.requestPointerLock();
                    Browser.isFullscreen = true;
                    if (Browser.resizeCanvas) {
                        Browser.setFullscreenCanvasSize();
                    } else {
                        Browser.updateCanvasDimensions(canvas);
                    }
                } else {
                    // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
                    canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
                    canvasContainer.parentNode.removeChild(canvasContainer);

                    if (Browser.resizeCanvas) {
                        Browser.setWindowedCanvasSize();
                    } else {
                        Browser.updateCanvasDimensions(canvas);
                    }
                }
                if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
                if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
            }

            if (!Browser.fullscreenHandlersInstalled) {
                Browser.fullscreenHandlersInstalled = true;
                document.addEventListener('fullscreenchange', fullscreenChange, false);
                document.addEventListener('mozfullscreenchange', fullscreenChange, false);
                document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
                document.addEventListener('MSFullscreenChange', fullscreenChange, false);
            }

            // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
            var canvasContainer = document.createElement("div");
            canvas.parentNode.insertBefore(canvasContainer, canvas);
            canvasContainer.appendChild(canvas);

            // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
            canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                canvasContainer['mozRequestFullScreen'] ||
                canvasContainer['msRequestFullscreen'] ||
                (canvasContainer['webkitRequestFullscreen'] ? function () { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                (canvasContainer['webkitRequestFullScreen'] ? function () { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);

            canvasContainer.requestFullscreen();
        }, requestFullScreen: function () {
            abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');
        }, exitFullscreen: function () {
            // This is workaround for chrome. Trying to exit from fullscreen
            // not in fullscreen state will cause "TypeError: Document not active"
            // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
            if (!Browser.isFullscreen) {
                return false;
            }

            var CFS = document['exitFullscreen'] ||
                document['cancelFullScreen'] ||
                document['mozCancelFullScreen'] ||
                document['msExitFullscreen'] ||
                document['webkitCancelFullScreen'] ||
                (function () { });
            CFS.apply(document, []);
            return true;
        }, nextRAF: 0, fakeRequestAnimationFrame: function (func) {
            // try to keep 60fps between calls to here
            var now = Date.now();
            if (Browser.nextRAF === 0) {
                Browser.nextRAF = now + 1000 / 60;
            } else {
                while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
                    Browser.nextRAF += 1000 / 60;
                }
            }
            var delay = Math.max(Browser.nextRAF - now, 0);
            setTimeout(func, delay);
        }, requestAnimationFrame: function (func) {
            if (typeof requestAnimationFrame == 'function') {
                requestAnimationFrame(func);
                return;
            }
            var RAF = Browser.fakeRequestAnimationFrame;
            RAF(func);
        }, safeSetTimeout: function (func) {
            // Legacy function, this is used by the SDL2 port so we need to keep it
            // around at least until that is updated.
            return safeSetTimeout(func);
        }, safeRequestAnimationFrame: function (func) {

            return Browser.requestAnimationFrame(function () {

                callUserCallback(func);
            });
        }, getMimetype: function (name) {
            return {
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'png': 'image/png',
                'bmp': 'image/bmp',
                'ogg': 'audio/ogg',
                'wav': 'audio/wav',
                'mp3': 'audio/mpeg'
            }[name.substr(name.lastIndexOf('.') + 1)];
        }, getUserMedia: function (func) {
            if (!window.getUserMedia) {
                window.getUserMedia = navigator['getUserMedia'] ||
                    navigator['mozGetUserMedia'];
            }
            window.getUserMedia(func);
        }, getMovementX: function (event) {
            return event['movementX'] ||
                event['mozMovementX'] ||
                event['webkitMovementX'] ||
                0;
        }, getMovementY: function (event) {
            return event['movementY'] ||
                event['mozMovementY'] ||
                event['webkitMovementY'] ||
                0;
        }, getMouseWheelDelta: function (event) {
            var delta = 0;
            switch (event.type) {
                case 'DOMMouseScroll':
                    // 3 lines make up a step
                    delta = event.detail / 3;
                    break;
                case 'mousewheel':
                    // 120 units make up a step
                    delta = event.wheelDelta / 120;
                    break;
                case 'wheel':
                    delta = event.deltaY
                    switch (event.deltaMode) {
                        case 0:
                            // DOM_DELTA_PIXEL: 100 pixels make up a step
                            delta /= 100;
                            break;
                        case 1:
                            // DOM_DELTA_LINE: 3 lines make up a step
                            delta /= 3;
                            break;
                        case 2:
                            // DOM_DELTA_PAGE: A page makes up 80 steps
                            delta *= 80;
                            break;
                        default:
                            throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
                    }
                    break;
                default:
                    throw 'unrecognized mouse wheel event: ' + event.type;
            }
            return delta;
        }, mouseX: 0, mouseY: 0, mouseMovementX: 0, mouseMovementY: 0, touches: {}, lastTouches: {}, calculateMouseEvent: function (event) { // event should be mousemove, mousedown or mouseup
            if (Browser.pointerLock) {
                // When the pointer is locked, calculate the coordinates
                // based on the movement of the mouse.
                // Workaround for Firefox bug 764498
                if (event.type != 'mousemove' &&
                    ('mozMovementX' in event)) {
                    Browser.mouseMovementX = Browser.mouseMovementY = 0;
                } else {
                    Browser.mouseMovementX = Browser.getMovementX(event);
                    Browser.mouseMovementY = Browser.getMovementY(event);
                }

                // check if SDL is available
                if (typeof SDL != "undefined") {
                    Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
                    Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
                } else {
                    // just add the mouse delta to the current absolut mouse position
                    // FIXME: ideally this should be clamped against the canvas size and zero
                    Browser.mouseX += Browser.mouseMovementX;
                    Browser.mouseY += Browser.mouseMovementY;
                }
            } else {
                // Otherwise, calculate the movement based on the changes
                // in the coordinates.
                var rect = Module["canvas"].getBoundingClientRect();
                var cw = Module["canvas"].width;
                var ch = Module["canvas"].height;

                // Neither .scrollX or .pageXOffset are defined in a spec, but
                // we prefer .scrollX because it is currently in a spec draft.
                // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
                var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);
                var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);
                // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
                // and we have no viable fallback.
                assert((typeof scrollX != 'undefined') && (typeof scrollY != 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');

                if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
                    var touch = event.touch;
                    if (touch === undefined) {
                        return; // the "touch" property is only defined in SDL

                    }
                    var adjustedX = touch.pageX - (scrollX + rect.left);
                    var adjustedY = touch.pageY - (scrollY + rect.top);

                    adjustedX = adjustedX * (cw / rect.width);
                    adjustedY = adjustedY * (ch / rect.height);

                    var coords = { x: adjustedX, y: adjustedY };

                    if (event.type === 'touchstart') {
                        Browser.lastTouches[touch.identifier] = coords;
                        Browser.touches[touch.identifier] = coords;
                    } else if (event.type === 'touchend' || event.type === 'touchmove') {
                        var last = Browser.touches[touch.identifier];
                        if (!last) last = coords;
                        Browser.lastTouches[touch.identifier] = last;
                        Browser.touches[touch.identifier] = coords;
                    }
                    return;
                }

                var x = event.pageX - (scrollX + rect.left);
                var y = event.pageY - (scrollY + rect.top);

                // the canvas might be CSS-scaled compared to its backbuffer;
                // SDL-using content will want mouse coordinates in terms
                // of backbuffer units.
                x = x * (cw / rect.width);
                y = y * (ch / rect.height);

                Browser.mouseMovementX = x - Browser.mouseX;
                Browser.mouseMovementY = y - Browser.mouseY;
                Browser.mouseX = x;
                Browser.mouseY = y;
            }
        }, resizeListeners: [], updateResizeListeners: function () {
            var canvas = Module['canvas'];
            Browser.resizeListeners.forEach(function (listener) {
                listener(canvas.width, canvas.height);
            });
        }, setCanvasSize: function (width, height, noUpdates) {
            var canvas = Module['canvas'];
            Browser.updateCanvasDimensions(canvas, width, height);
            if (!noUpdates) Browser.updateResizeListeners();
        }, windowedWidth: 0, windowedHeight: 0, setFullscreenCanvasSize: function () {
            // check if SDL is available
            if (typeof SDL != "undefined") {
                var flags = HEAPU32[((SDL.screen) >> 2)];
                flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
                HEAP32[((SDL.screen) >> 2)] = flags;
            }
            Browser.updateCanvasDimensions(Module['canvas']);
            Browser.updateResizeListeners();
        }, setWindowedCanvasSize: function () {
            // check if SDL is available
            if (typeof SDL != "undefined") {
                var flags = HEAPU32[((SDL.screen) >> 2)];
                flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
                HEAP32[((SDL.screen) >> 2)] = flags;
            }
            Browser.updateCanvasDimensions(Module['canvas']);
            Browser.updateResizeListeners();
        }, updateCanvasDimensions: function (canvas, wNative, hNative) {
            if (wNative && hNative) {
                canvas.widthNative = wNative;
                canvas.heightNative = hNative;
            } else {
                wNative = canvas.widthNative;
                hNative = canvas.heightNative;
            }
            var w = wNative;
            var h = hNative;
            if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
                if (w / h < Module['forcedAspectRatio']) {
                    w = Math.round(h * Module['forcedAspectRatio']);
                } else {
                    h = Math.round(w / Module['forcedAspectRatio']);
                }
            }
            if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
                document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
                document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
                var factor = Math.min(screen.width / w, screen.height / h);
                w = Math.round(w * factor);
                h = Math.round(h * factor);
            }
            if (Browser.resizeCanvas) {
                if (canvas.width != w) canvas.width = w;
                if (canvas.height != h) canvas.height = h;
                if (typeof canvas.style != 'undefined') {
                    canvas.style.removeProperty("width");
                    canvas.style.removeProperty("height");
                }
            } else {
                if (canvas.width != wNative) canvas.width = wNative;
                if (canvas.height != hNative) canvas.height = hNative;
                if (typeof canvas.style != 'undefined') {
                    if (w != wNative || h != hNative) {
                        canvas.style.setProperty("width", w + "px", "important");
                        canvas.style.setProperty("height", h + "px", "important");
                    } else {
                        canvas.style.removeProperty("width");
                        canvas.style.removeProperty("height");
                    }
                }
            }
        }
    };
    var EGL = {
        errorCode: 12288, defaultDisplayInitialized: false, currentContext: 0, currentReadSurface: 0, currentDrawSurface: 0, contextAttributes: { alpha: false, depth: false, stencil: false, antialias: false }, stringCache: {}, setErrorCode: function (code) {
            EGL.errorCode = code;
        }, chooseConfig: function (display, attribList, config, config_size, numConfigs) {
            if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
                EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
                return 0;
            }

            if (attribList) {
                // read attribList if it is non-null
                for (; ;) {
                    var param = HEAP32[((attribList) >> 2)];
                    if (param == 0x3021 /*EGL_ALPHA_SIZE*/) {
                        var alphaSize = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.alpha = (alphaSize > 0);
                    } else if (param == 0x3025 /*EGL_DEPTH_SIZE*/) {
                        var depthSize = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.depth = (depthSize > 0);
                    } else if (param == 0x3026 /*EGL_STENCIL_SIZE*/) {
                        var stencilSize = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.stencil = (stencilSize > 0);
                    } else if (param == 0x3031 /*EGL_SAMPLES*/) {
                        var samples = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.antialias = (samples > 0);
                    } else if (param == 0x3032 /*EGL_SAMPLE_BUFFERS*/) {
                        var samples = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.antialias = (samples == 1);
                    } else if (param == 0x3100 /*EGL_CONTEXT_PRIORITY_LEVEL_IMG*/) {
                        var requestedPriority = HEAP32[(((attribList) + (4)) >> 2)];
                        EGL.contextAttributes.lowLatency = (requestedPriority != 0x3103 /*EGL_CONTEXT_PRIORITY_LOW_IMG*/);
                    } else if (param == 0x3038 /*EGL_NONE*/) {
                        break;
                    }
                    attribList += 8;
                }
            }

            if ((!config || !config_size) && !numConfigs) {
                EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
                return 0;
            }
            if (numConfigs) {
                HEAP32[((numConfigs) >> 2)] = 1; // Total number of supported configs: 1.
            }
            if (config && config_size > 0) {
                HEAP32[((config) >> 2)] = 62002;
            }

            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }
    };
    function _eglBindAPI(api) {
        if (api == 0x30A0 /* EGL_OPENGL_ES_API */) {
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        } else { // if (api == 0x30A1 /* EGL_OPENVG_API */ || api == 0x30A2 /* EGL_OPENGL_API */) {
            EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
            return 0;
        }
    }
    _eglBindAPI.sig = 'ii';

    function _eglChooseConfig(display, attrib_list, configs, config_size, numConfigs) {
        return EGL.chooseConfig(display, attrib_list, configs, config_size, numConfigs);
    }
    _eglChooseConfig.sig = 'iiiiii';

    function __webgl_enable_ANGLE_instanced_arrays(ctx) {
        // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
        var ext = ctx.getExtension('ANGLE_instanced_arrays');
        if (ext) {
            ctx['vertexAttribDivisor'] = function (index, divisor) { ext['vertexAttribDivisorANGLE'](index, divisor); };
            ctx['drawArraysInstanced'] = function (mode, first, count, primcount) { ext['drawArraysInstancedANGLE'](mode, first, count, primcount); };
            ctx['drawElementsInstanced'] = function (mode, count, type, indices, primcount) { ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount); };
            return 1;
        }
    }

    function __webgl_enable_OES_vertex_array_object(ctx) {
        // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
        var ext = ctx.getExtension('OES_vertex_array_object');
        if (ext) {
            ctx['createVertexArray'] = function () { return ext['createVertexArrayOES'](); };
            ctx['deleteVertexArray'] = function (vao) { ext['deleteVertexArrayOES'](vao); };
            ctx['bindVertexArray'] = function (vao) { ext['bindVertexArrayOES'](vao); };
            ctx['isVertexArray'] = function (vao) { return ext['isVertexArrayOES'](vao); };
            return 1;
        }
    }

    function __webgl_enable_WEBGL_draw_buffers(ctx) {
        // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
        var ext = ctx.getExtension('WEBGL_draw_buffers');
        if (ext) {
            ctx['drawBuffers'] = function (n, bufs) { ext['drawBuffersWEBGL'](n, bufs); };
            return 1;
        }
    }

    function __webgl_enable_WEBGL_multi_draw(ctx) {
        // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
        return !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));
    }
    var GL = {
        counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: [], offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
            if (!GL.lastError) {
                GL.lastError = errorCode;
            }
        }, getNewId: function (table) {
            var ret = GL.counter++;
            for (var i = table.length; i < ret; i++) {
                table[i] = null;
            }
            return ret;
        }, getSource: function (shader, count, string, length) {
            var source = '';
            for (var i = 0; i < count; ++i) {
                var len = length ? HEAP32[(((length) + (i * 4)) >> 2)] : -1;
                source += UTF8ToString(HEAP32[(((string) + (i * 4)) >> 2)], len < 0 ? undefined : len);
            }
            return source;
        }, createContext: function (/** @type {HTMLCanvasElement} */ canvas, webGLContextAttributes) {

            // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL context on a canvas,
            // calling .getContext() will always return that context independent of which 'webgl' or 'webgl2'
            // context version was passed. See https://bugs.webkit.org/show_bug.cgi?id=222758 and
            // https://github.com/emscripten-core/emscripten/issues/13295.
            // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari version field in above check.
            if (!canvas.getContextSafariWebGL2Fixed) {
                canvas.getContextSafariWebGL2Fixed = canvas.getContext;
                /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */
                function fixedGetContext(ver, attrs) {
                    var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                    return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;
                }
                canvas.getContext = fixedGetContext;
            }

            var ctx =
                (canvas.getContext("webgl", webGLContextAttributes)
                    // https://caniuse.com/#feat=webgl
                );

            if (!ctx) return 0;

            var handle = GL.registerContext(ctx, webGLContextAttributes);

            return handle;
        }, registerContext: function (ctx, webGLContextAttributes) {
            // without pthreads a context is just an integer ID
            var handle = GL.getNewId(GL.contexts);

            var context = {
                handle: handle,
                attributes: webGLContextAttributes,
                version: webGLContextAttributes.majorVersion,
                GLctx: ctx
            };

            // Store the created context object so that we can access the context given a canvas without having to pass the parameters again.
            if (ctx.canvas) ctx.canvas.GLctxObject = context;
            GL.contexts[handle] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault == 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
                GL.initExtensions(context);
            }

            return handle;
        }, makeContextCurrent: function (contextHandle) {

            GL.currentContext = GL.contexts[contextHandle]; // Active Emscripten GL layer context object.
            Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx; // Active WebGL context object.
            return !(contextHandle && !GLctx);
        }, getContext: function (contextHandle) {
            return GL.contexts[contextHandle];
        }, deleteContext: function (contextHandle) {
            if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
            if (typeof JSEvents == 'object') JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas); // Release all JS event handlers on the DOM element that the GL context is associated with since the context is now deleted.
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined; // Make sure the canvas object no longer refers to the context object so there are no GC surprises.
            GL.contexts[contextHandle] = null;
        }, initExtensions: function (context) {
            // If this function is called without a specific context object, init the extensions of the currently active context.
            if (!context) context = GL.currentContext;

            if (context.initExtensionsDone) return;
            context.initExtensionsDone = true;

            var GLctx = context.GLctx;

            // Detect the presence of a few extensions manually, this GL interop layer itself will need to know if they exist.

            // Extensions that are only available in WebGL 1 (the calls will be no-ops if called on a WebGL 2 context active)
            __webgl_enable_ANGLE_instanced_arrays(GLctx);
            __webgl_enable_OES_vertex_array_object(GLctx);
            __webgl_enable_WEBGL_draw_buffers(GLctx);

            {
                GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
            }

            __webgl_enable_WEBGL_multi_draw(GLctx);

            // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
            var exts = GLctx.getSupportedExtensions() || [];
            exts.forEach(function (ext) {
                // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders are not enabled by default.
                if (!ext.includes('lose_context') && !ext.includes('debug')) {
                    // Call .getExtension() to enable that extension permanently.
                    GLctx.getExtension(ext);
                }
            });
        }
    };
    function _eglCreateContext(display, config, hmm, contextAttribs) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }

        // EGL 1.4 spec says default EGL_CONTEXT_CLIENT_VERSION is GLES1, but this is not supported by Emscripten.
        // So user must pass EGL_CONTEXT_CLIENT_VERSION == 2 to initialize EGL.
        var glesContextVersion = 1;
        for (; ;) {
            var param = HEAP32[((contextAttribs) >> 2)];
            if (param == 0x3098 /*EGL_CONTEXT_CLIENT_VERSION*/) {
                glesContextVersion = HEAP32[(((contextAttribs) + (4)) >> 2)];
            } else if (param == 0x3038 /*EGL_NONE*/) {
                break;
            } else {
                /* EGL1.4 specifies only EGL_CONTEXT_CLIENT_VERSION as supported attribute */
                EGL.setErrorCode(0x3004 /*EGL_BAD_ATTRIBUTE*/);
                return 0;
            }
            contextAttribs += 8;
        }
        if (glesContextVersion != 2) {
            EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
            return 0; /* EGL_NO_CONTEXT */
        }

        EGL.contextAttributes.majorVersion = glesContextVersion - 1; // WebGL 1 is GLES 2, WebGL2 is GLES3
        EGL.contextAttributes.minorVersion = 0;

        EGL.context = GL.createContext(Module['canvas'], EGL.contextAttributes);

        if (EGL.context != 0) {
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);

            // Run callbacks so that GL emulation works
            GL.makeContextCurrent(EGL.context);
            Module.useWebGL = true;
            Browser.moduleContextCreatedCallbacks.forEach(function (callback) { callback() });

            // Note: This function only creates a context, but it shall not make it active.
            GL.makeContextCurrent(null);
            return 62004; // Magic ID for Emscripten EGLContext
        } else {
            EGL.setErrorCode(0x3009 /* EGL_BAD_MATCH */); // By the EGL 1.4 spec, an implementation that does not support GLES2 (WebGL in this case), this error code is set.
            return 0; /* EGL_NO_CONTEXT */
        }
    }
    _eglCreateContext.sig = 'iiiii';

    function _eglCreateWindowSurface(display, config, win, attrib_list) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
            EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
            return 0;
        }
        // TODO: Examine attrib_list! Parameters that can be present there are:
        // - EGL_RENDER_BUFFER (must be EGL_BACK_BUFFER)
        // - EGL_VG_COLORSPACE (can't be set)
        // - EGL_VG_ALPHA_FORMAT (can't be set)
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 62006; /* Magic ID for Emscripten 'default surface' */
    }
    _eglCreateWindowSurface.sig = 'iiiii';

    function _eglDestroyContext(display, context) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        if (context != 62004 /* Magic ID for Emscripten EGLContext */) {
            EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
            return 0;
        }

        GL.deleteContext(EGL.context);
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        if (EGL.currentContext == context) {
            EGL.currentContext = 0;
        }
        return 1 /* EGL_TRUE */;
    }
    _eglDestroyContext.sig = 'iii';

    function _eglDestroySurface(display, surface) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        if (surface != 62006 /* Magic ID for the only EGLSurface supported by Emscripten */) {
            EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
            return 1;
        }
        if (EGL.currentReadSurface == surface) {
            EGL.currentReadSurface = 0;
        }
        if (EGL.currentDrawSurface == surface) {
            EGL.currentDrawSurface = 0;
        }
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1; /* Magic ID for Emscripten 'default surface' */
    }
    _eglDestroySurface.sig = 'iii';

    function _eglGetConfigAttrib(display, config, attribute, value) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        if (config != 62002 /* Magic ID for the only EGLConfig supported by Emscripten */) {
            EGL.setErrorCode(0x3005 /* EGL_BAD_CONFIG */);
            return 0;
        }
        if (!value) {
            EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
            return 0;
        }
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        switch (attribute) {
            case 0x3020: // EGL_BUFFER_SIZE
                HEAP32[((value) >> 2)] = EGL.contextAttributes.alpha ? 32 : 24;
                return 1;
            case 0x3021: // EGL_ALPHA_SIZE
                HEAP32[((value) >> 2)] = EGL.contextAttributes.alpha ? 8 : 0;
                return 1;
            case 0x3022: // EGL_BLUE_SIZE
                HEAP32[((value) >> 2)] = 8;
                return 1;
            case 0x3023: // EGL_GREEN_SIZE
                HEAP32[((value) >> 2)] = 8;
                return 1;
            case 0x3024: // EGL_RED_SIZE
                HEAP32[((value) >> 2)] = 8;
                return 1;
            case 0x3025: // EGL_DEPTH_SIZE
                HEAP32[((value) >> 2)] = EGL.contextAttributes.depth ? 24 : 0;
                return 1;
            case 0x3026: // EGL_STENCIL_SIZE
                HEAP32[((value) >> 2)] = EGL.contextAttributes.stencil ? 8 : 0;
                return 1;
            case 0x3027: // EGL_CONFIG_CAVEAT
                // We can return here one of EGL_NONE (0x3038), EGL_SLOW_CONFIG (0x3050) or EGL_NON_CONFORMANT_CONFIG (0x3051).
                HEAP32[((value) >> 2)] = 0x3038;
                return 1;
            case 0x3028: // EGL_CONFIG_ID
                HEAP32[((value) >> 2)] = 62002;
                return 1;
            case 0x3029: // EGL_LEVEL
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x302A: // EGL_MAX_PBUFFER_HEIGHT
                HEAP32[((value) >> 2)] = 4096;
                return 1;
            case 0x302B: // EGL_MAX_PBUFFER_PIXELS
                HEAP32[((value) >> 2)] = 16777216;
                return 1;
            case 0x302C: // EGL_MAX_PBUFFER_WIDTH
                HEAP32[((value) >> 2)] = 4096;
                return 1;
            case 0x302D: // EGL_NATIVE_RENDERABLE
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x302E: // EGL_NATIVE_VISUAL_ID
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x302F: // EGL_NATIVE_VISUAL_TYPE
                HEAP32[((value) >> 2)] = 0x3038;
                return 1;
            case 0x3031: // EGL_SAMPLES
                HEAP32[((value) >> 2)] = EGL.contextAttributes.antialias ? 4 : 0;
                return 1;
            case 0x3032: // EGL_SAMPLE_BUFFERS
                HEAP32[((value) >> 2)] = EGL.contextAttributes.antialias ? 1 : 0;
                return 1;
            case 0x3033: // EGL_SURFACE_TYPE
                HEAP32[((value) >> 2)] = 0x4;
                return 1;
            case 0x3034: // EGL_TRANSPARENT_TYPE
                // If this returns EGL_TRANSPARENT_RGB (0x3052), transparency is used through color-keying. No such thing applies to Emscripten canvas.
                HEAP32[((value) >> 2)] = 0x3038;
                return 1;
            case 0x3035: // EGL_TRANSPARENT_BLUE_VALUE
            case 0x3036: // EGL_TRANSPARENT_GREEN_VALUE
            case 0x3037: // EGL_TRANSPARENT_RED_VALUE
                // "If EGL_TRANSPARENT_TYPE is EGL_NONE, then the values for EGL_TRANSPARENT_RED_VALUE, EGL_TRANSPARENT_GREEN_VALUE, and EGL_TRANSPARENT_BLUE_VALUE are undefined."
                HEAP32[((value) >> 2)] = -1;
                return 1;
            case 0x3039: // EGL_BIND_TO_TEXTURE_RGB
            case 0x303A: // EGL_BIND_TO_TEXTURE_RGBA
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x303B: // EGL_MIN_SWAP_INTERVAL
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x303C: // EGL_MAX_SWAP_INTERVAL
                HEAP32[((value) >> 2)] = 1;
                return 1;
            case 0x303D: // EGL_LUMINANCE_SIZE
            case 0x303E: // EGL_ALPHA_MASK_SIZE
                HEAP32[((value) >> 2)] = 0;
                return 1;
            case 0x303F: // EGL_COLOR_BUFFER_TYPE
                // EGL has two types of buffers: EGL_RGB_BUFFER and EGL_LUMINANCE_BUFFER.
                HEAP32[((value) >> 2)] = 0x308E;
                return 1;
            case 0x3040: // EGL_RENDERABLE_TYPE
                // A bit combination of EGL_OPENGL_ES_BIT,EGL_OPENVG_BIT,EGL_OPENGL_ES2_BIT and EGL_OPENGL_BIT.
                HEAP32[((value) >> 2)] = 0x4;
                return 1;
            case 0x3042: // EGL_CONFORMANT
                // "EGL_CONFORMANT is a mask indicating if a client API context created with respect to the corresponding EGLConfig will pass the required conformance tests for that API."
                HEAP32[((value) >> 2)] = 0;
                return 1;
            default:
                EGL.setErrorCode(0x3004 /* EGL_BAD_ATTRIBUTE */);
                return 0;
        }
    }
    _eglGetConfigAttrib.sig = 'iiiii';

    function _eglGetDisplay(nativeDisplayType) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        // Note: As a 'conformant' implementation of EGL, we would prefer to init here only if the user
        //       calls this function with EGL_DEFAULT_DISPLAY. Other display IDs would be preferred to be unsupported
        //       and EGL_NO_DISPLAY returned. Uncomment the following code lines to do this.
        // Instead, an alternative route has been preferred, namely that the Emscripten EGL implementation
        // "emulates" X11, and eglGetDisplay is expected to accept/receive a pointer to an X11 Display object.
        // Therefore, be lax and allow anything to be passed in, and return the magic handle to our default EGLDisplay object.

        //    if (nativeDisplayType == 0 /* EGL_DEFAULT_DISPLAY */) {
        return 62000; // Magic ID for Emscripten 'default display'
        //    }
        //    else
        //      return 0; // EGL_NO_DISPLAY
    }
    _eglGetDisplay.sig = 'ii';

    function _eglGetError() {
        return EGL.errorCode;
    }
    _eglGetError.sig = 'i';

    function _eglInitialize(display, majorVersion, minorVersion) {
        if (display == 62000 /* Magic ID for Emscripten 'default display' */) {
            if (majorVersion) {
                HEAP32[((majorVersion) >> 2)] = 1; // Advertise EGL Major version: '1'
            }
            if (minorVersion) {
                HEAP32[((minorVersion) >> 2)] = 4; // Advertise EGL Minor version: '4'
            }
            EGL.defaultDisplayInitialized = true;
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1;
        }
        else {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
    }
    _eglInitialize.sig = 'iiii';

    function _eglMakeCurrent(display, draw, read, context) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0 /* EGL_FALSE */;
        }
        //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
        if (context != 0 && context != 62004 /* Magic ID for Emscripten EGLContext */) {
            EGL.setErrorCode(0x3006 /* EGL_BAD_CONTEXT */);
            return 0;
        }
        if ((read != 0 && read != 62006) || (draw != 0 && draw != 62006 /* Magic ID for Emscripten 'default surface' */)) {
            EGL.setErrorCode(0x300D /* EGL_BAD_SURFACE */);
            return 0;
        }

        GL.makeContextCurrent(context ? EGL.context : null);

        EGL.currentContext = context;
        EGL.currentDrawSurface = draw;
        EGL.currentReadSurface = read;
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1 /* EGL_TRUE */;
    }
    _eglMakeCurrent.sig = 'iiiii';

    function _eglQueryString(display, name) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        //\todo An EGL_NOT_INITIALIZED error is generated if EGL is not initialized for dpy.
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        if (EGL.stringCache[name]) return EGL.stringCache[name];
        var ret;
        switch (name) {
            case 0x3053 /* EGL_VENDOR */: ret = allocateUTF8("Emscripten"); break;
            case 0x3054 /* EGL_VERSION */: ret = allocateUTF8("1.4 Emscripten EGL"); break;
            case 0x3055 /* EGL_EXTENSIONS */: ret = allocateUTF8(""); break; // Currently not supporting any EGL extensions.
            case 0x308D /* EGL_CLIENT_APIS */: ret = allocateUTF8("OpenGL_ES"); break;
            default:
                EGL.setErrorCode(0x300C /* EGL_BAD_PARAMETER */);
                return 0;
        }
        EGL.stringCache[name] = ret;
        return ret;
    }
    _eglQueryString.sig = 'iii';

    function _eglSwapBuffers() {

        if (!EGL.defaultDisplayInitialized) {
            EGL.setErrorCode(0x3001 /* EGL_NOT_INITIALIZED */);
        } else if (!Module.ctx) {
            EGL.setErrorCode(0x3002 /* EGL_BAD_ACCESS */);
        } else if (Module.ctx.isContextLost()) {
            EGL.setErrorCode(0x300E /* EGL_CONTEXT_LOST */);
        } else {
            // According to documentation this does an implicit flush.
            // Due to discussion at https://github.com/emscripten-core/emscripten/pull/1871
            // the flush was removed since this _may_ result in slowing code down.
            //_glFlush();
            EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
            return 1 /* EGL_TRUE */;
        }
        return 0 /* EGL_FALSE */;
    }
    _eglSwapBuffers.sig = 'iii';

    function _eglSwapInterval(display, interval) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        if (interval == 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 0);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, interval);

        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
    }
    _eglSwapInterval.sig = 'iii';

    function _eglTerminate(display) {
        if (display != 62000 /* Magic ID for Emscripten 'default display' */) {
            EGL.setErrorCode(0x3008 /* EGL_BAD_DISPLAY */);
            return 0;
        }
        EGL.currentContext = 0;
        EGL.currentReadSurface = 0;
        EGL.currentDrawSurface = 0;
        EGL.defaultDisplayInitialized = false;
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
    }
    _eglTerminate.sig = 'ii';

    function _eglWaitClient() {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
    }
    _eglWaitClient.sig = 'i';
    function _eglWaitGL(
    ) {
        return _eglWaitClient();
    }
    _eglWaitGL.sig = 'i';

    function _eglWaitNative(nativeEngineId) {
        EGL.setErrorCode(0x3000 /* EGL_SUCCESS */);
        return 1;
    }
    _eglWaitNative.sig = 'ii';

    var readAsmConstArgsArray = [];
    function readAsmConstArgs(sigPtr, buf) {
        ;
        // Nobody should have mutated _readAsmConstArgsArray underneath us to be something else than an array.
        assert(Array.isArray(readAsmConstArgsArray));
        // The input buffer is allocated on the stack, so it must be stack-aligned.
        assert(buf % 16 == 0);
        readAsmConstArgsArray.length = 0;
        var ch;
        // Most arguments are i32s, so shift the buffer pointer so it is a plain
        // index into HEAP32.
        buf >>= 2;
        while (ch = HEAPU8[sigPtr++]) {
            assert(ch === 100/*'d'*/ || ch === 102/*'f'*/ || ch === 105 /*'i'*/, 'Invalid character ' + ch + '("' + String.fromCharCode(ch) + '") in readAsmConstArgs! Use only "d", "f" or "i", and do not specify "v" for void return argument.');
            // A double takes two 32-bit slots, and must also be aligned - the backend
            // will emit padding to avoid that.
            var readAsmConstArgsDouble = ch < 105;
            if (readAsmConstArgsDouble && (buf & 1)) buf++;
            readAsmConstArgsArray.push(readAsmConstArgsDouble ? HEAPF64[buf++ >> 1] : HEAP32[buf]);
            ++buf;
        }
        return readAsmConstArgsArray;
    }
    function _emscripten_asm_const_int(code, sigPtr, argbuf) {
        code -= 1024;
        var args = readAsmConstArgs(sigPtr, argbuf);
        if (!ASM_CONSTS.hasOwnProperty(code)) abort('No EM_ASM constant found at address ' + code);
        return ASM_CONSTS[code].apply(null, args);
    }
    _emscripten_asm_const_int.sig = 'iiii';

    function _emscripten_console_error(str) {
        assert(typeof str == 'number');
        console.error(UTF8ToString(str));
    }
    _emscripten_console_error.sig = 'vi';

    var JSEvents = {
        inEventHandler: 0, removeAllEventListeners: function () {
            for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
                JSEvents._removeHandler(i);
            }
            JSEvents.eventHandlers = [];
            JSEvents.deferredCalls = [];
        }, registerRemoveEventListeners: function () {
            if (!JSEvents.removeEventListenersRegistered) {
                __ATEXIT__.push(JSEvents.removeAllEventListeners);
                JSEvents.removeEventListenersRegistered = true;
            }
        }, deferredCalls: [], deferCall: function (targetFunction, precedence, argsList) {
            function arraysHaveEqualContent(arrA, arrB) {
                if (arrA.length != arrB.length) return false;

                for (var i in arrA) {
                    if (arrA[i] != arrB[i]) return false;
                }
                return true;
            }
            // Test if the given call was already queued, and if so, don't add it again.
            for (var i in JSEvents.deferredCalls) {
                var call = JSEvents.deferredCalls[i];
                if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                    return;
                }
            }
            JSEvents.deferredCalls.push({
                targetFunction: targetFunction,
                precedence: precedence,
                argsList: argsList
            });

            JSEvents.deferredCalls.sort(function (x, y) { return x.precedence < y.precedence; });
        }, removeDeferredCalls: function (targetFunction) {
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
                if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
                    JSEvents.deferredCalls.splice(i, 1);
                    --i;
                }
            }
        }, canPerformEventHandlerRequests: function () {
            return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
        }, runDeferredCalls: function () {
            if (!JSEvents.canPerformEventHandlerRequests()) {
                return;
            }
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
                var call = JSEvents.deferredCalls[i];
                JSEvents.deferredCalls.splice(i, 1);
                --i;
                call.targetFunction.apply(null, call.argsList);
            }
        }, eventHandlers: [], removeAllHandlersOnTarget: function (target, eventTypeString) {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                if (JSEvents.eventHandlers[i].target == target &&
                    (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
                    JSEvents._removeHandler(i--);
                }
            }
        }, _removeHandler: function (i) {
            var h = JSEvents.eventHandlers[i];
            h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
            JSEvents.eventHandlers.splice(i, 1);
        }, registerOrRemoveHandler: function (eventHandler) {
            var jsEventHandler = function jsEventHandler(event) {
                // Increment nesting count for the event handler.
                ++JSEvents.inEventHandler;
                JSEvents.currentEventHandler = eventHandler;
                // Process any old deferred calls the user has placed.
                JSEvents.runDeferredCalls();
                // Process the actual event, calls back to user C code handler.
                eventHandler.handlerFunc(event);
                // Process any new deferred calls that were placed right now from this event handler.
                JSEvents.runDeferredCalls();
                // Out of event handler - restore nesting count.
                --JSEvents.inEventHandler;
            };

            if (eventHandler.callbackfunc) {
                eventHandler.eventListenerFunc = jsEventHandler;
                eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
                JSEvents.eventHandlers.push(eventHandler);
                JSEvents.registerRemoveEventListeners();
            } else {
                for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                    if (JSEvents.eventHandlers[i].target == eventHandler.target
                        && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                        JSEvents._removeHandler(i--);
                    }
                }
            }
        }, getNodeNameForTarget: function (target) {
            if (!target) return '';
            if (target == window) return '#window';
            if (target == screen) return '#screen';
            return (target && target.nodeName) ? target.nodeName : '';
        }, fullscreenEnabled: function () {
            return document.fullscreenEnabled
                // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
                // TODO: If Safari at some point ships with unprefixed version, update the version check above.
                || document.webkitFullscreenEnabled
                ;
        }
    };

    var currentFullscreenStrategy = {};

    function maybeCStringToJsString(cString) {
        // "cString > 2" checks if the input is a number, and isn't of the special
        // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
        // In other words, if cString > 2 then it's a pointer to a valid place in
        // memory, and points to a C string.
        return cString > 2 ? UTF8ToString(cString) : cString;
    }

    var specialHTMLTargets = [0, typeof document != 'undefined' ? document : 0, typeof window != 'undefined' ? window : 0];
    function findEventTarget(target) {
        target = maybeCStringToJsString(target);
        var domElement = specialHTMLTargets[target] || (typeof document != 'undefined' ? document.querySelector(target) : undefined);
        return domElement;
    }
    function findCanvasEventTarget(target) { return findEventTarget(target); }
    function _emscripten_get_canvas_element_size(target, width, height) {
        var canvas = findCanvasEventTarget(target);
        if (!canvas) return -4;
        HEAP32[((width) >> 2)] = canvas.width;
        HEAP32[((height) >> 2)] = canvas.height;
    }
    function getCanvasElementSize(target) {
        return withStackSave(function () {
            var w = stackAlloc(8);
            var h = w + 4;

            var targetInt = stackAlloc(target.id.length + 1);
            stringToUTF8(target.id, targetInt, target.id.length + 1);
            var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
            var size = [HEAP32[((w) >> 2)], HEAP32[((h) >> 2)]];
            return size;
        });
    }

    function _emscripten_set_canvas_element_size(target, width, height) {
        var canvas = findCanvasEventTarget(target);
        if (!canvas) return -4;
        canvas.width = width;
        canvas.height = height;
        return 0;
    }
    _emscripten_set_canvas_element_size.sig = 'iiii';
    function setCanvasElementSize(target, width, height) {
        if (!target.controlTransferredOffscreen) {
            target.width = width;
            target.height = height;
        } else {
            // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
            // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
            withStackSave(function () {
                var targetInt = stackAlloc(target.id.length + 1);
                stringToUTF8(target.id, targetInt, target.id.length + 1);
                _emscripten_set_canvas_element_size(targetInt, width, height);
            });
        }
    }
    function registerRestoreOldStyle(canvas) {
        var canvasSize = getCanvasElementSize(canvas);
        var oldWidth = canvasSize[0];
        var oldHeight = canvasSize[1];
        var oldCssWidth = canvas.style.width;
        var oldCssHeight = canvas.style.height;
        var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
        var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
        // Firefox always has black background color.
        var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
        var oldPaddingRight = canvas.style.paddingRight;
        var oldPaddingTop = canvas.style.paddingTop;
        var oldPaddingBottom = canvas.style.paddingBottom;
        var oldMarginLeft = canvas.style.marginLeft; // IE11
        var oldMarginRight = canvas.style.marginRight;
        var oldMarginTop = canvas.style.marginTop;
        var oldMarginBottom = canvas.style.marginBottom;
        var oldDocumentBodyMargin = document.body.style.margin;
        var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
        var oldDocumentScroll = document.body.scroll; // IE
        var oldImageRendering = canvas.style.imageRendering;

        function restoreOldStyle() {
            var fullscreenElement = document.fullscreenElement
                || document.webkitFullscreenElement
                || document.msFullscreenElement
                ;
            if (!fullscreenElement) {
                document.removeEventListener('fullscreenchange', restoreOldStyle);

                // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
                // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
                document.removeEventListener('webkitfullscreenchange', restoreOldStyle);

                setCanvasElementSize(canvas, oldWidth, oldHeight);

                canvas.style.width = oldCssWidth;
                canvas.style.height = oldCssHeight;
                canvas.style.backgroundColor = oldBackgroundColor; // Chrome
                // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
                // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
                // had explicitly set so subsequent fullscreen transitions would not set background color properly.
                if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = 'white';
                document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
                canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
                canvas.style.paddingRight = oldPaddingRight;
                canvas.style.paddingTop = oldPaddingTop;
                canvas.style.paddingBottom = oldPaddingBottom;
                canvas.style.marginLeft = oldMarginLeft; // IE11
                canvas.style.marginRight = oldMarginRight;
                canvas.style.marginTop = oldMarginTop;
                canvas.style.marginBottom = oldMarginBottom;
                document.body.style.margin = oldDocumentBodyMargin;
                document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
                document.body.scroll = oldDocumentScroll; // IE
                canvas.style.imageRendering = oldImageRendering;
                if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);

                if (currentFullscreenStrategy.canvasResizedCallback) {
                    getWasmTableEntry(currentFullscreenStrategy.canvasResizedCallback)(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
                }
            }
        }
        document.addEventListener('fullscreenchange', restoreOldStyle);
        // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
        // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
        document.addEventListener('webkitfullscreenchange', restoreOldStyle);
        return restoreOldStyle;
    }

    function setLetterbox(element, topBottom, leftRight) {
        // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
        element.style.paddingLeft = element.style.paddingRight = leftRight + 'px';
        element.style.paddingTop = element.style.paddingBottom = topBottom + 'px';
    }

    function getBoundingClientRect(e) {
        return specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : { 'left': 0, 'top': 0 };
    }
    function _JSEvents_resizeCanvasForFullscreen(target, strategy) {
        var restoreOldStyle = registerRestoreOldStyle(target);
        var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
        var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
        var rect = getBoundingClientRect(target);
        var windowedCssWidth = rect.width;
        var windowedCssHeight = rect.height;
        var canvasSize = getCanvasElementSize(target);
        var windowedRttWidth = canvasSize[0];
        var windowedRttHeight = canvasSize[1];

        if (strategy.scaleMode == 3) {
            setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
            cssWidth = windowedCssWidth;
            cssHeight = windowedCssHeight;
        } else if (strategy.scaleMode == 2) {
            if (cssWidth * windowedRttHeight < windowedRttWidth * cssHeight) {
                var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
                setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
                cssHeight = desiredCssHeight;
            } else {
                var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
                setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
                cssWidth = desiredCssWidth;
            }
        }

        // If we are adding padding, must choose a background color or otherwise Chrome will give the
        // padding a default white color. Do it only if user has not customized their own background color.
        if (!target.style.backgroundColor) target.style.backgroundColor = 'black';
        // IE11 does the same, but requires the color to be set in the document body.
        if (!document.body.style.backgroundColor) document.body.style.backgroundColor = 'black'; // IE11
        // Firefox always shows black letterboxes independent of style color.

        target.style.width = cssWidth + 'px';
        target.style.height = cssHeight + 'px';

        if (strategy.filteringMode == 1) {
            target.style.imageRendering = 'optimizeSpeed';
            target.style.imageRendering = '-moz-crisp-edges';
            target.style.imageRendering = '-o-crisp-edges';
            target.style.imageRendering = '-webkit-optimize-contrast';
            target.style.imageRendering = 'optimize-contrast';
            target.style.imageRendering = 'crisp-edges';
            target.style.imageRendering = 'pixelated';
        }

        var dpiScale = (strategy.canvasResolutionScaleMode == 2) ? devicePixelRatio : 1;
        if (strategy.canvasResolutionScaleMode != 0) {
            var newWidth = (cssWidth * dpiScale) | 0;
            var newHeight = (cssHeight * dpiScale) | 0;
            setCanvasElementSize(target, newWidth, newHeight);
            if (target.GLctxObject) target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
        }
        return restoreOldStyle;
    }
    function _JSEvents_requestFullscreen(target, strategy) {
        // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
        if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
            _JSEvents_resizeCanvasForFullscreen(target, strategy);
        }

        if (target.requestFullscreen) {
            target.requestFullscreen();
        } else if (target.webkitRequestFullscreen) {
            target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else {
            return JSEvents.fullscreenEnabled() ? -3 : -1;
        }

        currentFullscreenStrategy = strategy;

        if (strategy.canvasResizedCallback) {
            getWasmTableEntry(strategy.canvasResizedCallback)(37, 0, strategy.canvasResizedCallbackUserData);
        }

        return 0;
    }
    function _emscripten_exit_fullscreen() {
        if (!JSEvents.fullscreenEnabled()) return -1;
        // Make sure no queued up calls will fire after this.
        JSEvents.removeDeferredCalls(_JSEvents_requestFullscreen);

        var d = specialHTMLTargets[1];
        if (d.exitFullscreen) {
            d.fullscreenElement && d.exitFullscreen();
        } else if (d.webkitExitFullscreen) {
            d.webkitFullscreenElement && d.webkitExitFullscreen();
        } else {
            return -1;
        }

        return 0;
    }
    _emscripten_exit_fullscreen.sig = 'i';

    function requestPointerLock(target) {
        if (target.requestPointerLock) {
            target.requestPointerLock();
        } else if (target.msRequestPointerLock) {
            target.msRequestPointerLock();
        } else {
            // document.body is known to accept pointer lock, so use that to differentiate if the user passed a bad element,
            // or if the whole browser just doesn't support the feature.
            if (document.body.requestPointerLock
                || document.body.msRequestPointerLock
            ) {
                return -3;
            } else {
                return -1;
            }
        }
        return 0;
    }
    function _emscripten_exit_pointerlock() {
        // Make sure no queued up calls will fire after this.
        JSEvents.removeDeferredCalls(requestPointerLock);

        if (document.exitPointerLock) {
            document.exitPointerLock();
        } else if (document.msExitPointerLock) {
            document.msExitPointerLock();
        } else {
            return -1;
        }
        return 0;
    }
    _emscripten_exit_pointerlock.sig = 'i';

    function _emscripten_get_device_pixel_ratio() {
        return (typeof devicePixelRatio == 'number' && devicePixelRatio) || 1.0;
    }
    _emscripten_get_device_pixel_ratio.sig = 'd';

    function _emscripten_get_element_css_size(target, width, height) {
        target = findEventTarget(target);
        if (!target) return -4;

        var rect = getBoundingClientRect(target);
        HEAPF64[((width) >> 3)] = rect.width;
        HEAPF64[((height) >> 3)] = rect.height;

        return 0;
    }
    _emscripten_get_element_css_size.sig = 'iiii';

    function fillGamepadEventData(eventStruct, e) {
        HEAPF64[((eventStruct) >> 3)] = e.timestamp;
        for (var i = 0; i < e.axes.length; ++i) {
            HEAPF64[(((eventStruct + i * 8) + (16)) >> 3)] = e.axes[i];
        }
        for (var i = 0; i < e.buttons.length; ++i) {
            if (typeof e.buttons[i] == 'object') {
                HEAPF64[(((eventStruct + i * 8) + (528)) >> 3)] = e.buttons[i].value;
            } else {
                HEAPF64[(((eventStruct + i * 8) + (528)) >> 3)] = e.buttons[i];
            }
        }
        for (var i = 0; i < e.buttons.length; ++i) {
            if (typeof e.buttons[i] == 'object') {
                HEAP32[(((eventStruct + i * 4) + (1040)) >> 2)] = e.buttons[i].pressed;
            } else {
                // Assigning a boolean to HEAP32, that's ok, but Closure would like to warn about it:
                /** @suppress {checkTypes} */
                HEAP32[(((eventStruct + i * 4) + (1040)) >> 2)] = e.buttons[i] == 1;
            }
        }
        HEAP32[(((eventStruct) + (1296)) >> 2)] = e.connected;
        HEAP32[(((eventStruct) + (1300)) >> 2)] = e.index;
        HEAP32[(((eventStruct) + (8)) >> 2)] = e.axes.length;
        HEAP32[(((eventStruct) + (12)) >> 2)] = e.buttons.length;
        stringToUTF8(e.id, eventStruct + 1304, 64);
        stringToUTF8(e.mapping, eventStruct + 1368, 64);
    }
    function _emscripten_get_gamepad_status(index, gamepadState) {
        if (!JSEvents.lastGamepadState) throw 'emscripten_get_gamepad_status() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';

        // INVALID_PARAM is returned on a Gamepad index that never was there.
        if (index < 0 || index >= JSEvents.lastGamepadState.length) return -5;

        // NO_DATA is returned on a Gamepad index that was removed.
        // For previously disconnected gamepads there should be an empty slot (null/undefined/false) at the index.
        // This is because gamepads must keep their original position in the array.
        // For example, removing the first of two gamepads produces [null/undefined/false, gamepad].
        if (!JSEvents.lastGamepadState[index]) return -7;

        fillGamepadEventData(gamepadState, JSEvents.lastGamepadState[index]);
        return 0;
    }
    _emscripten_get_gamepad_status.sig = 'iii';

    function _emscripten_get_heap_max() {
        return HEAPU8.length;
    }


    function _emscripten_get_num_gamepads() {
        if (!JSEvents.lastGamepadState) throw 'emscripten_get_num_gamepads() can only be called after having first called emscripten_sample_gamepad_data() and that function has returned EMSCRIPTEN_RESULT_SUCCESS!';
        // N.B. Do not call emscripten_get_num_gamepads() unless having first called emscripten_sample_gamepad_data(), and that has returned EMSCRIPTEN_RESULT_SUCCESS.
        // Otherwise the following line will throw an exception.
        return JSEvents.lastGamepadState.length;
    }
    _emscripten_get_num_gamepads.sig = 'i';

    function _emscripten_get_screen_size(width, height) {
        HEAP32[((width) >> 2)] = screen.width;
        HEAP32[((height) >> 2)] = screen.height;
    }
    _emscripten_get_screen_size.sig = 'vii';

    function _emscripten_glActiveTexture(x0) { GLctx['activeTexture'](x0) }
    _emscripten_glActiveTexture.sig = 'vi';

    function _emscripten_glAttachShader(program, shader) {
        GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
    }
    _emscripten_glAttachShader.sig = 'vii';

    function _emscripten_glBeginQueryEXT(target, id) {
        GLctx.disjointTimerQueryExt['beginQueryEXT'](target, GL.queries[id]);
    }
    _emscripten_glBeginQueryEXT.sig = 'vii';

    function _emscripten_glBindAttribLocation(program, index, name) {
        GLctx.bindAttribLocation(GL.programs[program], index, UTF8ToString(name));
    }
    _emscripten_glBindAttribLocation.sig = 'viii';

    function _emscripten_glBindBuffer(target, buffer) {

        GLctx.bindBuffer(target, GL.buffers[buffer]);
    }
    _emscripten_glBindBuffer.sig = 'vii';

    function _emscripten_glBindFramebuffer(target, framebuffer) {

        GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);

    }
    _emscripten_glBindFramebuffer.sig = 'vii';

    function _emscripten_glBindRenderbuffer(target, renderbuffer) {
        GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    }
    _emscripten_glBindRenderbuffer.sig = 'vii';

    function _emscripten_glBindTexture(target, texture) {
        GLctx.bindTexture(target, GL.textures[texture]);
    }
    _emscripten_glBindTexture.sig = 'vii';

    function _emscripten_glBindVertexArrayOES(vao) {
        GLctx['bindVertexArray'](GL.vaos[vao]);
    }
    _emscripten_glBindVertexArrayOES.sig = 'vi';

    function _emscripten_glBlendColor(x0, x1, x2, x3) { GLctx['blendColor'](x0, x1, x2, x3) }
    _emscripten_glBlendColor.sig = 'vffff';

    function _emscripten_glBlendEquation(x0) { GLctx['blendEquation'](x0) }
    _emscripten_glBlendEquation.sig = 'vi';

    function _emscripten_glBlendEquationSeparate(x0, x1) { GLctx['blendEquationSeparate'](x0, x1) }
    _emscripten_glBlendEquationSeparate.sig = 'vii';

    function _emscripten_glBlendFunc(x0, x1) { GLctx['blendFunc'](x0, x1) }
    _emscripten_glBlendFunc.sig = 'vii';

    function _emscripten_glBlendFuncSeparate(x0, x1, x2, x3) { GLctx['blendFuncSeparate'](x0, x1, x2, x3) }
    _emscripten_glBlendFuncSeparate.sig = 'viiii';

    function _emscripten_glBufferData(target, size, data, usage) {

        // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
        // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
        GLctx.bufferData(target, data ? HEAPU8.subarray(data, data + size) : size, usage);
    }
    _emscripten_glBufferData.sig = 'viiii';

    function _emscripten_glBufferSubData(target, offset, size, data) {
        GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data + size));
    }
    _emscripten_glBufferSubData.sig = 'viiii';

    function _emscripten_glCheckFramebufferStatus(x0) { return GLctx['checkFramebufferStatus'](x0) }
    _emscripten_glCheckFramebufferStatus.sig = 'ii';

    function _emscripten_glClear(x0) { GLctx['clear'](x0) }
    _emscripten_glClear.sig = 'vi';

    function _emscripten_glClearColor(x0, x1, x2, x3) { GLctx['clearColor'](x0, x1, x2, x3) }
    _emscripten_glClearColor.sig = 'vffff';

    function _emscripten_glClearDepthf(x0) { GLctx['clearDepth'](x0) }
    _emscripten_glClearDepthf.sig = 'vf';

    function _emscripten_glClearStencil(x0) { GLctx['clearStencil'](x0) }
    _emscripten_glClearStencil.sig = 'vi';

    function _emscripten_glColorMask(red, green, blue, alpha) {
        GLctx.colorMask(!!red, !!green, !!blue, !!alpha);
    }
    _emscripten_glColorMask.sig = 'viiii';

    function _emscripten_glCompileShader(shader) {
        GLctx.compileShader(GL.shaders[shader]);
    }
    _emscripten_glCompileShader.sig = 'vi';

    function _emscripten_glCompressedTexImage2D(target, level, internalFormat, width, height, border, imageSize, data) {
        GLctx['compressedTexImage2D'](target, level, internalFormat, width, height, border, data ? HEAPU8.subarray((data), (data + imageSize)) : null);
    }
    _emscripten_glCompressedTexImage2D.sig = 'viiiiiiii';

    function _emscripten_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) {
        GLctx['compressedTexSubImage2D'](target, level, xoffset, yoffset, width, height, format, data ? HEAPU8.subarray((data), (data + imageSize)) : null);
    }
    _emscripten_glCompressedTexSubImage2D.sig = 'viiiiiiiii';

    function _emscripten_glCopyTexImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
    _emscripten_glCopyTexImage2D.sig = 'viiiiiiii';

    function _emscripten_glCopyTexSubImage2D(x0, x1, x2, x3, x4, x5, x6, x7) { GLctx['copyTexSubImage2D'](x0, x1, x2, x3, x4, x5, x6, x7) }
    _emscripten_glCopyTexSubImage2D.sig = 'viiiiiiii';

    function _emscripten_glCreateProgram() {
        var id = GL.getNewId(GL.programs);
        var program = GLctx.createProgram();
        // Store additional information needed for each shader program:
        program.name = id;
        // Lazy cache results of glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
        program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
        program.uniformIdCounter = 1;
        GL.programs[id] = program;
        return id;
    }
    _emscripten_glCreateProgram.sig = 'i';

    function _emscripten_glCreateShader(shaderType) {
        var id = GL.getNewId(GL.shaders);
        GL.shaders[id] = GLctx.createShader(shaderType);

        return id;
    }
    _emscripten_glCreateShader.sig = 'ii';

    function _emscripten_glCullFace(x0) { GLctx['cullFace'](x0) }
    _emscripten_glCullFace.sig = 'vi';

    function _emscripten_glDeleteBuffers(n, buffers) {
        for (var i = 0; i < n; i++) {
            var id = HEAP32[(((buffers) + (i * 4)) >> 2)];
            var buffer = GL.buffers[id];

            // From spec: "glDeleteBuffers silently ignores 0's and names that do not
            // correspond to existing buffer objects."
            if (!buffer) continue;

            GLctx.deleteBuffer(buffer);
            buffer.name = 0;
            GL.buffers[id] = null;

        }
    }
    _emscripten_glDeleteBuffers.sig = 'vii';

    function _emscripten_glDeleteFramebuffers(n, framebuffers) {
        for (var i = 0; i < n; ++i) {
            var id = HEAP32[(((framebuffers) + (i * 4)) >> 2)];
            var framebuffer = GL.framebuffers[id];
            if (!framebuffer) continue; // GL spec: "glDeleteFramebuffers silently ignores 0s and names that do not correspond to existing framebuffer objects".
            GLctx.deleteFramebuffer(framebuffer);
            framebuffer.name = 0;
            GL.framebuffers[id] = null;
        }
    }
    _emscripten_glDeleteFramebuffers.sig = 'vii';

    function _emscripten_glDeleteProgram(id) {
        if (!id) return;
        var program = GL.programs[id];
        if (!program) { // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        GLctx.deleteProgram(program);
        program.name = 0;
        GL.programs[id] = null;
    }
    _emscripten_glDeleteProgram.sig = 'vi';

    function _emscripten_glDeleteQueriesEXT(n, ids) {
        for (var i = 0; i < n; i++) {
            var id = HEAP32[(((ids) + (i * 4)) >> 2)];
            var query = GL.queries[id];
            if (!query) continue; // GL spec: "unused names in ids are ignored, as is the name zero."
            GLctx.disjointTimerQueryExt['deleteQueryEXT'](query);
            GL.queries[id] = null;
        }
    }
    _emscripten_glDeleteQueriesEXT.sig = 'vii';

    function _emscripten_glDeleteRenderbuffers(n, renderbuffers) {
        for (var i = 0; i < n; i++) {
            var id = HEAP32[(((renderbuffers) + (i * 4)) >> 2)];
            var renderbuffer = GL.renderbuffers[id];
            if (!renderbuffer) continue; // GL spec: "glDeleteRenderbuffers silently ignores 0s and names that do not correspond to existing renderbuffer objects".
            GLctx.deleteRenderbuffer(renderbuffer);
            renderbuffer.name = 0;
            GL.renderbuffers[id] = null;
        }
    }
    _emscripten_glDeleteRenderbuffers.sig = 'vii';

    function _emscripten_glDeleteShader(id) {
        if (!id) return;
        var shader = GL.shaders[id];
        if (!shader) { // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        GLctx.deleteShader(shader);
        GL.shaders[id] = null;
    }
    _emscripten_glDeleteShader.sig = 'vi';

    function _emscripten_glDeleteTextures(n, textures) {
        for (var i = 0; i < n; i++) {
            var id = HEAP32[(((textures) + (i * 4)) >> 2)];
            var texture = GL.textures[id];
            if (!texture) continue; // GL spec: "glDeleteTextures silently ignores 0s and names that do not correspond to existing textures".
            GLctx.deleteTexture(texture);
            texture.name = 0;
            GL.textures[id] = null;
        }
    }
    _emscripten_glDeleteTextures.sig = 'vii';

    function _emscripten_glDeleteVertexArraysOES(n, vaos) {
        for (var i = 0; i < n; i++) {
            var id = HEAP32[(((vaos) + (i * 4)) >> 2)];
            GLctx['deleteVertexArray'](GL.vaos[id]);
            GL.vaos[id] = null;
        }
    }
    _emscripten_glDeleteVertexArraysOES.sig = 'vii';

    function _emscripten_glDepthFunc(x0) { GLctx['depthFunc'](x0) }
    _emscripten_glDepthFunc.sig = 'vi';

    function _emscripten_glDepthMask(flag) {
        GLctx.depthMask(!!flag);
    }
    _emscripten_glDepthMask.sig = 'vi';

    function _emscripten_glDepthRangef(x0, x1) { GLctx['depthRange'](x0, x1) }
    _emscripten_glDepthRangef.sig = 'vii';

    function _emscripten_glDetachShader(program, shader) {
        GLctx.detachShader(GL.programs[program], GL.shaders[shader]);
    }
    _emscripten_glDetachShader.sig = 'vii';

    function _emscripten_glDisable(x0) { GLctx['disable'](x0) }
    _emscripten_glDisable.sig = 'vi';

    function _emscripten_glDisableVertexAttribArray(index) {
        GLctx.disableVertexAttribArray(index);
    }
    _emscripten_glDisableVertexAttribArray.sig = 'vi';

    function _emscripten_glDrawArrays(mode, first, count) {

        GLctx.drawArrays(mode, first, count);

    }
    _emscripten_glDrawArrays.sig = 'viii';

    function _emscripten_glDrawArraysInstancedANGLE(mode, first, count, primcount) {
        GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }
    _emscripten_glDrawArraysInstancedANGLE.sig = 'viiii';

    var tempFixedLengthArray = [];
    function _emscripten_glDrawBuffersWEBGL(n, bufs) {

        var bufArray = tempFixedLengthArray[n];
        for (var i = 0; i < n; i++) {
            bufArray[i] = HEAP32[(((bufs) + (i * 4)) >> 2)];
        }

        GLctx['drawBuffers'](bufArray);
    }
    _emscripten_glDrawBuffersWEBGL.sig = 'vii';

    function _emscripten_glDrawElements(mode, count, type, indices) {

        GLctx.drawElements(mode, count, type, indices);

    }
    _emscripten_glDrawElements.sig = 'viiii';

    function _emscripten_glDrawElementsInstancedANGLE(mode, count, type, indices, primcount) {
        GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }
    _emscripten_glDrawElementsInstancedANGLE.sig = 'viiiii';

    function _emscripten_glEnable(x0) { GLctx['enable'](x0) }
    _emscripten_glEnable.sig = 'vi';

    function _emscripten_glEnableVertexAttribArray(index) {
        GLctx.enableVertexAttribArray(index);
    }
    _emscripten_glEnableVertexAttribArray.sig = 'vi';

    function _emscripten_glEndQueryEXT(target) {
        GLctx.disjointTimerQueryExt['endQueryEXT'](target);
    }
    _emscripten_glEndQueryEXT.sig = 'vi';

    function _emscripten_glFinish() { GLctx['finish']() }
    _emscripten_glFinish.sig = 'v';

    function _emscripten_glFlush() { GLctx['flush']() }
    _emscripten_glFlush.sig = 'v';

    function _emscripten_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) {
        GLctx.framebufferRenderbuffer(target, attachment, renderbuffertarget,
            GL.renderbuffers[renderbuffer]);
    }
    _emscripten_glFramebufferRenderbuffer.sig = 'viiii';

    function _emscripten_glFramebufferTexture2D(target, attachment, textarget, texture, level) {
        GLctx.framebufferTexture2D(target, attachment, textarget,
            GL.textures[texture], level);
    }
    _emscripten_glFramebufferTexture2D.sig = 'viiiii';

    function _emscripten_glFrontFace(x0) { GLctx['frontFace'](x0) }
    _emscripten_glFrontFace.sig = 'vi';

    function __glGenObject(n, buffers, createFunction, objectTable
    ) {
        for (var i = 0; i < n; i++) {
            var buffer = GLctx[createFunction]();
            var id = buffer && GL.getNewId(objectTable);
            if (buffer) {
                buffer.name = id;
                objectTable[id] = buffer;
            } else {
                GL.recordError(0x502 /* GL_INVALID_OPERATION */);
            }
            HEAP32[(((buffers) + (i * 4)) >> 2)] = id;
        }
    }
    __glGenObject.sig = 'vii';
    function _emscripten_glGenBuffers(n, buffers) {
        __glGenObject(n, buffers, 'createBuffer', GL.buffers
        );
    }
    _emscripten_glGenBuffers.sig = 'vii';

    function _emscripten_glGenFramebuffers(n, ids) {
        __glGenObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    }
    _emscripten_glGenFramebuffers.sig = 'vii';

    function _emscripten_glGenQueriesEXT(n, ids) {
        for (var i = 0; i < n; i++) {
            var query = GLctx.disjointTimerQueryExt['createQueryEXT']();
            if (!query) {
                GL.recordError(0x502 /* GL_INVALID_OPERATION */);
                while (i < n) HEAP32[(((ids) + (i++ * 4)) >> 2)] = 0;
                return;
            }
            var id = GL.getNewId(GL.queries);
            query.name = id;
            GL.queries[id] = query;
            HEAP32[(((ids) + (i * 4)) >> 2)] = id;
        }
    }
    _emscripten_glGenQueriesEXT.sig = 'vii';

    function _emscripten_glGenRenderbuffers(n, renderbuffers) {
        __glGenObject(n, renderbuffers, 'createRenderbuffer', GL.renderbuffers
        );
    }
    _emscripten_glGenRenderbuffers.sig = 'vii';

    function _emscripten_glGenTextures(n, textures) {
        __glGenObject(n, textures, 'createTexture', GL.textures
        );
    }
    _emscripten_glGenTextures.sig = 'vii';

    function _emscripten_glGenVertexArraysOES(n, arrays) {
        __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }
    _emscripten_glGenVertexArraysOES.sig = 'vii';

    function _emscripten_glGenerateMipmap(x0) { GLctx['generateMipmap'](x0) }
    _emscripten_glGenerateMipmap.sig = 'vi';

    function __glGetActiveAttribOrUniform(funcName, program, index, bufSize, length, size, type, name) {
        program = GL.programs[program];
        var info = GLctx[funcName](program, index);
        if (info) { // If an error occurs, nothing will be written to length, size and type and name.
            var numBytesWrittenExclNull = name && stringToUTF8(info.name, name, bufSize);
            if (length) HEAP32[((length) >> 2)] = numBytesWrittenExclNull;
            if (size) HEAP32[((size) >> 2)] = info.size;
            if (type) HEAP32[((type) >> 2)] = info.type;
        }
    }
    function _emscripten_glGetActiveAttrib(program, index, bufSize, length, size, type, name) {
        __glGetActiveAttribOrUniform('getActiveAttrib', program, index, bufSize, length, size, type, name);
    }
    _emscripten_glGetActiveAttrib.sig = 'viiiiiii';

    function _emscripten_glGetActiveUniform(program, index, bufSize, length, size, type, name) {
        __glGetActiveAttribOrUniform('getActiveUniform', program, index, bufSize, length, size, type, name);
    }
    _emscripten_glGetActiveUniform.sig = 'viiiiiii';

    function _emscripten_glGetAttachedShaders(program, maxCount, count, shaders) {
        var result = GLctx.getAttachedShaders(GL.programs[program]);
        var len = result.length;
        if (len > maxCount) {
            len = maxCount;
        }
        HEAP32[((count) >> 2)] = len;
        for (var i = 0; i < len; ++i) {
            var id = GL.shaders.indexOf(result[i]);
            HEAP32[(((shaders) + (i * 4)) >> 2)] = id;
        }
    }
    _emscripten_glGetAttachedShaders.sig = 'viiii';

    function _emscripten_glGetAttribLocation(program, name) {
        return GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));
    }
    _emscripten_glGetAttribLocation.sig = 'iii';

    function readI53FromI64(ptr) {
        return HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
    }

    function readI53FromU64(ptr) {
        return HEAPU32[ptr >> 2] + HEAPU32[ptr + 4 >> 2] * 4294967296;
    }
    function writeI53ToI64(ptr, num) {
        HEAPU32[ptr >> 2] = num;
        HEAPU32[ptr + 4 >> 2] = (num - HEAPU32[ptr >> 2]) / 4294967296;
        var deserialized = (num >= 0) ? readI53FromU64(ptr) : readI53FromI64(ptr);
        if (deserialized != num) warnOnce('writeI53ToI64() out of range: serialized JS Number ' + num + ' to Wasm heap as bytes lo=0x' + HEAPU32[ptr >> 2].toString(16) + ', hi=0x' + HEAPU32[ptr + 4 >> 2].toString(16) + ', which deserializes back to ' + deserialized + ' instead!');
    }
    function emscriptenWebGLGet(name_, p, type) {
        // Guard against user passing a null pointer.
        // Note that GLES2 spec does not say anything about how passing a null pointer should be treated.
        // Testing on desktop core GL 3, the application crashes on glGetIntegerv to a null pointer, but
        // better to report an error instead of doing anything random.
        if (!p) {
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var ret = undefined;
        switch (name_) { // Handle a few trivial GLES values
            case 0x8DFA: // GL_SHADER_COMPILER
                ret = 1;
                break;
            case 0x8DF8: // GL_SHADER_BINARY_FORMATS
                if (type != 0 && type != 1) {
                    GL.recordError(0x500); // GL_INVALID_ENUM
                }
                return; // Do not write anything to the out pointer, since no binary formats are supported.
            case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
                ret = 0;
                break;
            case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
                // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be queried for length),
                // so implement it ourselves to allow C++ GLES2 code get the length.
                var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
                ret = formats ? formats.length : 0;
                break;

        }

        if (ret === undefined) {
            var result = GLctx.getParameter(name_);
            switch (typeof result) {
                case "number":
                    ret = result;
                    break;
                case "boolean":
                    ret = result ? 1 : 0;
                    break;
                case "string":
                    GL.recordError(0x500); // GL_INVALID_ENUM
                    return;
                case "object":
                    if (result === null) {
                        // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
                        // can mean an invalid name_, which we need to report as an error
                        switch (name_) {
                            case 0x8894: // ARRAY_BUFFER_BINDING
                            case 0x8B8D: // CURRENT_PROGRAM
                            case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                            case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                            case 0x8CA7: // RENDERBUFFER_BINDING
                            case 0x8069: // TEXTURE_BINDING_2D
                            case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                            case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                                ret = 0;
                                break;
                            }
                            default: {
                                GL.recordError(0x500); // GL_INVALID_ENUM
                                return;
                            }
                        }
                    } else if (result instanceof Float32Array ||
                        result instanceof Uint32Array ||
                        result instanceof Int32Array ||
                        result instanceof Array) {
                        for (var i = 0; i < result.length; ++i) {
                            switch (type) {
                                case 0: HEAP32[(((p) + (i * 4)) >> 2)] = result[i]; break;
                                case 2: HEAPF32[(((p) + (i * 4)) >> 2)] = result[i]; break;
                                case 4: HEAP8[(((p) + (i)) >> 0)] = result[i] ? 1 : 0; break;
                            }
                        }
                        return;
                    } else {
                        try {
                            ret = result.name | 0;
                        } catch (e) {
                            GL.recordError(0x500); // GL_INVALID_ENUM
                            err('GL_INVALID_ENUM in glGet' + type + 'v: Unknown object returned from WebGL getParameter(' + name_ + ')! (error: ' + e + ')');
                            return;
                        }
                    }
                    break;
                default:
                    GL.recordError(0x500); // GL_INVALID_ENUM
                    err('GL_INVALID_ENUM in glGet' + type + 'v: Native code calling glGet' + type + 'v(' + name_ + ') and it returns ' + result + ' of type ' + typeof (result) + '!');
                    return;
            }
        }

        switch (type) {
            case 1: writeI53ToI64(p, ret); break;
            case 0: HEAP32[((p) >> 2)] = ret; break;
            case 2: HEAPF32[((p) >> 2)] = ret; break;
            case 4: HEAP8[((p) >> 0)] = ret ? 1 : 0; break;
        }
    }
    function _emscripten_glGetBooleanv(name_, p) {
        emscriptenWebGLGet(name_, p, 4);
    }
    _emscripten_glGetBooleanv.sig = 'vii';

    function _emscripten_glGetBufferParameteriv(target, value, data) {
        if (!data) {
            // GLES2 specification does not specify how to behave if data is a null pointer. Since calling this function does not make sense
            // if data == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAP32[((data) >> 2)] = GLctx.getBufferParameter(target, value);
    }
    _emscripten_glGetBufferParameteriv.sig = 'viii';

    function _emscripten_glGetError() {
        var error = GLctx.getError() || GL.lastError;
        GL.lastError = 0/*GL_NO_ERROR*/;
        return error;
    }
    _emscripten_glGetError.sig = 'i';

    function _emscripten_glGetFloatv(name_, p) {
        emscriptenWebGLGet(name_, p, 2);
    }
    _emscripten_glGetFloatv.sig = 'vii';

    function _emscripten_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) {
        var result = GLctx.getFramebufferAttachmentParameter(target, attachment, pname);
        if (result instanceof WebGLRenderbuffer ||
            result instanceof WebGLTexture) {
            result = result.name | 0;
        }
        HEAP32[((params) >> 2)] = result;
    }
    _emscripten_glGetFramebufferAttachmentParameteriv.sig = 'viiii';

    function _emscripten_glGetIntegerv(name_, p) {
        emscriptenWebGLGet(name_, p, 0);
    }
    _emscripten_glGetIntegerv.sig = 'vii';

    function _emscripten_glGetProgramInfoLog(program, maxLength, length, infoLog) {
        var log = GLctx.getProgramInfoLog(GL.programs[program]);
        if (log === null) log = '(unknown error)';
        var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
        if (length) HEAP32[((length) >> 2)] = numBytesWrittenExclNull;
    }
    _emscripten_glGetProgramInfoLog.sig = 'viiii';

    function _emscripten_glGetProgramiv(program, pname, p) {
        if (!p) {
            // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }

        if (program >= GL.counter) {
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }

        program = GL.programs[program];

        if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
            var log = GLctx.getProgramInfoLog(program);
            if (log === null) log = '(unknown error)';
            HEAP32[((p) >> 2)] = log.length + 1;
        } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
            if (!program.maxUniformLength) {
                for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
                    program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length + 1);
                }
            }
            HEAP32[((p) >> 2)] = program.maxUniformLength;
        } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
            if (!program.maxAttributeLength) {
                for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/); ++i) {
                    program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length + 1);
                }
            }
            HEAP32[((p) >> 2)] = program.maxAttributeLength;
        } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
            if (!program.maxUniformBlockNameLength) {
                for (var i = 0; i < GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/); ++i) {
                    program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length + 1);
                }
            }
            HEAP32[((p) >> 2)] = program.maxUniformBlockNameLength;
        } else {
            HEAP32[((p) >> 2)] = GLctx.getProgramParameter(program, pname);
        }
    }
    _emscripten_glGetProgramiv.sig = 'viii';

    function _emscripten_glGetQueryObjecti64vEXT(id, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var query = GL.queries[id];
        var param;
        {
            param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
        }
        var ret;
        if (typeof param == 'boolean') {
            ret = param ? 1 : 0;
        } else {
            ret = param;
        }
        writeI53ToI64(params, ret);
    }
    _emscripten_glGetQueryObjecti64vEXT.sig = 'viii';

    function _emscripten_glGetQueryObjectivEXT(id, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var query = GL.queries[id];
        var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
        var ret;
        if (typeof param == 'boolean') {
            ret = param ? 1 : 0;
        } else {
            ret = param;
        }
        HEAP32[((params) >> 2)] = ret;
    }
    _emscripten_glGetQueryObjectivEXT.sig = 'viii';

    function _emscripten_glGetQueryObjectui64vEXT(id, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var query = GL.queries[id];
        var param;
        {
            param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
        }
        var ret;
        if (typeof param == 'boolean') {
            ret = param ? 1 : 0;
        } else {
            ret = param;
        }
        writeI53ToI64(params, ret);
    }
    _emscripten_glGetQueryObjectui64vEXT.sig = 'viii';

    function _emscripten_glGetQueryObjectuivEXT(id, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var query = GL.queries[id];
        var param = GLctx.disjointTimerQueryExt['getQueryObjectEXT'](query, pname);
        var ret;
        if (typeof param == 'boolean') {
            ret = param ? 1 : 0;
        } else {
            ret = param;
        }
        HEAP32[((params) >> 2)] = ret;
    }
    _emscripten_glGetQueryObjectuivEXT.sig = 'viii';

    function _emscripten_glGetQueryivEXT(target, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAP32[((params) >> 2)] = GLctx.disjointTimerQueryExt['getQueryEXT'](target, pname);
    }
    _emscripten_glGetQueryivEXT.sig = 'viii';

    function _emscripten_glGetRenderbufferParameteriv(target, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if params == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAP32[((params) >> 2)] = GLctx.getRenderbufferParameter(target, pname);
    }
    _emscripten_glGetRenderbufferParameteriv.sig = 'viii';

    function _emscripten_glGetShaderInfoLog(shader, maxLength, length, infoLog) {
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
        if (length) HEAP32[((length) >> 2)] = numBytesWrittenExclNull;
    }
    _emscripten_glGetShaderInfoLog.sig = 'viiii';

    function _emscripten_glGetShaderPrecisionFormat(shaderType, precisionType, range, precision) {
        var result = GLctx.getShaderPrecisionFormat(shaderType, precisionType);
        HEAP32[((range) >> 2)] = result.rangeMin;
        HEAP32[(((range) + (4)) >> 2)] = result.rangeMax;
        HEAP32[((precision) >> 2)] = result.precision;
    }
    _emscripten_glGetShaderPrecisionFormat.sig = 'viiii';

    function _emscripten_glGetShaderSource(shader, bufSize, length, source) {
        var result = GLctx.getShaderSource(GL.shaders[shader]);
        if (!result) return; // If an error occurs, nothing will be written to length or source.
        var numBytesWrittenExclNull = (bufSize > 0 && source) ? stringToUTF8(result, source, bufSize) : 0;
        if (length) HEAP32[((length) >> 2)] = numBytesWrittenExclNull;
    }
    _emscripten_glGetShaderSource.sig = 'viiii';

    function _emscripten_glGetShaderiv(shader, pname, p) {
        if (!p) {
            // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
            var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
            if (log === null) log = '(unknown error)';
            // The GLES2 specification says that if the shader has an empty info log,
            // a value of 0 is returned. Otherwise the log has a null char appended.
            // (An empty string is falsey, so we can just check that instead of
            // looking at log.length.)
            var logLength = log ? log.length + 1 : 0;
            HEAP32[((p) >> 2)] = logLength;
        } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
            var source = GLctx.getShaderSource(GL.shaders[shader]);
            // source may be a null, or the empty string, both of which are falsey
            // values that we report a 0 length for.
            var sourceLength = source ? source.length + 1 : 0;
            HEAP32[((p) >> 2)] = sourceLength;
        } else {
            HEAP32[((p) >> 2)] = GLctx.getShaderParameter(GL.shaders[shader], pname);
        }
    }
    _emscripten_glGetShaderiv.sig = 'viii';

    function stringToNewUTF8(jsString) {
        var length = lengthBytesUTF8(jsString) + 1;
        var cString = _malloc(length);
        stringToUTF8(jsString, cString, length);
        return cString;
    }
    function _emscripten_glGetString(name_) {
        var ret = GL.stringCache[name_];
        if (!ret) {
            switch (name_) {
                case 0x1F03 /* GL_EXTENSIONS */:
                    var exts = GLctx.getSupportedExtensions() || []; // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
                    exts = exts.concat(exts.map(function (e) { return "GL_" + e; }));
                    ret = stringToNewUTF8(exts.join(' '));
                    break;
                case 0x1F00 /* GL_VENDOR */:
                case 0x1F01 /* GL_RENDERER */:
                case 0x9245 /* UNMASKED_VENDOR_WEBGL */:
                case 0x9246 /* UNMASKED_RENDERER_WEBGL */:
                    var s = GLctx.getParameter(name_);
                    if (!s) {
                        GL.recordError(0x500/*GL_INVALID_ENUM*/);
                    }
                    ret = s && stringToNewUTF8(s);
                    break;

                case 0x1F02 /* GL_VERSION */:
                    var glVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);
                    // return GLES version string corresponding to the version of the WebGL context
                    {
                        glVersion = 'OpenGL ES 2.0 (' + glVersion + ')';
                    }
                    ret = stringToNewUTF8(glVersion);
                    break;
                case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:
                    var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);
                    // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'
                    var ver_re = /^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;
                    var ver_num = glslVersion.match(ver_re);
                    if (ver_num !== null) {
                        if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits
                        glslVersion = 'OpenGL ES GLSL ES ' + ver_num[1] + ' (' + glslVersion + ')';
                    }
                    ret = stringToNewUTF8(glslVersion);
                    break;
                default:
                    GL.recordError(0x500/*GL_INVALID_ENUM*/);
                // fall through
            }
            GL.stringCache[name_] = ret;
        }
        return ret;
    }
    _emscripten_glGetString.sig = 'ii';

    function _emscripten_glGetTexParameterfv(target, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAPF32[((params) >> 2)] = GLctx.getTexParameter(target, pname);
    }
    _emscripten_glGetTexParameterfv.sig = 'viii';

    function _emscripten_glGetTexParameteriv(target, pname, params) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if p == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAP32[((params) >> 2)] = GLctx.getTexParameter(target, pname);
    }
    _emscripten_glGetTexParameteriv.sig = 'viii';

    /** @suppress {checkTypes} */
    function jstoi_q(str) {
        return parseInt(str);
    }

    /** @noinline */
    function webglGetLeftBracePos(name) {
        return name.slice(-1) == ']' && name.lastIndexOf('[');
    }
    function webglPrepareUniformLocationsBeforeFirstUse(program) {
        var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation
            uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]
            i, j;

        // On the first time invocation of glGetUniformLocation on this shader program:
        // initialize cache data structures and discover which uniforms are arrays.
        if (!uniformLocsById) {
            // maps GLint integer locations to WebGLUniformLocations
            program.uniformLocsById = uniformLocsById = {};
            // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
            program.uniformArrayNamesById = {};

            for (i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
                var u = GLctx.getActiveUniform(program, i);
                var nm = u.name;
                var sz = u.size;
                var lb = webglGetLeftBracePos(nm);
                var arrayName = lb > 0 ? nm.slice(0, lb) : nm;

                // Assign a new location.
                var id = program.uniformIdCounter;
                program.uniformIdCounter += sz;
                // Eagerly get the location of the uniformArray[0] base element.
                // The remaining indices >0 will be left for lazy evaluation to
                // improve performance. Those may never be needed to fetch, if the
                // application fills arrays always in full starting from the first
                // element of the array.
                uniformSizeAndIdsByName[arrayName] = [sz, id];

                // Store placeholder integers in place that highlight that these
                // >0 index locations are array indices pending population.
                for (j = 0; j < sz; ++j) {
                    uniformLocsById[id] = j;
                    program.uniformArrayNamesById[id++] = arrayName;
                }
            }
        }
    }
    function _emscripten_glGetUniformLocation(program, name) {

        name = UTF8ToString(name);

        if (program = GL.programs[program]) {
            webglPrepareUniformLocationsBeforeFirstUse(program);
            var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
            var arrayIndex = 0;
            var uniformBaseName = name;

            // Invariant: when populating integer IDs for uniform locations, we must maintain the precondition that
            // arrays reside in contiguous addresses, i.e. for a 'vec4 colors[10];', colors[4] must be at location colors[0]+4.
            // However, user might call glGetUniformLocation(program, "colors") for an array, so we cannot discover based on the user
            // input arguments whether the uniform we are dealing with is an array. The only way to discover which uniforms are arrays
            // is to enumerate over all the active uniforms in the program.
            var leftBrace = webglGetLeftBracePos(name);

            // If user passed an array accessor "[index]", parse the array index off the accessor.
            if (leftBrace > 0) {
                arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
                uniformBaseName = name.slice(0, leftBrace);
            }

            // Have we cached the location of this uniform before?
            var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; // A pair [array length, GLint of the uniform location]

            // If an uniform with this name exists, and if its index is within the array limits (if it's even an array),
            // query the WebGLlocation, or return an existing cached location.
            if (sizeAndId && arrayIndex < sizeAndId[0]) {
                arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
                if ((uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))) {
                    return arrayIndex;
                }
            }
        }
        else {
            // N.b. we are currently unable to distinguish between GL program IDs that never existed vs GL program IDs that have been deleted,
            // so report GL_INVALID_VALUE in both cases.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
        }
        return -1;
    }
    _emscripten_glGetUniformLocation.sig = 'iii';

    function webglGetUniformLocation(location) {
        var p = GLctx.currentProgram;

        if (p) {
            var webglLoc = p.uniformLocsById[location];
            // p.uniformLocsById[location] stores either an integer, or a WebGLUniformLocation.

            // If an integer, we have not yet bound the location, so do it now. The integer value specifies the array index
            // we should bind to.
            if (typeof webglLoc == 'number') {
                p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? '[' + webglLoc + ']' : ''));
            }
            // Else an already cached WebGLUniformLocation, return it.
            return webglLoc;
        } else {
            GL.recordError(0x502/*GL_INVALID_OPERATION*/);
        }
    }
    /** @suppress{checkTypes} */
    function emscriptenWebGLGetUniform(program, location, params, type) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if params == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        program = GL.programs[program];
        webglPrepareUniformLocationsBeforeFirstUse(program);
        var data = GLctx.getUniform(program, webglGetUniformLocation(location));
        if (typeof data == 'number' || typeof data == 'boolean') {
            switch (type) {
                case 0: HEAP32[((params) >> 2)] = data; break;
                case 2: HEAPF32[((params) >> 2)] = data; break;
            }
        } else {
            for (var i = 0; i < data.length; i++) {
                switch (type) {
                    case 0: HEAP32[(((params) + (i * 4)) >> 2)] = data[i]; break;
                    case 2: HEAPF32[(((params) + (i * 4)) >> 2)] = data[i]; break;
                }
            }
        }
    }
    function _emscripten_glGetUniformfv(program, location, params) {
        emscriptenWebGLGetUniform(program, location, params, 2);
    }
    _emscripten_glGetUniformfv.sig = 'viii';

    function _emscripten_glGetUniformiv(program, location, params) {
        emscriptenWebGLGetUniform(program, location, params, 0);
    }
    _emscripten_glGetUniformiv.sig = 'viii';

    function _emscripten_glGetVertexAttribPointerv(index, pname, pointer) {
        if (!pointer) {
            // GLES2 specification does not specify how to behave if pointer is a null pointer. Since calling this function does not make sense
            // if pointer == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        HEAP32[((pointer) >> 2)] = GLctx.getVertexAttribOffset(index, pname);
    }
    _emscripten_glGetVertexAttribPointerv.sig = 'viii';

    /** @suppress{checkTypes} */
    function emscriptenWebGLGetVertexAttrib(index, pname, params, type) {
        if (!params) {
            // GLES2 specification does not specify how to behave if params is a null pointer. Since calling this function does not make sense
            // if params == null, issue a GL error to notify user about it.
            GL.recordError(0x501 /* GL_INVALID_VALUE */);
            return;
        }
        var data = GLctx.getVertexAttrib(index, pname);
        if (pname == 0x889F/*VERTEX_ATTRIB_ARRAY_BUFFER_BINDING*/) {
            HEAP32[((params) >> 2)] = data && data["name"];
        } else if (typeof data == 'number' || typeof data == 'boolean') {
            switch (type) {
                case 0: HEAP32[((params) >> 2)] = data; break;
                case 2: HEAPF32[((params) >> 2)] = data; break;
                case 5: HEAP32[((params) >> 2)] = Math.fround(data); break;
            }
        } else {
            for (var i = 0; i < data.length; i++) {
                switch (type) {
                    case 0: HEAP32[(((params) + (i * 4)) >> 2)] = data[i]; break;
                    case 2: HEAPF32[(((params) + (i * 4)) >> 2)] = data[i]; break;
                    case 5: HEAP32[(((params) + (i * 4)) >> 2)] = Math.fround(data[i]); break;
                }
            }
        }
    }
    function _emscripten_glGetVertexAttribfv(index, pname, params) {
        // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
        // otherwise the results are undefined. (GLES3 spec 6.1.12)
        emscriptenWebGLGetVertexAttrib(index, pname, params, 2);
    }
    _emscripten_glGetVertexAttribfv.sig = 'viii';

    function _emscripten_glGetVertexAttribiv(index, pname, params) {
        // N.B. This function may only be called if the vertex attribute was specified using the function glVertexAttrib*f(),
        // otherwise the results are undefined. (GLES3 spec 6.1.12)
        emscriptenWebGLGetVertexAttrib(index, pname, params, 5);
    }
    _emscripten_glGetVertexAttribiv.sig = 'viii';

    function _emscripten_glHint(x0, x1) { GLctx['hint'](x0, x1) }
    _emscripten_glHint.sig = 'vii';

    function _emscripten_glIsBuffer(buffer) {
        var b = GL.buffers[buffer];
        if (!b) return 0;
        return GLctx.isBuffer(b);
    }
    _emscripten_glIsBuffer.sig = 'ii';

    function _emscripten_glIsEnabled(x0) { return GLctx['isEnabled'](x0) }
    _emscripten_glIsEnabled.sig = 'ii';

    function _emscripten_glIsFramebuffer(framebuffer) {
        var fb = GL.framebuffers[framebuffer];
        if (!fb) return 0;
        return GLctx.isFramebuffer(fb);
    }
    _emscripten_glIsFramebuffer.sig = 'ii';

    function _emscripten_glIsProgram(program) {
        program = GL.programs[program];
        if (!program) return 0;
        return GLctx.isProgram(program);
    }
    _emscripten_glIsProgram.sig = 'ii';

    function _emscripten_glIsQueryEXT(id) {
        var query = GL.queries[id];
        if (!query) return 0;
        return GLctx.disjointTimerQueryExt['isQueryEXT'](query);
    }
    _emscripten_glIsQueryEXT.sig = 'ii';

    function _emscripten_glIsRenderbuffer(renderbuffer) {
        var rb = GL.renderbuffers[renderbuffer];
        if (!rb) return 0;
        return GLctx.isRenderbuffer(rb);
    }
    _emscripten_glIsRenderbuffer.sig = 'ii';

    function _emscripten_glIsShader(shader) {
        var s = GL.shaders[shader];
        if (!s) return 0;
        return GLctx.isShader(s);
    }
    _emscripten_glIsShader.sig = 'ii';

    function _emscripten_glIsTexture(id) {
        var texture = GL.textures[id];
        if (!texture) return 0;
        return GLctx.isTexture(texture);
    }
    _emscripten_glIsTexture.sig = 'ii';

    function _emscripten_glIsVertexArrayOES(array) {

        var vao = GL.vaos[array];
        if (!vao) return 0;
        return GLctx['isVertexArray'](vao);
    }
    _emscripten_glIsVertexArrayOES.sig = 'ii';

    function _emscripten_glLineWidth(x0) { GLctx['lineWidth'](x0) }
    _emscripten_glLineWidth.sig = 'vf';

    function _emscripten_glLinkProgram(program) {
        program = GL.programs[program];
        GLctx.linkProgram(program);
        // Invalidate earlier computed uniform->ID mappings, those have now become stale
        program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
        program.uniformSizeAndIdsByName = {};

    }
    _emscripten_glLinkProgram.sig = 'vi';

    function _emscripten_glPixelStorei(pname, param) {
        if (pname == 0xCF5 /* GL_UNPACK_ALIGNMENT */) {
            GL.unpackAlignment = param;
        }
        GLctx.pixelStorei(pname, param);
    }
    _emscripten_glPixelStorei.sig = 'vii';

    function _emscripten_glPolygonOffset(x0, x1) { GLctx['polygonOffset'](x0, x1) }
    _emscripten_glPolygonOffset.sig = 'vff';

    function _emscripten_glQueryCounterEXT(id, target) {
        GLctx.disjointTimerQueryExt['queryCounterEXT'](GL.queries[id], target);
    }
    _emscripten_glQueryCounterEXT.sig = 'vii';

    function computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
        function roundedToNextMultipleOf(x, y) {
            return (x + y - 1) & -y;
        }
        var plainRowSize = width * sizePerPixel;
        var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
        return height * alignedRowSize;
    }

    function __colorChannelsInGlTextureFormat(format) {
        // Micro-optimizations for size: map format to size by subtracting smallest enum value (0x1902) from all values first.
        // Also omit the most common size value (1) from the list, which is assumed by formats not on the list.
        var colorChannels = {
            // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
            // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
            5: 3,
            6: 4,
            // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
            8: 2,
            29502: 3,
            29504: 4,
        };
        return colorChannels[format - 0x1902] || 1;
    }

    function heapObjectForWebGLType(type) {
        // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
        // smaller values for the heap, for shorter generated code size.
        // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
        // (since most types are HEAPU16)
        type -= 0x1400;

        if (type == 1) return HEAPU8;

        if (type == 4) return HEAP32;

        if (type == 6) return HEAPF32;

        if (type == 5
            || type == 28922
        )
            return HEAPU32;

        return HEAPU16;
    }

    function heapAccessShiftForWebGLHeap(heap) {
        return 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
    }
    function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
        var heap = heapObjectForWebGLType(type);
        var shift = heapAccessShiftForWebGLHeap(heap);
        var byteSize = 1 << shift;
        var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
        var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
        return heap.subarray(pixels >> shift, pixels + bytes >> shift);
    }
    function _emscripten_glReadPixels(x, y, width, height, format, type, pixels) {
        var pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, format);
        if (!pixelData) {
            GL.recordError(0x500/*GL_INVALID_ENUM*/);
            return;
        }
        GLctx.readPixels(x, y, width, height, format, type, pixelData);
    }
    _emscripten_glReadPixels.sig = 'viiiiiii';

    function _emscripten_glReleaseShaderCompiler() {
        // NOP (as allowed by GLES 2.0 spec)
    }
    _emscripten_glReleaseShaderCompiler.sig = 'v';

    function _emscripten_glRenderbufferStorage(x0, x1, x2, x3) { GLctx['renderbufferStorage'](x0, x1, x2, x3) }
    _emscripten_glRenderbufferStorage.sig = 'viiii';

    function _emscripten_glSampleCoverage(value, invert) {
        GLctx.sampleCoverage(value, !!invert);
    }
    _emscripten_glSampleCoverage.sig = 'vii';

    function _emscripten_glScissor(x0, x1, x2, x3) { GLctx['scissor'](x0, x1, x2, x3) }
    _emscripten_glScissor.sig = 'viiii';

    function _emscripten_glShaderBinary() {
        GL.recordError(0x500/*GL_INVALID_ENUM*/);
    }
    _emscripten_glShaderBinary.sig = 'v';

    function _emscripten_glShaderSource(shader, count, string, length) {
        var source = GL.getSource(shader, count, string, length);

        GLctx.shaderSource(GL.shaders[shader], source);
    }
    _emscripten_glShaderSource.sig = 'viiii';

    function _emscripten_glStencilFunc(x0, x1, x2) { GLctx['stencilFunc'](x0, x1, x2) }
    _emscripten_glStencilFunc.sig = 'viii';

    function _emscripten_glStencilFuncSeparate(x0, x1, x2, x3) { GLctx['stencilFuncSeparate'](x0, x1, x2, x3) }
    _emscripten_glStencilFuncSeparate.sig = 'viiii';

    function _emscripten_glStencilMask(x0) { GLctx['stencilMask'](x0) }
    _emscripten_glStencilMask.sig = 'vi';

    function _emscripten_glStencilMaskSeparate(x0, x1) { GLctx['stencilMaskSeparate'](x0, x1) }
    _emscripten_glStencilMaskSeparate.sig = 'vii';

    function _emscripten_glStencilOp(x0, x1, x2) { GLctx['stencilOp'](x0, x1, x2) }
    _emscripten_glStencilOp.sig = 'viii';

    function _emscripten_glStencilOpSeparate(x0, x1, x2, x3) { GLctx['stencilOpSeparate'](x0, x1, x2, x3) }
    _emscripten_glStencilOpSeparate.sig = 'viiii';

    function _emscripten_glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
        GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    }
    _emscripten_glTexImage2D.sig = 'viiiiiiiii';

    function _emscripten_glTexParameterf(x0, x1, x2) { GLctx['texParameterf'](x0, x1, x2) }
    _emscripten_glTexParameterf.sig = 'viii';

    function _emscripten_glTexParameterfv(target, pname, params) {
        var param = HEAPF32[((params) >> 2)];
        GLctx.texParameterf(target, pname, param);
    }
    _emscripten_glTexParameterfv.sig = 'viii';

    function _emscripten_glTexParameteri(x0, x1, x2) { GLctx['texParameteri'](x0, x1, x2) }
    _emscripten_glTexParameteri.sig = 'viii';

    function _emscripten_glTexParameteriv(target, pname, params) {
        var param = HEAP32[((params) >> 2)];
        GLctx.texParameteri(target, pname, param);
    }
    _emscripten_glTexParameteriv.sig = 'viii';

    function _emscripten_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) {
        var pixelData = null;
        if (pixels) pixelData = emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0);
        GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);
    }
    _emscripten_glTexSubImage2D.sig = 'viiiiiiiii';

    function _emscripten_glUniform1f(location, v0) {
        GLctx.uniform1f(webglGetUniformLocation(location), v0);
    }
    _emscripten_glUniform1f.sig = 'vif';

    var miniTempWebGLFloatBuffers = [];
    function _emscripten_glUniform1fv(location, count, value) {

        if (count <= 288) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[count - 1];
            for (var i = 0; i < count; ++i) {
                view[i] = HEAPF32[(((value) + (4 * i)) >> 2)];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 4) >> 2);
        }
        GLctx.uniform1fv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform1fv.sig = 'viii';

    function _emscripten_glUniform1i(location, v0) {
        GLctx.uniform1i(webglGetUniformLocation(location), v0);
    }
    _emscripten_glUniform1i.sig = 'vii';

    var __miniTempWebGLIntBuffers = [];
    function _emscripten_glUniform1iv(location, count, value) {

        if (count <= 288) {
            // avoid allocation when uploading few enough uniforms
            var view = __miniTempWebGLIntBuffers[count - 1];
            for (var i = 0; i < count; ++i) {
                view[i] = HEAP32[(((value) + (4 * i)) >> 2)];
            }
        } else {
            var view = HEAP32.subarray((value) >> 2, (value + count * 4) >> 2);
        }
        GLctx.uniform1iv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform1iv.sig = 'viii';

    function _emscripten_glUniform2f(location, v0, v1) {
        GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
    }
    _emscripten_glUniform2f.sig = 'viff';

    function _emscripten_glUniform2fv(location, count, value) {

        if (count <= 144) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[2 * count - 1];
            for (var i = 0; i < 2 * count; i += 2) {
                view[i] = HEAPF32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAPF32[(((value) + (4 * i + 4)) >> 2)];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 8) >> 2);
        }
        GLctx.uniform2fv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform2fv.sig = 'viii';

    function _emscripten_glUniform2i(location, v0, v1) {
        GLctx.uniform2i(webglGetUniformLocation(location), v0, v1);
    }
    _emscripten_glUniform2i.sig = 'viii';

    function _emscripten_glUniform2iv(location, count, value) {

        if (count <= 144) {
            // avoid allocation when uploading few enough uniforms
            var view = __miniTempWebGLIntBuffers[2 * count - 1];
            for (var i = 0; i < 2 * count; i += 2) {
                view[i] = HEAP32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAP32[(((value) + (4 * i + 4)) >> 2)];
            }
        } else {
            var view = HEAP32.subarray((value) >> 2, (value + count * 8) >> 2);
        }
        GLctx.uniform2iv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform2iv.sig = 'viii';

    function _emscripten_glUniform3f(location, v0, v1, v2) {
        GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
    }
    _emscripten_glUniform3f.sig = 'vifff';

    function _emscripten_glUniform3fv(location, count, value) {

        if (count <= 96) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[3 * count - 1];
            for (var i = 0; i < 3 * count; i += 3) {
                view[i] = HEAPF32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAPF32[(((value) + (4 * i + 4)) >> 2)];
                view[i + 2] = HEAPF32[(((value) + (4 * i + 8)) >> 2)];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 12) >> 2);
        }
        GLctx.uniform3fv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform3fv.sig = 'viii';

    function _emscripten_glUniform3i(location, v0, v1, v2) {
        GLctx.uniform3i(webglGetUniformLocation(location), v0, v1, v2);
    }
    _emscripten_glUniform3i.sig = 'viiii';

    function _emscripten_glUniform3iv(location, count, value) {

        if (count <= 96) {
            // avoid allocation when uploading few enough uniforms
            var view = __miniTempWebGLIntBuffers[3 * count - 1];
            for (var i = 0; i < 3 * count; i += 3) {
                view[i] = HEAP32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAP32[(((value) + (4 * i + 4)) >> 2)];
                view[i + 2] = HEAP32[(((value) + (4 * i + 8)) >> 2)];
            }
        } else {
            var view = HEAP32.subarray((value) >> 2, (value + count * 12) >> 2);
        }
        GLctx.uniform3iv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform3iv.sig = 'viii';

    function _emscripten_glUniform4f(location, v0, v1, v2, v3) {
        GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
    }
    _emscripten_glUniform4f.sig = 'viffff';

    function _emscripten_glUniform4fv(location, count, value) {

        if (count <= 72) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            // hoist the heap out of the loop for size and for pthreads+growth.
            var heap = HEAPF32;
            value >>= 2;
            for (var i = 0; i < 4 * count; i += 4) {
                var dst = value + i;
                view[i] = heap[dst];
                view[i + 1] = heap[dst + 1];
                view[i + 2] = heap[dst + 2];
                view[i + 3] = heap[dst + 3];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 16) >> 2);
        }
        GLctx.uniform4fv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform4fv.sig = 'viii';

    function _emscripten_glUniform4i(location, v0, v1, v2, v3) {
        GLctx.uniform4i(webglGetUniformLocation(location), v0, v1, v2, v3);
    }
    _emscripten_glUniform4i.sig = 'viiiii';

    function _emscripten_glUniform4iv(location, count, value) {

        if (count <= 72) {
            // avoid allocation when uploading few enough uniforms
            var view = __miniTempWebGLIntBuffers[4 * count - 1];
            for (var i = 0; i < 4 * count; i += 4) {
                view[i] = HEAP32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAP32[(((value) + (4 * i + 4)) >> 2)];
                view[i + 2] = HEAP32[(((value) + (4 * i + 8)) >> 2)];
                view[i + 3] = HEAP32[(((value) + (4 * i + 12)) >> 2)];
            }
        } else {
            var view = HEAP32.subarray((value) >> 2, (value + count * 16) >> 2);
        }
        GLctx.uniform4iv(webglGetUniformLocation(location), view);
    }
    _emscripten_glUniform4iv.sig = 'viii';

    function _emscripten_glUniformMatrix2fv(location, count, transpose, value) {

        if (count <= 72) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[4 * count - 1];
            for (var i = 0; i < 4 * count; i += 4) {
                view[i] = HEAPF32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAPF32[(((value) + (4 * i + 4)) >> 2)];
                view[i + 2] = HEAPF32[(((value) + (4 * i + 8)) >> 2)];
                view[i + 3] = HEAPF32[(((value) + (4 * i + 12)) >> 2)];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 16) >> 2);
        }
        GLctx.uniformMatrix2fv(webglGetUniformLocation(location), !!transpose, view);
    }
    _emscripten_glUniformMatrix2fv.sig = 'viiii';

    function _emscripten_glUniformMatrix3fv(location, count, transpose, value) {

        if (count <= 32) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[9 * count - 1];
            for (var i = 0; i < 9 * count; i += 9) {
                view[i] = HEAPF32[(((value) + (4 * i)) >> 2)];
                view[i + 1] = HEAPF32[(((value) + (4 * i + 4)) >> 2)];
                view[i + 2] = HEAPF32[(((value) + (4 * i + 8)) >> 2)];
                view[i + 3] = HEAPF32[(((value) + (4 * i + 12)) >> 2)];
                view[i + 4] = HEAPF32[(((value) + (4 * i + 16)) >> 2)];
                view[i + 5] = HEAPF32[(((value) + (4 * i + 20)) >> 2)];
                view[i + 6] = HEAPF32[(((value) + (4 * i + 24)) >> 2)];
                view[i + 7] = HEAPF32[(((value) + (4 * i + 28)) >> 2)];
                view[i + 8] = HEAPF32[(((value) + (4 * i + 32)) >> 2)];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 36) >> 2);
        }
        GLctx.uniformMatrix3fv(webglGetUniformLocation(location), !!transpose, view);
    }
    _emscripten_glUniformMatrix3fv.sig = 'viiii';

    function _emscripten_glUniformMatrix4fv(location, count, transpose, value) {

        if (count <= 18) {
            // avoid allocation when uploading few enough uniforms
            var view = miniTempWebGLFloatBuffers[16 * count - 1];
            // hoist the heap out of the loop for size and for pthreads+growth.
            var heap = HEAPF32;
            value >>= 2;
            for (var i = 0; i < 16 * count; i += 16) {
                var dst = value + i;
                view[i] = heap[dst];
                view[i + 1] = heap[dst + 1];
                view[i + 2] = heap[dst + 2];
                view[i + 3] = heap[dst + 3];
                view[i + 4] = heap[dst + 4];
                view[i + 5] = heap[dst + 5];
                view[i + 6] = heap[dst + 6];
                view[i + 7] = heap[dst + 7];
                view[i + 8] = heap[dst + 8];
                view[i + 9] = heap[dst + 9];
                view[i + 10] = heap[dst + 10];
                view[i + 11] = heap[dst + 11];
                view[i + 12] = heap[dst + 12];
                view[i + 13] = heap[dst + 13];
                view[i + 14] = heap[dst + 14];
                view[i + 15] = heap[dst + 15];
            }
        } else {
            var view = HEAPF32.subarray((value) >> 2, (value + count * 64) >> 2);
        }
        GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
    }
    _emscripten_glUniformMatrix4fv.sig = 'viiii';

    function _emscripten_glUseProgram(program) {
        program = GL.programs[program];
        GLctx.useProgram(program);
        // Record the currently active program so that we can access the uniform
        // mapping table of that program.
        GLctx.currentProgram = program;
    }
    _emscripten_glUseProgram.sig = 'vi';

    function _emscripten_glValidateProgram(program) {
        GLctx.validateProgram(GL.programs[program]);
    }
    _emscripten_glValidateProgram.sig = 'vi';

    function _emscripten_glVertexAttrib1f(x0, x1) { GLctx['vertexAttrib1f'](x0, x1) }
    _emscripten_glVertexAttrib1f.sig = 'vif';

    function _emscripten_glVertexAttrib1fv(index, v) {

        GLctx.vertexAttrib1f(index, HEAPF32[v >> 2]);
    }
    _emscripten_glVertexAttrib1fv.sig = 'vii';

    function _emscripten_glVertexAttrib2f(x0, x1, x2) { GLctx['vertexAttrib2f'](x0, x1, x2) }
    _emscripten_glVertexAttrib2f.sig = 'viff';

    function _emscripten_glVertexAttrib2fv(index, v) {

        GLctx.vertexAttrib2f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2]);
    }
    _emscripten_glVertexAttrib2fv.sig = 'vii';

    function _emscripten_glVertexAttrib3f(x0, x1, x2, x3) { GLctx['vertexAttrib3f'](x0, x1, x2, x3) }
    _emscripten_glVertexAttrib3f.sig = 'vifff';

    function _emscripten_glVertexAttrib3fv(index, v) {

        GLctx.vertexAttrib3f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2], HEAPF32[v + 8 >> 2]);
    }
    _emscripten_glVertexAttrib3fv.sig = 'vii';

    function _emscripten_glVertexAttrib4f(x0, x1, x2, x3, x4) { GLctx['vertexAttrib4f'](x0, x1, x2, x3, x4) }
    _emscripten_glVertexAttrib4f.sig = 'viffff';

    function _emscripten_glVertexAttrib4fv(index, v) {

        GLctx.vertexAttrib4f(index, HEAPF32[v >> 2], HEAPF32[v + 4 >> 2], HEAPF32[v + 8 >> 2], HEAPF32[v + 12 >> 2]);
    }
    _emscripten_glVertexAttrib4fv.sig = 'vii';

    function _emscripten_glVertexAttribDivisorANGLE(index, divisor) {
        GLctx['vertexAttribDivisor'](index, divisor);
    }
    _emscripten_glVertexAttribDivisorANGLE.sig = 'vii';

    function _emscripten_glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
        GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    }
    _emscripten_glVertexAttribPointer.sig = 'viiiiii';

    function _emscripten_glViewport(x0, x1, x2, x3) { GLctx['viewport'](x0, x1, x2, x3) }
    _emscripten_glViewport.sig = 'viiii';

    function _emscripten_has_asyncify() {
        return false;
    }

    function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest, src, src + num);
    }

    function doRequestFullscreen(target, strategy) {
        if (!JSEvents.fullscreenEnabled()) return -1;
        target = findEventTarget(target);
        if (!target) return -4;

        if (!target.requestFullscreen
            && !target.webkitRequestFullscreen
        ) {
            return -3;
        }

        var canPerformRequests = JSEvents.canPerformEventHandlerRequests();

        // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
        if (!canPerformRequests) {
            if (strategy.deferUntilInEventHandler) {
                JSEvents.deferCall(_JSEvents_requestFullscreen, 1 /* priority over pointer lock */, [target, strategy]);
                return 1;
            } else {
                return -2;
            }
        }

        return _JSEvents_requestFullscreen(target, strategy);
    }
    function _emscripten_request_fullscreen_strategy(target, deferUntilInEventHandler, fullscreenStrategy) {
        var strategy = {
            scaleMode: HEAP32[((fullscreenStrategy) >> 2)],
            canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy) + (4)) >> 2)],
            filteringMode: HEAP32[(((fullscreenStrategy) + (8)) >> 2)],
            deferUntilInEventHandler: deferUntilInEventHandler,
            canvasResizedCallback: HEAP32[(((fullscreenStrategy) + (12)) >> 2)],
            canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy) + (16)) >> 2)]
        };

        return doRequestFullscreen(target, strategy);
    }
    _emscripten_request_fullscreen_strategy.sig = 'iiii';

    function _emscripten_request_pointerlock(target, deferUntilInEventHandler) {
        target = findEventTarget(target);
        if (!target) return -4;
        if (!target.requestPointerLock
            && !target.msRequestPointerLock
        ) {
            return -1;
        }

        var canPerformRequests = JSEvents.canPerformEventHandlerRequests();

        // Queue this function call if we're not currently in an event handler and the user saw it appropriate to do so.
        if (!canPerformRequests) {
            if (deferUntilInEventHandler) {
                JSEvents.deferCall(requestPointerLock, 2 /* priority below fullscreen */, [target]);
                return 1;
            } else {
                return -2;
            }
        }

        return requestPointerLock(target);
    }
    _emscripten_request_pointerlock.sig = 'iii';

    function abortOnCannotGrowMemory(requestedSize) {
        abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s INITIAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }
    function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        abortOnCannotGrowMemory(requestedSize);
    }

    function _emscripten_sample_gamepad_data() {
        return (JSEvents.lastGamepadState = (navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : null)))
            ? 0 : -1;
    }
    _emscripten_sample_gamepad_data.sig = 'i';

    function registerBeforeUnloadEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString) {
        var beforeUnloadEventHandlerFunc = function (ev) {
            var e = ev || event;

            // Note: This is always called on the main browser thread, since it needs synchronously return a value!
            var confirmationMessage = getWasmTableEntry(callbackfunc)(eventTypeId, 0, userData);

            if (confirmationMessage) {
                confirmationMessage = UTF8ToString(confirmationMessage);
            }
            if (confirmationMessage) {
                e.preventDefault();
                e.returnValue = confirmationMessage;
                return confirmationMessage;
            }
        };

        var eventHandler = {
            target: findEventTarget(target),
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: beforeUnloadEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_beforeunload_callback_on_thread(userData, callbackfunc, targetThread) {
        if (typeof onbeforeunload == 'undefined') return -1;
        // beforeunload callback can only be registered on the main browser thread, because the page will go away immediately after returning from the handler,
        // and there is no time to start proxying it anywhere.
        if (targetThread !== 1) return -5;
        registerBeforeUnloadEventCallback(2, userData, true, callbackfunc, 28, "beforeunload");
        return 0;
    }
    _emscripten_set_beforeunload_callback_on_thread.sig = 'iii';

    function registerFocusEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.focusEvent) JSEvents.focusEvent = _malloc(256);

        var focusEventHandlerFunc = function (ev) {
            var e = ev || event;

            var nodeName = JSEvents.getNodeNameForTarget(e.target);
            var id = e.target.id ? e.target.id : '';

            var focusEvent = JSEvents.focusEvent;
            stringToUTF8(nodeName, focusEvent + 0, 128);
            stringToUTF8(id, focusEvent + 128, 128);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, focusEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: findEventTarget(target),
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: focusEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_blur_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerFocusEventCallback(target, userData, useCapture, callbackfunc, 12, "blur", targetThread);
        return 0;
    }
    _emscripten_set_blur_callback_on_thread.sig = 'iiiiii';


    function _emscripten_set_element_css_size(target, width, height) {
        target = findEventTarget(target);
        if (!target) return -4;

        target.style.width = width + "px";
        target.style.height = height + "px";

        return 0;
    }
    _emscripten_set_element_css_size.sig = 'iiii';

    function _emscripten_set_focus_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerFocusEventCallback(target, userData, useCapture, callbackfunc, 13, "focus", targetThread);
        return 0;
    }
    _emscripten_set_focus_callback_on_thread.sig = 'iiiiii';

    function fillFullscreenChangeEventData(eventStruct) {
        var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
        var isFullscreen = !!fullscreenElement;
        // Assigning a boolean to HEAP32 with expected type coercion.
        /** @suppress{checkTypes} */
        HEAP32[((eventStruct) >> 2)] = isFullscreen;
        HEAP32[(((eventStruct) + (4)) >> 2)] = JSEvents.fullscreenEnabled();
        // If transitioning to fullscreen, report info about the element that is now fullscreen.
        // If transitioning to windowed mode, report info about the element that just was fullscreen.
        var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
        var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
        var id = (reportedElement && reportedElement.id) ? reportedElement.id : '';
        stringToUTF8(nodeName, eventStruct + 8, 128);
        stringToUTF8(id, eventStruct + 136, 128);
        HEAP32[(((eventStruct) + (264)) >> 2)] = reportedElement ? reportedElement.clientWidth : 0;
        HEAP32[(((eventStruct) + (268)) >> 2)] = reportedElement ? reportedElement.clientHeight : 0;
        HEAP32[(((eventStruct) + (272)) >> 2)] = screen.width;
        HEAP32[(((eventStruct) + (276)) >> 2)] = screen.height;
        if (isFullscreen) {
            JSEvents.previousFullscreenElement = fullscreenElement;
        }
    }
    function registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc(280);

        var fullscreenChangeEventhandlerFunc = function (ev) {
            var e = ev || event;

            var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;

            fillFullscreenChangeEventData(fullscreenChangeEvent);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: fullscreenChangeEventhandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        if (!JSEvents.fullscreenEnabled()) return -1;
        target = findEventTarget(target);
        if (!target) return -4;
        registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);

        // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
        // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
        registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);

        return 0;
    }
    _emscripten_set_fullscreenchange_callback_on_thread.sig = 'iiiiii';

    function registerGamepadEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.gamepadEvent) JSEvents.gamepadEvent = _malloc(1432);

        var gamepadEventHandlerFunc = function (ev) {
            var e = ev || event;

            var gamepadEvent = JSEvents.gamepadEvent;
            fillGamepadEventData(gamepadEvent, e["gamepad"]);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, gamepadEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: findEventTarget(target),
            allowsDeferredCalls: true,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: gamepadEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_gamepadconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
        if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
        registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 26, "gamepadconnected", targetThread);
        return 0;
    }
    _emscripten_set_gamepadconnected_callback_on_thread.sig = 'iiiii';

    function _emscripten_set_gamepaddisconnected_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
        if (!navigator.getGamepads && !navigator.webkitGetGamepads) return -1;
        registerGamepadEventCallback(2, userData, useCapture, callbackfunc, 27, "gamepaddisconnected", targetThread);
        return 0;
    }
    _emscripten_set_gamepaddisconnected_callback_on_thread.sig = 'iiiii';

    function registerKeyEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc(176);

        var keyEventHandlerFunc = function (e) {
            assert(e);

            var keyEventData = JSEvents.keyEvent;
            HEAPF64[((keyEventData) >> 3)] = e.timeStamp;

            var idx = keyEventData >> 2;

            HEAP32[idx + 2] = e.location;
            HEAP32[idx + 3] = e.ctrlKey;
            HEAP32[idx + 4] = e.shiftKey;
            HEAP32[idx + 5] = e.altKey;
            HEAP32[idx + 6] = e.metaKey;
            HEAP32[idx + 7] = e.repeat;
            HEAP32[idx + 8] = e.charCode;
            HEAP32[idx + 9] = e.keyCode;
            HEAP32[idx + 10] = e.which;
            stringToUTF8(e.key || '', keyEventData + 44, 32);
            stringToUTF8(e.code || '', keyEventData + 76, 32);
            stringToUTF8(e.char || '', keyEventData + 108, 32);
            stringToUTF8(e.locale || '', keyEventData + 140, 32);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, keyEventData, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: findEventTarget(target),
            allowsDeferredCalls: true,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: keyEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
        return 0;
    }
    _emscripten_set_keydown_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
        return 0;
    }
    _emscripten_set_keypress_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
        return 0;
    }
    _emscripten_set_keyup_callback_on_thread.sig = 'iiiiii';

    function fillMouseEventData(eventStruct, e, target) {
        assert(eventStruct % 4 == 0);
        HEAPF64[((eventStruct) >> 3)] = e.timeStamp;
        var idx = eventStruct >> 2;
        HEAP32[idx + 2] = e.screenX;
        HEAP32[idx + 3] = e.screenY;
        HEAP32[idx + 4] = e.clientX;
        HEAP32[idx + 5] = e.clientY;
        HEAP32[idx + 6] = e.ctrlKey;
        HEAP32[idx + 7] = e.shiftKey;
        HEAP32[idx + 8] = e.altKey;
        HEAP32[idx + 9] = e.metaKey;
        HEAP16[idx * 2 + 20] = e.button;
        HEAP16[idx * 2 + 21] = e.buttons;

        HEAP32[idx + 11] = e["movementX"]
            ;

        HEAP32[idx + 12] = e["movementY"]
            ;

        var rect = getBoundingClientRect(target);
        HEAP32[idx + 13] = e.clientX - rect.left;
        HEAP32[idx + 14] = e.clientY - rect.top;

    }
    function registerMouseEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc(72);
        target = findEventTarget(target);

        var mouseEventHandlerFunc = function (ev) {
            var e = ev || event;

            // TODO: Make this access thread safe, or this could update live while app is reading it.
            fillMouseEventData(JSEvents.mouseEvent, e, target);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: mouseEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
        return 0;
    }
    _emscripten_set_mousedown_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
        return 0;
    }
    _emscripten_set_mouseenter_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
        return 0;
    }
    _emscripten_set_mouseleave_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
        return 0;
    }
    _emscripten_set_mousemove_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
        return 0;
    }
    _emscripten_set_mouseup_callback_on_thread.sig = 'iiiiii';

    function fillPointerlockChangeEventData(eventStruct) {
        var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
        var isPointerlocked = !!pointerLockElement;
        // Assigning a boolean to HEAP32 with expected type coercion.
        /** @suppress{checkTypes} */
        HEAP32[((eventStruct) >> 2)] = isPointerlocked;
        var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
        var id = (pointerLockElement && pointerLockElement.id) ? pointerLockElement.id : '';
        stringToUTF8(nodeName, eventStruct + 4, 128);
        stringToUTF8(id, eventStruct + 132, 128);
    }
    function registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.pointerlockChangeEvent) JSEvents.pointerlockChangeEvent = _malloc(260);

        var pointerlockChangeEventHandlerFunc = function (ev) {
            var e = ev || event;

            var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
            fillPointerlockChangeEventData(pointerlockChangeEvent);

            if (getWasmTableEntry(callbackfunc)(eventTypeId, pointerlockChangeEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: pointerlockChangeEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    /** @suppress {missingProperties} */
    function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
        if (!document || !document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
            return -1;
        }

        target = findEventTarget(target);
        if (!target) return -4;
        registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
        registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
        registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
        registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
        return 0;
    }
    _emscripten_set_pointerlockchange_callback_on_thread.sig = 'iiiiii';

    function registerUiEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc(36);

        target = findEventTarget(target);

        var uiEventHandlerFunc = function (ev) {
            var e = ev || event;
            if (e.target != target) {
                // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
                // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
                // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
                // causing a new scroll, etc..
                return;
            }
            var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
            if (!b) {
                // During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
                return;
            }
            var uiEvent = JSEvents.uiEvent;
            HEAP32[((uiEvent) >> 2)] = e.detail;
            HEAP32[(((uiEvent) + (4)) >> 2)] = b.clientWidth;
            HEAP32[(((uiEvent) + (8)) >> 2)] = b.clientHeight;
            HEAP32[(((uiEvent) + (12)) >> 2)] = innerWidth;
            HEAP32[(((uiEvent) + (16)) >> 2)] = innerHeight;
            HEAP32[(((uiEvent) + (20)) >> 2)] = outerWidth;
            HEAP32[(((uiEvent) + (24)) >> 2)] = outerHeight;
            HEAP32[(((uiEvent) + (28)) >> 2)] = pageXOffset;
            HEAP32[(((uiEvent) + (32)) >> 2)] = pageYOffset;
            if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: uiEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
        return 0;
    }
    _emscripten_set_resize_callback_on_thread.sig = 'iiiiii';

    function registerTouchEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.touchEvent) JSEvents.touchEvent = _malloc(1696);

        target = findEventTarget(target);

        var touchEventHandlerFunc = function (e) {
            assert(e);
            var t, touches = {}, et = e.touches;
            // To ease marshalling different kinds of touches that browser reports (all touches are listed in e.touches, 
            // only changed touches in e.changedTouches, and touches on target at a.targetTouches), mark a boolean in
            // each Touch object so that we can later loop only once over all touches we see to marshall over to Wasm.

            for (var i = 0; i < et.length; ++i) {
                t = et[i];
                // Browser might recycle the generated Touch objects between each frame (Firefox on Android), so reset any
                // changed/target states we may have set from previous frame.
                t.isChanged = t.onTarget = 0;
                touches[t.identifier] = t;
            }
            // Mark which touches are part of the changedTouches list.
            for (var i = 0; i < e.changedTouches.length; ++i) {
                t = e.changedTouches[i];
                t.isChanged = 1;
                touches[t.identifier] = t;
            }
            // Mark which touches are part of the targetTouches list.
            for (var i = 0; i < e.targetTouches.length; ++i) {
                touches[e.targetTouches[i].identifier].onTarget = 1;
            }

            var touchEvent = JSEvents.touchEvent;
            HEAPF64[((touchEvent) >> 3)] = e.timeStamp;
            var idx = touchEvent >> 2; // Pre-shift the ptr to index to HEAP32 to save code size
            HEAP32[idx + 3] = e.ctrlKey;
            HEAP32[idx + 4] = e.shiftKey;
            HEAP32[idx + 5] = e.altKey;
            HEAP32[idx + 6] = e.metaKey;
            idx += 7; // Advance to the start of the touch array.
            var targetRect = getBoundingClientRect(target);
            var numTouches = 0;
            for (var i in touches) {
                t = touches[i];
                HEAP32[idx + 0] = t.identifier;
                HEAP32[idx + 1] = t.screenX;
                HEAP32[idx + 2] = t.screenY;
                HEAP32[idx + 3] = t.clientX;
                HEAP32[idx + 4] = t.clientY;
                HEAP32[idx + 5] = t.pageX;
                HEAP32[idx + 6] = t.pageY;
                HEAP32[idx + 7] = t.isChanged;
                HEAP32[idx + 8] = t.onTarget;
                HEAP32[idx + 9] = t.clientX - targetRect.left;
                HEAP32[idx + 10] = t.clientY - targetRect.top;

                idx += 13;

                if (++numTouches > 31) {
                    break;
                }
            }
            HEAP32[(((touchEvent) + (8)) >> 2)] = numTouches;

            if (getWasmTableEntry(callbackfunc)(eventTypeId, touchEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            allowsDeferredCalls: eventTypeString == 'touchstart' || eventTypeString == 'touchend',
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: touchEventHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_touchcancel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerTouchEventCallback(target, userData, useCapture, callbackfunc, 25, "touchcancel", targetThread);
        return 0;
    }
    _emscripten_set_touchcancel_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_touchend_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerTouchEventCallback(target, userData, useCapture, callbackfunc, 23, "touchend", targetThread);
        return 0;
    }
    _emscripten_set_touchend_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_touchmove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerTouchEventCallback(target, userData, useCapture, callbackfunc, 24, "touchmove", targetThread);
        return 0;
    }
    _emscripten_set_touchmove_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_touchstart_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        registerTouchEventCallback(target, userData, useCapture, callbackfunc, 22, "touchstart", targetThread);
        return 0;
    }
    _emscripten_set_touchstart_callback_on_thread.sig = 'iiiiii';

    function fillVisibilityChangeEventData(eventStruct) {
        var visibilityStates = ["hidden", "visible", "prerender", "unloaded"];
        var visibilityState = visibilityStates.indexOf(document.visibilityState);

        // Assigning a boolean to HEAP32 with expected type coercion.
        /** @suppress{checkTypes} */
        HEAP32[((eventStruct) >> 2)] = document.hidden;
        HEAP32[(((eventStruct) + (4)) >> 2)] = visibilityState;
    }
    function _emscripten_sleep() {
        throw 'Please compile your program with async support in order to use asynchronous operations like emscripten_sleep';
    }

    function registerVisibilityChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.visibilityChangeEvent) JSEvents.visibilityChangeEvent = _malloc( 8 );
    
        var visibilityChangeEventHandlerFunc = function(ev) {
          var e = ev || event;
    
          var visibilityChangeEvent = JSEvents.visibilityChangeEvent;
    
          fillVisibilityChangeEventData(visibilityChangeEvent);
    
          if (getWasmTableEntry(callbackfunc)(eventTypeId, visibilityChangeEvent, userData)) e.preventDefault();
        };
    
        var eventHandler = {
          target: target,
          eventTypeString: eventTypeString,
          callbackfunc: callbackfunc,
          handlerFunc: visibilityChangeEventHandlerFunc,
          useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
      }

    function _emscripten_set_visibilitychange_callback_on_thread(userData, useCapture, callbackfunc, targetThread) {
        if (!specialHTMLTargets[1]) {
            return -4;
        }
        registerVisibilityChangeEventCallback(specialHTMLTargets[1], userData, useCapture, callbackfunc, 21, "visibilitychange", targetThread);
        return 0;
    }
    _emscripten_set_visibilitychange_callback_on_thread.sig = 'iiiii';

    function registerWheelEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
        if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc(104);

        // The DOM Level 3 events spec event 'wheel'
        var wheelHandlerFunc = function (ev) {
            var e = ev || event;
            var wheelEvent = JSEvents.wheelEvent;
            fillMouseEventData(wheelEvent, e, target);
            HEAPF64[(((wheelEvent) + (72)) >> 3)] = e["deltaX"];
            HEAPF64[(((wheelEvent) + (80)) >> 3)] = e["deltaY"];
            HEAPF64[(((wheelEvent) + (88)) >> 3)] = e["deltaZ"];
            HEAP32[(((wheelEvent) + (96)) >> 2)] = e["deltaMode"];
            if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData)) e.preventDefault();
        };

        var eventHandler = {
            target: target,
            allowsDeferredCalls: true,
            eventTypeString: eventTypeString,
            callbackfunc: callbackfunc,
            handlerFunc: wheelHandlerFunc,
            useCapture: useCapture
        };
        JSEvents.registerOrRemoveHandler(eventHandler);
    }
    function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
        target = findEventTarget(target);
        if (typeof target.onwheel != 'undefined') {
            registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
            return 0;
        } else {
            return -1;
        }
    }
    _emscripten_set_wheel_callback_on_thread.sig = 'iiiiii';

    function _emscripten_set_window_title(title) {
        setWindowTitle(UTF8ToString(title));
    }
    _emscripten_set_window_title.sig = 'vi';

    function _emscripten_set_main_loop_timing(mode, value) {
        Browser.mainLoop.timingMode = mode;
        Browser.mainLoop.timingValue = value;
    
        if (!Browser.mainLoop.func) {
          err('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
          return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
        }
    
        if (!Browser.mainLoop.running) {
          
          Browser.mainLoop.running = true;
        }
        if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
            var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
            setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
          };
          Browser.mainLoop.method = 'timeout';
        } else if (mode == 1 /*EM_TIMING_RAF*/) {
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
            Browser.requestAnimationFrame(Browser.mainLoop.runner);
          };
          Browser.mainLoop.method = 'rAF';
        } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
          if (typeof setImmediate == 'undefined') {
            // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
            var setImmediates = [];
            var emscriptenMainLoopMessageId = 'setimmediate';
            var Browser_setImmediate_messageHandler = function(/** @type {Event} */ event) {
              // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
              // so check for both cases.
              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
                event.stopPropagation();
                setImmediates.shift()();
              }
            }
            addEventListener("message", Browser_setImmediate_messageHandler, true);
            setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
              setImmediates.push(func);
              if (ENVIRONMENT_IS_WORKER) {
                if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
                Module['setImmediates'].push(func);
                postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
              } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
            })
          }
          Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
            setImmediate(Browser.mainLoop.runner);
          };
          Browser.mainLoop.method = 'immediate';
        }
        return 0;
      }
    _emscripten_set_main_loop_timing.sig = 'iii';

    var sdl_functions = {
        "emscripten_get_num_gamepads": _emscripten_get_num_gamepads,
        "emscripten_get_screen_size": _emscripten_get_screen_size,
        "emscripten_glActiveTexture": _emscripten_glActiveTexture,
        "emscripten_glAttachShader": _emscripten_glAttachShader,
        "emscripten_glBeginQueryEXT": _emscripten_glBeginQueryEXT,
        "emscripten_glBindAttribLocation": _emscripten_glBindAttribLocation,
        "emscripten_glBindBuffer": _emscripten_glBindBuffer,
        "emscripten_glBindFramebuffer": _emscripten_glBindFramebuffer,
        "emscripten_glBindRenderbuffer": _emscripten_glBindRenderbuffer,
        "emscripten_glBindTexture": _emscripten_glBindTexture,
        "emscripten_glBindVertexArrayOES": _emscripten_glBindVertexArrayOES,
        "emscripten_glBlendColor": _emscripten_glBlendColor,
        "emscripten_glBlendEquation": _emscripten_glBlendEquation,
        "emscripten_glBlendEquationSeparate": _emscripten_glBlendEquationSeparate,
        "emscripten_glBlendFunc": _emscripten_glBlendFunc,
        "emscripten_glBlendFuncSeparate": _emscripten_glBlendFuncSeparate,
        "emscripten_glBufferData": _emscripten_glBufferData,
        "emscripten_glBufferSubData": _emscripten_glBufferSubData,
        "emscripten_glCheckFramebufferStatus": _emscripten_glCheckFramebufferStatus,
        "emscripten_glClear": _emscripten_glClear,
        "emscripten_glClearColor": _emscripten_glClearColor,
        "emscripten_glClearDepthf": _emscripten_glClearDepthf,
        "emscripten_glClearStencil": _emscripten_glClearStencil,
        "emscripten_glColorMask": _emscripten_glColorMask,
        "emscripten_glCompileShader": _emscripten_glCompileShader,
        "emscripten_glCompressedTexImage2D": _emscripten_glCompressedTexImage2D,
        "emscripten_glCompressedTexSubImage2D": _emscripten_glCompressedTexSubImage2D,
        "emscripten_glCopyTexImage2D": _emscripten_glCopyTexImage2D,
        "emscripten_glCopyTexSubImage2D": _emscripten_glCopyTexSubImage2D,
        "emscripten_glCreateProgram": _emscripten_glCreateProgram,
        "emscripten_glCreateShader": _emscripten_glCreateShader,
        "emscripten_glCullFace": _emscripten_glCullFace,
        "emscripten_glDeleteBuffers": _emscripten_glDeleteBuffers,
        "emscripten_glDeleteFramebuffers": _emscripten_glDeleteFramebuffers,
        "emscripten_glDeleteProgram": _emscripten_glDeleteProgram,
        "emscripten_glDeleteQueriesEXT": _emscripten_glDeleteQueriesEXT,
        "emscripten_glDeleteRenderbuffers": _emscripten_glDeleteRenderbuffers,
        "emscripten_glDeleteShader": _emscripten_glDeleteShader,
        "emscripten_glDeleteTextures": _emscripten_glDeleteTextures,
        "emscripten_glDeleteVertexArraysOES": _emscripten_glDeleteVertexArraysOES,
        "emscripten_glDepthFunc": _emscripten_glDepthFunc,
        "emscripten_glDepthMask": _emscripten_glDepthMask,
        "emscripten_glDepthRangef": _emscripten_glDepthRangef,
        "emscripten_glDetachShader": _emscripten_glDetachShader,
        "emscripten_glDisable": _emscripten_glDisable,
        "emscripten_glDisableVertexAttribArray": _emscripten_glDisableVertexAttribArray,
        "emscripten_glDrawArrays": _emscripten_glDrawArrays,
        "emscripten_glDrawArraysInstancedANGLE": _emscripten_glDrawArraysInstancedANGLE,
        "emscripten_glDrawBuffersWEBGL": _emscripten_glDrawBuffersWEBGL,
        "emscripten_glDrawElements": _emscripten_glDrawElements,
        "emscripten_glDrawElementsInstancedANGLE": _emscripten_glDrawElementsInstancedANGLE,
        "emscripten_glEnable": _emscripten_glEnable,
        "emscripten_glEnableVertexAttribArray": _emscripten_glEnableVertexAttribArray,
        "emscripten_glEndQueryEXT": _emscripten_glEndQueryEXT,
        "emscripten_glFinish": _emscripten_glFinish,
        "emscripten_glFlush": _emscripten_glFlush,
        "emscripten_glFramebufferRenderbuffer": _emscripten_glFramebufferRenderbuffer,
        "emscripten_glFramebufferTexture2D": _emscripten_glFramebufferTexture2D,
        "emscripten_glFrontFace": _emscripten_glFrontFace,
        "emscripten_glGenBuffers": _emscripten_glGenBuffers,
        "emscripten_glGenFramebuffers": _emscripten_glGenFramebuffers,
        "emscripten_glGenQueriesEXT": _emscripten_glGenQueriesEXT,
        "emscripten_glGenRenderbuffers": _emscripten_glGenRenderbuffers,
        "emscripten_glGenTextures": _emscripten_glGenTextures,
        "emscripten_glGenVertexArraysOES": _emscripten_glGenVertexArraysOES,
        "emscripten_glGenerateMipmap": _emscripten_glGenerateMipmap,
        "emscripten_glGetActiveAttrib": _emscripten_glGetActiveAttrib,
        "emscripten_glGetActiveUniform": _emscripten_glGetActiveUniform,
        "emscripten_glGetAttachedShaders": _emscripten_glGetAttachedShaders,
        "emscripten_glGetAttribLocation": _emscripten_glGetAttribLocation,
        "emscripten_glGetBooleanv": _emscripten_glGetBooleanv,
        "emscripten_glGetBufferParameteriv": _emscripten_glGetBufferParameteriv,
        "emscripten_glGetError": _emscripten_glGetError,
        "emscripten_glGetFloatv": _emscripten_glGetFloatv,
        "emscripten_glGetFramebufferAttachmentParameteriv": _emscripten_glGetFramebufferAttachmentParameteriv,
        "emscripten_glGetIntegerv": _emscripten_glGetIntegerv,
        "emscripten_glGetProgramInfoLog": _emscripten_glGetProgramInfoLog,
        "emscripten_glGetProgramiv": _emscripten_glGetProgramiv,
        "emscripten_glGetQueryObjecti64vEXT": _emscripten_glGetQueryObjecti64vEXT,
        "emscripten_glGetQueryObjectivEXT": _emscripten_glGetQueryObjectivEXT,
        "emscripten_glGetQueryObjectui64vEXT": _emscripten_glGetQueryObjectui64vEXT,
        "emscripten_glGetQueryObjectuivEXT": _emscripten_glGetQueryObjectuivEXT,
        "emscripten_glGetQueryivEXT": _emscripten_glGetQueryivEXT,
        "emscripten_glGetRenderbufferParameteriv": _emscripten_glGetRenderbufferParameteriv,
        "emscripten_glGetShaderInfoLog": _emscripten_glGetShaderInfoLog,
        "emscripten_glGetShaderPrecisionFormat": _emscripten_glGetShaderPrecisionFormat,
        "emscripten_glGetShaderSource": _emscripten_glGetShaderSource,
        "emscripten_glGetShaderiv": _emscripten_glGetShaderiv,
        "emscripten_glGetString": _emscripten_glGetString,
        "emscripten_glGetTexParameterfv": _emscripten_glGetTexParameterfv,
        "emscripten_glGetTexParameteriv": _emscripten_glGetTexParameteriv,
        "emscripten_glGetUniformLocation": _emscripten_glGetUniformLocation,
        "emscripten_glGetUniformfv": _emscripten_glGetUniformfv,
        "emscripten_glGetUniformiv": _emscripten_glGetUniformiv,
        "emscripten_glGetVertexAttribPointerv": _emscripten_glGetVertexAttribPointerv,
        "emscripten_glGetVertexAttribfv": _emscripten_glGetVertexAttribfv,
        "emscripten_glGetVertexAttribiv": _emscripten_glGetVertexAttribiv,
        "emscripten_glHint": _emscripten_glHint,
        "emscripten_glIsBuffer": _emscripten_glIsBuffer,
        "emscripten_glIsEnabled": _emscripten_glIsEnabled,
        "emscripten_glIsFramebuffer": _emscripten_glIsFramebuffer,
        "emscripten_glIsProgram": _emscripten_glIsProgram,
        "emscripten_glIsQueryEXT": _emscripten_glIsQueryEXT,
        "emscripten_glIsRenderbuffer": _emscripten_glIsRenderbuffer,
        "emscripten_glIsShader": _emscripten_glIsShader,
        "emscripten_glIsTexture": _emscripten_glIsTexture,
        "emscripten_glIsVertexArrayOES": _emscripten_glIsVertexArrayOES,
        "emscripten_glLineWidth": _emscripten_glLineWidth,
        "emscripten_glLinkProgram": _emscripten_glLinkProgram,
        "emscripten_glPixelStorei": _emscripten_glPixelStorei,
        "emscripten_glPolygonOffset": _emscripten_glPolygonOffset,
        "emscripten_glQueryCounterEXT": _emscripten_glQueryCounterEXT,
        "emscripten_glReadPixels": _emscripten_glReadPixels,
        "emscripten_glReleaseShaderCompiler": _emscripten_glReleaseShaderCompiler,
        "emscripten_glRenderbufferStorage": _emscripten_glRenderbufferStorage,
        "emscripten_glSampleCoverage": _emscripten_glSampleCoverage,
        "emscripten_glScissor": _emscripten_glScissor,
        "emscripten_glShaderBinary": _emscripten_glShaderBinary,
        "emscripten_glShaderSource": _emscripten_glShaderSource,
        "emscripten_glStencilFunc": _emscripten_glStencilFunc,
        "emscripten_glStencilFuncSeparate": _emscripten_glStencilFuncSeparate,
        "emscripten_glStencilMask": _emscripten_glStencilMask,
        "emscripten_glStencilMaskSeparate": _emscripten_glStencilMaskSeparate,
        "emscripten_glStencilOp": _emscripten_glStencilOp,
        "emscripten_glStencilOpSeparate": _emscripten_glStencilOpSeparate,
        "emscripten_glTexImage2D": _emscripten_glTexImage2D,
        "emscripten_glTexParameterf": _emscripten_glTexParameterf,
        "emscripten_glTexParameterfv": _emscripten_glTexParameterfv,
        "emscripten_glTexParameteri": _emscripten_glTexParameteri,
        "emscripten_glTexParameteriv": _emscripten_glTexParameteriv,
        "emscripten_glTexSubImage2D": _emscripten_glTexSubImage2D,
        "emscripten_glUniform1f": _emscripten_glUniform1f,
        "emscripten_glUniform1fv": _emscripten_glUniform1fv,
        "emscripten_glUniform1i": _emscripten_glUniform1i,
        "emscripten_glUniform1iv": _emscripten_glUniform1iv,
        "emscripten_glUniform2f": _emscripten_glUniform2f,
        "emscripten_glUniform2fv": _emscripten_glUniform2fv,
        "emscripten_glUniform2i": _emscripten_glUniform2i,
        "emscripten_glUniform2iv": _emscripten_glUniform2iv,
        "emscripten_glUniform3f": _emscripten_glUniform3f,
        "emscripten_glUniform3fv": _emscripten_glUniform3fv,
        "emscripten_glUniform3i": _emscripten_glUniform3i,
        "emscripten_glUniform3iv": _emscripten_glUniform3iv,
        "emscripten_glUniform4f": _emscripten_glUniform4f,
        "emscripten_glUniform4fv": _emscripten_glUniform4fv,
        "emscripten_glUniform4i": _emscripten_glUniform4i,
        "emscripten_glUniform4iv": _emscripten_glUniform4iv,
        "emscripten_glUniformMatrix2fv": _emscripten_glUniformMatrix2fv,
        "emscripten_glUniformMatrix3fv": _emscripten_glUniformMatrix3fv,
        "emscripten_glUniformMatrix4fv": _emscripten_glUniformMatrix4fv,
        "emscripten_glUseProgram": _emscripten_glUseProgram,
        "emscripten_glValidateProgram": _emscripten_glValidateProgram,
        "emscripten_glVertexAttrib1f": _emscripten_glVertexAttrib1f,
        "emscripten_glVertexAttrib1fv": _emscripten_glVertexAttrib1fv,
        "emscripten_glVertexAttrib2f": _emscripten_glVertexAttrib2f,
        "emscripten_glVertexAttrib2fv": _emscripten_glVertexAttrib2fv,
        "emscripten_glVertexAttrib3f": _emscripten_glVertexAttrib3f,
        "emscripten_glVertexAttrib3fv": _emscripten_glVertexAttrib3fv,
        "emscripten_glVertexAttrib4f": _emscripten_glVertexAttrib4f,
        "emscripten_glVertexAttrib4fv": _emscripten_glVertexAttrib4fv,
        "emscripten_glVertexAttribDivisorANGLE": _emscripten_glVertexAttribDivisorANGLE,
        "emscripten_glVertexAttribPointer": _emscripten_glVertexAttribPointer,
        "emscripten_glViewport": _emscripten_glViewport,
        "emscripten_has_asyncify": _emscripten_has_asyncify,
        "emscripten_sleep": _emscripten_sleep,
        "eglBindAPI": _eglBindAPI,
        "eglChooseConfig": _eglChooseConfig,
        "eglCreateContext": _eglCreateContext,
        "eglCreateWindowSurface": _eglCreateWindowSurface,
        "eglDestroyContext": _eglDestroyContext,
        "eglDestroySurface": _eglDestroySurface,
        "eglGetConfigAttrib": _eglGetConfigAttrib,
        "eglGetDisplay": _eglGetDisplay,
        "eglGetError": _eglGetError,
        "eglInitialize": _eglInitialize,
        "eglMakeCurrent": _eglMakeCurrent,
        "eglQueryString": _eglQueryString,
        "eglSwapBuffers": _eglSwapBuffers,
        "eglSwapInterval": _eglSwapInterval,
        "eglTerminate": _eglTerminate,
        "eglWaitGL": _eglWaitGL,
        "eglWaitNative": _eglWaitNative,
        "emscripten_asm_const_int": _emscripten_asm_const_int,
        "emscripten_set_beforeunload_callback_on_thread": _emscripten_set_beforeunload_callback_on_thread,
        "emscripten_set_blur_callback_on_thread": _emscripten_set_blur_callback_on_thread,
        "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
        "emscripten_set_element_css_size": _emscripten_set_element_css_size,
        "emscripten_set_focus_callback_on_thread": _emscripten_set_focus_callback_on_thread,
        "emscripten_set_fullscreenchange_callback_on_thread": _emscripten_set_fullscreenchange_callback_on_thread,
        "emscripten_set_gamepadconnected_callback_on_thread": _emscripten_set_gamepadconnected_callback_on_thread,
        "emscripten_set_gamepaddisconnected_callback_on_thread": _emscripten_set_gamepaddisconnected_callback_on_thread,
        "emscripten_set_keydown_callback_on_thread": _emscripten_set_keydown_callback_on_thread,
        "emscripten_set_keypress_callback_on_thread": _emscripten_set_keypress_callback_on_thread,
        "emscripten_set_keyup_callback_on_thread": _emscripten_set_keyup_callback_on_thread,
        "emscripten_set_mousedown_callback_on_thread": _emscripten_set_mousedown_callback_on_thread,
        "emscripten_set_mouseenter_callback_on_thread": _emscripten_set_mouseenter_callback_on_thread,
        "emscripten_set_mouseleave_callback_on_thread": _emscripten_set_mouseleave_callback_on_thread,
        "emscripten_set_mousemove_callback_on_thread": _emscripten_set_mousemove_callback_on_thread,
        "emscripten_set_mouseup_callback_on_thread": _emscripten_set_mouseup_callback_on_thread,
        "emscripten_set_pointerlockchange_callback_on_thread": _emscripten_set_pointerlockchange_callback_on_thread,
        "emscripten_set_resize_callback_on_thread": _emscripten_set_resize_callback_on_thread,
        "emscripten_set_touchcancel_callback_on_thread": _emscripten_set_touchcancel_callback_on_thread,
        "emscripten_set_touchend_callback_on_thread": _emscripten_set_touchend_callback_on_thread,
        "emscripten_set_touchmove_callback_on_thread": _emscripten_set_touchmove_callback_on_thread,
        "emscripten_set_touchstart_callback_on_thread": _emscripten_set_touchstart_callback_on_thread,
        "emscripten_set_visibilitychange_callback_on_thread": _emscripten_set_visibilitychange_callback_on_thread,
        "emscripten_set_wheel_callback_on_thread": _emscripten_set_wheel_callback_on_thread,
        "emscripten_sample_gamepad_data": _emscripten_sample_gamepad_data,
        "emscripten_set_beforeunload_callback_on_thread": _emscripten_set_beforeunload_callback_on_thread,
        "emscripten_set_blur_callback_on_thread": _emscripten_set_blur_callback_on_thread,
        "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
        "emscripten_set_element_css_size": _emscripten_set_element_css_size,
        "emscripten_set_focus_callback_on_thread": _emscripten_set_focus_callback_on_thread,
        "emscripten_set_fullscreenchange_callback_on_thread": _emscripten_set_fullscreenchange_callback_on_thread,
        "emscripten_set_gamepadconnected_callback_on_thread": _emscripten_set_gamepadconnected_callback_on_thread,
        "emscripten_set_gamepaddisconnected_callback_on_thread": _emscripten_set_gamepaddisconnected_callback_on_thread,
        "emscripten_set_keydown_callback_on_thread": _emscripten_set_keydown_callback_on_thread,
        "emscripten_set_keypress_callback_on_thread": _emscripten_set_keypress_callback_on_thread,
        "emscripten_set_keyup_callback_on_thread": _emscripten_set_keyup_callback_on_thread,
        "emscripten_set_mousedown_callback_on_thread": _emscripten_set_mousedown_callback_on_thread,
        "emscripten_set_mouseenter_callback_on_thread": _emscripten_set_mouseenter_callback_on_thread,
        "emscripten_set_mouseleave_callback_on_thread": _emscripten_set_mouseleave_callback_on_thread,
        "emscripten_set_mousemove_callback_on_thread": _emscripten_set_mousemove_callback_on_thread,
        "emscripten_set_mouseup_callback_on_thread": _emscripten_set_mouseup_callback_on_thread,
        "emscripten_set_pointerlockchange_callback_on_thread": _emscripten_set_pointerlockchange_callback_on_thread,
        "emscripten_set_resize_callback_on_thread": _emscripten_set_resize_callback_on_thread,
        "emscripten_set_touchcancel_callback_on_thread": _emscripten_set_touchcancel_callback_on_thread,
        "emscripten_set_touchend_callback_on_thread": _emscripten_set_touchend_callback_on_thread,
        "emscripten_set_touchmove_callback_on_thread": _emscripten_set_touchmove_callback_on_thread,
        "emscripten_set_touchstart_callback_on_thread": _emscripten_set_touchstart_callback_on_thread,
        "emscripten_set_visibilitychange_callback_on_thread": _emscripten_set_visibilitychange_callback_on_thread,
        "emscripten_set_wheel_callback_on_thread": _emscripten_set_wheel_callback_on_thread,
        "emscripten_set_window_title": _emscripten_set_window_title,
        "emscripten_get_gamepad_status": _emscripten_get_gamepad_status,
        "emscripten_request_fullscreen_strategy": _emscripten_request_fullscreen_strategy,
        "emscripten_request_pointerlock": _emscripten_request_pointerlock,
        "emscripten_exit_pointerlock": _emscripten_exit_pointerlock,
        "emscripten_get_device_pixel_ratio": _emscripten_get_device_pixel_ratio,
        "emscripten_exit_fullscreen": _emscripten_exit_fullscreen,
        "emscripten_exit_pointerlock": _emscripten_exit_pointerlock,
        "emscripten_get_device_pixel_ratio": _emscripten_get_device_pixel_ratio,
        "emscripten_get_element_css_size": _emscripten_get_element_css_size,
        "emscripten_get_gamepad_status": _emscripten_get_gamepad_status,

    }
    return sdl_functions;
}


/***/ }),

/***/ "./webinterface/UAudio.ts":
/*!********************************!*\
  !*** ./webinterface/UAudio.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniversalAudio = void 0;
const core_coder_js_1 = __webpack_require__(/*! ./core-coder.js */ "./webinterface/core-coder.js");
const memio_1 = __webpack_require__(/*! ./memio */ "./webinterface/memio.ts");
class UniversalAudio extends HTMLAudioElement {
    get decodingPromise() {
        return this._decodingPromise;
    }
    connectedCallback() {
        const self = this;
        const using_attribute = self.getAttribute("using");
        const with_attribute = self.getAttribute("with").split(';');
        let args = {};
        for (var i = 0, atts = this.attributes, n = atts.length, arr = []; i < n; i++) {
            const nodeName = atts[i].nodeName;
            args[nodeName] = atts[i].nodeValue;
        }
        core_coder_js_1.location.using = using_attribute;
        core_coder_js_1.location.with = with_attribute;
        this.io = new memio_1.fileio();
        this._decodingPromise = new Promise((main_resolve, _main_reject) => {
            with_attribute.push("writegen.wasm");
            with_attribute.push("fileout.wasm");
            with_attribute.push("filein.wasm");
            new core_coder_js_1.Module({
                dynamicLibraries: with_attribute
            }).then(module => {
                self.module = module;
                self.io.module = module;
                self.entry = self.module._constructor();
                let buffer_in = self.io.make_fileio(self.src, true);
                let buffer_out = self.io.make_fileio("out.wav", false);
                args["io_in"] = buffer_in.file_io;
                args["io_out"] = buffer_out.file_io;
                // Set input filters
                args["filters"] = self.module.filter_entries.map(entry => self.module["_" + entry](0));
                Promise.all(self.io.fetch_promises).then(res_fetch => {
                    Promise.all(self.io.buffer_promises).then(res_buffer => {
                        // Convert json to string buffer
                        const json_args = JSON.stringify(args);
                        const len_args = (json_args.length << 2) + 1;
                        const ptr_args = self.module.stackAlloc(len_args);
                        self.module.stringToUTF8(json_args, ptr_args, len_args);
                        // Call set function and decode
                        self.module._set(self.entry, ptr_args);
                        // Retrieve result
                        const props = [];
                        if (self.hasAttribute("connections")) {
                            props.push("connections");
                        }
                        const get_args = JSON.stringify(props);
                        const get_args_len = (get_args.length << 2) + 1;
                        const ptr_get_args = self.module.stackAlloc(get_args_len);
                        self.module.stringToUTF8(get_args, ptr_get_args, get_args_len);
                        const ptr_data = self.module._get(self.entry, ptr_get_args);
                        const json_res = self.module.UTF8ToString(ptr_data);
                        const json_res_parsed = JSON.parse(json_res);
                        const blob = new Blob([buffer_out.buffer_u8], { type: "audio/wave" });
                        self.src = URL.createObjectURL(blob);
                        self.load();
                        main_resolve(self.src);
                    });
                });
            });
        });
    }
    disconnectedCallback() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        switch (name) {
            case 'src':
                break;
            case 'using':
                break;
            case 'with':
                break;
        }
    }
    static get observedAttributes() { return ['src', 'using', 'with']; }
}
exports.UniversalAudio = UniversalAudio;


/***/ }),

/***/ "./webinterface/UCanvas.ts":
/*!*********************************!*\
  !*** ./webinterface/UCanvas.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniversalCanvas = void 0;
const core_player_js_1 = __webpack_require__(/*! ./core-player.js */ "./webinterface/core-player.js");
class UniversalCanvas extends HTMLCanvasElement {
    get decodingPromise() {
        return this._decodingPromise;
    }
    static flush_image(_entry) {
        let self = this;
        const get_args = JSON.stringify([
            "getImage", "getSize", "getWidth", "getHeight"
        ]);
        const get_args_len = (get_args.length << 2) + 1;
        const ptr_get_args = self.instance.stackAlloc(get_args_len);
        self.instance.stringToUTF8(get_args, ptr_get_args, get_args_len);
        const ptr_data = self.instance._get(self.entry, ptr_get_args);
        const json = self.instance.UTF8ToString(ptr_data);
        const json_parsed = JSON.parse(json);
        if (json_parsed.getImage == 0)
            return;
        const image = self.instance.HEAPU8.slice(json_parsed.getImage, json_parsed.getImage + json_parsed.getSize);
        let canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        var imageData = ctx.createImageData(json_parsed.getWidth, json_parsed.getHeight);
        canvas.setAttribute('width', json_parsed.getWidth);
        canvas.setAttribute('height', json_parsed.getHeight);
        const data = imageData.data;
        const len = data.length;
        var i = 0;
        var t = 0;
        for (; i < len; i += 4) {
            data[i] = image[t];
            data[i + 1] = image[t + 1];
            data[i + 2] = image[t + 2];
            data[i + 3] = 255;
            t += 3;
        }
        ctx.putImageData(imageData, 0, 0);
        canvas.toBlob(function (blob) {
            self.src = URL.createObjectURL(blob);
        });
    }
    connectedCallback() {
        const self = this;
        const using_attribute = self.getAttribute("using");
        const with_attribute = self.getAttribute("with").split(';');
        let args = {};
        this.src = self.getAttribute("src");
        for (var i = 0, atts = this.attributes, n = atts.length, arr = []; i < n; i++) {
            const nodeName = atts[i].nodeName;
            args[nodeName] = atts[i].nodeValue;
        }
        core_player_js_1.location.using = using_attribute;
        core_player_js_1.location.with = with_attribute;
        this._decodingPromise = new Promise((main_resolve, _main_reject) => {
            with_attribute.push("writegen.wasm");
            with_attribute.push("rfimg.wasm");
            with_attribute.push("compose.wasm");
            with_attribute.push("pngenc.wasm");
            with_attribute.push("fileout.wasm");
            with_attribute.push("filein.wasm");
            with_attribute.push("sdl_out.wasm");
            with_attribute.push("aout.wasm");
            with_attribute.push("httpin.wasm");
            new core_player_js_1.Module({
                dynamicLibraries: with_attribute,
                canvas: this
            }).then(module => {
                module['canvas'] = this;
                self.module = module;
                self.entry = self.module._constructor();
                // Set input filters
                args["filters"] = self.module.filter_entries.map(entry => self.module["_" + entry](0));
                args["modules"] = self.module.module_entries.map(entry => self.module["_" + entry]());
                // Convert json to string buffer
                const json_args = JSON.stringify(args);
                const len_args = (json_args.length << 2) + 1;
                const ptr_args = self.module.stackAlloc(len_args);
                self.module.stringToUTF8(json_args, ptr_args, len_args);
                // Call set function and decode
                self.module._set(self.entry, ptr_args);
                // Retrieve result
                const props = [];
                if (self.hasAttribute("connections")) {
                    props.push("connections");
                }
                const get_args = JSON.stringify(props);
                const get_args_len = (get_args.length << 2) + 1;
                const ptr_get_args = self.module.stackAlloc(get_args_len);
                self.module.stringToUTF8(get_args, ptr_get_args, get_args_len);
                const ptr_data = self.module._get(self.entry, ptr_get_args);
                const json_res = self.module.UTF8ToString(ptr_data);
                const json_res_parsed = JSON.parse(json_res);
                function call() {
                    self.module._run(self.entry);
                    setTimeout(call, 1);
                }
                setTimeout(call, 1);
            });
        });
    }
    disconnectedCallback() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        switch (name) {
            case 'src':
                break;
            case 'using':
                break;
            case 'with':
                break;
        }
    }
    static get observedAttributes() { return ['src', 'using', 'with']; }
}
exports.UniversalCanvas = UniversalCanvas;


/***/ }),

/***/ "./webinterface/UImage.ts":
/*!********************************!*\
  !*** ./webinterface/UImage.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniversalImage = void 0;
const core_coder_js_1 = __webpack_require__(/*! ./core-coder.js */ "./webinterface/core-coder.js");
const memio_1 = __webpack_require__(/*! ./memio */ "./webinterface/memio.ts");
//declare var Module: any;
class UniversalImage extends HTMLImageElement {
    get decodingPromise() {
        return this._decodingPromise;
    }
    static flush_image(_entry) {
        let self = this;
        const get_args = JSON.stringify([
            "getImage", "getSize", "getWidth", "getHeight"
        ]);
        const get_args_len = (get_args.length << 2) + 1;
        const ptr_get_args = self.instance.stackAlloc(get_args_len);
        self.instance.stringToUTF8(get_args, ptr_get_args, get_args_len);
        const ptr_data = self.instance._get(self.entry, ptr_get_args);
        const json = self.instance.UTF8ToString(ptr_data);
        const json_parsed = JSON.parse(json);
        if (json_parsed.getImage == 0)
            return;
        const image = self.instance.HEAPU8.slice(json_parsed.getImage, json_parsed.getImage + json_parsed.getSize);
        let canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        var imageData = ctx.createImageData(json_parsed.getWidth, json_parsed.getHeight);
        canvas.setAttribute('width', json_parsed.getWidth);
        canvas.setAttribute('height', json_parsed.getHeight);
        const data = imageData.data;
        const len = data.length;
        var i = 0;
        var t = 0;
        for (; i < len; i += 4) {
            data[i] = image[t];
            data[i + 1] = image[t + 1];
            data[i + 2] = image[t + 2];
            data[i + 3] = 255;
            t += 3;
        }
        ctx.putImageData(imageData, 0, 0);
        canvas.toBlob(function (blob) {
            self.srcset = URL.createObjectURL(blob);
        });
    }
    connectedCallback() {
        const self = this;
        const using_attribute = self.getAttribute("using");
        const with_attribute = self.getAttribute("with").split(';');
        let args = {};
        for (var i = 0, atts = this.attributes, n = atts.length, arr = []; i < n; i++) {
            const nodeName = atts[i].nodeName;
            args[nodeName] = atts[i].nodeValue;
        }
        core_coder_js_1.location.using = using_attribute;
        core_coder_js_1.location.with = with_attribute;
        this.io = new memio_1.fileio();
        this._decodingPromise = new Promise((main_resolve, _main_reject) => {
            with_attribute.push("writegen.wasm");
            with_attribute.push("rfimg.wasm");
            with_attribute.push("pngenc.wasm");
            with_attribute.push("fileout.wasm");
            with_attribute.push("filein.wasm");
            new core_coder_js_1.Module({
                dynamicLibraries: with_attribute
            }).then(module => {
                self.module = module;
                self.io.module = module;
                self.entry = self.module._constructor();
                let buffer_in = self.io.make_fileio(self.src, true);
                let buffer_out = self.io.make_fileio("out.png", false);
                args["io_in"] = buffer_in.file_io;
                args["io_out"] = buffer_out.file_io;
                // Set input filters
                args["filters"] = self.module.filter_entries.map(entry => self.module["_" + entry](0));
                Promise.all(self.io.fetch_promises).then(res_fetch => {
                    Promise.all(self.io.buffer_promises).then(res_buffer => {
                        // Convert json to string buffer
                        const json_args = JSON.stringify(args);
                        const len_args = (json_args.length << 2) + 1;
                        const ptr_args = self.module.stackAlloc(len_args);
                        self.module.stringToUTF8(json_args, ptr_args, len_args);
                        // Call set function and decode
                        self.module._set(self.entry, ptr_args);
                        // Retrieve result
                        const props = [];
                        if (self.hasAttribute("connections")) {
                            props.push("connections");
                        }
                        const get_args = JSON.stringify(props);
                        const get_args_len = (get_args.length << 2) + 1;
                        const ptr_get_args = self.module.stackAlloc(get_args_len);
                        self.module.stringToUTF8(get_args, ptr_get_args, get_args_len);
                        const ptr_data = self.module._get(self.entry, ptr_get_args);
                        const json_res = self.module.UTF8ToString(ptr_data);
                        const json_res_parsed = JSON.parse(json_res);
                        const blob = new Blob([buffer_out.buffer_u8]);
                        self.srcset = URL.createObjectURL(blob);
                        main_resolve(self.srcset);
                    });
                });
            });
        });
    }
    disconnectedCallback() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        switch (name) {
            case 'src':
                console.log("src has changed");
                break;
            case 'using':
                break;
            case 'with':
                break;
        }
    }
    static get observedAttributes() { return ['src', 'using', 'with']; }
}
exports.UniversalImage = UniversalImage;


/***/ }),

/***/ "./webinterface/UVideo.ts":
/*!********************************!*\
  !*** ./webinterface/UVideo.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UniversalVideo = void 0;
const core_coder_js_1 = __webpack_require__(/*! ./core-coder.js */ "./webinterface/core-coder.js");
const memio_1 = __webpack_require__(/*! ./memio */ "./webinterface/memio.ts");
class UniversalVideo extends HTMLVideoElement {
    get decodingPromise() {
        return this._decodingPromise;
    }
    connectedCallback() {
        const self = this;
        const using_attribute = self.getAttribute("using");
        const with_attribute = self.getAttribute("with").split(';');
        let args = {};
        for (var i = 0, atts = this.attributes, n = atts.length, arr = []; i < n; i++) {
            const nodeName = atts[i].nodeName;
            args[nodeName] = atts[i].nodeValue;
        }
        core_coder_js_1.location.using = using_attribute;
        core_coder_js_1.location.with = with_attribute;
        this.io = new memio_1.fileio();
        this._decodingPromise = new Promise((main_resolve, _main_reject) => {
            with_attribute.push("writegen.wasm");
            new core_coder_js_1.Module({
                dynamicLibraries: with_attribute
            }).then(module => {
                self.module = module;
                self.io.module = module;
                self.entry = self.module._constructor();
                let buffer_in = self.io.make_fileio(self.src, true);
                let buffer_out = self.io.make_fileio("out.mp4", false);
                args["io_in"] = buffer_in.file_io;
                args["io_out"] = buffer_out.file_io;
                // Set input filters
                args["filters"] = self.module.filter_entries.map(entry => self.module["_" + entry](0));
                Promise.all(self.io.fetch_promises).then(res_fetch => {
                    Promise.all(self.io.buffer_promises).then(res_buffer => {
                        // Convert json to string buffer
                        const json_args = JSON.stringify(args);
                        const len_args = (json_args.length << 2) + 1;
                        const ptr_args = self.module.stackAlloc(len_args);
                        self.module.stringToUTF8(json_args, ptr_args, len_args);
                        // Call set function and decode
                        self.module._set(self.entry, ptr_args);
                        // Retrieve result
                        const props = [];
                        if (self.hasAttribute("connections")) {
                            props.push("connections");
                        }
                        const get_args = JSON.stringify(props);
                        const get_args_len = (get_args.length << 2) + 1;
                        const ptr_get_args = self.module.stackAlloc(get_args_len);
                        self.module.stringToUTF8(get_args, ptr_get_args, get_args_len);
                        const ptr_data = self.module._get(self.entry, ptr_get_args);
                        const json_res = self.module.UTF8ToString(ptr_data);
                        const json_res_parsed = JSON.parse(json_res);
                        const blob = new Blob([buffer_out.buffer_u8], { type: "video/mp4" });
                        self.src = URL.createObjectURL(blob);
                        self.load();
                        main_resolve(self.src);
                    });
                });
            });
        });
    }
    disconnectedCallback() {
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
            return;
        switch (name) {
            case 'src':
                break;
            case 'using':
                break;
            case 'with':
                break;
        }
    }
    static get observedAttributes() { return ['src', 'using', 'with']; }
}
exports.UniversalVideo = UniversalVideo;


/***/ }),

/***/ "./webinterface/memio.ts":
/*!*******************************!*\
  !*** ./webinterface/memio.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileio = void 0;
const core_coder_js_1 = __webpack_require__(/*! ./core-coder.js */ "./webinterface/core-coder.js");
class buffer {
    constructor(src, src_ptr, write) {
        this.p = 0;
        this.nb_refs = 0;
        this.src = src;
        this.src_ptr = src_ptr;
        this.write = write;
    }
    open(mode) {
        switch (mode[0]) {
            case "r":
                this.buffer_u8 = new Uint8Array(this.buffer);
                break;
            case "w":
                this.buffer_u8 = new Uint8Array(0);
                break;
        }
    }
    size() {
        return this.buffer_u8.length;
    }
}
class fileio {
    constructor() {
        this.fetch_promises = new Array();
        this.buffer_promises = new Array();
        this.io_ctxs = new Array();
        this.SEEK_SET = 0;
        this.SEEK_CUR = 1;
        this.SEEK_END = 2;
        this.createIO();
    }
    createIO() {
        this.read = function (fileio, buffer, bytes) {
            const ioctx_id = this.module._gf_fileio_get_udta(fileio);
            const mem = this.io_ctxs[ioctx_id];
            //console.log("reading from "+mem.p+" to "+ (mem.p+bytes));
            let remaining = mem.buffer_u8.length - mem.p;
            if (bytes > remaining) {
                this.module.HEAPU8.set(mem.buffer_u8.slice(mem.p, mem.p + remaining), buffer);
                mem.p += remaining;
                return remaining;
            }
            this.module.HEAPU8.set(mem.buffer_u8.slice(mem.p, mem.p + bytes), buffer);
            mem.p += bytes;
            return bytes;
        }.bind(this);
        this.read.sig = ['i', 'i', 'i', 'i'];
        this.write = function (fileio, buffer, bytes) {
            const ioctx_id = this.module._gf_fileio_get_udta(fileio);
            const mem = this.io_ctxs[ioctx_id];
            //console.log("write from "+mem.p+" to "+ (mem.p+bytes));
            let remaining = mem.buffer_u8.length - mem.p;
            if (bytes > remaining) {
                let new_size = bytes + mem.buffer_u8.length - remaining;
                let old_buffer = mem.buffer_u8;
                mem.buffer_u8 = new Uint8Array(new_size);
                mem.buffer_u8.set(old_buffer);
            }
            mem.buffer_u8.set(this.module.HEAPU8.slice(buffer, buffer + bytes), mem.p);
            mem.p += bytes;
            return bytes;
        }.bind(this);
        this.write.sig = ['i', 'i', 'i', 'i'];
        this.seek = function (fileio, offset, whence) {
            const ioctx_id = this.module._gf_fileio_get_udta(fileio);
            const mem = this.io_ctxs[ioctx_id];
            //console.log("seek from "+offset+" with "+ whence);
            switch (whence) {
                case this.SEEK_SET:
                    mem.p = Number(offset);
                    break;
                case this.SEEK_CUR:
                    mem.p += Number(offset);
                    break;
                case this.SEEK_END:
                    mem.p = mem.buffer_u8.length + Number(offset);
                    break;
            }
            return 0;
        }.bind(this);
        this.seek.sig = ['i', 'i', 'j', 'i'];
        this.tell = function (fileio) {
            const ioctx_id = this.module._gf_fileio_get_udta(fileio);
            const mem = this.io_ctxs[ioctx_id];
            //console.log("tell : " + mem.p);
            return BigInt(mem.p);
        }.bind(this);
        this.tell.sig = ['j', 'i'];
        this.eof = function (fileio) {
            const ioctx_id = this.module._gf_fileio_get_udta(fileio);
            const mem = this.io_ctxs[ioctx_id];
            /*if(mem.p == mem.buffer_u8.length){
                console.log("eof  : true");
            }else{
                console.log("eof  : false");
            }*/
            return mem.p == mem.buffer_u8.length;
        }.bind(this);
        this.eof.sig = ['i', 'i'];
        this.printf = function (fileio, format, args) {
            console.log("printf  ");
            console.log("memio printf has to be implemented");
            return 0;
        };
        this.printf.sig = ['i', 'i', 'i', 'i'];
        this.open = function (fileio_ref, url_ptr, mode_ptr, out_err) {
            //console.log("open  ");
            const mode = this.module.UTF8ToString(mode_ptr);
            const url = this.module.UTF8ToString(url_ptr);
            const ioctx_id = this.module._gf_fileio_get_udta(fileio_ref);
            const cur_buffer = this.io_ctxs[ioctx_id];
            this.module.HEAP32[((out_err) >> 2)] = 0; //GF_OK
            if (mode == "ref") {
                cur_buffer.nb_refs++;
                return fileio_ref;
            }
            if (mode == "unref") {
                if (!cur_buffer.nb_refs)
                    return 0;
                cur_buffer.nb_refs--;
                if (cur_buffer.nb_refs)
                    return fileio_ref;
                this.module.HEAP8[url] = 0;
            }
            if (mode == "url") {
                if (!url_ptr)
                    return 0;
                const path_ptr = this.module._gf_url_concatenate(cur_buffer.src_ptr, url_ptr);
                const path = this.module.UTF8ToString(path_ptr);
                let new_buffer = new buffer(path, path_ptr, cur_buffer.is_input);
                let buffer_idx = this.io_ctxs.push(new_buffer);
                const gfio = this.module._gf_fileio_new(path_ptr, buffer_idx - 1, this.open.value, this.seek.value, this.read.value, this.write.value, this.tell.value, this.eof.value, this.printf.value);
                return gfio;
            }
            if (mode == "probe") {
                if (!this.module._gf_file_exists(url_ptr)) {
                    this.module.HEAP32[((out_err) >> 2)] = -12; //GF_URL_ERROR
                }
                return 0;
            }
            if (!url_ptr) {
                if (!cur_buffer.nb_refs) {
                    this.io_ctxs.splice(ioctx_id, 1);
                }
                return 0;
            }
            //file handle not opened, we can use the current gfio
            if (!cur_buffer.buffer_u8 && url.startsWith("gfio://") || url == cur_buffer.src) {
                cur_buffer.open(mode);
                //in test mode we want to use our ftell and fseek wrappers
                if (mode[0] == 'r') {
                    this.module._gf_fileio_set_stats_u32(fileio_ref, cur_buffer.size(), cur_buffer.size(), 1, 0);
                }
                return fileio_ref;
            }
            let gfio = null;
            let ioctx = null;
            let ioctx_idx = 0;
            let no_concatenate = false;
            let new_buffer = null;
            for (let i = 0; i < this.io_ctxs.length; i++) {
                ioctx = this.io_ctxs[i];
                if (ioctx.src == url) {
                    if (ioctx.buffer_u8) {
                        no_concatenate = true;
                        ioctx = null;
                    }
                    ioctx_idx = i;
                    break;
                }
                ioctx = null;
            }
            if (!ioctx) {
                let path_ptr = null;
                if (url.startsWith("gfio://")) {
                    if (no_concatenate) {
                        path_ptr = this.module._gf_strdup(url_ptr);
                    }
                    else {
                        path_ptr = this.module._gf_url_concatenate(cur_buffer.src_ptr, url_ptr);
                    }
                }
                else {
                    path_ptr = this.module.gf_strdup(cur_buffer.src_ptr);
                }
                new_buffer = new buffer(url, path_ptr, cur_buffer.is_input);
                new_buffer.buffer = cur_buffer.buffer;
                new_buffer.open(mode);
                let buffer_idx = this.io_ctxs.push(new_buffer);
                gfio = this.module._gf_fileio_new(path_ptr, buffer_idx - 1, this.open.value, this.seek.value, this.read.value, this.write.value, this.tell.value, this.eof.value, this.printf.value);
                if (mode[0] == 'r') {
                    this.module._gf_fileio_set_stats_u32(fileio_ref, cur_buffer.size(), cur_buffer.size(), 1, 0);
                }
            }
            return gfio;
        }.bind(this);
        this.open.sig = ['i', 'i', 'i', 'i', 'i'];
        core_coder_js_1.memio.push(this.read, this.write, this.open, this.seek, this.tell, this.eof, this.printf, this.open);
    }
    make_fileio(src, is_input) {
        const len_source_str = (src.length << 2) + 1;
        const ptr_source_str = this.module.stackAlloc(len_source_str);
        this.module.stringToUTF8(src, ptr_source_str, len_source_str);
        let new_buffer = new buffer(src, ptr_source_str, is_input);
        let buffer_idx = this.io_ctxs.push(new_buffer);
        const fio = this.module._gf_fileio_new(ptr_source_str, buffer_idx - 1, this.open.value, this.seek.value, this.read.value, this.write.value, this.tell.value, this.eof.value, this.printf.value);
        const fio_url_ptr = this.module._gf_fileio_url(fio);
        if (is_input) {
            const fetch_promise = fetch(src);
            this.fetch_promises.push(fetch_promise);
            fetch_promise.then(response => {
                const buffer_promise = response.arrayBuffer();
                this.buffer_promises.push(buffer_promise);
                buffer_promise.then(buffer => {
                    new_buffer.buffer = buffer;
                });
            });
        }
        new_buffer.file_io = this.module.UTF8ToString(fio_url_ptr);
        return new_buffer;
    }
}
exports.fileio = fileio;


/***/ }),

/***/ "./node_modules/webpack/hot sync ^\\.\\/log$":
/*!***************************************************************!*\
  !*** ./node_modules/webpack/hot/ sync nonrecursive ^\.\/log$ ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./log": "./node_modules/webpack/hot/log.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/webpack/hot sync ^\\.\\/log$";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
var exports = {};
/*!*******************************!*\
  !*** ./webinterface/index.ts ***!
  \*******************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
//import {UniversalCanvas} from "./UCanvas"
const UImage_1 = __webpack_require__(/*! ./UImage */ "./webinterface/UImage.ts");
const UAudio_1 = __webpack_require__(/*! ./UAudio */ "./webinterface/UAudio.ts");
const UVideo_1 = __webpack_require__(/*! ./UVideo */ "./webinterface/UVideo.ts");
const UCanvas_1 = __webpack_require__(/*! ./UCanvas */ "./webinterface/UCanvas.ts");
if (!customElements.get('universal-img')) {
    customElements.define('universal-img', UImage_1.UniversalImage, { extends: 'img' });
}
if (!customElements.get('universal-audio')) {
    customElements.define('universal-audio', UAudio_1.UniversalAudio, { extends: 'audio' });
}
if (!customElements.get('universal-video')) {
    customElements.define('universal-video', UVideo_1.UniversalVideo, { extends: 'video' });
}
if (!customElements.get('universal-canvas')) {
    customElements.define('universal-canvas', UCanvas_1.UniversalCanvas, { extends: 'canvas' });
}

})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*******************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?http://localhost:8081 ***!
  \*******************************************************************************/
var __resourceQuery = "?http://localhost:8081";

/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(/*! strip-ansi */ "./node_modules/webpack-dev-server/node_modules/strip-ansi/index.js");

var socket = __webpack_require__(/*! ./socket */ "./node_modules/webpack-dev-server/client/socket.js");

var overlay = __webpack_require__(/*! ./overlay */ "./node_modules/webpack-dev-server/client/overlay.js");

var _require = __webpack_require__(/*! ./utils/log */ "./node_modules/webpack-dev-server/client/utils/log.js"),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(/*! ./utils/sendMessage */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");

var reloadApp = __webpack_require__(/*! ./utils/reloadApp */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");

var createSocketUrl = __webpack_require__(/*! ./utils/createSocketUrl */ "./node_modules/webpack-dev-server/client/utils/createSocketUrl.js");

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__("./node_modules/webpack/hot sync ^\\.\\/log$");

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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b0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQSxxRUFBcUU7QUFDckUsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3hTRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvRGE7O0FBRWIsY0FBYyxHQUFHLDJGQUFtQztBQUNwRCxjQUFjLEdBQUcsK0ZBQXVDOzs7Ozs7Ozs7Ozs7QUNIeEQ7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pNQTtBQUNBOzs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25EQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3a0JBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFtQixLQUEwQjtBQUM3QztBQUNBLGtCQUFrQixLQUF5QjtBQUMzQztBQUNBLHlCQUF5QixxQkFBTSxnQkFBZ0IscUJBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekIsMENBQTBDLHFCQUFxQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxpQkFBaUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBRVU7QUFDWjtBQUNBLEVBQUUsbUNBQW1CO0FBQ3JCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osR0FBRyxLQUFLLEVBVU47O0FBRUYsQ0FBQzs7Ozs7Ozs7Ozs7O0FDamhCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsMENBQVE7O0FBRTNCLGFBQWE7QUFDYixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLGNBQWM7O0FBRWQsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQUs7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixtQkFBTyxDQUFDLHdEQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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T0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtB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Qix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsaUNBQWlDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0EsS0FBSztBQUNMLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9FQUFvRTtBQUNoSSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQ0FBaUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNB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QUFDQSxrQkFBa0I7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxpQ0FBaUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBLGtDQUFrQyx3REFBVTtBQUM1QyxrQ0FBa0MsNERBQVk7QUFDOUM7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQzFCLFVBQVU7QUFDViwwREFBMEQ7QUFDMUQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsK0RBQStELG1CQUFtQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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VjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9DQUFvQyxHQUFHO0FBQ3BFLGdCQUFnQixvREFBb0Q7QUFDcEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4eklBLG1HQUFrRDtBQUNsRCw4RUFBZ0M7QUFFaEMsTUFBTSxjQUFlLFNBQVEsZ0JBQWdCO0lBY3pDLElBQUksZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQ2pDLENBQUM7SUFFRCxpQkFBaUI7UUFDYixNQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFDbEIsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RCxJQUFJLElBQUksR0FBUSxFQUFFLENBQUM7UUFFbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDdEM7UUFFRCx3QkFBUSxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUM7UUFDakMsd0JBQVEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDO1FBQy9CLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxjQUFNLEVBQUUsQ0FBQztRQUV2QixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLEVBQUU7WUFDL0QsY0FBYyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNyQyxjQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3BDLGNBQWMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbkMsSUFBSyxzQkFBYyxDQUFDO2dCQUNoQixnQkFBZ0IsRUFBRSxjQUFjO2FBQ25DLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ3JCLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUN4QyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNwRCxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3ZELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztnQkFFcEMsb0JBQW9CO2dCQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFdkYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDakQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTt3QkFFbkQsZ0NBQWdDO3dCQUNoQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUN2QyxNQUFNLFFBQVEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUM3QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFeEQsK0JBQStCO3dCQUMvQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUV2QyxrQkFBa0I7d0JBQ2xCLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQzt3QkFDakIsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFOzRCQUNsQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO3lCQUM3Qjt3QkFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUV2QyxNQUFNLFlBQVksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUNoRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFFMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFFL0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFDNUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQ3BELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBRTdDLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFHLFlBQVksRUFBQyxDQUFDLENBQUM7d0JBQ3JFLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDbkMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO3dCQUNkLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzNCLENBQUMsQ0FBQyxDQUFDO2dCQUNQLENBQUMsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFHRCxvQkFBb0I7SUFFcEIsQ0FBQztJQUVELHdCQUF3QixDQUFDLElBQVksRUFBRSxRQUFnQixFQUFFLFFBQWdCO1FBQ3JFLElBQUksUUFBUSxLQUFLLFFBQVE7WUFBRSxPQUFPO1FBQ2xDLFFBQVEsSUFBSSxFQUFFO1lBQ1YsS0FBSyxLQUFLO2dCQUNOLE1BQU07WUFDVixLQUFLLE9BQU87Z0JBQ1IsTUFBTTtZQUNWLEtBQUssTUFBTTtnQkFDUCxNQUFNO1NBQ2I7SUFDTCxDQUFDO0lBRUQsTUFBTSxLQUFLLGtCQUFrQixLQUFLLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN2RTtBQUVRLHdDQUFjOzs7Ozs7Ozs7Ozs7O0FDbEh2QixzR0FBbUQ7QUFFbkQsTUFBTSxlQUFnQixTQUFRLGlCQUFpQjtJQWMzQyxJQUFJLGVBQWU7UUFDZixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUNqQyxDQUFDO0lBRUQsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFjO1FBQzdCLElBQUksSUFBSSxHQUFHLElBQVcsQ0FBQztRQUV2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQzVCLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFdBQVc7U0FDakQsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxZQUFZLEdBQUcsQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUU1RCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRWpFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFOUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVyQyxJQUFJLFdBQVcsQ0FBQyxRQUFRLElBQUksQ0FBQztZQUFFLE9BQU87UUFFdEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFM0csSUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLElBQUksU0FBUyxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDakYsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNyRCxNQUFNLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDO1FBQzVCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDeEIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRVYsT0FBTyxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzNCLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBRWxCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDVjtRQUVELEdBQUcsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVsQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsSUFBSTtZQUN4QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekMsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUdELGlCQUFpQjtRQUNiLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25ELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVELElBQUksSUFBSSxHQUFRLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzNFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDdEM7UUFFRCx5QkFBUSxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUM7UUFDakMseUJBQVEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDO1FBRS9CLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLE9BQU8sQ0FBQyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsRUFBRTtZQUMvRCxjQUFjLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQ3JDLGNBQWMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDbEMsY0FBYyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNwQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ25DLGNBQWMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDcEMsY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNuQyxjQUFjLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3BDLGNBQWMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDakMsY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVuQyxJQUFLLHVCQUFjLENBQUM7Z0JBQ2hCLGdCQUFnQixFQUFFLGNBQWM7Z0JBQ2hDLE1BQU0sRUFBQyxJQUFJO2FBQ2QsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDYixNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDO2dCQUN4QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUV4QyxvQkFBb0I7Z0JBQ3BCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN2RixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUc5RSxnQ0FBZ0M7Z0JBQ2hDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZDLE1BQU0sUUFBUSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQzdDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUV4RCwrQkFBK0I7Z0JBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBRXZDLGtCQUFrQjtnQkFDbEIsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO2dCQUNqQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQUU7b0JBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7aUJBQzdCO2dCQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBRXZDLE1BQU0sWUFBWSxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUUxRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUUvRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUM1RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDcEQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFFN0MsU0FBUyxJQUFJO29CQUNULElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDN0IsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztnQkFDRCxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsb0JBQW9CO0lBRXBCLENBQUM7SUFFRCx3QkFBd0IsQ0FBQyxJQUFZLEVBQUUsUUFBZ0IsRUFBRSxRQUFnQjtRQUNyRSxJQUFJLFFBQVEsS0FBSyxRQUFRO1lBQUUsT0FBTztRQUNsQyxRQUFRLElBQUksRUFBRTtZQUNWLEtBQUssS0FBSztnQkFDTixNQUFNO1lBQ1YsS0FBSyxPQUFPO2dCQUNSLE1BQU07WUFDVixLQUFLLE1BQU07Z0JBQ1AsTUFBTTtTQUNiO0lBQ0wsQ0FBQztJQUVELE1BQU0sS0FBSyxrQkFBa0IsS0FBSyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdkU7QUFFUSwwQ0FBZTs7Ozs7Ozs7Ozs7OztBQ2hLeEIsbUdBQWtEO0FBQ2xELDhFQUE4QjtBQUU5QiwwQkFBMEI7QUFFMUIsTUFBTSxjQUFlLFNBQVEsZ0JBQWdCO0lBY3pDLElBQUksZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0lBQ2pDLENBQUM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQWM7UUFDN0IsSUFBSSxJQUFJLEdBQUcsSUFBVyxDQUFDO1FBRXZCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDNUIsVUFBVSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsV0FBVztTQUNqRCxDQUFDLENBQUM7UUFDSCxNQUFNLFlBQVksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRTVELElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFakUsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztRQUU5RCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsRCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXJDLElBQUksV0FBVyxDQUFDLFFBQVEsSUFBSSxDQUFDO1lBQUUsT0FBTztRQUV0QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUzRyxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlDLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsSUFBSSxTQUFTLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRixNQUFNLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDNUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDVixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFVixPQUFPLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25CLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMzQixJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFFbEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNWO1FBRUQsR0FBRyxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJO1lBQ3hCLElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUM7SUFDTixDQUFDO0lBR0QsaUJBQWlCO1FBQ2IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUQsSUFBSSxJQUFJLEdBQVEsRUFBRSxDQUFDO1FBRW5CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMzRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1NBQ3RDO1FBRUQsd0JBQVEsQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDO1FBQ2pDLHdCQUFRLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUMvQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksY0FBTSxFQUFFLENBQUM7UUFFdkIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxFQUFFO1lBQy9ELGNBQWMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDckMsY0FBYyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNsQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ25DLGNBQWMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDcEMsY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNuQyxJQUFLLHNCQUFjLENBQUM7Z0JBQ2hCLGdCQUFnQixFQUFFLGNBQWM7YUFDbkMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDYixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDckIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO2dCQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ3hDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ3BELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7Z0JBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDO2dCQUVwQyxvQkFBb0I7Z0JBQ3BCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUV2RixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUNqRCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO3dCQUVuRCxnQ0FBZ0M7d0JBQ2hDLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ3ZDLE1BQU0sUUFBUSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzdDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO3dCQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUV4RCwrQkFBK0I7d0JBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7d0JBRXZDLGtCQUFrQjt3QkFDbEIsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO3dCQUNqQixJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQUU7NEJBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7eUJBQzdCO3dCQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBRXZDLE1BQU0sWUFBWSxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQ2hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO3dCQUUxRCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDO3dCQUUvRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO3dCQUM1RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFDcEQsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFFN0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzt3QkFDOUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUN4QyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUM5QixDQUFDLENBQUMsQ0FBQztnQkFDUCxDQUFDLENBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsb0JBQW9CO0lBRXBCLENBQUM7SUFFRCx3QkFBd0IsQ0FBQyxJQUFZLEVBQUUsUUFBZ0IsRUFBRSxRQUFnQjtRQUNyRSxJQUFJLFFBQVEsS0FBSyxRQUFRO1lBQUUsT0FBTztRQUNsQyxRQUFRLElBQUksRUFBRTtZQUNWLEtBQUssS0FBSztnQkFDTixPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7Z0JBQy9CLE1BQU07WUFDVixLQUFLLE9BQU87Z0JBQ1IsTUFBTTtZQUNWLEtBQUssTUFBTTtnQkFDUCxNQUFNO1NBQ2I7SUFDTCxDQUFDO0lBRUQsTUFBTSxLQUFLLGtCQUFrQixLQUFLLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN2RTtBQUVRLHdDQUFjOzs7Ozs7Ozs7Ozs7O0FDbEt2QixtR0FBa0Q7QUFDbEQsOEVBQWdDO0FBRWhDLE1BQU0sY0FBZSxTQUFRLGdCQUFnQjtJQWN6QyxJQUFJLGVBQWU7UUFDZixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUNqQyxDQUFDO0lBRUQsaUJBQWlCO1FBQ2IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkQsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUQsSUFBSSxJQUFJLEdBQVEsRUFBRSxDQUFDO1FBRW5CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMzRSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1NBQ3RDO1FBRUQsd0JBQVEsQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDO1FBQ2pDLHdCQUFRLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUMvQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksY0FBTSxFQUFFLENBQUM7UUFFdkIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxFQUFFO1lBQy9ELGNBQWMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDckMsSUFBSyxzQkFBYyxDQUFDO2dCQUNoQixnQkFBZ0IsRUFBRSxjQUFjO2FBQ25DLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ3JCLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztnQkFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO2dCQUN4QyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNwRCxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3ZELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO2dCQUNsQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztnQkFFcEMsb0JBQW9CO2dCQUNwQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFdkYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDakQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTt3QkFFbkQsZ0NBQWdDO3dCQUNoQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUN2QyxNQUFNLFFBQVEsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUM3QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFFeEQsK0JBQStCO3dCQUMvQixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3dCQUV2QyxrQkFBa0I7d0JBQ2xCLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQzt3QkFDakIsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFOzRCQUNsQyxLQUFLLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO3lCQUM3Qjt3QkFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUV2QyxNQUFNLFlBQVksR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUNoRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQzt3QkFFMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFFL0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQzt3QkFDNUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBQ3BELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7d0JBRTdDLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUMsSUFBSSxFQUFHLFdBQVcsRUFBQyxDQUFDLENBQUM7d0JBQ3BFLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQzt3QkFDbkMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO3dCQUNkLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzNCLENBQUMsQ0FBQyxDQUFDO2dCQUNQLENBQUMsQ0FBQyxDQUFDO1lBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFHRCxvQkFBb0I7SUFFcEIsQ0FBQztJQUVELHdCQUF3QixDQUFDLElBQVksRUFBRSxRQUFnQixFQUFFLFFBQWdCO1FBQ3JFLElBQUksUUFBUSxLQUFLLFFBQVE7WUFBRSxPQUFPO1FBQ2xDLFFBQVEsSUFBSSxFQUFFO1lBQ1YsS0FBSyxLQUFLO2dCQUNOLE1BQU07WUFDVixLQUFLLE9BQU87Z0JBQ1IsTUFBTTtZQUNWLEtBQUssTUFBTTtnQkFDUCxNQUFNO1NBQ2I7SUFDTCxDQUFDO0lBRUQsTUFBTSxLQUFLLGtCQUFrQixLQUFLLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN2RTtBQUVRLHdDQUFjOzs7Ozs7Ozs7Ozs7O0FDakh2QixtR0FBdUM7QUFFdkMsTUFBTSxNQUFNO0lBVVIsWUFBWSxHQUFVLEVBQUUsT0FBVyxFQUFFLEtBQWE7UUFObEQsTUFBQyxHQUFVLENBQUMsQ0FBQztRQUNiLFlBQU8sR0FBVSxDQUFDLENBQUM7UUFNZixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxJQUFJLENBQUMsSUFBVztRQUNaLFFBQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFDO1lBQ1gsS0FBSyxHQUFHO2dCQUNKLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUM3QyxNQUFNO1lBRVYsS0FBSyxHQUFHO2dCQUNKLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ25DLE1BQU07U0FDYjtJQUNMLENBQUM7SUFFRCxJQUFJO1FBQ0EsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztJQUNqQyxDQUFDO0NBQ0o7QUFFRCxNQUFNLE1BQU07SUFpQlI7UUFoQkEsbUJBQWMsR0FBc0IsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUNoRCxvQkFBZSxHQUF5QixJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ3BELFlBQU8sR0FBVyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBU3JCLGFBQVEsR0FBRyxDQUFDLENBQUM7UUFDYixhQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsYUFBUSxHQUFHLENBQUMsQ0FBQztRQUlsQixJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQUVELFFBQVE7UUFDSixJQUFJLENBQUMsSUFBSSxHQUFHLFVBQVUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLO1lBQ3ZDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuQywyREFBMkQ7WUFDM0QsSUFBSSxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUU3QyxJQUFJLEtBQUssR0FBRyxTQUFTLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBQzlFLEdBQUcsQ0FBQyxDQUFDLElBQUksU0FBUyxDQUFDO2dCQUNuQixPQUFPLFNBQVMsQ0FBQzthQUNwQjtZQUVELElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDMUUsR0FBRyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUM7WUFDZixPQUFPLEtBQUssQ0FBQztRQUNqQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBQyxHQUFHLENBQUMsQ0FBQztRQUVwQyxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLO1lBQ3hDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuQyx5REFBeUQ7WUFDekQsSUFBSSxTQUFTLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUU3QyxJQUFJLEtBQUssR0FBRyxTQUFTLEVBQUU7Z0JBQ25CLElBQUksUUFBUSxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7Z0JBQ3hELElBQUksVUFBVSxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUM7Z0JBQy9CLEdBQUcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3pDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ2pDO1lBRUQsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUUsS0FBSyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFFLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO1lBQ2YsT0FBTyxLQUFLLENBQUM7UUFDakIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUMsR0FBRyxDQUFDLENBQUM7UUFFckMsSUFBSSxDQUFDLElBQUksR0FBRyxVQUFVLE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTTtZQUN4QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pELE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFbkMsb0RBQW9EO1lBQ3BELFFBQVEsTUFBTSxFQUFFO2dCQUNaLEtBQUssSUFBSSxDQUFDLFFBQVE7b0JBQ2QsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ3ZCLE1BQU07Z0JBQ1YsS0FBSyxJQUFJLENBQUMsUUFBUTtvQkFDZCxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDeEIsTUFBTTtnQkFDVixLQUFLLElBQUksQ0FBQyxRQUFRO29CQUNkLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUM5QyxNQUFNO2FBQ2I7WUFDRCxPQUFPLENBQUMsQ0FBQztRQUNiLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXBDLElBQUksQ0FBQyxJQUFJLEdBQUcsVUFBVSxNQUFNO1lBQ3hCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekQsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuQyxpQ0FBaUM7WUFDakMsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUUzQixJQUFJLENBQUMsR0FBRyxHQUFHLFVBQVUsTUFBTTtZQUN2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pELE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFbkM7Ozs7ZUFJRztZQUVILE9BQU8sR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUN6QyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSTtZQUN4QyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0NBQW9DLENBQUMsQ0FBQztZQUNsRCxPQUFPLENBQUMsQ0FBQztRQUNiLENBQUM7UUFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRXJDLElBQUksQ0FBQyxJQUFJLEdBQUcsVUFBVSxVQUFVLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPO1lBQ3hELHdCQUF3QjtZQUV4QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNoRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzdELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFMUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTztZQUUvQyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUU7Z0JBQ2YsVUFBVSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNyQixPQUFPLFVBQVUsQ0FBQzthQUNyQjtZQUVELElBQUksSUFBSSxJQUFJLE9BQU8sRUFBRTtnQkFDakIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPO29CQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUNsQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3JCLElBQUksVUFBVSxDQUFDLE9BQU87b0JBQ2xCLE9BQU8sVUFBVSxDQUFDO2dCQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDOUI7WUFFRCxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDLE9BQU87b0JBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3ZCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDOUUsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBRWhELElBQUksVUFBVSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNqRSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFFL0MsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLFVBQVUsR0FBRyxDQUFDLEVBQzVELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUV2QixPQUFPLElBQUksQ0FBQzthQUNmO1lBRUQsSUFBSSxJQUFJLElBQUksT0FBTyxFQUFFO2dCQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQUM7b0JBQ3RDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsY0FBYztpQkFDM0Q7Z0JBQ0QsT0FBTyxDQUFDLENBQUM7YUFDWjtZQUVELElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBRVYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUU7b0JBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBQyxDQUFDLENBQUMsQ0FBQztpQkFDbkM7Z0JBQ0QsT0FBTyxDQUFDLENBQUM7YUFDWjtZQUVELHFEQUFxRDtZQUNyRCxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQUMsR0FBRyxFQUFHO2dCQUM5RSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUV0QiwwREFBMEQ7Z0JBQzFELElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUcsRUFBRTtvQkFDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQy9GO2dCQUNELE9BQU8sVUFBVSxDQUFDO2FBQ3JCO1lBRUQsSUFBSSxJQUFJLEdBQUUsSUFBSSxDQUFDO1lBQ2YsSUFBSSxLQUFLLEdBQUUsSUFBSSxDQUFDO1lBQ2hCLElBQUksU0FBUyxHQUFFLENBQUMsQ0FBQztZQUNqQixJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUM7WUFDM0IsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQ3RCLEtBQUssSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdkMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hCLElBQUksS0FBSyxDQUFDLEdBQUcsSUFBSSxHQUFHLEVBQUU7b0JBQ2xCLElBQUksS0FBSyxDQUFDLFNBQVMsRUFBRTt3QkFDakIsY0FBYyxHQUFHLElBQUksQ0FBQzt3QkFDdEIsS0FBSyxHQUFHLElBQUksQ0FBQztxQkFDaEI7b0JBQ0QsU0FBUyxHQUFHLENBQUMsQ0FBQztvQkFDZCxNQUFNO2lCQUNUO2dCQUNELEtBQUssR0FBRyxJQUFJLENBQUM7YUFDaEI7WUFFRCxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNSLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDcEIsSUFBSSxHQUFHLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUMzQixJQUFJLGNBQWMsRUFBQzt3QkFDZixRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQzlDO3lCQUNHO3dCQUNBLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7cUJBQzNFO2lCQUVKO3FCQUFNO29CQUNILFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQ3hEO2dCQUVELFVBQVUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDNUQsVUFBVSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDO2dCQUN0QyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN0QixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxVQUFVLEdBQUcsQ0FBQyxFQUN0RCxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDZixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQ2YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQ2QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxFQUFFO29CQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLHdCQUF3QixDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsSUFBSSxFQUFFLEVBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDL0Y7YUFDSjtZQUVELE9BQU8sSUFBSSxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsRUFBQyxHQUFHLEVBQUMsR0FBRyxFQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2QyxxQkFBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLEdBQUcsRUFBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDdEcsQ0FBQztJQUVELFdBQVcsQ0FBRSxHQUFZLEVBQUUsUUFBa0I7UUFFekMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM3QyxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUM5RCxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRTlELElBQUksVUFBVSxHQUFHLElBQUksTUFBTSxDQUFDLEdBQUcsRUFBRSxjQUFjLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDM0QsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFL0MsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFFLFVBQVUsR0FBRyxDQUFDLEVBQ2pFLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUNmLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDZixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXZCLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXBELElBQUksUUFBUSxFQUFDO1lBQ1QsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3hDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzFCLE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDOUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBRTFDLGNBQWMsQ0FBQyxJQUFJLENBQUUsTUFBTSxDQUFDLEVBQUU7b0JBQzFCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO2dCQUMvQixDQUFDLENBQUMsQ0FBQztZQUNQLENBQUMsQ0FBQztTQUNMO1FBRUQsVUFBVSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzRCxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0NBQ0o7QUFFTyx3QkFBTTs7Ozs7Ozs7Ozs7QUNyVGQ7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztVQ3RCQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDekJBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBOzs7OztXQ1ZBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7Ozs7Ozs7Ozs7QUNKQSwyQ0FBMkM7QUFDM0MsaUZBQXVDO0FBQ3ZDLGlGQUF1QztBQUN2QyxpRkFBdUM7QUFDdkMsb0ZBQXlDO0FBRXpDLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxFQUFFO0lBQ3RDLGNBQWMsQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLHVCQUFjLEVBQUUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztDQUM5RTtBQUVELElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEVBQUU7SUFDeEMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSx1QkFBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7Q0FDbEY7QUFFRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0lBQ3hDLGNBQWMsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsdUJBQWMsRUFBRSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0NBQ2xGO0FBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRTtJQUN6QyxjQUFjLENBQUMsTUFBTSxDQUFDLGtCQUFrQixFQUFFLHlCQUFlLEVBQUUsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztDQUNyRjs7Ozs7Ozs7Ozs7QUNwQlk7QUFDYjs7QUFFQTs7QUFFQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBWTs7QUFFcEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFVOztBQUUvQixjQUFjLG1CQUFPLENBQUMsc0VBQVc7O0FBRWpDLGVBQWUsbUJBQU8sQ0FBQywwRUFBYTtBQUNwQztBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDBGQUFxQjs7QUFFL0MsZ0JBQWdCLG1CQUFPLENBQUMsc0ZBQW1COztBQUUzQyxzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBeUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQixrRUFBa0Q7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3Qvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi9lbnRyeS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi9ldmVudC9jbG9zZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi9ldmVudC9lbWl0dGVyLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2V2ZW50L2V2ZW50LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2V2ZW50L2V2ZW50dGFyZ2V0LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2V2ZW50L3RyYW5zLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvZmFjYWRlLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2lmcmFtZS1ib290c3RyYXAuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvaW5mby1hamF4LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2luZm8taWZyYW1lLXJlY2VpdmVyLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2luZm8taWZyYW1lLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL2luZm8tcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvbG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvbWFpbi5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi9zaGltcy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQtbGlzdC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvYnJvd3Nlci9hYnN0cmFjdC14aHIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvZXZlbnRzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2Jyb3dzZXIvd2Vic29ja2V0LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3RyYW5zcG9ydC9ldmVudHNvdXJjZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvaHRtbGZpbGUuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2lmcmFtZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvanNvbnAtcG9sbGluZy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvbGliL2FqYXgtYmFzZWQuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2xpYi9idWZmZXJlZC1zZW5kZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvbGliL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L2xpYi9zZW5kZXItcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL2V2ZW50c291cmNlLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3RyYW5zcG9ydC9yZWNlaXZlci9odG1sZmlsZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvcmVjZWl2ZXIvanNvbnAuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L3JlY2VpdmVyL3hoci5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvc2VuZGVyL2pzb25wLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3RyYW5zcG9ydC9zZW5kZXIveGRyLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQvd2Vic29ja2V0LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3RyYW5zcG9ydC94ZHItcG9sbGluZy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQveGRyLXN0cmVhbWluZy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi90cmFuc3BvcnQveGhyLXBvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdXRpbHMvYnJvd3Nlci1jcnlwdG8uanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdXRpbHMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi91dGlscy9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdXRpbHMvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdXRpbHMvaWZyYW1lLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi91dGlscy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdXRpbHMvcmFuZG9tLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3QvbGliL3V0aWxzL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L2xpYi91dGlscy91cmwuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9kaXN0L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3Qvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L2Rpc3Qvbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9ub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VXJsLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2xvZy5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi93ZWJpbnRlcmZhY2UvY29yZS1jb2Rlci5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi93ZWJpbnRlcmZhY2UvY29yZS1mZXRjaC5qcyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi93ZWJpbnRlcmZhY2UvY29yZS1wbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vd2ViaW50ZXJmYWNlL2NvcmUtc2RsLmpzIiwid2VicGFjazovL3BsYXllci8uL3dlYmludGVyZmFjZS9VQXVkaW8udHMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vd2ViaW50ZXJmYWNlL1VDYW52YXMudHMiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vd2ViaW50ZXJmYWNlL1VJbWFnZS50cyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi93ZWJpbnRlcmZhY2UvVVZpZGVvLnRzIiwid2VicGFjazovL3BsYXllci8uL3dlYmludGVyZmFjZS9tZW1pby50cyIsIndlYnBhY2s6Ly9wbGF5ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvIHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovL3BsYXllci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wbGF5ZXIvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL3BsYXllci93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcGxheWVyL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vcGxheWVyL3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcGxheWVyL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcGxheWVyL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcGxheWVyL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vcGxheWVyLy4vd2ViaW50ZXJmYWNlL2luZGV4LnRzIiwid2VicGFjazovL3BsYXllci8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3Vycm9nYXRlX3BhaXJzXzEgPSByZXF1aXJlKFwiLi9zdXJyb2dhdGUtcGFpcnNcIik7XG52YXIgSFRNTF9BTFBIQSA9IFsnYXBvcycsICduYnNwJywgJ2lleGNsJywgJ2NlbnQnLCAncG91bmQnLCAnY3VycmVuJywgJ3llbicsICdicnZiYXInLCAnc2VjdCcsICd1bWwnLCAnY29weScsICdvcmRmJywgJ2xhcXVvJywgJ25vdCcsICdzaHknLCAncmVnJywgJ21hY3InLCAnZGVnJywgJ3BsdXNtbicsICdzdXAyJywgJ3N1cDMnLCAnYWN1dGUnLCAnbWljcm8nLCAncGFyYScsICdtaWRkb3QnLCAnY2VkaWwnLCAnc3VwMScsICdvcmRtJywgJ3JhcXVvJywgJ2ZyYWMxNCcsICdmcmFjMTInLCAnZnJhYzM0JywgJ2lxdWVzdCcsICdBZ3JhdmUnLCAnQWFjdXRlJywgJ0FjaXJjJywgJ0F0aWxkZScsICdBdW1sJywgJ0FyaW5nJywgJ0FFbGlnJywgJ0NjZWRpbCcsICdFZ3JhdmUnLCAnRWFjdXRlJywgJ0VjaXJjJywgJ0V1bWwnLCAnSWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyYycsICdJdW1sJywgJ0VUSCcsICdOdGlsZGUnLCAnT2dyYXZlJywgJ09hY3V0ZScsICdPY2lyYycsICdPdGlsZGUnLCAnT3VtbCcsICd0aW1lcycsICdPc2xhc2gnLCAnVWdyYXZlJywgJ1VhY3V0ZScsICdVY2lyYycsICdVdW1sJywgJ1lhY3V0ZScsICdUSE9STicsICdzemxpZycsICdhZ3JhdmUnLCAnYWFjdXRlJywgJ2FjaXJjJywgJ2F0aWxkZScsICdhdW1sJywgJ2FyaW5nJywgJ2FlbGlnJywgJ2NjZWRpbCcsICdlZ3JhdmUnLCAnZWFjdXRlJywgJ2VjaXJjJywgJ2V1bWwnLCAnaWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyYycsICdpdW1sJywgJ2V0aCcsICdudGlsZGUnLCAnb2dyYXZlJywgJ29hY3V0ZScsICdvY2lyYycsICdvdGlsZGUnLCAnb3VtbCcsICdkaXZpZGUnLCAnb3NsYXNoJywgJ3VncmF2ZScsICd1YWN1dGUnLCAndWNpcmMnLCAndXVtbCcsICd5YWN1dGUnLCAndGhvcm4nLCAneXVtbCcsICdxdW90JywgJ2FtcCcsICdsdCcsICdndCcsICdPRWxpZycsICdvZWxpZycsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1l1bWwnLCAnY2lyYycsICd0aWxkZScsICdlbnNwJywgJ2Vtc3AnLCAndGhpbnNwJywgJ3p3bmonLCAnendqJywgJ2xybScsICdybG0nLCAnbmRhc2gnLCAnbWRhc2gnLCAnbHNxdW8nLCAncnNxdW8nLCAnc2JxdW8nLCAnbGRxdW8nLCAncmRxdW8nLCAnYmRxdW8nLCAnZGFnZ2VyJywgJ0RhZ2dlcicsICdwZXJtaWwnLCAnbHNhcXVvJywgJ3JzYXF1bycsICdldXJvJywgJ2Zub2YnLCAnQWxwaGEnLCAnQmV0YScsICdHYW1tYScsICdEZWx0YScsICdFcHNpbG9uJywgJ1pldGEnLCAnRXRhJywgJ1RoZXRhJywgJ0lvdGEnLCAnS2FwcGEnLCAnTGFtYmRhJywgJ011JywgJ051JywgJ1hpJywgJ09taWNyb24nLCAnUGknLCAnUmhvJywgJ1NpZ21hJywgJ1RhdScsICdVcHNpbG9uJywgJ1BoaScsICdDaGknLCAnUHNpJywgJ09tZWdhJywgJ2FscGhhJywgJ2JldGEnLCAnZ2FtbWEnLCAnZGVsdGEnLCAnZXBzaWxvbicsICd6ZXRhJywgJ2V0YScsICd0aGV0YScsICdpb3RhJywgJ2thcHBhJywgJ2xhbWJkYScsICdtdScsICdudScsICd4aScsICdvbWljcm9uJywgJ3BpJywgJ3JobycsICdzaWdtYWYnLCAnc2lnbWEnLCAndGF1JywgJ3Vwc2lsb24nLCAncGhpJywgJ2NoaScsICdwc2knLCAnb21lZ2EnLCAndGhldGFzeW0nLCAndXBzaWgnLCAncGl2JywgJ2J1bGwnLCAnaGVsbGlwJywgJ3ByaW1lJywgJ1ByaW1lJywgJ29saW5lJywgJ2ZyYXNsJywgJ3dlaWVycCcsICdpbWFnZScsICdyZWFsJywgJ3RyYWRlJywgJ2FsZWZzeW0nLCAnbGFycicsICd1YXJyJywgJ3JhcnInLCAnZGFycicsICdoYXJyJywgJ2NyYXJyJywgJ2xBcnInLCAndUFycicsICdyQXJyJywgJ2RBcnInLCAnaEFycicsICdmb3JhbGwnLCAncGFydCcsICdleGlzdCcsICdlbXB0eScsICduYWJsYScsICdpc2luJywgJ25vdGluJywgJ25pJywgJ3Byb2QnLCAnc3VtJywgJ21pbnVzJywgJ2xvd2FzdCcsICdyYWRpYycsICdwcm9wJywgJ2luZmluJywgJ2FuZycsICdhbmQnLCAnb3InLCAnY2FwJywgJ2N1cCcsICdpbnQnLCAndGhlcmU0JywgJ3NpbScsICdjb25nJywgJ2FzeW1wJywgJ25lJywgJ2VxdWl2JywgJ2xlJywgJ2dlJywgJ3N1YicsICdzdXAnLCAnbnN1YicsICdzdWJlJywgJ3N1cGUnLCAnb3BsdXMnLCAnb3RpbWVzJywgJ3BlcnAnLCAnc2RvdCcsICdsY2VpbCcsICdyY2VpbCcsICdsZmxvb3InLCAncmZsb29yJywgJ2xhbmcnLCAncmFuZycsICdsb3onLCAnc3BhZGVzJywgJ2NsdWJzJywgJ2hlYXJ0cycsICdkaWFtcyddO1xudmFyIEhUTUxfQ09ERVMgPSBbMzksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCwgMTg1LCAxODYsIDE4NywgMTg4LCAxODksIDE5MCwgMTkxLCAxOTIsIDE5MywgMTk0LCAxOTUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTAsIDIxMSwgMjEyLCAyMTMsIDIxNCwgMjE1LCAyMTYsIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMiwgMjMzLCAyMzQsIDIzNSwgMjM2LCAyMzcsIDIzOCwgMjM5LCAyNDAsIDI0MSwgMjQyLCAyNDMsIDI0NCwgMjQ1LCAyNDYsIDI0NywgMjQ4LCAyNDksIDI1MCwgMjUxLCAyNTIsIDI1MywgMjU0LCAyNTUsIDM0LCAzOCwgNjAsIDYyLCAzMzgsIDMzOSwgMzUyLCAzNTMsIDM3NiwgNzEwLCA3MzIsIDgxOTQsIDgxOTUsIDgyMDEsIDgyMDQsIDgyMDUsIDgyMDYsIDgyMDcsIDgyMTEsIDgyMTIsIDgyMTYsIDgyMTcsIDgyMTgsIDgyMjAsIDgyMjEsIDgyMjIsIDgyMjQsIDgyMjUsIDgyNDAsIDgyNDksIDgyNTAsIDgzNjQsIDQwMiwgOTEzLCA5MTQsIDkxNSwgOTE2LCA5MTcsIDkxOCwgOTE5LCA5MjAsIDkyMSwgOTIyLCA5MjMsIDkyNCwgOTI1LCA5MjYsIDkyNywgOTI4LCA5MjksIDkzMSwgOTMyLCA5MzMsIDkzNCwgOTM1LCA5MzYsIDkzNywgOTQ1LCA5NDYsIDk0NywgOTQ4LCA5NDksIDk1MCwgOTUxLCA5NTIsIDk1MywgOTU0LCA5NTUsIDk1NiwgOTU3LCA5NTgsIDk1OSwgOTYwLCA5NjEsIDk2MiwgOTYzLCA5NjQsIDk2NSwgOTY2LCA5NjcsIDk2OCwgOTY5LCA5NzcsIDk3OCwgOTgyLCA4MjI2LCA4MjMwLCA4MjQyLCA4MjQzLCA4MjU0LCA4MjYwLCA4NDcyLCA4NDY1LCA4NDc2LCA4NDgyLCA4NTAxLCA4NTkyLCA4NTkzLCA4NTk0LCA4NTk1LCA4NTk2LCA4NjI5LCA4NjU2LCA4NjU3LCA4NjU4LCA4NjU5LCA4NjYwLCA4NzA0LCA4NzA2LCA4NzA3LCA4NzA5LCA4NzExLCA4NzEyLCA4NzEzLCA4NzE1LCA4NzE5LCA4NzIxLCA4NzIyLCA4NzI3LCA4NzMwLCA4NzMzLCA4NzM0LCA4NzM2LCA4NzQzLCA4NzQ0LCA4NzQ1LCA4NzQ2LCA4NzQ3LCA4NzU2LCA4NzY0LCA4NzczLCA4Nzc2LCA4ODAwLCA4ODAxLCA4ODA0LCA4ODA1LCA4ODM0LCA4ODM1LCA4ODM2LCA4ODM4LCA4ODM5LCA4ODUzLCA4ODU1LCA4ODY5LCA4OTAxLCA4OTY4LCA4OTY5LCA4OTcwLCA4OTcxLCA5MDAxLCA5MDAyLCA5Njc0LCA5ODI0LCA5ODI3LCA5ODI5LCA5ODMwXTtcbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICAgICAgYWxwaGFJbmRleFthXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIG51bUluZGV4W2NdID0gYTtcbiAgICAgICAgaSsrO1xuICAgIH1cbn0pKCk7XG52YXIgSHRtbDRFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge1xuICAgIH1cbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgICAgICAgIHZhciBjaHI7XG4gICAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihjb2RlKSB8fCBjb2RlID49IC0zMjc2OCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8PSA2NTUzNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNociA9IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNjID49IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVGcm9tICYmIGNjIDw9IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVUbykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChzdHIsIGkpICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGNjICsgJzsnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPj0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZUZyb20gJiYgYyA8PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlVG8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChzdHIsIGkpICsgJzsnO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNEVudGl0aWVzO1xufSgpKTtcbmV4cG9ydHMuSHRtbDRFbnRpdGllcyA9IEh0bWw0RW50aXRpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdXJyb2dhdGVfcGFpcnNfMSA9IHJlcXVpcmUoXCIuL3N1cnJvZ2F0ZS1wYWlyc1wiKTtcbnZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xudmFyIERFQ09ERV9PTkxZX0VOVElUSUVTID0gW1snTmV3TGluZScsIFsxMF1dXTtcbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG52YXIgSHRtbDVFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIdG1sNUVudGl0aWVzKCkge1xuICAgIH1cbiAgICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgICAgICAgIHZhciBjaHI7XG4gICAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihjb2RlKSB8fCBjb2RlID49IC0zMjc2OCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8PSA2NTUzNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNociA9IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgICAgIGlmIChjID49IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVGcm9tICYmIGMgPD0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgc3Vycm9nYXRlX3BhaXJzXzEuZ2V0Q29kZVBvaW50KHN0ciwgaSkgKyAnOyc7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID49IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVGcm9tICYmIGMgPD0gc3Vycm9nYXRlX3BhaXJzXzEuaGlnaFN1cnJvZ2F0ZVRvKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoc3RyLCBpKSArICc7JztcbiAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1RW50aXRpZXM7XG59KCkpO1xuZXhwb3J0cy5IdG1sNUVudGl0aWVzID0gSHRtbDVFbnRpdGllcztcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgX2EgPSBFTlRJVElFU1tpXSwgYWxwaGEgPSBfYVswXSwgX2IgPSBfYVsxXSwgY2hyID0gX2JbMF0sIGNocjIgPSBfYlsxXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hyMikge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpID0gREVDT0RFX09OTFlfRU5USVRJRVMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIF9jID0gREVDT0RFX09OTFlfRU5USVRJRVNbaV0sIGFscGhhID0gX2NbMF0sIF9kID0gX2NbMV0sIGNociA9IF9kWzBdLCBjaHIyID0gX2RbMV07XG4gICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgKGNocjIgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpIDogJycpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhtbF9lbnRpdGllc18xID0gcmVxdWlyZShcIi4veG1sLWVudGl0aWVzXCIpO1xuZXhwb3J0cy5YbWxFbnRpdGllcyA9IHhtbF9lbnRpdGllc18xLlhtbEVudGl0aWVzO1xudmFyIGh0bWw0X2VudGl0aWVzXzEgPSByZXF1aXJlKFwiLi9odG1sNC1lbnRpdGllc1wiKTtcbmV4cG9ydHMuSHRtbDRFbnRpdGllcyA9IGh0bWw0X2VudGl0aWVzXzEuSHRtbDRFbnRpdGllcztcbnZhciBodG1sNV9lbnRpdGllc18xID0gcmVxdWlyZShcIi4vaHRtbDUtZW50aXRpZXNcIik7XG5leHBvcnRzLkh0bWw1RW50aXRpZXMgPSBodG1sNV9lbnRpdGllc18xLkh0bWw1RW50aXRpZXM7XG5leHBvcnRzLkFsbEh0bWxFbnRpdGllcyA9IGh0bWw1X2VudGl0aWVzXzEuSHRtbDVFbnRpdGllcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQgfHwgZnVuY3Rpb24gKGFzdHJhbENvZGVQb2ludCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoKGFzdHJhbENvZGVQb2ludCAtIDB4MTAwMDApIC8gMHg0MDApICsgMHhEODAwLCAoYXN0cmFsQ29kZVBvaW50IC0gMHgxMDAwMCkgJSAweDQwMCArIDB4REMwMCk7XG59O1xuZXhwb3J0cy5nZXRDb2RlUG9pbnQgPSBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ID9cbiAgICBmdW5jdGlvbiAoaW5wdXQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5jb2RlUG9pbnRBdChwb3NpdGlvbik7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24gKGlucHV0LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gKGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24pIC0gMHhEODAwKSAqIDB4NDAwXG4gICAgICAgICAgICArIGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfTtcbmV4cG9ydHMuaGlnaFN1cnJvZ2F0ZUZyb20gPSAweEQ4MDA7XG5leHBvcnRzLmhpZ2hTdXJyb2dhdGVUbyA9IDB4REJGRjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN1cnJvZ2F0ZV9wYWlyc18xID0gcmVxdWlyZShcIi4vc3Vycm9nYXRlLXBhaXJzXCIpO1xudmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xudmFyIFhtbEVudGl0aWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge1xuICAgIH1cbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvWzw+XCInJl0vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oY29kZSkgfHwgY29kZSA+PSAtMzI3NjgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPD0gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlRnJvbSAmJiBjIDw9IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVUbykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIHN1cnJvZ2F0ZV9wYWlyc18xLmdldENvZGVQb2ludChzdHIsIGkpICsgJzsnO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA+PSBzdXJyb2dhdGVfcGFpcnNfMS5oaWdoU3Vycm9nYXRlRnJvbSAmJiBjIDw9IHN1cnJvZ2F0ZV9wYWlyc18xLmhpZ2hTdXJyb2dhdGVUbykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgc3Vycm9nYXRlX3BhaXJzXzEuZ2V0Q29kZVBvaW50KHN0ciwgaSkgKyAnOyc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sRW50aXRpZXM7XG59KCkpO1xuZXhwb3J0cy5YbWxFbnRpdGllcyA9IFhtbEVudGl0aWVzO1xuIiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICBkZWZhdWx0TGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuXG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj07IGV4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMCBVVENcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGRlZmF1bHRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoZGVmYXVsdExldmVsLCBmYWxzZSk7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAoKHR5cGVvZiBuYW1lICE9PSBcInN5bWJvbFwiICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgLy8gRVM2IGRlZmF1bHQgZXhwb3J0LCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGRlZmF1bHRMb2dnZXJbJ2RlZmF1bHQnXSA9IGRlZmF1bHRMb2dnZXI7XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnbWVzc2FnZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04uc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTi5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBwWzFdO1xuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xuICAgICAgICB2YXIgYmFzZVVybCA9IHBbM107XG4gICAgICAgIGRlYnVnKHZlcnNpb24sIHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgU29ja0pTISBNYWluIHNpdGUgdXNlczonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIFNvY2tKUy52ZXJzaW9uICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRyYW5zVXJsLCBsb2MuaHJlZikgfHxcbiAgICAgICAgICAgICF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGJhc2VVcmwsIGxvYy5ocmVmKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdpZnJhbWUuICgnICsgbG9jLmhyZWYgKyAnLCAnICsgdHJhbnNVcmwgKyAnLCAnICsgYmFzZVVybCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgaWYgKGZhY2FkZSkge1xuICAgICAgICAgIGZhY2FkZS5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdzJyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTi5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OLnBhcnNlKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBtc2cpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaWZyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBzZWVtcyB0aGUgc2FtZSBhcyB0aGUgJ25lZWRCb2R5JyBmcm9tIHRyYW5zcG9ydHNcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xuICB9IGVsc2Uge1xuICAgIGdvKCk7XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaWZyKSB7XG4gICAgdGhpcy5pZnIuY2xvc2UoKTtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLmlmciA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9JZnJhbWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBYRFIgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGRyJylcbiAgLCBYSFJDb3JzID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIFhIUkZha2UgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UnKVxuICAsIEluZm9JZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVyKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgZGVidWcoYmFzZVVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmRvWGhyKGJhc2VVcmwsIHVybEluZm8pO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBUT0RPIHRoaXMgaXMgY3VycmVudGx5IGlnbm9yaW5nIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGFuZCB0aGUgd2hpdGVsaXN0XG5cbkluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmwsIHVybEluZm8pIHtcbiAgLy8gZGV0ZXJtaW5lIG1ldGhvZCBvZiBDT1JTIHN1cHBvcnQgKGlmIG5lZWRlZClcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJMb2NhbCk7XG4gIH1cbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJDb3JzKTtcbiAgfVxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhEUik7XG4gIH1cbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaW5mbycpXG4gICAgO1xuICBkZWJ1ZygnZG9YaHInLCB1cmwpO1xuXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XG5cbiAgdGhpcy50aW1lb3V0UmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICB9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XG4gIGlmICghd2FzQ2xlYW4gJiYgdGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgfVxuICB0aGlzLnhvID0gbnVsbDtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnRpbWVvdXQgPSA4MDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMDtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICAvLyBleGNlcHRpb24gaXMgMTI3LjAuMC4wLzggYW5kIDo6MSB1cmxzXG4gICAgaWYgKCF1cmxVdGlscy5pc0xvb3BiYWNrQWRkcihwYXJzZWRVcmwuaG9zdG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXQsICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0LmJpbmQodGhpcyksIHRpbWVvdXRNcyk7XG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuXG4gICAgdmFyIHRyYW5zcG9ydFVybCA9IHVybFV0aWxzLmFkZFBhdGgodGhpcy5fdHJhbnNVcmwsICcvJyArIHRoaXMuX3NlcnZlciArICcvJyArIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkKCkpO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XG4gICAgZGVidWcoJ3RyYW5zcG9ydCB1cmwnLCB0cmFuc3BvcnRVcmwpO1xuICAgIHZhciB0cmFuc3BvcnRPYmogPSBuZXcgVHJhbnNwb3J0KHRyYW5zcG9ydFVybCwgdGhpcy5fdHJhbnNVcmwsIG9wdGlvbnMpO1xuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLm9uY2UoJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLnRyYW5zcG9ydE5hbWUgPSBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fY2xvc2UoMjAwMCwgJ0FsbCB0cmFuc3BvcnRzIGZhaWxlZCcsIGZhbHNlKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRUaW1lb3V0Jyk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhbnNwb3J0Q2xvc2UoMjAwNywgJ1RyYW5zcG9ydCB0aW1lZCBvdXQnKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBkZWJ1ZygnX3RyYW5zcG9ydE1lc3NhZ2UnLCBtc2cpO1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcbiAgICAsIGNvbnRlbnQgPSBtc2cuc2xpY2UoMSlcbiAgICAsIHBheWxvYWRcbiAgICA7XG5cbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG1lc3NhZ2VzIHRoYXQgZG9uJ3QgbmVlZCBhIHBheWxvYWRcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbyc6XG4gICAgICB0aGlzLl9vcGVuKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnaCc6XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdoZWFydGJlYXQnKSk7XG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQgJiYgdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fY2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uLCB3YXNDbGVhbiwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9pcikge1xuICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgdGhpcy5faXIuY2xvc2UoKTtcbiAgICB0aGlzLl9pciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFNvY2tKUyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCcpO1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIGlmIChmb3JjZUZhaWwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgIGUuY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxuU29ja0pTLnByb3RvdHlwZS5jb3VudFJUTyA9IGZ1bmN0aW9uKHJ0dCkge1xuICAvLyBJbiBhIGxvY2FsIGVudmlyb25tZW50LCB3aGVuIHVzaW5nIElFOC85IGFuZCB0aGUgYGpzb25wLXBvbGxpbmdgXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXG4gIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gIC8vIGFyb3VuZCAyMDBtc2VjICh0aGUgbG93ZXIgYm91bmQgdXNlZCBpbiB0aGUgYXJ0aWNsZSBhYm92ZSkgYW5kIHRoaXNcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcbiAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICBpZiAocnR0ID4gMTAwKSB7XG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcbiAgfVxuICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXF1aXJlKCcuL2lmcmFtZS1ib290c3RyYXAnKShTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXR1cm4gU29ja0pTO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBqc2NzOiBkaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgRVMzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbi8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufVxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDkuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbmZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICB2YXIgbiA9ICtudW07XG4gICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cbiAgICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbn1cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIHZhciBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxudmFyIHN0cmluZ19zcGxpdCA9IFN0cmluZ1Byb3RvdHlwZS5zcGxpdDtcbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyAneCcgOiAnJykgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04ucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04uc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04uc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG52YXIgb25VbmxvYWQgPSB7fVxuICAsIGFmdGVyVW5sb2FkID0gZmFsc2VcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgLCBpc0Nocm9tZVBhY2thZ2VkQXBwID0gZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBpZiAoaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlclVubG9hZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiwgdW5sb2FkRGVsOiBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cblxuLCB0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWZ0ZXJVbmxvYWQgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG5pZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgbW9kdWxlLmV4cG9ydHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZFRyaWdnZXJlZCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgIC8vIG9udW5sb2FkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgZXJyKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBlc2xpbnQgbm8tdW5kZWY6IFwib2ZmXCIsIG5ldy1jYXA6IFwib2ZmXCIgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9XG5cbiwgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxuXG4sIGlzTG9vcGJhY2tBZGRyOiBmdW5jdGlvbiAoYWRkcikge1xuICAgIHJldHVybiAvXjEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8IC9eXFxbOjoxXFxdJC8udGVzdChhZGRyKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gJzEuNi4wJztcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHVuZGVmO1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIGNvbnRyb2xPcldoaXRlc3BhY2UgPSAvXltcXHgwMC1cXHgyMFxcdTAwYTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXSsvXG4gICwgQ1JIVExGID0gL1tcXG5cXHJcXHRdL2dcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vXG4gICwgcG9ydCA9IC86XFxkKyQvXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFxcL10rKT8oW1xcU1xcc10qKS9pXG4gICwgd2luZG93c0RyaXZlTGV0dGVyID0gL15bYS16QS1aXTovO1xuXG4vKipcbiAqIFJlbW92ZSBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHdoaXRlc3BhY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge1N0cmluZ30gQSBuZXcgc3RyaW5nIHJlcHJlc2VudGluZyBgc3RyYCBzdHJpcHBlZCBvZiBjb250cm9sXG4gKiAgICAgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIGl0cyBiZWdpbm5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UoY29udHJvbE9yV2hpdGVzcGFjZSwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzLCB1cmwpIHsgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/IGFkZHJlc3MucmVwbGFjZSgvXFxcXC9nLCAnLycpIDogYWRkcmVzcztcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKikkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvdG9jb2wgc2NoZW1lIGlzIHNwZWNpYWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFRoZSBwcm90b2NvbCBzY2hlbWUgb2YgdGhlIFVSTFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbCwgZWxzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWwoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lID09PSAnZmlsZTonIHx8XG4gICAgc2NoZW1lID09PSAnZnRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwOicgfHxcbiAgICBzY2hlbWUgPT09ICdodHRwczonIHx8XG4gICAgc2NoZW1lID09PSAnd3M6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ3dzczonXG4gICk7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jYXRpb25cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MsIGxvY2F0aW9uKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcbiAgYWRkcmVzcyA9IGFkZHJlc3MucmVwbGFjZShDUkhUTEYsICcnKTtcbiAgbG9jYXRpb24gPSBsb2NhdGlvbiB8fCB7fTtcblxuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnO1xuICB2YXIgZm9yd2FyZFNsYXNoZXMgPSAhIW1hdGNoWzJdO1xuICB2YXIgb3RoZXJTbGFzaGVzID0gISFtYXRjaFszXTtcbiAgdmFyIHNsYXNoZXNDb3VudCA9IDA7XG4gIHZhciByZXN0O1xuXG4gIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGggKyBtYXRjaFszXS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3QgPSBtYXRjaFsyXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbMl0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzRdXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgaWYgKHNsYXNoZXNDb3VudCA+PSAyKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbCkge1xuICAgIGlmIChmb3J3YXJkU2xhc2hlcykge1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNsYXNoZXNDb3VudCA+PSAyICYmIGlzU3BlY2lhbChsb2NhdGlvbi5wcm90b2NvbCkpIHtcbiAgICByZXN0ID0gbWF0Y2hbNF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBzbGFzaGVzOiBmb3J3YXJkU2xhc2hlcyB8fCBpc1NwZWNpYWwocHJvdG9jb2wpLFxuICAgIHNsYXNoZXNDb3VudDogc2xhc2hlc0NvdW50LFxuICAgIHJlc3Q6IHJlc3RcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIGlmIChyZWxhdGl2ZSA9PT0gJycpIHJldHVybiBiYXNlO1xuXG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbbG9jYXRpb25dIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW3BhcnNlcl0gUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnLCBsb2NhdGlvbik7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoXG4gICAgZXh0cmFjdGVkLnByb3RvY29sID09PSAnZmlsZTonICYmIChcbiAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgIT09IDIgfHwgd2luZG93c0RyaXZlTGV0dGVyLnRlc3QoYWRkcmVzcykpIHx8XG4gICAgKCFleHRyYWN0ZWQuc2xhc2hlcyAmJlxuICAgICAgKGV4dHJhY3RlZC5wcm90b2NvbCB8fFxuICAgICAgICBleHRyYWN0ZWQuc2xhc2hlc0NvdW50IDwgMiB8fFxuICAgICAgICAhaXNTcGVjaWFsKHVybC5wcm90b2NvbCkpKVxuICApIHtcbiAgICBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcbiAgfVxuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcywgdXJsKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpbmRleCA9IHBhcnNlID09PSAnQCdcbiAgICAgICAgPyBhZGRyZXNzLmxhc3RJbmRleE9mKHBhcnNlKVxuICAgICAgICA6IGFkZHJlc3MuaW5kZXhPZihwYXJzZSk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSkge1xuICAgIHVybC5wYXRobmFtZSA9ICcvJyArIHVybC5wYXRobmFtZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuXG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluZGV4ID0gdXJsLmF1dGguaW5kZXhPZignOicpO1xuXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgdXJsLnVzZXJuYW1lID0gdXJsLmF1dGguc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcblxuICAgICAgdXJsLnBhc3N3b3JkID0gdXJsLmF1dGguc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgIHVybC5wYXNzd29yZCA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnBhc3N3b3JkKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwuYXV0aCkpO1xuICAgIH1cblxuICAgIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsnOicrIHVybC5wYXNzd29yZCA6IHVybC51c2VybmFtZTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiYgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiYgdXJsLmhvc3RcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHBvcnQudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3VzZXJuYW1lJzpcbiAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICB1cmxbcGFydF0gPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRoJzpcbiAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJzonKTtcblxuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICB1cmwudXNlcm5hbWUgPSB2YWx1ZS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSk7XG5cbiAgICAgICAgdXJsLnBhc3N3b3JkID0gdmFsdWUuc2xpY2UoaW5kZXggKyAxKTtcbiAgICAgICAgdXJsLnBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC51c2VybmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwuYXV0aCA9IHVybC5wYXNzd29yZCA/IHVybC51c2VybmFtZSArJzonKyB1cmwucGFzc3dvcmQgOiB1cmwudXNlcm5hbWU7XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGhvc3QgPSB1cmwuaG9zdFxuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9XG4gICAgcHJvdG9jb2wgK1xuICAgICgodXJsLnByb3RvY29sICYmIHVybC5zbGFzaGVzKSB8fCBpc1NwZWNpYWwodXJsLnByb3RvY29sKSA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAodXJsLnBhc3N3b3JkKSB7XG4gICAgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH0gZWxzZSBpZiAoXG4gICAgdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmXG4gICAgaXNTcGVjaWFsKHVybC5wcm90b2NvbCkgJiZcbiAgICAhaG9zdCAmJlxuICAgIHVybC5wYXRobmFtZSAhPT0gJy8nXG4gICkge1xuICAgIC8vXG4gICAgLy8gQWRkIGJhY2sgdGhlIGVtcHR5IHVzZXJpbmZvLCBvdGhlcndpc2UgdGhlIG9yaWdpbmFsIGludmFsaWQgVVJMXG4gICAgLy8gbWlnaHQgYmUgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZSB3aXRoIGB1cmwucGF0aG5hbWVgIGFzIGhvc3QuXG4gICAgLy9cbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgLy9cbiAgLy8gVHJhaWxpbmcgY29sb24gaXMgcmVtb3ZlZCBmcm9tIGB1cmwuaG9zdGAgd2hlbiBpdCBpcyBwYXJzZWQuIElmIGl0IHN0aWxsXG4gIC8vIGVuZHMgd2l0aCBhIGNvbG9uLCB0aGVuIGFkZCBiYWNrIHRoZSB0cmFpbGluZyBjb2xvbiB0aGF0IHdhcyByZW1vdmVkLiBUaGlzXG4gIC8vIHByZXZlbnRzIGFuIGludmFsaWQgVVJMIGZyb20gYmVpbmcgdHJhbnNmb3JtZWQgaW50byBhIHZhbGlkIG9uZS5cbiAgLy9cbiAgaWYgKGhvc3RbaG9zdC5sZW5ndGggLSAxXSA9PT0gJzonIHx8IChwb3J0LnRlc3QodXJsLmhvc3RuYW1lKSAmJiAhdXJsLnBvcnQpKSB7XG4gICAgaG9zdCArPSAnOic7XG4gIH1cblxuICByZXN1bHQgKz0gaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQ2xpZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ2xpZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbmVlZHMgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNsaWVudDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgU29ja0pTID0gcmVxdWlyZSgnc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcycpO1xuXG52YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vQmFzZUNsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDbGllbnQpIHtcbiAgX2luaGVyaXRzKFNvY2tKU0NsaWVudCwgX0Jhc2VDbGllbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU29ja0pTQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgICBfdGhpcy5zb2NrLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7Ly8gVE9ETzogdXNlIGxvZ2dlciB0byBsb2cgdGhlIGVycm9yIGV2ZW50IG9uY2UgY2xpZW50IGFuZCBjbGllbnQtc3JjXG4gICAgICAvLyBhcmUgcmVvcmdhbml6ZWQgdG8gaGF2ZSB0aGUgc2FtZSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrSlNDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5zb2NrLm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmKGUuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKCcuL1NvY2tKU0NsaWVudCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyIsIid1c2Ugc3RyaWN0JzsgLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbC1jb21tdW5pdHknKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLFxuICAgIEFsbEh0bWxFbnRpdGllcyA9IF9yZXF1aXJlLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEFsbEh0bWxFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcbnZhciBvdmVybGF5RGl2ID0gbnVsbDtcbnZhciBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuXG5mdW5jdGlvbiBhZGRPdmVybGF5RGl2VG8oaWZyYW1lKSB7XG4gIHZhciBkaXYgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gIGRpdi5zdHlsZS5yaWdodCA9IDA7XG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJyNFOEU4RTgnO1xuICBkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZSc7XG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJyZW0nO1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9ICcxLjInO1xuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIGRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGluZyBhbiBpZnJhbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBzbyB3ZSdsbCBzY2hlZHVsZSB0aGUgY2FsbGJhY2suXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cblxuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuXG4gIGlmIChvdmVybGF5SWZyYW1lKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBjcmVhdGVkIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcbiAgb3ZlcmxheURpdiA9IG51bGw7XG4gIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuXG5mdW5jdGlvbiBzaG93TWVzc2FnZShtZXNzYWdlcykge1xuICBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjXCIuY29uY2F0KGNvbG9ycy5yZWQsIFwiXFxcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj5cIikuY29uY2F0KGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtZXNzYWdlc1swXSkpKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhcjogY2xlYXIsXG4gIHNob3dNZXNzYWdlOiBzaG93TWVzc2FnZVxufTsiLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gKi9cblxuLyogZXNsaW50LWRpc2FibGVcbiAgY2FtZWxjYXNlXG4qL1xuLy8gdGhpcyBTb2NrSlNDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgaW5saW5lIG1vZGVcbi8vIGlzIG9mZiBvciB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZC4gVGhpcyB3aWxsIGJlIHN3aXRjaGVkIHRvXG4vLyBXZWJzb2NrZXRDbGllbnQgd2hlbiBpdCBiZWNvbWVzIHRoZSBkZWZhdWx0XG4vLyBpbXBvcnRhbnQ6IHRoZSBwYXRoIHRvIFNvY2tKU0NsaWVudCBoZXJlIGlzIG1hZGUgdG8gd29yayBpbiB0aGUgJ2NsaWVudCdcbi8vIGRpcmVjdG9yeSwgYnV0IGlzIHVwZGF0ZWQgdmlhIHRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIHdoZW4gY29tcGlsZWQgZnJvbVxuLy8gdGhlICdjbGllbnQtc3JjJyBkaXJlY3RvcnlcblxudmFyIENsaWVudCA9IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBzZWxmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgPSByZXF1aXJlKCcuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UnKTtcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VXJsKHJlc291cmNlUXVlcnksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgdXJsUGFydHM7XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICAvLyBmb3JtYXQgaXMgbGlrZSBgP2h0dHA6Ly8wLjAuMC4wOjgwOTYmc29ja1BvcnQ9ODA5NyZzb2NrSG9zdD1sb2NhbGhvc3RgXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeSAvLyBzdHJpcCBsZWFkaW5nIGA/YCBmcm9tIHF1ZXJ5IHN0cmluZyB0byBnZXQgYSB2YWxpZCBVUkxcbiAgICAuc3Vic3RyKDEpIC8vIHJlcGxhY2UgZmlyc3QgYCZgIHdpdGggYD9gIHRvIGhhdmUgYSB2YWxpZCBxdWVyeSBzdHJpbmdcbiAgICAucmVwbGFjZSgnJicsICc/JyksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIHRydWUsIHRydWUpO1xuICB9IC8vIFVzZSBwYXJhbWV0ZXIgdG8gYWxsb3cgcGFzc2luZyBsb2NhdGlvbiBpbiB1bml0IHRlc3RzXG5cblxuICBpZiAodHlwZW9mIGN1cnJlbnRMb2NhdGlvbiA9PT0gJ3N0cmluZycgJiYgY3VycmVudExvY2F0aW9uICE9PSAnJykge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHVybC5wYXJzZShjdXJyZW50TG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHNlbGYubG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBjdXJyZW50TG9jYXRpb24pO1xufVxuLypcbiAqIEdldHMgc29ja2V0IFVSTCBiYXNlZCBvbiBTY3JpcHQgU291cmNlL0xvY2F0aW9uXG4gKiAoc2NyaXB0U3JjOiBVUkwsIGxvY2F0aW9uOiBVUkwpIC0+IFVSTFxuICovXG5cblxuZnVuY3Rpb24gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBsb2MpIHtcbiAgdmFyIGF1dGggPSB1cmxQYXJ0cy5hdXRoLFxuICAgICAgcXVlcnkgPSB1cmxQYXJ0cy5xdWVyeTtcbiAgdmFyIGhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sLFxuICAgICAgcG9ydCA9IHVybFBhcnRzLnBvcnQ7XG5cbiAgaWYgKCFwb3J0IHx8IHBvcnQgPT09ICcwJykge1xuICAgIHBvcnQgPSBsb2MucG9ydDtcbiAgfSAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cblxuICBpZiAoKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpICYmIGxvYy5ob3N0bmFtZSAmJiBsb2MucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAwKSB7XG4gICAgaG9zdG5hbWUgPSBsb2MuaG9zdG5hbWU7XG4gIH0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuICAvLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4gIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbiAgaWYgKGhvc3RuYW1lICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJyAmJiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gbG9jLnByb3RvY29sO1xuICB9IC8vIGFsbCBvZiB0aGVzZSBzb2NrIHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2hcbiAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja0hvc3QgPSBxdWVyeS5zb2NrSG9zdCB8fCBob3N0bmFtZTtcbiAgdmFyIHNvY2tQYXRoID0gcXVlcnkuc29ja1BhdGggfHwgJy9zb2NranMtbm9kZSc7XG4gIHZhciBzb2NrUG9ydCA9IHF1ZXJ5LnNvY2tQb3J0IHx8IHBvcnQ7XG5cbiAgaWYgKHNvY2tQb3J0ID09PSAnbG9jYXRpb24nKSB7XG4gICAgc29ja1BvcnQgPSBsb2MucG9ydDtcbiAgfVxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTb2NrZXRVcmw7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgREVCVUcgPSAnZGVidWcnO1xudmFyIFRSQUNFID0gJ3RyYWNlJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JzsgLy8gZGVwcmVjYXRlZFxuLy8gVE9ETzogcmVtb3ZlIHRoZXNlIGF0IG1ham9yIHJlbGVhc2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8xODI1XG5cbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIE5PTkUgPSAnbm9uZSc7IC8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcblxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgSU5GTzpcbiAgICBjYXNlIFdBUk46XG4gICAgY2FzZSBFUlJPUjpcbiAgICBjYXNlIERFQlVHOlxuICAgIGNhc2UgVFJBQ0U6XG4gICAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBXQVJOSU5HOlxuICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgTk9ORTpcbiAgICBjYXNlIFNJTEVOVDpcbiAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBzZXRMb2dMZXZlbDogc2V0TG9nTGV2ZWxcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2c7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBfcmVmMikge1xuICB2YXIgaG90UmVsb2FkID0gX3JlZi5ob3RSZWxvYWQsXG4gICAgICBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIHZhciBpc1VubG9hZGluZyA9IF9yZWYyLmlzVW5sb2FkaW5nLFxuICAgICAgY3VycmVudEhhc2ggPSBfcmVmMi5jdXJyZW50SGFzaDtcblxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcblxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xuXG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KGN1cnJlbnRIYXNoKSwgJyonKTtcbiAgICB9XG4gIH0gLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCkge1xuICAgICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmOyAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcblxuICAgICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuXG4gICAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWxvYWRBcHA7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRNc2c7IiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd3cyBkb2VzIG5vdCB3b3JrIGluIHRoZSBicm93c2VyLiBCcm93c2VyIGNsaWVudHMgbXVzdCB1c2UgdGhlIG5hdGl2ZSAnICtcbiAgICAgICdXZWJTb2NrZXQgb2JqZWN0J1xuICApO1xufTtcbiIsIlxudmFyIE1vZHVsZSA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgX19maWxlbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIF9zY3JpcHREaXIgPSBfc2NyaXB0RGlyIHx8IF9fZmlsZW5hbWU7XG4gIHJldHVybiAoXG5mdW5jdGlvbihNb2R1bGUpIHtcbiAgTW9kdWxlID0gTW9kdWxlIHx8IHt9O1xuXG5cblxuLy8gVGhlIE1vZHVsZSBvYmplY3Q6IE91ciBpbnRlcmZhY2UgdG8gdGhlIG91dHNpZGUgd29ybGQuIFdlIGltcG9ydFxuLy8gYW5kIGV4cG9ydCB2YWx1ZXMgb24gaXQuIFRoZXJlIGFyZSB2YXJpb3VzIHdheXMgTW9kdWxlIGNhbiBiZSB1c2VkOlxuLy8gMS4gTm90IGRlZmluZWQuIFdlIGNyZWF0ZSBpdCBoZXJlXG4vLyAyLiBBIGZ1bmN0aW9uIHBhcmFtZXRlciwgZnVuY3Rpb24oTW9kdWxlKSB7IC4uZ2VuZXJhdGVkIGNvZGUuLiB9XG4vLyAzLiBwcmUtcnVuIGFwcGVuZGVkIGl0LCB2YXIgTW9kdWxlID0ge307IC4uZ2VuZXJhdGVkIGNvZGUuLlxuLy8gNC4gRXh0ZXJuYWwgc2NyaXB0IHRhZyBkZWZpbmVzIHZhciBNb2R1bGUuXG4vLyBXZSBuZWVkIHRvIGNoZWNrIGlmIE1vZHVsZSBhbHJlYWR5IGV4aXN0cyAoZS5nLiBjYXNlIDMgYWJvdmUpLlxuLy8gU3Vic3RpdHV0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgY29kZSBvbiBsYXRlciBzdGFnZSBvZiB0aGUgYnVpbGQsXG4vLyB0aGlzIHdheSBDbG9zdXJlIENvbXBpbGVyIHdpbGwgbm90IG1hbmdsZSBpdCAoZS5nLiBjYXNlIDQuIGFib3ZlKS5cbi8vIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBydW4gY2xvc3VyZSwgYW5kIGFsc28gdG8gdXNlIE1vZHVsZVxuLy8gYWZ0ZXIgdGhlIGdlbmVyYXRlZCBjb2RlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZSAgIHZhciBNb2R1bGUgPSB7fTtcbi8vIGJlZm9yZSB0aGUgY29kZS4gVGhlbiB0aGF0IG9iamVjdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNvZGUsIGFuZCB5b3Vcbi8vIGNhbiBjb250aW51ZSB0byB1c2UgTW9kdWxlIGFmdGVyd2FyZHMgYXMgd2VsbC5cbnZhciBNb2R1bGUgPSB0eXBlb2YgTW9kdWxlICE9ICd1bmRlZmluZWQnID8gTW9kdWxlIDoge307XG52YXIgZmlsdGVyX2VudHJpZXMgPSBNb2R1bGVbJ2ZpbHRlcl9lbnRyaWVzJ10gfHwgW107XG52YXIgbW9kdWxlX2VudHJpZXMgPSBNb2R1bGVbJ21vZHVsZV9lbnRyaWVzJ10gfHwgW107XG5cbi8vIFNlZSBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX29iamVjdF9hc3NpZ25cblxuLy8gU2V0IHVwIHRoZSBwcm9taXNlIHRoYXQgaW5kaWNhdGVzIHRoZSBNb2R1bGUgaXMgaW5pdGlhbGl6ZWRcbnZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG5Nb2R1bGVbJ3JlYWR5J10gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBcImZpbHRlcl9lbnRyaWVzXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmlsdGVyX2VudHJpZXMgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwibW9kdWxlX2VudHJpZXNcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVfZW50cmllcyB9IH0pO1xuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfdW5sb2NrJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X3VubG9jaycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9wdGhyZWFkX211dGV4X3VubG9jayBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF91bmxvY2snLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcHRocmVhZF9tdXRleF91bmxvY2sgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfbG9jaycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9sb2NrJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3B0aHJlYWRfbXV0ZXhfbG9jayBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9sb2NrJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3B0aHJlYWRfbXV0ZXhfbG9jayBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9zZWxmJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX3NlbGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcHRocmVhZF9zZWxmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX3NlbGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcHRocmVhZF9zZWxmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zcHJpbnRmJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3NwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3ByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfdmZwcmludGYnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3ZmcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3ZmcHJpbnRmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ192ZnByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF92ZnByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZnByaW50ZicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZnByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9mcHJpbnRmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2ZwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2JzZWFyY2gnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2JzZWFyY2gnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfYnNlYXJjaCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYnNlYXJjaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9ic2VhcmNoIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19mcmV4cCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZnJleHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZnJleHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2ZyZXhwJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2ZyZXhwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19sbHJpbnQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2xscmludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9sbHJpbnQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2xscmludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9sbHJpbnQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2Z3cml0ZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZndyaXRlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2Z3cml0ZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZndyaXRlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2Z3cml0ZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfY29zJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jb3MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfY29zIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jb3MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfY29zIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19jb3NoJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jb3NoJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2Nvc2ggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2Nvc2gnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfY29zaCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfYWNvcycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYWNvcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9hY29zIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19hY29zJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2Fjb3Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3NpbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2luJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3NpbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2luJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3NpbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc2luaCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2luaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zaW5oIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zaW5oJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3Npbmggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2FzaW4nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2FzaW4nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfYXNpbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYXNpbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9hc2luIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ190YW4nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3RhbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF90YW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3RhbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF90YW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3RhbmgnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3RhbmgnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfdGFuaCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdGFuaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF90YW5oIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19hdGFuJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19hdGFuJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2F0YW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2F0YW4nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfYXRhbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZXhwJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19leHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZXhwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19leHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZXhwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19sb2cnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2xvZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9sb2cgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2xvZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9sb2cgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2ZhYnMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2ZhYnMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZmFicyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZmFicycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9mYWJzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJuY21wJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJuY21wJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3N0cm5jbXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RybmNtcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc3RyZHVwJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJkdXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RyZHVwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJkdXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RyZHVwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF90aW1lc2NhbGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF90aW1lc2NhbGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF90aW1lc2NhbGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X2N0cycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2N0cyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2N0cyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb24nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X2R1cmF0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2R1cmF0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9kdXJhdGlvbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF9kdXJhdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX3VybCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX3VybCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWxlaW9fdXJsIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fdXJsJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbGVpb191cmwgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb19uZXcnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb19uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsZWlvX25ldyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWxlaW9fbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fc2V0X3N0YXRzX3UzMicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzInLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb19zZXRfc3RhdHNfdTMyJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbGVpb19zZXRfc3RhdHNfdTMyIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19sZGV4cCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbGRleHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfbGRleHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2xkZXhwJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2xkZXhwIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X2Rlc3Ryb3knKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfZGVzdHJveScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9wdGhyZWFkX211dGV4X2Rlc3Ryb3kgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfZGVzdHJveScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9wdGhyZWFkX211dGV4X2Rlc3Ryb3kgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfaW5pdCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9pbml0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3B0aHJlYWRfbXV0ZXhfaW5pdCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9pbml0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3B0aHJlYWRfbXV0ZXhfaW5pdCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcG9zaXhfbWVtYWxpZ24nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3Bvc2l4X21lbWFsaWduJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3Bvc2l4X21lbWFsaWduIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wb3NpeF9tZW1hbGlnbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9wb3NpeF9tZW1hbGlnbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcG93JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wb3cnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcG93IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wb3cnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcG93IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ192c25wcmludGYnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3ZzbnByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF92c25wcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3ZzbnByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF92c25wcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dldGVudicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2V0ZW52JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dldGVudiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2V0ZW52JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dldGVudiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc3RyY21wJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RyY21wIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RyY21wIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJsZW4nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmxlbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zdHJsZW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmxlbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJsZW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNweScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RyY3B5JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3N0cmNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RyY3B5JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3N0cmNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc3RyY2F0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjYXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RyY2F0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjYXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RyY2F0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJuY3B5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJuY3B5JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3N0cm5jcHkgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RybmNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc3RyY2hyJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjaHInLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RyY2hyIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjaHInLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RyY2hyIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19tZW1zZXQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX21lbXNldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9tZW1zZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX21lbXNldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9tZW1zZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX21lbWNweScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtY3B5JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX21lbWNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtY3B5JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX21lbWNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfbWVtbW92ZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtbW92ZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9tZW1tb3ZlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1tb3ZlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX21lbW1vdmUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX21lbWFsaWduJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1hbGlnbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9tZW1hbGlnbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtYWxpZ24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfbWVtYWxpZ24gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX21lbWNtcCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtY21wJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX21lbWNtcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtY21wJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX21lbWNtcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfY2FsbG9jJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jYWxsb2MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfY2FsbG9jIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jYWxsb2MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfY2FsbG9jIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19yZWFsbG9jJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19yZWFsbG9jJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3JlYWxsb2Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3JlYWxsb2MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcmVhbGxvYyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfdXJsX2NvbmNhdGVuYXRlJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl91cmxfY29uY2F0ZW5hdGUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfdXJsX2NvbmNhdGVuYXRlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl91cmxfY29uY2F0ZW5hdGUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfdXJsX2NvbmNhdGVuYXRlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9zdHJkdXAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX3N0cmR1cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9zdHJkdXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX3N0cmR1cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9zdHJkdXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb19nZXRfdWR0YScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX2dldF91ZHRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbGVpb19nZXRfdWR0YSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX2dldF91ZHRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbGVpb19nZXRfdWR0YSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfbmV3JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfYnNfbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfYnNfbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19hdmFpbGFibGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2F2YWlsYWJsZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9ic19hdmFpbGFibGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2F2YWlsYWJsZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9ic19hdmFpbGFibGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX3JlYWRfaW50JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19yZWFkX2ludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9ic19yZWFkX2ludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfcmVhZF9pbnQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfYnNfcmVhZF9pbnQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2dldF9wb3NpdGlvbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfZ2V0X3Bvc2l0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2JzX2dldF9wb3NpdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfZ2V0X3Bvc2l0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2JzX2dldF9wb3NpdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfZGVsJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19kZWwnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfYnNfZGVsIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19kZWwnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfYnNfZGVsIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfZ2V0X3VkdGEnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9nZXRfdWR0YScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfZ2V0X3VkdGEgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9nZXRfdWR0YScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfZ2V0X3VkdGEgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfZ2V0X3BhY2tldCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9waWRfZ2V0X3BhY2tldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9waWRfZ2V0X3BhY2tldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfZGF0YScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfZGF0YScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF9kYXRhIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9kYXRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2RhdGEgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfc2V0X3Byb3BlcnR5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX3NldF9wcm9wZXJ0eScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX3NldF9wcm9wZXJ0eSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHkgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfbmV3X2FsbG9jJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX25ld19hbGxvYycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX25ld19hbGxvYyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2VuZCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZW5kJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2VuZCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZW5kJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2VuZCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9jaGVja19jYXBzJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9jaGVja19jYXBzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9jaGVja19jYXBzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2dldF9wcm9wZXJ0eScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHkgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfZ2V0X3Byb3BlcnR5JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9waWRfZ2V0X3Byb3BlcnR5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX25ldycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfbmV3JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9waWRfbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2NvcHlfcHJvcGVydGllcycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfY29weV9wcm9wZXJ0aWVzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9waWRfY29weV9wcm9wZXJ0aWVzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfc2V0X25hbWUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9zZXRfbmFtZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfc2V0X25hbWUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9zZXRfbmFtZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfc2V0X25hbWUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2RlcGVuZGVuY3lfZmxhZ3MnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2RlcGVuZGVuY3lfZmxhZ3MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9kZXBlbmRlbmN5X2ZsYWdzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX3NldF9mcmFtaW5nX21vZGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX3NldF9mcmFtaW5nX21vZGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGlkX3NldF9mcmFtaW5nX21vZGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfbmV3X3JlZicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfbmV3X3JlZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfbmV3X3JlZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfY3RzJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9zYXAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9zYXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9zYXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2R1cmF0aW9uJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9kdXJhdGlvbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9kdXJhdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb24gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3Byb3BlcnR5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9wcm9wZXJ0eScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF9wcm9wZXJ0eSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHkgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2ZyYW1pbmcnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2ZyYW1pbmcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9mcmFtaW5nIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9zZWVrX2ZsYWcnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9zZWVrX2ZsYWcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9zZWVrX2ZsYWcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3NlZWtfZmxhZycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X3NlZWtfZmxhZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X3NlZWtfZmxhZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZmZsdXNoJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mZmx1c2gnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZmZsdXNoIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mZmx1c2gnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZmZsdXNoIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zaXByaW50ZicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2lwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc2lwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NpcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3NpcHJpbnRmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19jb25zdHJ1Y3RvcicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfY29uc3RydWN0b3InLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfY29uc3RydWN0b3Igb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2NvbnN0cnVjdG9yJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2NvbnN0cnVjdG9yIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zZXQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dldCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZGVzdHJ1Y3RvcicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZGVzdHJ1Y3RvcicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9kZXN0cnVjdG9yIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19kZXN0cnVjdG9yJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2Rlc3RydWN0b3Igb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX19fc3RkaW9fZXhpdCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfX19zdGRpb19leGl0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX19fc3RkaW9fZXhpdCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfX19zdGRpb19leGl0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX19fc3RkaW9fZXhpdCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19uZXcnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfbmV3JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfYnNfbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGdmX2JzX25ldyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19hdmFpbGFibGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfYXZhaWxhYmxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfYnNfYXZhaWxhYmxlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX2F2YWlsYWJsZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGdmX2JzX2F2YWlsYWJsZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19nZXRfcG9zaXRpb24nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfZ2V0X3Bvc2l0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfYnNfZ2V0X3Bvc2l0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX2dldF9wb3NpdGlvbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGdmX2JzX2dldF9wb3NpdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2N0cycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2N0cyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfZmlsdGVyX3Bja19nZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19nZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfZ2V0X2N0cycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGdmX2ZpbHRlcl9wY2tfZ2V0X2N0cyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX29yaWckbGxyaW50JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGxscmludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9vcmlnJGxscmludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRsbHJpbnQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfb3JpZyRsbHJpbnQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnb25SdW50aW1lSW5pdGlhbGl6ZWQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnb25SdW50aW1lSW5pdGlhbGl6ZWQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBvblJ1bnRpbWVJbml0aWFsaXplZCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdvblJ1bnRpbWVJbml0aWFsaXplZCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIG9uUnVudGltZUluaXRpYWxpemVkIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuLy8gLS1wcmUtanNlcyBhcmUgZW1pdHRlZCBhZnRlciB0aGUgTW9kdWxlIGludGVncmF0aW9uIGNvZGUsIHNvIHRoYXQgdGhleSBjYW5cbi8vIHJlZmVyIHRvIE1vZHVsZSAoaWYgdGhleSBjaG9vc2U7IHRoZXkgY2FuIGFsc28gZGVmaW5lIE1vZHVsZSlcbi8vIHt7UFJFX0pTRVN9fVxuXG4vLyBTb21ldGltZXMgYW4gZXhpc3RpbmcgTW9kdWxlIG9iamVjdCBleGlzdHMgd2l0aCBwcm9wZXJ0aWVzXG4vLyBtZWFudCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbW9kdWxlIGZ1bmN0aW9uYWxpdHkuIEhlcmVcbi8vIHdlIGNvbGxlY3QgdGhvc2UgcHJvcGVydGllcyBhbmQgcmVhcHBseSBfYWZ0ZXJfIHdlIGNvbmZpZ3VyZVxuLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBkZWZhdWx0cyB0byBhdm9pZCBoYXZpbmcgdG8gYmUgc29cbi8vIGRlZmVuc2l2ZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG52YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxudmFyIGFyZ3VtZW50c18gPSBbXTtcbnZhciB0aGlzUHJvZ3JhbSA9ICcuL3RoaXMucHJvZ3JhbSc7XG52YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gIHRocm93IHRvVGhyb3c7XG59O1xuXG4vLyBEZXRlcm1pbmUgdGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgd2UgYXJlIGluLiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGlzIGJ5XG4vLyBzZXR0aW5nIHRoZSBFTlZJUk9OTUVOVCBzZXR0aW5nIGF0IGNvbXBpbGUgdGltZSAoc2VlIHNldHRpbmdzLmpzKS5cblxuLy8gQXR0ZW1wdCB0byBhdXRvLWRldGVjdCB0aGUgZW52aXJvbm1lbnRcbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnO1xudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IGZhbHNlOy8vdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gJ2Z1bmN0aW9uJztcbi8vIE4uYi4gRWxlY3Ryb24uanMgZW52aXJvbm1lbnQgaXMgc2ltdWx0YW5lb3VzbHkgYSBOT0RFLWVudmlyb25tZW50LCBidXRcbi8vIGFsc28gYSB3ZWIgZW52aXJvbm1lbnQuXG52YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IGZhbHNlOy8vdHlwZW9mIHByb2Nlc3MgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSAnc3RyaW5nJztcbnZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9IGZhbHNlOy8vIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG5pZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddKSB7XG4gIHRocm93IG5ldyBFcnJvcignTW9kdWxlLkVOVklST05NRU5UIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFRvIGZvcmNlIHRoZSBlbnZpcm9ubWVudCwgdXNlIHRoZSBFTlZJUk9OTUVOVCBjb21waWxlLXRpbWUgb3B0aW9uIChmb3IgZXhhbXBsZSwgLXMgRU5WSVJPTk1FTlQ9d2ViIG9yIC1zIEVOVklST05NRU5UPW5vZGUpJyk7XG59XG5cbi8vIGAvYCBzaG91bGQgYmUgcHJlc2VudCBhdCB0aGUgZW5kIGlmIGBzY3JpcHREaXJlY3RvcnlgIGlzIG5vdCBlbXB0eVxudmFyIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICB9XG4gIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBwYXRoO1xufVxuXG4vLyBIb29rcyB0aGF0IGFyZSBpbXBsZW1lbnRlZCBkaWZmZXJlbnRseSBpbiBkaWZmZXJlbnQgcnVudGltZSBlbnZpcm9ubWVudHMuXG52YXIgcmVhZF8sXG4gICAgcmVhZEFzeW5jLFxuICAgIHJlYWRCaW5hcnksXG4gICAgc2V0V2luZG93VGl0bGU7XG5cbi8vIE5vcm1hbGx5IHdlIGRvbid0IGxvZyBleGNlcHRpb25zIGJ1dCBpbnN0ZWFkIGxldCB0aGVtIGJ1YmJsZSBvdXQgdGhlIHRvcFxuLy8gbGV2ZWwgd2hlcmUgdGhlIGVtYmVkZGluZyBlbnZpcm9ubWVudCAoZS5nLiB0aGUgYnJvd3NlcikgY2FuIGhhbmRsZVxuLy8gdGhlbS5cbi8vIEhvd2V2ZXIgdW5kZXIgdjggYW5kIG5vZGUgd2Ugc29tZXRpbWVzIGV4aXQgdGhlIHByb2Nlc3MgZGlyZWNseSBpbiB3aGljaCBjYXNlXG4vLyBpdHMgdXAgdG8gdXNlIHVzIHRvIGxvZyB0aGUgZXhjZXB0aW9uIGJlZm9yZSBleGl0aW5nLlxuLy8gSWYgd2UgZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9pc3N1ZXMvMTUwODBcbi8vIHRoaXMgbWF5IG5vIGxvbmdlciBiZSBuZWVkZWQgdW5kZXIgbm9kZS5cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbk9uRXhpdChlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRXhpdFN0YXR1cykgcmV0dXJuO1xuICBsZXQgdG9Mb2cgPSBlO1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PSAnb2JqZWN0JyAmJiBlLnN0YWNrKSB7XG4gICAgdG9Mb2cgPSBbZSwgZS5zdGFja107XG4gIH1cbiAgZXJyKCdleGl0aW5nIGR1ZSB0byBleGNlcHRpb246ICcgKyB0b0xvZyk7XG59XG5cbnZhciBmcztcblxuaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XG5cbiAgaWYgKCh0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRXJyb3IoJ25vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pJyk7XG5cbiAgaWYgKHR5cGVvZiByZWFkICE9ICd1bmRlZmluZWQnKSB7XG4gICAgcmVhZF8gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKGYpIHtcbiAgICAgIHJldHVybiByZWFkKGYpO1xuICAgIH07XG4gIH1cblxuICByZWFkQmluYXJ5ID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZWFkYnVmZmVyKGYpKTtcbiAgICB9XG4gICAgZGF0YSA9IHJlYWQoZiwgJ2JpbmFyeScpO1xuICAgIGFzc2VydCh0eXBlb2YgZGF0YSA9PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmVhZEFzeW5jID0gZnVuY3Rpb24gcmVhZEFzeW5jKGYsIG9ubG9hZCwgb25lcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gb25sb2FkKHJlYWRCaW5hcnkoZikpLCAwKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIHNjcmlwdEFyZ3MgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhcmd1bWVudHNfID0gc2NyaXB0QXJncztcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzICE9ICd1bmRlZmluZWQnKSB7XG4gICAgYXJndW1lbnRzXyA9IGFyZ3VtZW50cztcbiAgfVxuXG4gIGlmICh0eXBlb2YgcXVpdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICAgICBsb2dFeGNlcHRpb25PbkV4aXQodG9UaHJvdyk7XG4gICAgICBxdWl0KHN0YXR1cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJpbnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBQcmVmZXIgdG8gdXNlIHByaW50L3ByaW50RXJyIHdoZXJlIHRoZXkgZXhpc3QsIGFzIHRoZXkgdXN1YWxseSB3b3JrIGJldHRlci5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUgPSAvKiogQHR5cGV7IUNvbnNvbGV9ICovKHt9KTtcbiAgICBjb25zb2xlLmxvZyA9IC8qKiBAdHlwZXshZnVuY3Rpb24odGhpczpDb25zb2xlLCAuLi4qKTogdW5kZWZpbmVkfSAqLyAocHJpbnQpO1xuICAgIGNvbnNvbGUud2FybiA9IGNvbnNvbGUuZXJyb3IgPSAvKiogQHR5cGV7IWZ1bmN0aW9uKHRoaXM6Q29uc29sZSwgLi4uKik6IHVuZGVmaW5lZH0gKi8gKHR5cGVvZiBwcmludEVyciAhPSAndW5kZWZpbmVkJyA/IHByaW50RXJyIDogcHJpbnQpO1xuICB9XG5cbn0gZWxzZVxuXG4vLyBOb3RlIHRoYXQgdGhpcyBpbmNsdWRlcyBOb2RlLmpzIHdvcmtlcnMgd2hlbiByZWxldmFudCAocHRocmVhZHMgaXMgZW5hYmxlZCkuXG4vLyBOb2RlLmpzIHdvcmtlcnMgYXJlIGRldGVjdGVkIGFzIGEgY29tYmluYXRpb24gb2YgRU5WSVJPTk1FTlRfSVNfV09SS0VSIGFuZFxuLy8gRU5WSVJPTk1FTlRfSVNfTk9ERS5cbmlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHsgLy8gQ2hlY2sgd29ya2VyLCBub3Qgd2ViLCBzaW5jZSB3aW5kb3cgY291bGQgYmUgcG9seWZpbGxlZFxuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkgeyAvLyB3ZWJcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgfVxuICAvLyBXaGVuIE1PRFVMQVJJWkUsIHRoaXMgSlMgbWF5IGJlIGV4ZWN1dGVkIGxhdGVyLCBhZnRlciBkb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gIC8vIGlzIGdvbmUsIHNvIHdlIHNhdmVkIGl0LCBhbmQgd2UgdXNlIGl0IGhlcmUgaW5zdGVhZCBvZiBhbnkgb3RoZXIgaW5mby5cbiAgaWYgKF9zY3JpcHREaXIpIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBfc2NyaXB0RGlyO1xuICB9XG4gIC8vIGJsb2IgdXJscyBsb29rIGxpa2UgYmxvYjpodHRwOi8vc2l0ZS5jb20vZXRjL2V0YyBhbmQgd2UgY2Fubm90IGluZmVyIGFueXRoaW5nIGZyb20gdGhlbS5cbiAgLy8gb3RoZXJ3aXNlLCBzbGljZSBvZmYgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHVybCB0byBmaW5kIHRoZSBzY3JpcHQgZGlyZWN0b3J5LlxuICAvLyBpZiBzY3JpcHREaXJlY3RvcnkgZG9lcyBub3QgY29udGFpbiBhIHNsYXNoLCBsYXN0SW5kZXhPZiB3aWxsIHJldHVybiAtMSxcbiAgLy8gYW5kIHNjcmlwdERpcmVjdG9yeSB3aWxsIGNvcnJlY3RseSBiZSByZXBsYWNlZCB3aXRoIGFuIGVtcHR5IHN0cmluZy5cbiAgLy8gSWYgc2NyaXB0RGlyZWN0b3J5IGNvbnRhaW5zIGEgcXVlcnkgKHN0YXJ0aW5nIHdpdGggPykgb3IgYSBmcmFnbWVudCAoc3RhcnRpbmcgd2l0aCAjKSxcbiAgLy8gdGhleSBhcmUgcmVtb3ZlZCBiZWNhdXNlIHRoZXkgY291bGQgY29udGFpbiBhIHNsYXNoLlxuICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCBcIlwiKS5sYXN0SW5kZXhPZignLycpKzEpO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nKSkgdGhyb3cgbmV3IEVycm9yKCdub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KScpO1xuXG4gIC8vIERpZmZlcmVudGlhdGUgdGhlIFdlYiBXb3JrZXIgZnJvbSB0aGUgTm9kZSBXb3JrZXIgY2FzZSwgYXMgcmVhZGluZyBtdXN0XG4gIC8vIGJlIGRvbmUgZGlmZmVyZW50bHkuXG4gIHtcbi8vIGluY2x1ZGU6IHdlYl9vcl93b3JrZXJfc2hlbGxfcmVhZC5qc1xuXG5cbiAgcmVhZF8gPSAodXJsKSA9PiB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICB9XG5cbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgIHJlYWRCaW5hcnkgPSAodXJsKSA9PiB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgvKiogQHR5cGV7IUFycmF5QnVmZmVyfSAqLyh4aHIucmVzcG9uc2UpKTtcbiAgICB9O1xuICB9XG5cbiAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7IC8vIGZpbGUgVVJMcyBjYW4gcmV0dXJuIDBcbiAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uZXJyb3IoKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgfVxuXG4vLyBlbmQgaW5jbHVkZTogd2ViX29yX3dvcmtlcl9zaGVsbF9yZWFkLmpzXG4gIH1cblxuICBzZXRXaW5kb3dUaXRsZSA9ICh0aXRsZSkgPT4gZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbn0gZWxzZVxue1xuICB0aHJvdyBuZXcgRXJyb3IoJ2Vudmlyb25tZW50IGRldGVjdGlvbiBlcnJvcicpO1xufVxuXG52YXIgb3V0ID0gTW9kdWxlWydwcmludCddIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG52YXIgZXJyID0gTW9kdWxlWydwcmludEVyciddIHx8IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuXG4vLyBNZXJnZSBiYWNrIGluIHRoZSBvdmVycmlkZXNcbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuLy8gRnJlZSB0aGUgb2JqZWN0IGhpZXJhcmNoeSBjb250YWluZWQgaW4gdGhlIG92ZXJyaWRlcywgdGhpcyBsZXRzIHRoZSBHQ1xuLy8gcmVjbGFpbSBkYXRhIHVzZWQgZS5nLiBpbiBtZW1vcnlJbml0aWFsaXplclJlcXVlc3QsIHdoaWNoIGlzIGEgbGFyZ2UgdHlwZWQgYXJyYXkuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuY2hlY2tJbmNvbWluZ01vZHVsZUFQSSgpO1xuXG4vLyBFbWl0IGNvZGUgdG8gaGFuZGxlIGV4cGVjdGVkIHZhbHVlcyBvbiB0aGUgTW9kdWxlIG9iamVjdC4gVGhpcyBhcHBsaWVzIE1vZHVsZS54XG4vLyB0byB0aGUgcHJvcGVyIGxvY2FsIHguIFRoaXMgaGFzIHR3byBiZW5lZml0czogZmlyc3QsIHdlIG9ubHkgZW1pdCBpdCBpZiBpdCBpc1xuLy8gZXhwZWN0ZWQgdG8gYXJyaXZlLCBhbmQgc2Vjb25kLCBieSB1c2luZyBhIGxvY2FsIGV2ZXJ5d2hlcmUgZWxzZSB0aGF0IGNhbiBiZVxuLy8gbWluaWZpZWQuXG5cbmlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtsZWdhY3lNb2R1bGVQcm9wKCdhcmd1bWVudHMnLCAnYXJndW1lbnRzXycpO1xuXG5pZiAoTW9kdWxlWyd0aGlzUHJvZ3JhbSddKSB0aGlzUHJvZ3JhbSA9IE1vZHVsZVsndGhpc1Byb2dyYW0nXTtsZWdhY3lNb2R1bGVQcm9wKCd0aGlzUHJvZ3JhbScsICd0aGlzUHJvZ3JhbScpO1xuXG5pZiAoTW9kdWxlWydxdWl0J10pIHF1aXRfID0gTW9kdWxlWydxdWl0J107bGVnYWN5TW9kdWxlUHJvcCgncXVpdCcsICdxdWl0XycpO1xuXG4vLyBwZXJmb3JtIGFzc2VydGlvbnMgaW4gc2hlbGwuanMgYWZ0ZXIgd2Ugc2V0IHVwIG91dCgpIGFuZCBlcnIoKSwgYXMgb3RoZXJ3aXNlIGlmIGFuIGFzc2VydGlvbiBmYWlscyBpdCBjYW5ub3QgcHJpbnQgdGhlIG1lc3NhZ2Vcbi8vIEFzc2VydGlvbnMgb24gcmVtb3ZlZCBpbmNvbWluZyBNb2R1bGUgSlMgQVBJcy5cbmFzc2VydCh0eXBlb2YgTW9kdWxlWydtZW1vcnlJbml0aWFsaXplclByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydwdGhyZWFkTWFpblByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnB0aHJlYWRNYWluUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydjZEluaXRpYWxpemVyUHJlZml4VVJMJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuY2RJbml0aWFsaXplclByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnZmlsZVBhY2thZ2VQcmVmaXhVUkwnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5maWxlUGFja2FnZVByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncmVhZCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLnJlYWQgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZF8gaW4gSlMpJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsncmVhZEFzeW5jJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucmVhZEFzeW5jIG9wdGlvbiB3YXMgcmVtb3ZlZCAobW9kaWZ5IHJlYWRBc3luYyBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydyZWFkQmluYXJ5J10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucmVhZEJpbmFyeSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQmluYXJ5IGluIEpTKScpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3NldFdpbmRvd1RpdGxlJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuc2V0V2luZG93VGl0bGUgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgc2V0V2luZG93VGl0bGUgaW4gSlMpJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnVE9UQUxfTUVNT1JZJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUuVE9UQUxfTUVNT1JZIGhhcyBiZWVuIHJlbmFtZWQgTW9kdWxlLklOSVRJQUxfTUVNT1JZJyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdyZWFkJywgJ3JlYWRfJyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdyZWFkQXN5bmMnLCAncmVhZEFzeW5jJyk7XG5sZWdhY3lNb2R1bGVQcm9wKCdyZWFkQmluYXJ5JywgJ3JlYWRCaW5hcnknKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ3NldFdpbmRvd1RpdGxlJywgJ3NldFdpbmRvd1RpdGxlJyk7XG52YXIgSURCRlMgPSAnSURCRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWxpZGJmcy5qcyc7XG52YXIgUFJPWFlGUyA9ICdQUk9YWUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1scHJveHlmcy5qcyc7XG52YXIgV09SS0VSRlMgPSAnV09SS0VSRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWx3b3JrZXJmcy5qcyc7XG52YXIgTk9ERUZTID0gJ05PREVGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbG5vZGVmcy5qcyc7XG5cblxuYXNzZXJ0KCFFTlZJUk9OTUVOVF9JU19TSEVMTCwgXCJzaGVsbCBlbnZpcm9ubWVudCBkZXRlY3RlZCBidXQgbm90IGVuYWJsZWQgYXQgYnVpbGQgdGltZS4gIEFkZCAnc2hlbGwnIHRvIGAtcyBFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiKTtcblxuXG5cblxudmFyIFNUQUNLX0FMSUdOID0gMTY7XG52YXIgUE9JTlRFUl9TSVpFID0gNDtcblxuZnVuY3Rpb24gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpMSc6IGNhc2UgJ2k4JzogcmV0dXJuIDE7XG4gICAgY2FzZSAnaTE2JzogcmV0dXJuIDI7XG4gICAgY2FzZSAnaTMyJzogcmV0dXJuIDQ7XG4gICAgY2FzZSAnaTY0JzogcmV0dXJuIDg7XG4gICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gNDtcbiAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gODtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIFBPSU5URVJfU0laRTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ2knKSB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBOdW1iZXIodHlwZS5zdWJzdHIoMSkpO1xuICAgICAgICBhc3NlcnQoYml0cyAlIDggPT09IDAsICdnZXROYXRpdmVUeXBlU2l6ZSBpbnZhbGlkIGJpdHMgJyArIGJpdHMgKyAnLCB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgcmV0dXJuIGJpdHMgLyA4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcbiAgaWYgKCF3YXJuT25jZS5zaG93bikgd2Fybk9uY2Uuc2hvd24gPSB7fTtcbiAgaWYgKCF3YXJuT25jZS5zaG93blt0ZXh0XSkge1xuICAgIHdhcm5PbmNlLnNob3duW3RleHRdID0gMTtcbiAgICBlcnIodGV4dCk7XG4gIH1cbn1cblxuLy8gaW5jbHVkZTogcnVudGltZV9mdW5jdGlvbnMuanNcblxuXG4vLyBXcmFwcyBhIEpTIGZ1bmN0aW9uIGFzIGEgd2FzbSBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gc2lnbmF0dXJlLlxuZnVuY3Rpb24gY29udmVydEpzRnVuY3Rpb25Ub1dhc20oZnVuYywgc2lnKSB7XG5cbiAgLy8gSWYgdGhlIHR5cGUgcmVmbGVjdGlvbiBwcm9wb3NhbCBpcyBhdmFpbGFibGUsIHVzZSB0aGUgbmV3XG4gIC8vIFwiV2ViQXNzZW1ibHkuRnVuY3Rpb25cIiBjb25zdHJ1Y3Rvci5cbiAgLy8gT3RoZXJ3aXNlLCBjb25zdHJ1Y3QgYSBtaW5pbWFsIHdhc20gbW9kdWxlIGltcG9ydGluZyB0aGUgSlMgZnVuY3Rpb24gYW5kXG4gIC8vIHJlLWV4cG9ydGluZyBpdC5cbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5GdW5jdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgdHlwZU5hbWVzID0ge1xuICAgICAgJ2knOiAnaTMyJyxcbiAgICAgICdqJzogJ2k2NCcsXG4gICAgICAnZic6ICdmMzInLFxuICAgICAgJ2QnOiAnZjY0J1xuICAgIH07XG4gICAgdmFyIHR5cGUgPSB7XG4gICAgICBwYXJhbWV0ZXJzOiBbXSxcbiAgICAgIHJlc3VsdHM6IHNpZ1swXSA9PSAndicgPyBbXSA6IFt0eXBlTmFtZXNbc2lnWzBdXV1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2lnLmxlbmd0aDsgKytpKSB7XG4gICAgICB0eXBlLnBhcmFtZXRlcnMucHVzaCh0eXBlTmFtZXNbc2lnW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgV2ViQXNzZW1ibHkuRnVuY3Rpb24odHlwZSwgZnVuYyk7XG4gIH1cblxuICAvLyBUaGUgbW9kdWxlIGlzIHN0YXRpYywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSB0eXBlIHNlY3Rpb24sIHdoaWNoIGlzXG4gIC8vIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgc2lnbmF0dXJlIHBhc3NlZCBpbi5cbiAgdmFyIHR5cGVTZWN0aW9uID0gW1xuICAgIDB4MDEsIC8vIGlkOiBzZWN0aW9uLFxuICAgIDB4MDAsIC8vIGxlbmd0aDogMCAocGxhY2Vob2xkZXIpXG4gICAgMHgwMSwgLy8gY291bnQ6IDFcbiAgICAweDYwLCAvLyBmb3JtOiBmdW5jXG4gIF07XG4gIHZhciBzaWdSZXQgPSBzaWcuc2xpY2UoMCwgMSk7XG4gIHZhciBzaWdQYXJhbSA9IHNpZy5zbGljZSgxKTtcbiAgdmFyIHR5cGVDb2RlcyA9IHtcbiAgICAnaSc6IDB4N2YsIC8vIGkzMlxuICAgICdqJzogMHg3ZSwgLy8gaTY0XG4gICAgJ2YnOiAweDdkLCAvLyBmMzJcbiAgICAnZCc6IDB4N2MsIC8vIGY2NFxuICB9O1xuXG4gIC8vIFBhcmFtZXRlcnMsIGxlbmd0aCArIHNpZ25hdHVyZXNcbiAgdHlwZVNlY3Rpb24ucHVzaChzaWdQYXJhbS5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ1BhcmFtLmxlbmd0aDsgKytpKSB7XG4gICAgdHlwZVNlY3Rpb24ucHVzaCh0eXBlQ29kZXNbc2lnUGFyYW1baV1dKTtcbiAgfVxuXG4gIC8vIFJldHVybiB2YWx1ZXMsIGxlbmd0aCArIHNpZ25hdHVyZXNcbiAgLy8gV2l0aCBubyBtdWx0aS1yZXR1cm4gaW4gTVZQLCBlaXRoZXIgMCAodm9pZCkgb3IgMSAoYW55dGhpbmcgZWxzZSlcbiAgaWYgKHNpZ1JldCA9PSAndicpIHtcbiAgICB0eXBlU2VjdGlvbi5wdXNoKDB4MDApO1xuICB9IGVsc2Uge1xuICAgIHR5cGVTZWN0aW9uID0gdHlwZVNlY3Rpb24uY29uY2F0KFsweDAxLCB0eXBlQ29kZXNbc2lnUmV0XV0pO1xuICB9XG5cbiAgLy8gV3JpdGUgdGhlIG92ZXJhbGwgbGVuZ3RoIG9mIHRoZSB0eXBlIHNlY3Rpb24gYmFjayBpbnRvIHRoZSBzZWN0aW9uIGhlYWRlclxuICAvLyAoZXhjZXB0aW5nIHRoZSAyIGJ5dGVzIGZvciB0aGUgc2VjdGlvbiBpZCBhbmQgbGVuZ3RoKVxuICB0eXBlU2VjdGlvblsxXSA9IHR5cGVTZWN0aW9uLmxlbmd0aCAtIDI7XG5cbiAgLy8gUmVzdCBvZiB0aGUgbW9kdWxlIGlzIHN0YXRpY1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShbXG4gICAgMHgwMCwgMHg2MSwgMHg3MywgMHg2ZCwgLy8gbWFnaWMgKFwiXFwwYXNtXCIpXG4gICAgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgLy8gdmVyc2lvbjogMVxuICBdLmNvbmNhdCh0eXBlU2VjdGlvbiwgW1xuICAgIDB4MDIsIDB4MDcsIC8vIGltcG9ydCBzZWN0aW9uXG4gICAgICAvLyAoaW1wb3J0IFwiZVwiIFwiZlwiIChmdW5jIDAgKHR5cGUgMCkpKVxuICAgICAgMHgwMSwgMHgwMSwgMHg2NSwgMHgwMSwgMHg2NiwgMHgwMCwgMHgwMCxcbiAgICAweDA3LCAweDA1LCAvLyBleHBvcnQgc2VjdGlvblxuICAgICAgLy8gKGV4cG9ydCBcImZcIiAoZnVuYyAwICh0eXBlIDApKSlcbiAgICAgIDB4MDEsIDB4MDEsIDB4NjYsIDB4MDAsIDB4MDAsXG4gIF0pKTtcblxuICAgLy8gV2UgY2FuIGNvbXBpbGUgdGhpcyB3YXNtIG1vZHVsZSBzeW5jaHJvbm91c2x5IGJlY2F1c2UgaXQgaXMgdmVyeSBzbWFsbC5cbiAgLy8gVGhpcyBhY2NlcHRzIGFuIGltcG9ydCAoYXQgXCJlLmZcIiksIHRoYXQgaXQgcmVyb3V0ZXMgdG8gYW4gZXhwb3J0IChhdCBcImZcIilcbiAgdmFyIG1vZHVsZSA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYnl0ZXMpO1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCB7XG4gICAgJ2UnOiB7XG4gICAgICAnZic6IGZ1bmNcbiAgICB9XG4gIH0pO1xuICB2YXIgd3JhcHBlZEZ1bmMgPSBpbnN0YW5jZS5leHBvcnRzWydmJ107XG4gIHJldHVybiB3cmFwcGVkRnVuYztcbn1cblxudmFyIGZyZWVUYWJsZUluZGV4ZXMgPSBbXTtcblxuLy8gV2VhayBtYXAgb2YgZnVuY3Rpb25zIGluIHRoZSB0YWJsZSB0byB0aGVpciBpbmRleGVzLCBjcmVhdGVkIG9uIGZpcnN0IHVzZS5cbnZhciBmdW5jdGlvbnNJblRhYmxlTWFwO1xuXG5mdW5jdGlvbiBnZXRFbXB0eVRhYmxlU2xvdCgpIHtcbiAgLy8gUmV1c2UgYSBmcmVlIGluZGV4IGlmIHRoZXJlIGlzIG9uZSwgb3RoZXJ3aXNlIGdyb3cuXG4gIGlmIChmcmVlVGFibGVJbmRleGVzLmxlbmd0aCkge1xuICAgIHJldHVybiBmcmVlVGFibGVJbmRleGVzLnBvcCgpO1xuICB9XG4gIC8vIEdyb3cgdGhlIHRhYmxlXG4gIHRyeSB7XG4gICAgd2FzbVRhYmxlLmdyb3coMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93ICdVbmFibGUgdG8gZ3JvdyB3YXNtIHRhYmxlLiBTZXQgQUxMT1dfVEFCTEVfR1JPV1RILic7XG4gIH1cbiAgcmV0dXJuIHdhc21UYWJsZS5sZW5ndGggLSAxO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUYWJsZU1hcChvZmZzZXQsIGNvdW50KSB7XG4gIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyBjb3VudDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRXYXNtVGFibGVFbnRyeShpKTtcbiAgICAvLyBJZ25vcmUgbnVsbCB2YWx1ZXMuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGZ1bmN0aW9uc0luVGFibGVNYXAuc2V0KGl0ZW0sIGkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIHRvIHRoZSB0YWJsZS5cbiAqICdzaWcnIHBhcmFtZXRlciBpcyByZXF1aXJlZCBpZiB0aGUgZnVuY3Rpb24gYmVpbmcgYWRkZWQgaXMgYSBKUyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gc2lnXG4gKi9cbmZ1bmN0aW9uIGFkZEZ1bmN0aW9uKGZ1bmMsIHNpZykge1xuICBhc3NlcnQodHlwZW9mIGZ1bmMgIT0gJ3VuZGVmaW5lZCcpO1xuXG4gIC8vIENoZWNrIGlmIHRoZSBmdW5jdGlvbiBpcyBhbHJlYWR5IGluIHRoZSB0YWJsZSwgdG8gZW5zdXJlIGVhY2ggZnVuY3Rpb25cbiAgLy8gZ2V0cyBhIHVuaXF1ZSBpbmRleC4gRmlyc3QsIGNyZWF0ZSB0aGUgbWFwIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHVzZS5cbiAgaWYgKCFmdW5jdGlvbnNJblRhYmxlTWFwKSB7XG4gICAgZnVuY3Rpb25zSW5UYWJsZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdXBkYXRlVGFibGVNYXAoMCwgd2FzbVRhYmxlLmxlbmd0aCk7XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0luVGFibGVNYXAuaGFzKGZ1bmMpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uc0luVGFibGVNYXAuZ2V0KGZ1bmMpO1xuICB9XG5cbiAgLy8gSXQncyBub3QgaW4gdGhlIHRhYmxlLCBhZGQgaXQgbm93LlxuXG4gIHZhciByZXQgPSBnZXRFbXB0eVRhYmxlU2xvdCgpO1xuXG4gIC8vIFNldCB0aGUgbmV3IHZhbHVlLlxuICB0cnkge1xuICAgIC8vIEF0dGVtcHRpbmcgdG8gY2FsbCB0aGlzIHdpdGggSlMgZnVuY3Rpb24gd2lsbCBjYXVzZSBvZiB0YWJsZS5zZXQoKSB0byBmYWlsXG4gICAgc2V0V2FzbVRhYmxlRW50cnkocmV0LCBmdW5jKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBhc3NlcnQodHlwZW9mIHNpZyAhPSAndW5kZWZpbmVkJywgJ01pc3Npbmcgc2lnbmF0dXJlIGFyZ3VtZW50IHRvIGFkZEZ1bmN0aW9uOiAnICsgZnVuYyk7XG4gICAgdmFyIHdyYXBwZWQgPSBjb252ZXJ0SnNGdW5jdGlvblRvV2FzbShmdW5jLCBzaWcpO1xuICAgIHNldFdhc21UYWJsZUVudHJ5KHJldCwgd3JhcHBlZCk7XG4gIH1cblxuICBmdW5jdGlvbnNJblRhYmxlTWFwLnNldChmdW5jLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGluZGV4KSB7XG4gIGZ1bmN0aW9uc0luVGFibGVNYXAuZGVsZXRlKGdldFdhc21UYWJsZUVudHJ5KGluZGV4KSk7XG4gIGZyZWVUYWJsZUluZGV4ZXMucHVzaChpbmRleCk7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2Z1bmN0aW9ucy5qc1xuLy8gaW5jbHVkZTogcnVudGltZV9kZWJ1Zy5qc1xuXG5cbmZ1bmN0aW9uIGxlZ2FjeU1vZHVsZVByb3AocHJvcCwgbmV3TmFtZSkge1xuICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIHByb3AsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGFib3J0KCdNb2R1bGUuJyArIHByb3AgKyAnIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggcGxhaW4gJyArIG5ld05hbWUgKyAnICh0aGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgcHJvdmlkZWQgb24gTW9kdWxlLCBidXQgYWZ0ZXIgc3RhcnR1cCB0aGUgdmFsdWUgaXMgb25seSBsb29rZWQgZm9yIG9uIGEgbG9jYWwgdmFyaWFibGUgb2YgdGhhdCBuYW1lKScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICAgIGFib3J0KCdgTW9kdWxlLicgKyBwcm9wICsgJ2Agd2FzIHN1cHBsaWVkIGJ1dCBgJyArIHByb3AgKyAnYCBub3QgaW5jbHVkZWQgaW4gSU5DT01JTkdfTU9EVUxFX0pTX0FQSScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRNZXNzYWdlKHN5bSwgaXNGU1N5Ym9sKSB7XG4gIHZhciBtc2cgPSBcIidcIiArIHN5bSArIFwiJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIjtcbiAgaWYgKGlzRlNTeWJvbCkge1xuICAgIG1zZyArPSAnLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdSc7XG4gIH1cbiAgcmV0dXJuIG1zZztcbn1cblxuZnVuY3Rpb24gdW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woc3ltLCBpc0ZTU3lib2wpIHtcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgc3ltKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIHN5bSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYWJvcnQodW5leHBvcnRlZE1lc3NhZ2Uoc3ltLCBpc0ZTU3lib2wpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKHN5bSwgaXNGU1N5Ym9sKSB7XG4gIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHN5bSkpIHtcbiAgICBNb2R1bGVbc3ltXSA9ICgpID0+IGFib3J0KHVuZXhwb3J0ZWRNZXNzYWdlKHN5bSwgaXNGU1N5Ym9sKSk7XG4gIH1cbn1cblxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZGVidWcuanNcbnZhciB0ZW1wUmV0MCA9IDA7XG52YXIgc2V0VGVtcFJldDAgPSAodmFsdWUpID0+IHsgdGVtcFJldDAgPSB2YWx1ZTsgfTtcbnZhciBnZXRUZW1wUmV0MCA9ICgpID0+IHRlbXBSZXQwO1xuXG5cblxuLy8gPT09IFByZWFtYmxlIGxpYnJhcnkgc3R1ZmYgPT09XG5cbi8vIERvY3VtZW50YXRpb24gZm9yIHRoZSBwdWJsaWMgQVBJcyBkZWZpbmVkIGluIHRoaXMgZmlsZSBtdXN0IGJlIHVwZGF0ZWQgaW46XG4vLyAgICBzaXRlL3NvdXJjZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMucnN0XG4vLyBBIHByZWJ1aWx0IGxvY2FsIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0OlxuLy8gICAgc2l0ZS9idWlsZC90ZXh0L2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy50eHRcbi8vIFlvdSBjYW4gYWxzbyBidWlsZCBkb2NzIGxvY2FsbHkgYXMgSFRNTCBvciBvdGhlciBmb3JtYXRzIGluIHNpdGUvXG4vLyBBbiBvbmxpbmUgSFRNTCB2ZXJzaW9uICh3aGljaCBtYXkgYmUgb2YgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBFbXNjcmlwdGVuKVxuLy8gICAgaXMgdXAgYXQgaHR0cDovL2tyaXBrZW4uZ2l0aHViLmlvL2Vtc2NyaXB0ZW4tc2l0ZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMuaHRtbFxuXG52YXIgZHluYW1pY0xpYnJhcmllcyA9IE1vZHVsZVsnZHluYW1pY0xpYnJhcmllcyddIHx8IFtdO1xuXG52YXIgd2FzbUJpbmFyeTtcbmlmIChNb2R1bGVbJ3dhc21CaW5hcnknXSkgd2FzbUJpbmFyeSA9IE1vZHVsZVsnd2FzbUJpbmFyeSddO2xlZ2FjeU1vZHVsZVByb3AoJ3dhc21CaW5hcnknLCAnd2FzbUJpbmFyeScpO1xudmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbJ25vRXhpdFJ1bnRpbWUnXSB8fCB0cnVlO2xlZ2FjeU1vZHVsZVByb3AoJ25vRXhpdFJ1bnRpbWUnLCAnbm9FeGl0UnVudGltZScpO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9ICdvYmplY3QnKSB7XG4gIGFib3J0KCdubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkJyk7XG59XG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfc2FmZV9oZWFwLmpzXG5cblxuLy8gSW4gTUlOSU1BTF9SVU5USU1FLCBzZXRWYWx1ZSgpIGFuZCBnZXRWYWx1ZSgpIGFyZSBvbmx5IGF2YWlsYWJsZSB3aGVuIGJ1aWxkaW5nIHdpdGggc2FmZSBoZWFwIGVuYWJsZWQsIGZvciBoZWFwIHNhZmV0eSBjaGVja2luZy5cbi8vIEluIHRyYWRpdGlvbmFsIHJ1bnRpbWUsIHNldFZhbHVlKCkgYW5kIGdldFZhbHVlKCkgYXJlIGFsd2F5cyBhdmFpbGFibGUgKGFsdGhvdWdoIHRoZWlyIHVzZSBpcyBoaWdobHkgZGlzY291cmFnZWQgZHVlIHRvIHBlcmYgcGVuYWx0aWVzKVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHB0clxuICAgIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbj19IG5vU2FmZSAqL1xuZnVuY3Rpb24gc2V0VmFsdWUocHRyLCB2YWx1ZSwgdHlwZSA9ICdpOCcsIG5vU2FmZSkge1xuICBpZiAodHlwZS5jaGFyQXQodHlwZS5sZW5ndGgtMSkgPT09ICcqJykgdHlwZSA9ICdpMzInO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaTEnOiBIRUFQOFsoKHB0cik+PjApXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2k4JzogSEVBUDhbKChwdHIpPj4wKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpMTYnOiBIRUFQMTZbKChwdHIpPj4xKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpMzInOiBIRUFQMzJbKChwdHIpPj4yKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlICdpNjQnOiAodGVtcEk2NCA9IFt2YWx1ZT4+PjAsKHRlbXBEb3VibGU9dmFsdWUsKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChwdHIpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChwdHIpKyg0KSk+PjIpXSA9IHRlbXBJNjRbMV0pOyBicmVhaztcbiAgICAgIGNhc2UgJ2Zsb2F0JzogSEVBUEYzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2RvdWJsZSc6IEhFQVBGNjRbKChwdHIpPj4zKV0gPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgIH1cbn1cblxuLyoqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAgICBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW49fSBub1NhZmUgKi9cbmZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9ICdpOCcsIG5vU2FmZSkge1xuICBpZiAodHlwZS5jaGFyQXQodHlwZS5sZW5ndGgtMSkgPT09ICcqJykgdHlwZSA9ICdpMzInO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaTEnOiByZXR1cm4gSEVBUDhbKChwdHIpPj4wKV07XG4gICAgICBjYXNlICdpOCc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcbiAgICAgIGNhc2UgJ2kxNic6IHJldHVybiBIRUFQMTZbKChwdHIpPj4xKV07XG4gICAgICBjYXNlICdpMzInOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xuICAgICAgY2FzZSAnaTY0JzogcmV0dXJuIEhFQVAzMlsoKHB0cik+PjIpXTtcbiAgICAgIGNhc2UgJ2Zsb2F0JzogcmV0dXJuIEhFQVBGMzJbKChwdHIpPj4yKV07XG4gICAgICBjYXNlICdkb3VibGUnOiByZXR1cm4gTnVtYmVyKEhFQVBGNjRbKChwdHIpPj4zKV0pO1xuICAgICAgZGVmYXVsdDogYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zYWZlX2hlYXAuanNcbi8vIFdhc20gZ2xvYmFsc1xuXG52YXIgd2FzbU1lbW9yeTtcblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSdW50aW1lIGVzc2VudGlhbHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB3aGV0aGVyIHdlIGFyZSBxdWl0dGluZyB0aGUgYXBwbGljYXRpb24uIG5vIGNvZGUgc2hvdWxkIHJ1biBhZnRlciB0aGlzLlxuLy8gc2V0IGluIGV4aXQoKSBhbmQgYWJvcnQoKVxudmFyIEFCT1JUID0gZmFsc2U7XG5cbi8vIHNldCBieSBleGl0KCkgYW5kIGFib3J0KCkuICBQYXNzZWQgdG8gJ29uRXhpdCcgaGFuZGxlci5cbi8vIE5PVEU6IFRoaXMgaXMgYWxzbyB1c2VkIGFzIHRoZSBwcm9jZXNzIHJldHVybiBjb2RlIGNvZGUgaW4gc2hlbGwgZW52aXJvbm1lbnRzXG4vLyBidXQgb25seSB3aGVuIG5vRXhpdFJ1bnRpbWUgaXMgZmFsc2UuXG52YXIgRVhJVFNUQVRVUztcblxuLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZCcgKyAodGV4dCA/ICc6ICcgKyB0ZXh0IDogJycpKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBDIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgaWRlbnRpZmllciAoZm9yIEMrKywgeW91IG5lZWQgdG8gZG8gbWFudWFsIG5hbWUgbWFuZ2xpbmcpXG5mdW5jdGlvbiBnZXRDRnVuYyhpZGVudCkge1xuICB2YXIgZnVuYyA9IE1vZHVsZVsnXycgKyBpZGVudF07IC8vIGNsb3N1cmUgZXhwb3J0ZWQgZnVuY3Rpb25cbiAgYXNzZXJ0KGZ1bmMsICdDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uICcgKyBpZGVudCArICcsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZCcpO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gQyBjYWxsaW5nIGludGVyZmFjZS5cbi8qKiBAcGFyYW0ge3N0cmluZ3xudWxsPX0gcmV0dXJuVHlwZVxuICAgIEBwYXJhbSB7QXJyYXk9fSBhcmdUeXBlc1xuICAgIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5PX0gYXJnc1xuICAgIEBwYXJhbSB7T2JqZWN0PX0gb3B0cyAqL1xuZnVuY3Rpb24gY2NhbGwoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmdzLCBvcHRzKSB7XG4gIC8vIEZvciBmYXN0IGxvb2t1cCBvZiBjb252ZXJzaW9uIGZ1bmN0aW9uc1xuICB2YXIgdG9DID0ge1xuICAgICdzdHJpbmcnOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHsgLy8gbnVsbCBzdHJpbmdcbiAgICAgICAgLy8gYXQgbW9zdCA0IGJ5dGVzIHBlciBVVEYtOCBjb2RlIHBvaW50LCArMSBmb3IgdGhlIHRyYWlsaW5nICdcXDAnXG4gICAgICAgIHZhciBsZW4gPSAoc3RyLmxlbmd0aCA8PCAyKSArIDE7XG4gICAgICAgIHJldCA9IHN0YWNrQWxsb2MobGVuKTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBsZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgICdhcnJheSc6IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XG4gICAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCkge1xuICAgIGlmIChyZXR1cm5UeXBlID09PSAnc3RyaW5nJykgcmV0dXJuIFVURjhUb1N0cmluZyhyZXQpO1xuICAgIGlmIChyZXR1cm5UeXBlID09PSAnYm9vbGVhbicpIHJldHVybiBCb29sZWFuKHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHZhciBmdW5jID0gZ2V0Q0Z1bmMoaWRlbnQpO1xuICB2YXIgY0FyZ3MgPSBbXTtcbiAgdmFyIHN0YWNrID0gMDtcbiAgYXNzZXJ0KHJldHVyblR5cGUgIT09ICdhcnJheScsICdSZXR1cm4gdHlwZSBzaG91bGQgbm90IGJlIFwiYXJyYXlcIi4nKTtcbiAgaWYgKGFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSB0b0NbYXJnVHlwZXNbaV1dO1xuICAgICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgICAgIGNBcmdzW2ldID0gY29udmVydGVyKGFyZ3NbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmV0ID0gZnVuYy5hcHBseShudWxsLCBjQXJncyk7XG4gIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcbiAgICBpZiAoc3RhY2sgIT09IDApIHN0YWNrUmVzdG9yZShzdGFjayk7XG4gICAgcmV0dXJuIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpO1xuICB9XG5cbiAgcmV0ID0gb25Eb25lKHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZz19IHJldHVyblR5cGVcbiAgICBAcGFyYW0ge0FycmF5PX0gYXJnVHlwZXNcbiAgICBAcGFyYW0ge09iamVjdD19IG9wdHMgKi9cbmZ1bmN0aW9uIGN3cmFwKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgb3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJndW1lbnRzLCBvcHRzKTtcbiAgfVxufVxuXG4vLyBXZSB1c2VkIHRvIGluY2x1ZGUgbWFsbG9jL2ZyZWUgYnkgZGVmYXVsdCBpbiB0aGUgcGFzdC4gU2hvdyBhIGhlbHBmdWwgZXJyb3IgaW5cbi8vIGJ1aWxkcyB3aXRoIGFzc2VydGlvbnMuXG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfbGVnYWN5LmpzXG5cblxudmFyIEFMTE9DX05PUk1BTCA9IDA7IC8vIFRyaWVzIHRvIHVzZSBfbWFsbG9jKClcbnZhciBBTExPQ19TVEFDSyA9IDE7IC8vIExpdmVzIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24gY2FsbFxuXG4vKipcbiAqIGFsbG9jYXRlKCk6IFRoaXMgZnVuY3Rpb24gaXMgbm8gbG9uZ2VyIHVzZWQgYnkgZW1zY3JpcHRlbiBidXQgaXMga2VwdCBhcm91bmQgdG8gYXZvaWRcbiAqICAgICAgICAgICAgIGJyZWFraW5nIGV4dGVybmFsIHVzZXJzLlxuICogICAgICAgICAgICAgWW91IHNob3VsZCBub3JtYWxseSBub3QgdXNlIGFsbG9jYXRlKCksIGFuZCBpbnN0ZWFkIGFsbG9jYXRlXG4gKiAgICAgICAgICAgICBtZW1vcnkgdXNpbmcgX21hbGxvYygpL3N0YWNrQWxsb2MoKSwgaW5pdGlhbGl6ZSBpdCB3aXRoXG4gKiAgICAgICAgICAgICBzZXRWYWx1ZSgpLCBhbmQgc28gZm9ydGguXG4gKiBAcGFyYW0geyhVaW50OEFycmF5fEFycmF5PG51bWJlcj4pfSBzbGFiOiBBbiBhcnJheSBvZiBkYXRhLlxuICogQHBhcmFtIHtudW1iZXI9fSBhbGxvY2F0b3IgOiBIb3cgdG8gYWxsb2NhdGUgbWVtb3J5LCBzZWUgQUxMT0NfKlxuICovXG5mdW5jdGlvbiBhbGxvY2F0ZShzbGFiLCBhbGxvY2F0b3IpIHtcbiAgdmFyIHJldDtcbiAgYXNzZXJ0KHR5cGVvZiBhbGxvY2F0b3IgPT0gJ251bWJlcicsICdhbGxvY2F0ZSBubyBsb25nZXIgdGFrZXMgYSB0eXBlIGFyZ3VtZW50JylcbiAgYXNzZXJ0KHR5cGVvZiBzbGFiICE9ICdudW1iZXInLCAnYWxsb2NhdGUgbm8gbG9uZ2VyIHRha2VzIGEgbnVtYmVyIGFzIGFyZzAnKVxuXG4gIGlmIChhbGxvY2F0b3IgPT0gQUxMT0NfU1RBQ0spIHtcbiAgICByZXQgPSBzdGFja0FsbG9jKHNsYWIubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBfbWFsbG9jKHNsYWIubGVuZ3RoKTtcbiAgfVxuXG4gIGlmICghc2xhYi5zdWJhcnJheSAmJiAhc2xhYi5zbGljZSkge1xuICAgIHNsYWIgPSBuZXcgVWludDhBcnJheShzbGFiKTtcbiAgfVxuICBIRUFQVTguc2V0KHNsYWIsIHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2xlZ2FjeS5qc1xuLy8gaW5jbHVkZTogcnVudGltZV9zdHJpbmdzLmpzXG5cblxuLy8gcnVudGltZV9zdHJpbmdzLmpzOiBTdHJpbmdzIHJlbGF0ZWQgcnVudGltZSBmdW5jdGlvbnMgdGhhdCBhcmUgcGFydCBvZiBib3RoIE1JTklNQUxfUlVOVElNRSBhbmQgcmVndWxhciBydW50aW1lLlxuXG52YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgY29udGFpbnMgdWludDggdmFsdWVzLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4vKipcbiAqIGhlYXBPckFycmF5IGlzIGVpdGhlciBhIHJlZ3VsYXIgYXJyYXksIG9yIGEgSmF2YVNjcmlwdCB0eXBlZCBhcnJheSB2aWV3LlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtudW1iZXI9fSBtYXhCeXRlc1RvUmVhZFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gIHZhciBlbmRQdHIgPSBpZHg7XG4gIC8vIFRleHREZWNvZGVyIG5lZWRzIHRvIGtub3cgdGhlIGJ5dGUgbGVuZ3RoIGluIGFkdmFuY2UsIGl0IGRvZXNuJ3Qgc3RvcCBvbiBudWxsIHRlcm1pbmF0b3IgYnkgaXRzZWxmLlxuICAvLyBBbHNvLCB1c2UgdGhlIGxlbmd0aCBpbmZvIHRvIGF2b2lkIHJ1bm5pbmcgdGlueSBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxuICAvLyAoQXMgYSB0aW55IGNvZGUgc2F2ZSB0cmljaywgY29tcGFyZSBlbmRQdHIgYWdhaW5zdCBlbmRJZHggdXNpbmcgYSBuZWdhdGlvbiwgc28gdGhhdCB1bmRlZmluZWQgbWVhbnMgSW5maW5pdHkpXG4gIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuXG4gIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIC8vIElmIGJ1aWxkaW5nIHdpdGggVGV4dERlY29kZXIsIHdlIGhhdmUgYWxyZWFkeSBjb21wdXRlZCB0aGUgc3RyaW5nIGxlbmd0aCBhYm92ZSwgc28gdGVzdCBsb29wIGVuZCBjb25kaXRpb24gYWdhaW5zdCB0aGF0XG4gICAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xuICAgICAgLy8gRm9yIFVURjggYnl0ZSBzdHJ1Y3R1cmUsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgIC8vIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dFxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMHg4MCkpIHsgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApOyBjb250aW51ZTsgfVxuICAgICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxuICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKHUwICYgMHhGOCkgIT0gMHhGMCkgd2Fybk9uY2UoJ0ludmFsaWQgVVRGLTggbGVhZGluZyBieXRlIDB4JyArIHUwLnRvU3RyaW5nKDE2KSArICcgZW5jb3VudGVyZWQgd2hlbiBkZXNlcmlhbGl6aW5nIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5IHRvIGEgSlMgc3RyaW5nIScpO1xuICAgICAgICB1MCA9ICgodTAgJiA3KSA8PCAxOCkgfCAodTEgPDwgMTIpIHwgKHUyIDw8IDYpIHwgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUwIDwgMHgxMDAwMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2ggPSB1MCAtIDB4MTAwMDA7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBlbXNjcmlwdGVuIEhFQVAsIHJldHVybnMgYVxuLy8gY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cbi8vIG1heEJ5dGVzVG9SZWFkOiBhbiBvcHRpb25hbCBsZW5ndGggdGhhdCBzcGVjaWZpZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIFlvdSBjYW4gb21pdFxuLy8gICAgICAgICAgICAgICAgIHRoaXMgcGFyYW1ldGVyIHRvIHNjYW4gdGhlIHN0cmluZyB1bnRpbCB0aGUgZmlyc3QgXFwwIGJ5dGUuIElmIG1heEJ5dGVzVG9SZWFkIGlzXG4vLyAgICAgICAgICAgICAgICAgcGFzc2VkLCBhbmQgdGhlIHN0cmluZyBhdCBbcHRyLCBwdHIrbWF4Qnl0ZXNUb1JlYWRyWyBjb250YWlucyBhIG51bGwgYnl0ZSBpbiB0aGVcbi8vICAgICAgICAgICAgICAgICBtaWRkbGUsIHRoZW4gdGhlIHN0cmluZyB3aWxsIGN1dCBzaG9ydCBhdCB0aGF0IGJ5dGUgaW5kZXggKGkuZS4gbWF4Qnl0ZXNUb1JlYWQgd2lsbFxuLy8gICAgICAgICAgICAgICAgIG5vdCBwcm9kdWNlIGEgc3RyaW5nIG9mIGV4YWN0IGxlbmd0aCBbcHRyLCBwdHIrbWF4Qnl0ZXNUb1JlYWRbKVxuLy8gICAgICAgICAgICAgICAgIE4uQi4gbWl4aW5nIGZyZXF1ZW50IHVzZXMgb2YgVVRGOFRvU3RyaW5nKCkgd2l0aCBhbmQgd2l0aG91dCBtYXhCeXRlc1RvUmVhZCBtYXlcbi8vICAgICAgICAgICAgICAgICB0aHJvdyBKUyBKSVQgb3B0aW1pemF0aW9ucyBvZmYsIHNvIGl0IGlzIHdvcnRoIHRvIGNvbnNpZGVyIGNvbnNpc3RlbnRseSB1c2luZyBvbmVcbi8vICAgICAgICAgICAgICAgICBzdHlsZSBvciB0aGUgb3RoZXIuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4Qnl0ZXNUb1JlYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgO1xuICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBhdCBhZGRyZXNzICdvdXRJZHgnLFxuLy8gZW5jb2RlZCBpbiBVVEY4IGZvcm0gYW5kIG51bGwtdGVybWluYXRlZC4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXG4vLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOCB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxuLy8gUGFyYW1ldGVyczpcbi8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cbi8vICAgaGVhcDogdGhlIGFycmF5IHRvIGNvcHkgdG8uIEVhY2ggaW5kZXggaW4gdGhpcyBhcnJheSBpcyBhc3N1bWVkIHRvIGJlIG9uZSA4LWJ5dGUgZWxlbWVudC5cbi8vICAgb3V0SWR4OiBUaGUgc3RhcnRpbmcgb2Zmc2V0IGluIHRoZSBhcnJheSB0byBiZWdpbiB0aGUgY29weWluZy5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LlxuLy8gICAgICAgICAgICAgICAgICAgIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGwgdGVybWluYXRvcixcbi8vICAgICAgICAgICAgICAgICAgICBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT0xLCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXG4vLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPTAgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsIHVuZGVmaW5lZCBhbmQgZmFsc2UgZWFjaCBkb24ndCB3cml0ZSBvdXQgYW55IGJ5dGVzLlxuICAgIHJldHVybiAwO1xuXG4gIHZhciBzdGFydElkeCA9IG91dElkeDtcbiAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7IC8vIC0xIGZvciBzdHJpbmcgbnVsbCB0ZXJtaW5hdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb24gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dCBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB7XG4gICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHUxICYgMHgzRkYpO1xuICAgIH1cbiAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEMwIHwgKHUgPj4gNik7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEUwIHwgKHUgPj4gMTIpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBpZiAodSA+IDB4MTBGRkZGKSB3YXJuT25jZSgnSW52YWxpZCBVbmljb2RlIGNvZGUgcG9pbnQgMHgnICsgdS50b1N0cmluZygxNikgKyAnIGVuY291bnRlcmVkIHdoZW4gc2VyaWFsaXppbmcgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkhIChWYWxpZCB1bmljb2RlIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbiByYW5nZSAwLTB4MTBGRkZGKS4nKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhGMCB8ICh1ID4+IDE4KTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIGJ1ZmZlci5cbiAgaGVhcFtvdXRJZHhdID0gMDtcbiAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGOCBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4IHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xuICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEY4IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcbiAgICBpZiAodSA8PSAweDdGKSArK2xlbjtcbiAgICBlbHNlIGlmICh1IDw9IDB4N0ZGKSBsZW4gKz0gMjtcbiAgICBlbHNlIGlmICh1IDw9IDB4RkZGRikgbGVuICs9IDM7XG4gICAgZWxzZSBsZW4gKz0gNDtcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zdHJpbmdzLmpzXG4vLyBpbmNsdWRlOiBydW50aW1lX3N0cmluZ3NfZXh0cmEuanNcblxuXG4vLyBydW50aW1lX3N0cmluZ3NfZXh0cmEuanM6IFN0cmluZ3MgcmVsYXRlZCBydW50aW1lIGZ1bmN0aW9ucyB0aGF0IGFyZSBhdmFpbGFibGUgb25seSBpbiByZWd1bGFyIHJ1bnRpbWUuXG5cbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBBU0NJSS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG5cbmZ1bmN0aW9uIEFzY2lpVG9TdHJpbmcocHRyKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgY2ggPSBIRUFQVThbKChwdHIrKyk+PjApXTtcbiAgICBpZiAoIWNoKSByZXR1cm4gc3RyO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgfVxufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gQVNDSUkgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCsxIGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxuXG5mdW5jdGlvbiBzdHJpbmdUb0FzY2lpKHN0ciwgb3V0UHRyKSB7XG4gIHJldHVybiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBvdXRQdHIsIGZhbHNlKTtcbn1cblxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjE2TEUtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xuLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxuXG52YXIgVVRGMTZEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZsZScpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBVVEYxNlRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgYXNzZXJ0KHB0ciAlIDIgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIFVURjE2VG9TdHJpbmcgbXVzdCBiZSBhbGlnbmVkIHRvIHR3byBieXRlcyEnKTtcbiAgdmFyIGVuZFB0ciA9IHB0cjtcbiAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uIG51bGwgdGVybWluYXRvciBieSBpdHNlbGYuXG4gIC8vIEFsc28sIHVzZSB0aGUgbGVuZ3RoIGluZm8gdG8gYXZvaWQgcnVubmluZyB0aW55IHN0cmluZ3MgdGhyb3VnaCBUZXh0RGVjb2Rlciwgc2luY2UgLnN1YmFycmF5KCkgYWxsb2NhdGVzIGdhcmJhZ2UuXG4gIHZhciBpZHggPSBlbmRQdHIgPj4gMTtcbiAgdmFyIG1heElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkIC8gMjtcbiAgLy8gSWYgbWF4Qnl0ZXNUb1JlYWQgaXMgbm90IHBhc3NlZCBleHBsaWNpdGx5LCBpdCB3aWxsIGJlIHVuZGVmaW5lZCwgYW5kIHRoaXNcbiAgLy8gd2lsbCBhbHdheXMgZXZhbHVhdGUgdG8gdHJ1ZS4gVGhpcyBzYXZlcyBvbiBjb2RlIHNpemUuXG4gIHdoaWxlICghKGlkeCA+PSBtYXhJZHgpICYmIEhFQVBVMTZbaWR4XSkgKytpZHg7XG4gIGVuZFB0ciA9IGlkeCA8PCAxO1xuXG4gIGlmIChlbmRQdHIgLSBwdHIgPiAzMiAmJiBVVEYxNkRlY29kZXIpIHtcbiAgICByZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLCBlbmRQdHIpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAvLyBJZiBtYXhCeXRlc1RvUmVhZCBpcyBub3QgcGFzc2VkIGV4cGxpY2l0bHksIGl0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhlIGZvci1sb29wJ3MgY29uZGl0aW9uXG4gICAgLy8gd2lsbCBhbHdheXMgZXZhbHVhdGUgdG8gdHJ1ZS4gVGhlIGxvb3AgaXMgdGhlbiB0ZXJtaW5hdGVkIG9uIHRoZSBmaXJzdCBudWxsIGNoYXIuXG4gICAgZm9yICh2YXIgaSA9IDA7ICEoaSA+PSBtYXhCeXRlc1RvUmVhZCAvIDIpOyArK2kpIHtcbiAgICAgIHZhciBjb2RlVW5pdCA9IEhFQVAxNlsoKChwdHIpKyhpKjIpKT4+MSldO1xuICAgICAgaWYgKGNvZGVVbml0ID09IDApIGJyZWFrO1xuICAgICAgLy8gZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBjb2RlIHVuaXQsIHNvIHdlIGNhbiBwYXNzIHRoZSBVVEYxNiBzdHJpbmcgcmlnaHQgdGhyb3VnaC5cbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYxNiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMiBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9Miwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTwyIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgYXNzZXJ0KG91dFB0ciAlIDIgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIHN0cmluZ1RvVVRGMTYgbXVzdCBiZSBhbGlnbmVkIHRvIHR3byBieXRlcyEnKTtcbiAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XG4gIH1cbiAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDIpIHJldHVybiAwO1xuICBtYXhCeXRlc1RvV3JpdGUgLT0gMjsgLy8gTnVsbCB0ZXJtaW5hdG9yLlxuICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XG4gIHZhciBudW1DaGFyc1RvV3JpdGUgPSAobWF4Qnl0ZXNUb1dyaXRlIDwgc3RyLmxlbmd0aCoyKSA/IChtYXhCeXRlc1RvV3JpdGUgLyAyKSA6IHN0ci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhcnNUb1dyaXRlOyArK2kpIHtcbiAgICAvLyBjaGFyQ29kZUF0IHJldHVybnMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIHNvIGl0IGNhbiBiZSBkaXJlY3RseSB3cml0dGVuIHRvIHRoZSBIRUFQLlxuICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgSEVBUDE2Wygob3V0UHRyKT4+MSldID0gY29kZVVuaXQ7XG4gICAgb3V0UHRyICs9IDI7XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gIEhFQVAxNlsoKG91dFB0cik+PjEpXSA9IDA7XG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNihzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGgqMjtcbn1cblxuZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gIGFzc2VydChwdHIgJSA0ID09IDAsICdQb2ludGVyIHBhc3NlZCB0byBVVEYzMlRvU3RyaW5nIG11c3QgYmUgYWxpZ25lZCB0byBmb3VyIGJ5dGVzIScpO1xuICB2YXIgaSA9IDA7XG5cbiAgdmFyIHN0ciA9ICcnO1xuICAvLyBJZiBtYXhCeXRlc1RvUmVhZCBpcyBub3QgcGFzc2VkIGV4cGxpY2l0bHksIGl0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhpc1xuICAvLyB3aWxsIGFsd2F5cyBldmFsdWF0ZSB0byB0cnVlLiBUaGlzIHNhdmVzIG9uIGNvZGUgc2l6ZS5cbiAgd2hpbGUgKCEoaSA+PSBtYXhCeXRlc1RvUmVhZCAvIDQpKSB7XG4gICAgdmFyIHV0ZjMyID0gSEVBUDMyWygoKHB0cikrKGkqNCkpPj4yKV07XG4gICAgaWYgKHV0ZjMyID09IDApIGJyZWFrO1xuICAgICsraTtcbiAgICAvLyBHb3RjaGE6IGZyb21DaGFyQ29kZSBjb25zdHJ1Y3RzIGEgY2hhcmFjdGVyIGZyb20gYSBVVEYtMTYgZW5jb2RlZCBjb2RlIChwYWlyKSwgbm90IGZyb20gYSBVbmljb2RlIGNvZGUgcG9pbnQhIFNvIGVuY29kZSB0aGUgY29kZSBwb2ludCB0byBVVEYtMTYgZm9yIGNvbnN0cnVjdGluZy5cbiAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xuICAgIGlmICh1dGYzMiA+PSAweDEwMDAwKSB7XG4gICAgICB2YXIgY2ggPSB1dGYzMiAtIDB4MTAwMDA7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgfCAoY2ggPj4gMTApLCAweERDMDAgfCAoY2ggJiAweDNGRikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYzMiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrNCBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9NCwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTw0IGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgYXNzZXJ0KG91dFB0ciAlIDQgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIHN0cmluZ1RvVVRGMzIgbXVzdCBiZSBhbGlnbmVkIHRvIGZvdXIgYnl0ZXMhJyk7XG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEYzMihzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIG1heCBieXRlcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgdW5zYWZlIHVuYm91bmRlZCB3cml0ZSBpcyBhbGxvd2VkLlxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXhCeXRlc1RvV3JpdGUgPSAweDdGRkZGRkZGO1xuICB9XG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPCA0KSByZXR1cm4gMDtcbiAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyO1xuICB2YXIgZW5kUHRyID0gc3RhcnRQdHIgKyBtYXhCeXRlc1RvV3JpdGUgLSA0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFdlIG11c3QgZGVjb2RlIHRoZSBzdHJpbmcgdG8gVVRGLTMyIHRvIHRoZSBoZWFwLlxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcbiAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikge1xuICAgICAgdmFyIHRyYWlsU3Vycm9nYXRlID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIGNvZGVVbml0ID0gMHgxMDAwMCArICgoY29kZVVuaXQgJiAweDNGRikgPDwgMTApIHwgKHRyYWlsU3Vycm9nYXRlICYgMHgzRkYpO1xuICAgIH1cbiAgICBIRUFQMzJbKChvdXRQdHIpPj4yKV0gPSBjb2RlVW5pdDtcbiAgICBvdXRQdHIgKz0gNDtcbiAgICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWs7XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gIEhFQVAzMlsoKG91dFB0cik+PjIpXSA9IDA7XG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMihzdHIpIHtcbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikgKytpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlLCBzbyBza2lwIG92ZXIgdGhlIHRhaWwgc3Vycm9nYXRlLlxuICAgIGxlbiArPSA0O1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuLy8gQWxsb2NhdGUgaGVhcCBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cbi8vIEl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyIHRvIGZyZWUoKSB0aGF0IG1lbW9yeS5cbmZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpIHtcbiAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuICBpZiAocmV0KSBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVA4LCByZXQsIHNpemUpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBBbGxvY2F0ZSBzdGFjayBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cbmZ1bmN0aW9uIGFsbG9jYXRlVVRGOE9uU3RhY2soc3RyKSB7XG4gIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcbiAgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRGVwcmVjYXRlZDogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWNhdXNlIGl0IGlzIHVuc2FmZSBhbmQgZG9lcyBub3QgcHJvdmlkZVxuLy8gYSBtYXhpbXVtIGxlbmd0aCBsaW1pdCBvZiBob3cgbWFueSBieXRlcyBpdCBpcyBhbGxvd2VkIHRvIHdyaXRlLiBQcmVmZXIgY2FsbGluZyB0aGVcbi8vIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KCkgaW5zdGVhZCwgd2hpY2ggdGFrZXMgaW4gYSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSB1c2VkXG4vLyB0byBiZSBzZWN1cmUgZnJvbSBvdXQgb2YgYm91bmRzIHdyaXRlcy5cbi8qKiBAZGVwcmVjYXRlZFxuICAgIEBwYXJhbSB7Ym9vbGVhbj19IGRvbnRBZGROdWxsICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1RvTWVtb3J5KHN0cmluZywgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICB3YXJuT25jZSgnd3JpdGVTdHJpbmdUb01lbW9yeSBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCEgVXNlIHN0cmluZ1RvVVRGOCgpIGluc3RlYWQhJyk7XG5cbiAgdmFyIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsYXN0Q2hhciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGVuZDtcbiAgaWYgKGRvbnRBZGROdWxsKSB7XG4gICAgLy8gc3RyaW5nVG9VVEY4QXJyYXkgYWx3YXlzIGFwcGVuZHMgbnVsbC4gSWYgd2UgZG9uJ3Qgd2FudCB0byBkbyB0aGF0LCByZW1lbWJlciB0aGVcbiAgICAvLyBjaGFyYWN0ZXIgdGhhdCBleGlzdGVkIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbnVsbCB3aWxsIGJlIHBsYWNlZCwgYW5kIHJlc3RvcmVcbiAgICAvLyB0aGF0IGFmdGVyIHRoZSB3cml0ZSAoYmVsb3cpLlxuICAgIGVuZCA9IGJ1ZmZlciArIGxlbmd0aEJ5dGVzVVRGOChzdHJpbmcpO1xuICAgIGxhc3RDaGFyID0gSEVBUDhbZW5kXTtcbiAgfVxuICBzdHJpbmdUb1VURjgoc3RyaW5nLCBidWZmZXIsIEluZmluaXR5KTtcbiAgaWYgKGRvbnRBZGROdWxsKSBIRUFQOFtlbmRdID0gbGFzdENoYXI7IC8vIFJlc3RvcmUgdGhlIHZhbHVlIHVuZGVyIHRoZSBudWxsIGNoYXJhY3Rlci5cbn1cblxuZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LCBidWZmZXIpIHtcbiAgYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCAnd3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KScpXG4gIEhFQVA4LnNldChhcnJheSwgYnVmZmVyKTtcbn1cblxuLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGRvbnRBZGROdWxsICovXG5mdW5jdGlvbiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBidWZmZXIsIGRvbnRBZGROdWxsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYXNzZXJ0KHN0ci5jaGFyQ29kZUF0KGkpID09PSAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSk7XG4gICAgSEVBUDhbKChidWZmZXIrKyk+PjApXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxuICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFsoKGJ1ZmZlcik+PjApXSA9IDA7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX3N0cmluZ3NfZXh0cmEuanNcbi8vIE1lbW9yeSBtYW5hZ2VtZW50XG5cbnZhciBIRUFQLFxuLyoqIEB0eXBlIHshQXJyYXlCdWZmZXJ9ICovXG4gIGJ1ZmZlcixcbi8qKiBAdHlwZSB7IUludDhBcnJheX0gKi9cbiAgSEVBUDgsXG4vKiogQHR5cGUgeyFVaW50OEFycmF5fSAqL1xuICBIRUFQVTgsXG4vKiogQHR5cGUgeyFJbnQxNkFycmF5fSAqL1xuICBIRUFQMTYsXG4vKiogQHR5cGUgeyFVaW50MTZBcnJheX0gKi9cbiAgSEVBUFUxNixcbi8qKiBAdHlwZSB7IUludDMyQXJyYXl9ICovXG4gIEhFQVAzMixcbi8qKiBAdHlwZSB7IVVpbnQzMkFycmF5fSAqL1xuICBIRUFQVTMyLFxuLyoqIEB0eXBlIHshRmxvYXQzMkFycmF5fSAqL1xuICBIRUFQRjMyLFxuLyoqIEB0eXBlIHshRmxvYXQ2NEFycmF5fSAqL1xuICBIRUFQRjY0O1xuXG5mdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgYnVmZmVyID0gYnVmO1xuICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmKTtcbn1cblxudmFyIFRPVEFMX1NUQUNLID0gNTI0Mjg4MDtcbmlmIChNb2R1bGVbJ1RPVEFMX1NUQUNLJ10pIGFzc2VydChUT1RBTF9TVEFDSyA9PT0gTW9kdWxlWydUT1RBTF9TVEFDSyddLCAndGhlIHN0YWNrIHNpemUgY2FuIG5vIGxvbmdlciBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUnKVxuXG52YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTM0MjE3NzI4O2xlZ2FjeU1vZHVsZVByb3AoJ0lOSVRJQUxfTUVNT1JZJywgJ0lOSVRJQUxfTUVNT1JZJyk7XG5cbmFzc2VydChJTklUSUFMX01FTU9SWSA+PSBUT1RBTF9TVEFDSywgJ0lOSVRJQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICcgKyBJTklUSUFMX01FTU9SWSArICchIChUT1RBTF9TVEFDSz0nICsgVE9UQUxfU1RBQ0sgKyAnKScpO1xuXG4vLyBjaGVjayBmb3IgZnVsbCBlbmdpbmUgc3VwcG9ydCAodXNlIHN0cmluZyAnc3ViYXJyYXknIHRvIGF2b2lkIGNsb3N1cmUgY29tcGlsZXIgY29uZnVzaW9uKVxuYXNzZXJ0KHR5cGVvZiBJbnQzMkFycmF5ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEludDMyQXJyYXkucHJvdG90eXBlLnN1YmFycmF5ICE9IHVuZGVmaW5lZCAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT0gdW5kZWZpbmVkLFxuICAgICAgICdKUyBlbmdpbmUgZG9lcyBub3QgcHJvdmlkZSBmdWxsIHR5cGVkIGFycmF5IHN1cHBvcnQnKTtcblxuLy8gSW4gbm9uLXN0YW5kYWxvbmUvbm9ybWFsIG1vZGUsIHdlIGNyZWF0ZSB0aGUgbWVtb3J5IGhlcmUuXG4vLyBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG5cblxuLy8gQ3JlYXRlIHRoZSB3YXNtIG1lbW9yeS4gKE5vdGU6IHRoaXMgb25seSBhcHBsaWVzIGlmIElNUE9SVEVEX01FTU9SWSBpcyBkZWZpbmVkKVxuXG4gIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ3dhc21NZW1vcnknXTtcbiAgfSBlbHNlXG4gIHtcbiAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAnaW5pdGlhbCc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG4gICAgICAnbWF4aW11bSc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzZcbiAgICB9KTtcbiAgfVxuXG5pZiAod2FzbU1lbW9yeSkge1xuICBidWZmZXIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbn1cblxuLy8gSWYgdGhlIHVzZXIgcHJvdmlkZXMgYW4gaW5jb3JyZWN0IGxlbmd0aCwganVzdCB1c2UgdGhhdCBsZW5ndGggaW5zdGVhZCByYXRoZXIgdGhhbiBwcm92aWRpbmcgdGhlIHVzZXIgdG9cbi8vIHNwZWNpZmljYWxseSBwcm92aWRlIHRoZSBtZW1vcnkgbGVuZ3RoIHdpdGggTW9kdWxlWydJTklUSUFMX01FTU9SWSddLlxuSU5JVElBTF9NRU1PUlkgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbmFzc2VydChJTklUSUFMX01FTU9SWSAlIDY1NTM2ID09PSAwKTtcbnVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKGJ1ZmZlcik7XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfaW5pdF90YWJsZS5qc1xuLy8gSW4gUkVMT0NBVEFCTEUgbW9kZSB3ZSBjcmVhdGUgdGhlIHRhYmxlIGluIEpTLlxudmFyIHdhc21UYWJsZSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7XG4gICdpbml0aWFsJzogNDM3NCxcbiAgJ2VsZW1lbnQnOiAnYW55ZnVuYydcbn0pO1xuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9pbml0X3RhYmxlLmpzXG4vLyBpbmNsdWRlOiBydW50aW1lX3N0YWNrX2NoZWNrLmpzXG5cblxuLy8gSW5pdGlhbGl6ZXMgdGhlIHN0YWNrIGNvb2tpZS4gQ2FsbGVkIGF0IHRoZSBzdGFydHVwIG9mIG1haW4gYW5kIGF0IHRoZSBzdGFydHVwIG9mIGVhY2ggdGhyZWFkIGluIHB0aHJlYWRzIG1vZGUuXG5mdW5jdGlvbiB3cml0ZVN0YWNrQ29va2llKCkge1xuICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuICBhc3NlcnQoKG1heCAmIDMpID09IDApO1xuICAvLyBUaGUgc3RhY2sgZ3JvdyBkb3dud2FyZHMgdG93YXJkcyBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kLlxuICAvLyBXZSB3cml0ZSBjb29raWVzIHRvIHRoZSBmaW5hbCB0d28gd29yZHMgaW4gdGhlIHN0YWNrIGFuZCBkZXRlY3QgaWYgdGhleSBhcmVcbiAgLy8gZXZlciBvdmVyd3JpdHRlbi5cbiAgSEVBUDMyWygobWF4KT4+MildID0gMHgyMTM1NDY3O1xuICBIRUFQMzJbKCgobWF4KSsoNCkpPj4yKV0gPSAweDg5QkFDREZFO1xuICAvLyBBbHNvIHRlc3QgdGhlIGdsb2JhbCBhZGRyZXNzIDAgZm9yIGludGVncml0eS5cbiAgSEVBUDMyWzBdID0gMHg2MzczNmQ2NTsgLyogJ2Vtc2MnICovXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhY2tDb29raWUoKSB7XG4gIGlmIChBQk9SVCkgcmV0dXJuO1xuICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuICB2YXIgY29va2llMSA9IEhFQVBVMzJbKChtYXgpPj4yKV07XG4gIHZhciBjb29raWUyID0gSEVBUFUzMlsoKChtYXgpKyg0KSk+PjIpXTtcbiAgLyppZiAoY29va2llMSAhPSAweDIxMzU0NjcgfHwgY29va2llMiAhPSAweDg5QkFDREZFKSB7XG4gICAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBTdGFjayBjb29raWUgaGFzIGJlZW4gb3ZlcndyaXR0ZW4sIGV4cGVjdGVkIGhleCBkd29yZHMgMHg4OUJBQ0RGRSBhbmQgMHgyMTM1NDY3LCBidXQgcmVjZWl2ZWQgMHgnICsgY29va2llMi50b1N0cmluZygxNikgKyAnIDB4JyArIGNvb2tpZTEudG9TdHJpbmcoMTYpKTtcbiAgfSovXG4gIC8vIEFsc28gdGVzdCB0aGUgZ2xvYmFsIGFkZHJlc3MgMCBmb3IgaW50ZWdyaXR5LlxuICBpZiAoSEVBUDMyWzBdICE9PSAweDYzNzM2ZDY1IC8qICdlbXNjJyAqLykgYWJvcnQoJ1J1bnRpbWUgZXJyb3I6IFRoZSBhcHBsaWNhdGlvbiBoYXMgY29ycnVwdGVkIGl0cyBoZWFwIG1lbW9yeSBhcmVhIChhZGRyZXNzIHplcm8pIScpO1xufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zdGFja19jaGVjay5qc1xuLy8gaW5jbHVkZTogcnVudGltZV9hc3NlcnRpb25zLmpzXG5cblxuLy8gRW5kaWFubmVzcyBjaGVja1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgaDE2ID0gbmV3IEludDE2QXJyYXkoMSk7XG4gIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gIGgxNlswXSA9IDB4NjM3MztcbiAgaWYgKGg4WzBdICE9PSAweDczIHx8IGg4WzFdICE9PSAweDYzKSB0aHJvdyAnUnVudGltZSBlcnJvcjogZXhwZWN0ZWQgdGhlIHN5c3RlbSB0byBiZSBsaXR0bGUtZW5kaWFuISAoUnVuIHdpdGggLXMgU1VQUE9SVF9CSUdfRU5ESUFOPTEgdG8gYnlwYXNzKSc7XG59KSgpO1xuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9hc3NlcnRpb25zLmpzXG52YXIgX19BVFBSRVJVTl9fICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGJlZm9yZSB0aGUgcnVudGltZSBpcyBpbml0aWFsaXplZFxudmFyIF9fQVRJTklUX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBkdXJpbmcgc3RhcnR1cFxudmFyIF9fQVRNQUlOX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCB3aGVuIG1haW4oKSBpcyB0byBiZSBydW5cbnZhciBfX0FURVhJVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHNodXRkb3duXG52YXIgX19BVFBPU1RSVU5fXyA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGFmdGVyIHRoZSBtYWluKCkgaXMgY2FsbGVkXG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpIHtcbiAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG59XG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcblxuICBpZiAoTW9kdWxlWydwcmVSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xufVxuXG5mdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuICBhc3NlcnQoIXJ1bnRpbWVJbml0aWFsaXplZCk7XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgXG5pZiAoIU1vZHVsZVtcIm5vRlNJbml0XCJdICYmICFGUy5pbml0LmluaXRpYWxpemVkKVxuICBGUy5pbml0KCk7XG5GUy5pZ25vcmVQZXJtaXNzaW9ucyA9IGZhbHNlO1xuXG5UVFkuaW5pdCgpO1xuU09DS0ZTLnJvb3QgPSBGUy5tb3VudChTT0NLRlMsIHt9LCBudWxsKTtcblBJUEVGUy5yb290ID0gRlMubW91bnQoUElQRUZTLCB7fSwgbnVsbCk7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG5mdW5jdGlvbiBwcmVNYWluKCkge1xuICBjaGVja1N0YWNrQ29va2llKCk7XG4gIFxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUTUFJTl9fKTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVNYWluKGNiKSB7XG4gIF9fQVRNQUlOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge1xufVxuXG5mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuLy8gaW5jbHVkZTogcnVudGltZV9tYXRoLmpzXG5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9pbXVsXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvZnJvdW5kXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuY1xuXG5hc3NlcnQoTWF0aC5pbXVsLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5pbXVsKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG5hc3NlcnQoTWF0aC5mcm91bmQsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmZyb3VuZCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGguY2x6MzIsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmNsejMyKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG5hc3NlcnQoTWF0aC50cnVuYywgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGgudHJ1bmMoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGwnKTtcblxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfbWF0aC5qc1xuLy8gQSBjb3VudGVyIG9mIGRlcGVuZGVuY2llcyBmb3IgY2FsbGluZyBydW4oKS4gSWYgd2UgbmVlZCB0b1xuLy8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYmVmb3JlIHJ1bm5pbmcsIGluY3JlbWVudCB0aGlzIGFuZFxuLy8gZGVjcmVtZW50IGl0LiBJbmNyZW1lbnRpbmcgbXVzdCBoYXBwZW4gaW4gYSBwbGFjZSBsaWtlXG4vLyBNb2R1bGUucHJlUnVuICh1c2VkIGJ5IGVtY2MgdG8gYWRkIGZpbGUgcHJlbG9hZGluZykuXG4vLyBOb3RlIHRoYXQgeW91IGNhbiBhZGQgZGVwZW5kZW5jaWVzIGluIHByZVJ1biwgZXZlbiB0aG91Z2hcbi8vIGl0IGhhcHBlbnMgcmlnaHQgYmVmb3JlIHJ1biAtIHJ1biB3aWxsIGJlIHBvc3Rwb25lZCB1bnRpbFxuLy8gdGhlIGRlcGVuZGVuY2llcyBhcmUgbWV0LlxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xudmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7IC8vIG92ZXJyaWRkZW4gdG8gdGFrZSBkaWZmZXJlbnQgYWN0aW9ucyB3aGVuIGFsbCBydW4gZGVwZW5kZW5jaWVzIGFyZSBmdWxmaWxsZWRcbnZhciBydW5EZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCkge1xuICB2YXIgb3JpZyA9IGlkO1xuICB3aGlsZSAoMSkge1xuICAgIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xuICAgIGlkID0gb3JpZyArIE1hdGgucmFuZG9tKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICBydW5EZXBlbmRlbmNpZXMrKztcblxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgaWYgKGlkKSB7XG4gICAgYXNzZXJ0KCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcbiAgICBydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gMTtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbWlzc2luZyBkZXBlbmRlbmNpZXMgZXZlcnkgZmV3IHNlY29uZHNcbiAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChBQk9SVCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICBpZiAoIXNob3duKSB7XG4gICAgICAgICAgICBzaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnIoJ3N0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczonKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyKCdkZXBlbmRlbmN5OiAnICsgZGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd24pIHtcbiAgICAgICAgICBlcnIoJyhlbmQgb2YgbGlzdCknKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IGFkZGVkIHdpdGhvdXQgSUQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gIH0gZWxzZSB7XG4gICAgZXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSByZW1vdmVkIHdpdGhvdXQgSUQnKTtcbiAgfVxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgIH1cbiAgfVxufVxuXG5Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl0gPSB7fTsgLy8gbWFwcyB1cmwgdG8gaW1hZ2UgZGF0YVxuTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGF1ZGlvIGRhdGFcbk1vZHVsZVtcInByZWxvYWRlZFdhc21cIl0gPSB7fTsgLy8gbWFwcyB1cmwgdG8gd2FzbSBpbnN0YW5jZSBleHBvcnRzXG5cbi8qKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSB3aGF0ICovXG5mdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gIHtcbiAgICBpZiAoTW9kdWxlWydvbkFib3J0J10pIHtcbiAgICAgIE1vZHVsZVsnb25BYm9ydCddKHdoYXQpO1xuICAgIH1cbiAgfVxuXG4gIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgLy8gVE9ETyhzYmMpOiBTaG91bGQgd2UgcmVtb3ZlIHByaW50aW5nIGFuZCBsZWF2ZSBpdCB1cCB0byB3aG9ldmVyXG4gIC8vIGNhdGNoZXMgdGhlIGV4Y2VwdGlvbj9cbiAgZXJyKHdoYXQpO1xuXG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG5cbiAgLy8gVXNlIGEgd2FzbSBydW50aW1lIGVycm9yLCBiZWNhdXNlIGEgSlMgZXJyb3IgbWlnaHQgYmUgc2VlbiBhcyBhIGZvcmVpZ25cbiAgLy8gZXhjZXB0aW9uLCB3aGljaCBtZWFucyB3ZSdkIHJ1biBkZXN0cnVjdG9ycyBvbiBpdC4gV2UgbmVlZCB0aGUgZXJyb3IgdG9cbiAgLy8gc2ltcGx5IG1ha2UgdGhlIHByb2dyYW0gc3RvcC5cblxuICAvLyBTdXBwcmVzcyBjbG9zdXJlIGNvbXBpbGVyIHdhcm5pbmcgaGVyZS4gQ2xvc3VyZSBjb21waWxlcidzIGJ1aWx0aW4gZXh0ZXJuXG4gIC8vIGRlZmludGlvbiBmb3IgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yIGNsYWltcyBpdCB0YWtlcyBubyBhcmd1bWVudHMgZXZlblxuICAvLyB0aG91Z2ggaXQgY2FuLlxuICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9wdWxsLzM5MTMpOiBSZW1vdmUgaWYvd2hlbiB1cHN0cmVhbSBjbG9zdXJlIGdldHMgZml4ZWQuXG5cbiAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgLy8gVGhyb3cgdGhlIGVycm9yIHdoZXRoZXIgb3Igbm90IE1PRFVMQVJJWkUgaXMgc2V0IGJlY2F1c2UgYWJvcnQgaXMgdXNlZFxuICAvLyBpbiBjb2RlIHBhdGhzIGFwYXJ0IGZyb20gaW5zdGFudGlhdGlvbiB3aGVyZSBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWRcbiAgLy8gdG8gYmUgdGhyb3duIHdoZW4gYWJvcnQgaXMgY2FsbGVkLlxuICB0aHJvdyBlO1xufVxuXG4vLyB7e01FTV9JTklUSUFMSVpFUn19XG5cbi8vIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG5cblxuLy8gZW5kIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG4vLyBpbmNsdWRlOiBVUklVdGlscy5qc1xuXG5cbi8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbi8vIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gIC8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxuICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbn1cblxuLy8gSW5kaWNhdGVzIHdoZXRoZXIgZmlsZW5hbWUgaXMgZGVsaXZlcmVkIHZpYSBmaWxlIHByb3RvY29sIChhcyBvcHBvc2VkIHRvIGh0dHAvaHR0cHMpXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbn1cblxuLy8gZW5kIGluY2x1ZGU6IFVSSVV0aWxzLmpzXG4vKiogQHBhcmFtIHtib29sZWFuPX0gZml4ZWRhc20gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgZml4ZWRhc20pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgdmFyIGFzbSA9IGZpeGVkYXNtO1xuICAgIGlmICghZml4ZWRhc20pIHtcbiAgICAgIGFzbSA9IE1vZHVsZVsnYXNtJ107XG4gICAgfVxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICduYXRpdmUgZnVuY3Rpb24gYCcgKyBkaXNwbGF5TmFtZSArICdgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvbicpO1xuICAgIGlmICghYXNtW25hbWVdKSB7XG4gICAgICBhc3NlcnQoYXNtW25hbWVdLCAnZXhwb3J0ZWQgbmF0aXZlIGZ1bmN0aW9uIGAnICsgZGlzcGxheU5hbWUgKyAnYCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzbVtuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG53YXNtQmluYXJ5RmlsZSA9IGxvY2F0aW9uLnVzaW5nO1xuICBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuICB9XG5cbmZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gIHRyeSB7XG4gICAgaWYgKGZpbGUgPT0gd2FzbUJpbmFyeUZpbGUgJiYgd2FzbUJpbmFyeSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgIH1cbiAgICBpZiAocmVhZEJpbmFyeSkge1xuICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgYmluYXJ5IHlldCwgdHJ5IHRvIHRvIGxvYWQgaXQgYXN5bmNocm9ub3VzbHkuXG4gIC8vIEZldGNoIGhhcyBzb21lIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb25zIG92ZXIgWEhSLCBsaWtlIGl0IGNhbid0IGJlIHVzZWQgb24gYSBmaWxlOi8vIHVybC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvcHVsbC85MiNpc3N1ZWNvbW1lbnQtMTQwNjY1OTMyXG4gIC8vIENvcmRvdmEgb3IgRWxlY3Ryb24gYXBwcyBhcmUgdHlwaWNhbGx5IGxvYWRlZCBmcm9tIGEgZmlsZTovLyB1cmwuXG4gIC8vIFNvIHVzZSBmZXRjaCBpZiBpdCBpcyBhdmFpbGFibGUgYW5kIHRoZSB1cmwgaXMgbm90IGEgZmlsZSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBYSFIuXG4gIGlmICghd2FzbUJpbmFyeSAmJiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoID09ICdmdW5jdGlvbidcbiAgICAgICYmICFpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XG4gICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIHdhc21CaW5hcnlGaWxlICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAocmVhZEFzeW5jKSB7XG4gICAgICAgIC8vIGZldGNoIGlzIG5vdCBhdmFpbGFibGUgb3IgdXJsIGlzIGZpbGUgPT4gdHJ5IFhIUiAocmVhZEFzeW5jIHVzZXMgWEhSIGludGVybmFsbHkpXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWFkQXN5bmMod2FzbUJpbmFyeUZpbGUsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7IHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBleyFBcnJheUJ1ZmZlcn0gKi8ocmVzcG9uc2UpKSkgfSwgcmVqZWN0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGdldEJpbmFyeSBzaG91bGQgYmUgYWJsZSB0byBnZXQgaXQgc3luY2hyb25vdXNseVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7IH0pO1xufVxuXG4vLyBDcmVhdGUgdGhlIHdhc20gaW5zdGFuY2UuXG4vLyBSZWNlaXZlcyB0aGUgd2FzbSBpbXBvcnRzLCByZXR1cm5zIHRoZSBleHBvcnRzLlxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgLy8gcHJlcGFyZSBpbXBvcnRzXG4gIHZhciBpbmZvID0ge1xuICAgICdlbnYnOiBhc21MaWJyYXJ5QXJnLFxuICAgICd3YXNpX3NuYXBzaG90X3ByZXZpZXcxJzogYXNtTGlicmFyeUFyZyxcbiAgICAnR09ULm1lbSc6IG5ldyBQcm94eShhc21MaWJyYXJ5QXJnLCBHT1RIYW5kbGVyKSxcbiAgICAnR09ULmZ1bmMnOiBuZXcgUHJveHkoYXNtTGlicmFyeUFyZywgR09USGFuZGxlciksXG4gIH07XG4gIC8vIExvYWQgdGhlIHdhc20gbW9kdWxlIGFuZCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdXNpbmcgbmF0aXZlIHN1cHBvcnQgaW4gdGhlIEpTIGVuZ2luZS5cbiAgLy8gaGFuZGxlIGEgZ2VuZXJhdGVkIHdhc20gaW5zdGFuY2UsIHJlY2VpdmluZyBpdHMgZXhwb3J0cyBhbmRcbiAgLy8gcGVyZm9ybWluZyBvdGhlciBuZWNlc3Nhcnkgc2V0dXBcbiAgLyoqIEBwYXJhbSB7V2ViQXNzZW1ibHkuTW9kdWxlPX0gbW9kdWxlKi9cbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICBleHBvcnRzID0gcmVsb2NhdGVFeHBvcnRzKGV4cG9ydHMsIDEwMjQpO1xuXG4gICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG5cbiAgICB2YXIgbWV0YWRhdGEgPSBnZXREeWxpbmtNZXRhZGF0YShtb2R1bGUpO1xuICAgIGlmIChtZXRhZGF0YS5uZWVkZWREeW5saWJzKSB7XG4gICAgICBkeW5hbWljTGlicmFyaWVzID0gbWV0YWRhdGEubmVlZGVkRHlubGlicy5jb25jYXQoZHluYW1pY0xpYnJhcmllcyk7XG4gICAgfVxuICAgIG1lcmdlTGliU3ltYm9scyhleHBvcnRzLCAnbWFpbicpXG5cbiAgICBhZGRPbkluaXQoTW9kdWxlWydhc20nXVsnX193YXNtX2NhbGxfY3RvcnMnXSk7XG5cbiAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgfVxuICAvLyB3ZSBjYW4ndCBydW4geWV0IChleGNlcHQgaW4gYSBwdGhyZWFkLCB3aGVyZSB3ZSBoYXZlIGEgY3VzdG9tIHN5bmMgaW5zdGFudGlhdG9yKVxuICBhZGRSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgLy8gUHJlZmVyIHN0cmVhbWluZyBpbnN0YW50aWF0aW9uIGlmIGF2YWlsYWJsZS5cbiAgLy8gQXN5bmMgY29tcGlsYXRpb24gY2FuIGJlIGNvbmZ1c2luZyB3aGVuIGFuIGVycm9yIG9uIHRoZSBwYWdlIG92ZXJ3cml0ZXMgTW9kdWxlXG4gIC8vIChmb3IgZXhhbXBsZSwgaWYgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIHdyb25nLCBhbmQgdGhlIG9uZSBkZWZpbmluZyBNb2R1bGUgaXNcbiAgLy8gbGF0ZXIpLCBzbyB3ZSBzYXZlIE1vZHVsZSBhbmQgY2hlY2sgaXQgbGF0ZXIuXG4gIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyAncmVzdWx0JyBpcyBhIFJlc3VsdE9iamVjdCBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXG4gICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcbiAgICBhc3NlcnQoTW9kdWxlID09PSB0cnVlTW9kdWxlLCAndGhlIE1vZHVsZSBvYmplY3Qgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBkdXJpbmcgYXN5bmMgY29tcGlsYXRpb24gLSBwZXJoYXBzIHRoZSBvcmRlciBvZiBIVE1MIGVsZW1lbnRzIGlzIHdyb25nPycpO1xuICAgIHRydWVNb2R1bGUgPSBudWxsO1xuICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10sIHJlc3VsdFsnbW9kdWxlJ10pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xuICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKCkudGhlbihmdW5jdGlvbihiaW5hcnkpIHtcbiAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSkudGhlbihyZWNlaXZlciwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuXG4gICAgICAvLyBXYXJuIG9uIHNvbWUgY29tbW9uIHByb2JsZW1zLlxuICAgICAgaWYgKGlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgICAgICAgZXJyKCd3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoJyArIHdhc21CaW5hcnlGaWxlICsgJykgaXMgbm90IHN1cHBvcnRlZCBpbiBtb3N0IGJyb3dzZXJzLiBTZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2dldHRpbmdfc3RhcnRlZC9GQVEuaHRtbCNob3ctZG8taS1ydW4tYS1sb2NhbC13ZWJzZXJ2ZXItZm9yLXRlc3Rpbmctd2h5LWRvZXMtbXktcHJvZ3JhbS1zdGFsbC1pbi1kb3dubG9hZGluZy1vci1wcmVwYXJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCkge1xuICAgIGlmICghd2FzbUJpbmFyeSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICAvLyBEb24ndCB1c2Ugc3RyZWFtaW5nIGZvciBmaWxlOi8vIGRlbGl2ZXJlZCBvYmplY3RzIGluIGEgd2VidmlldywgZmV0Y2ggdGhlbSBzeW5jaHJvbm91c2x5LlxuICAgICAgICAhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gU3VwcHJlc3MgY2xvc3VyZSB3YXJuaW5nIGhlcmUgc2luY2UgdGhlIHVwc3RyZWFtIGRlZmluaXRpb24gZm9yXG4gICAgICAgIC8vIGluc3RhbnRpYXRlU3RyZWFtaW5nIG9ubHkgYWxsb3dzIFByb21pc2U8UmVwc3BvbnNlPiByYXRoZXIgdGhhblxuICAgICAgICAvLyBhbiBhY3R1YWwgUmVzcG9uc2UuXG4gICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL3B1bGwvMzkxMyk6IFJlbW92ZSBpZi93aGVuIHVwc3RyZWFtIGNsb3N1cmUgaXMgZml4ZWQuXG4gICAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW5mbyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKFxuICAgICAgICAgIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSBtb3N0IGNvbW1vbiBmYWlsdXJlIGNhdXNlIHRvIGJlIGEgYmFkIE1JTUUgdHlwZSBmb3IgdGhlIGJpbmFyeSxcbiAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24gc2hvdWxkIHdvcmsuXG4gICAgICAgICAgICBlcnIoJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcbiAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlciBzaGVsbCBwYWdlcyBjYW4gd3JpdGUgdGhlaXIgb3duIE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gPSBmdW5jdGlvbihpbXBvcnRzLCBzdWNjZXNzQ2FsbGJhY2spIGNhbGxiYWNrXG4gIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0byBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWxcbiAgLy8gdG8gYW55IG90aGVyIGFzeW5jIHN0YXJ0dXAgYWN0aW9ucyB0aGV5IGFyZSBwZXJmb3JtaW5nLlxuICAvLyBBbHNvIHB0aHJlYWRzIGFuZCB3YXNtIHdvcmtlcnMgaW5pdGlhbGl6ZSB0aGUgd2FzbSBpbnN0YW5jZSB0aHJvdWdoIHRoaXMgcGF0aC5cbiAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGV4cG9ydHMgPSBNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycignTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGluc3RhbnRpYXRpb24gZmFpbHMsIHJlamVjdCB0aGUgbW9kdWxlIHJlYWR5IHByb21pc2UuXG4gIGluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICByZXR1cm4ge307IC8vIG5vIGV4cG9ydHMgeWV0OyB3ZSdsbCBmaWxsIHRoZW0gaW4gbGF0ZXJcbn1cblxuLy8gR2xvYmFscyB1c2VkIGJ5IEpTIGk2NCBjb252ZXJzaW9ucyAoc2VlIG1ha2VTZXRWYWx1ZSlcbnZhciB0ZW1wRG91YmxlO1xudmFyIHRlbXBJNjQ7XG5cbi8vID09PSBCb2R5ID09PVxuXG52YXIgQVNNX0NPTlNUUyA9IHtcbiAgXG59O1xuXG5cblxuXG5cblxuICB2YXIgR09UID0ge307XG4gIHZhciBHT1RIYW5kbGVyID0ge2dldDpmdW5jdGlvbihvYmosIHN5bU5hbWUpIHtcbiAgICAgICAgaWYgKCFHT1Rbc3ltTmFtZV0pIHtcbiAgICAgICAgICBHT1Rbc3ltTmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuR2xvYmFsKHsndmFsdWUnOiAnaTMyJywgJ211dGFibGUnOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdPVFtzeW1OYW1lXVxuICAgICAgfX07XG5cbiAgZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKE1vZHVsZSk7IC8vIFBhc3MgdGhlIG1vZHVsZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjay5mdW5jO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgd2FzbSBmdW5jdGlvbiBwdHIgd2l0aCBzaWduYXR1cmUgJ3YnLiBJZiBubyBmdW5jdGlvblxuICAgICAgICAgICAgLy8gd2l0aCBzdWNoIHNpZ25hdHVyZSB3YXMgZXhwb3J0ZWQsIHRoaXMgY2FsbCBkb2VzIG5vdCBuZWVkXG4gICAgICAgICAgICAvLyB0byBiZSBlbWl0dGVkIChhbmQgd291bGQgY29uZnVzZSBDbG9zdXJlKVxuICAgICAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnVuYykoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW55IGZ1bmN0aW9uIHdpdGggc2lnbmF0dXJlICd2aScgd2FzIGV4cG9ydGVkLCBydW5cbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayB3aXRoIHRoYXQgc2lnbmF0dXJlLlxuICAgICAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnVuYykoY2FsbGJhY2suYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnVuYyhjYWxsYmFjay5hcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjay5hcmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTdGFja1NhdmUoZikge1xuICAgICAgdmFyIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgICB2YXIgcmV0ID0gZigpO1xuICAgICAgc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBmdW5jdGlvbiBkZW1hbmdsZShmdW5jKSB7XG4gICAgICB3YXJuT25jZSgnd2FybmluZzogYnVpbGQgd2l0aCAgLXMgREVNQU5HTEVfU1VQUE9SVD0xICB0byBsaW5rIGluIGxpYmN4eGFiaSBkZW1hbmdsaW5nJyk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gZGVtYW5nbGVBbGwodGV4dCkge1xuICAgICAgdmFyIHJlZ2V4ID1cbiAgICAgICAgL1xcYl9aW1xcd1xcZF9dKy9nO1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleCxcbiAgICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7XG4gICAgICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogKHkgKyAnIFsnICsgeCArICddJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBnZXREeWxpbmtNZXRhZGF0YShiaW5hcnkpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGVuZCA9IDA7XG4gIFxuICAgICAgZnVuY3Rpb24gZ2V0VTgoKSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlbb2Zmc2V0KytdO1xuICAgICAgfVxuICBcbiAgICAgIGZ1bmN0aW9uIGdldExFQigpIHtcbiAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgIHZhciBtdWwgPSAxO1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHZhciBieXRlID0gYmluYXJ5W29mZnNldCsrXTtcbiAgICAgICAgICByZXQgKz0gKChieXRlICYgMHg3ZikgKiBtdWwpO1xuICAgICAgICAgIG11bCAqPSAweDgwO1xuICAgICAgICAgIGlmICghKGJ5dGUgJiAweDgwKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgXG4gICAgICBmdW5jdGlvbiBnZXRTdHJpbmcoKSB7XG4gICAgICAgIHZhciBsZW4gPSBnZXRMRUIoKTtcbiAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKGJpbmFyeSwgb2Zmc2V0IC0gbGVuLCBsZW4pO1xuICAgICAgfVxuICBcbiAgICAgIC8qKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgKi9cbiAgICAgIGZ1bmN0aW9uIGZhaWxJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBuYW1lID0gJ2R5bGluay4wJztcbiAgICAgIGlmIChiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpIHtcbiAgICAgICAgdmFyIGR5bGlua1NlY3Rpb24gPSBXZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnMoYmluYXJ5LCBuYW1lKTtcbiAgICAgICAgaWYgKGR5bGlua1NlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbmFtZSA9ICdkeWxpbmsnXG4gICAgICAgICAgZHlsaW5rU2VjdGlvbiA9IFdlYkFzc2VtYmx5Lk1vZHVsZS5jdXN0b21TZWN0aW9ucyhiaW5hcnksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZhaWxJZihkeWxpbmtTZWN0aW9uLmxlbmd0aCA9PT0gMCwgJ25lZWQgZHlsaW5rIHNlY3Rpb24nKTtcbiAgICAgICAgYmluYXJ5ID0gbmV3IFVpbnQ4QXJyYXkoZHlsaW5rU2VjdGlvblswXSk7XG4gICAgICAgIGVuZCA9IGJpbmFyeS5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkobmV3IFVpbnQ4QXJyYXkoYmluYXJ5LnN1YmFycmF5KDAsIDI0KSkuYnVmZmVyKTtcbiAgICAgICAgdmFyIG1hZ2ljTnVtYmVyRm91bmQgPSBpbnQzMlZpZXdbMF0gPT0gMHg2ZDczNjEwMDtcbiAgICAgICAgZmFpbElmKCFtYWdpY051bWJlckZvdW5kLCAnbmVlZCB0byBzZWUgd2FzbSBtYWdpYyBudW1iZXInKTsgLy8gXFwwYXNtXG4gICAgICAgIC8vIHdlIHNob3VsZCBzZWUgdGhlIGR5bGluayBjdXN0b20gc2VjdGlvbiByaWdodCBhZnRlciB0aGUgbWFnaWMgbnVtYmVyIGFuZCB3YXNtIHZlcnNpb25cbiAgICAgICAgZmFpbElmKGJpbmFyeVs4XSAhPT0gMCwgJ25lZWQgdGhlIGR5bGluayBzZWN0aW9uIHRvIGJlIGZpcnN0JylcbiAgICAgICAgb2Zmc2V0ID0gOTtcbiAgICAgICAgdmFyIHNlY3Rpb25fc2l6ZSA9IGdldExFQigpOyAvL3NlY3Rpb24gc2l6ZVxuICAgICAgICBlbmQgPSBvZmZzZXQgKyBzZWN0aW9uX3NpemU7XG4gICAgICAgIG5hbWUgPSBnZXRTdHJpbmcoKTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgY3VzdG9tU2VjdGlvbiA9IHsgbmVlZGVkRHlubGliczogW10sIHRsc0V4cG9ydHM6IHt9IH07XG4gICAgICBpZiAobmFtZSA9PSAnZHlsaW5rJykge1xuICAgICAgICBjdXN0b21TZWN0aW9uLm1lbW9yeVNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgY3VzdG9tU2VjdGlvbi5tZW1vcnlBbGlnbiA9IGdldExFQigpO1xuICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlU2l6ZSA9IGdldExFQigpO1xuICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgLy8gc2hhcmVkIGxpYnJhcmllcyB0aGlzIG1vZHVsZSBuZWVkcy4gV2UgbmVlZCB0byBsb2FkIHRoZW0gZmlyc3QsIHNvIHRoYXRcbiAgICAgICAgLy8gY3VycmVudCBtb2R1bGUgY291bGQgcmVzb2x2ZSBpdHMgaW1wb3J0cy4gKHNlZSB0b29scy9zaGFyZWQucHlcbiAgICAgICAgLy8gV2ViQXNzZW1ibHkubWFrZV9zaGFyZWRfbGlicmFyeSgpIGZvciBcImR5bGlua1wiIHNlY3Rpb24gZXh0ZW5zaW9uIGZvcm1hdClcbiAgICAgICAgdmFyIG5lZWRlZER5bmxpYnNDb3VudCA9IGdldExFQigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lZWRlZER5bmxpYnNDb3VudDsgKytpKSB7XG4gICAgICAgICAgdmFyIGxpYm5hbWUgPSBnZXRTdHJpbmcoKTtcbiAgICAgICAgICBjdXN0b21TZWN0aW9uLm5lZWRlZER5bmxpYnMucHVzaChsaWJuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbElmKG5hbWUgIT09ICdkeWxpbmsuMCcpO1xuICAgICAgICB2YXIgV0FTTV9EWUxJTktfTUVNX0lORk8gPSAweDE7XG4gICAgICAgIHZhciBXQVNNX0RZTElOS19ORUVERUQgPSAweDI7XG4gICAgICAgIHZhciBXQVNNX0RZTElOS19FWFBPUlRfSU5GTyA9IDB4MztcbiAgICAgICAgdmFyIFdBU01fU1lNQk9MX1RMUyA9IDB4MTAwO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHN1YnNlY3Rpb25UeXBlID0gZ2V0VTgoKTtcbiAgICAgICAgICB2YXIgc3Vic2VjdGlvblNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgICBpZiAoc3Vic2VjdGlvblR5cGUgPT09IFdBU01fRFlMSU5LX01FTV9JTkZPKSB7XG4gICAgICAgICAgICBjdXN0b21TZWN0aW9uLm1lbW9yeVNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGN1c3RvbVNlY3Rpb24ubWVtb3J5QWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGN1c3RvbVNlY3Rpb24udGFibGVTaXplID0gZ2V0TEVCKCk7XG4gICAgICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1YnNlY3Rpb25UeXBlID09PSBXQVNNX0RZTElOS19ORUVERUQpIHtcbiAgICAgICAgICAgIHZhciBuZWVkZWREeW5saWJzQ291bnQgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVlZGVkRHlubGlic0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgbGlibmFtZSA9IGdldFN0cmluZygpO1xuICAgICAgICAgICAgICBjdXN0b21TZWN0aW9uLm5lZWRlZER5bmxpYnMucHVzaChsaWJuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN1YnNlY3Rpb25UeXBlID09PSBXQVNNX0RZTElOS19FWFBPUlRfSU5GTykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gZ2V0TEVCKCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgICAgICB2YXIgc3ltbmFtZSA9IGdldFN0cmluZygpO1xuICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzICYgV0FTTV9TWU1CT0xfVExTKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tU2VjdGlvbi50bHNFeHBvcnRzW3N5bW5hbWVdID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIoJ3Vua25vd24gZHlsaW5rLjAgc3Vic2VjdGlvbjogJyArIHN1YnNlY3Rpb25UeXBlKVxuICAgICAgICAgICAgLy8gdW5rbm93biBzdWJzZWN0aW9uXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3Vic2VjdGlvblNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHRhYmxlQWxpZ24gPSBNYXRoLnBvdygyLCBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24pO1xuICAgICAgYXNzZXJ0KHRhYmxlQWxpZ24gPT09IDEsICdpbnZhbGlkIHRhYmxlQWxpZ24gJyArIHRhYmxlQWxpZ24pO1xuICAgICAgYXNzZXJ0KG9mZnNldCA9PSBlbmQpO1xuICBcbiAgICAgIHJldHVybiBjdXN0b21TZWN0aW9uO1xuICAgIH1cblxuICB2YXIgd2FzbVRhYmxlTWlycm9yID0gW107XG4gIGZ1bmN0aW9uIGdldFdhc21UYWJsZUVudHJ5KGZ1bmNQdHIpIHtcbiAgICAgIHZhciBmdW5jID0gd2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdO1xuICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIGlmIChmdW5jUHRyID49IHdhc21UYWJsZU1pcnJvci5sZW5ndGgpIHdhc21UYWJsZU1pcnJvci5sZW5ndGggPSBmdW5jUHRyICsgMTtcbiAgICAgICAgd2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdID0gZnVuYyA9IHdhc21UYWJsZS5nZXQoZnVuY1B0cik7XG4gICAgICB9XG4gICAgICBhc3NlcnQod2FzbVRhYmxlLmdldChmdW5jUHRyKSA9PSBmdW5jLCBcIkphdmFTY3JpcHQtc2lkZSBXYXNtIGZ1bmN0aW9uIHRhYmxlIG1pcnJvciBpcyBvdXQgb2YgZGF0ZSFcIik7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUpIHtcbiAgICAgIC8vIENlcnRhaW4gZXhjZXB0aW9uIHR5cGVzIHdlIGRvIG5vdCB0cmVhdCBhcyBlcnJvcnMgc2luY2UgdGhleSBhcmUgdXNlZCBmb3JcbiAgICAgIC8vIGludGVybmFsIGNvbnRyb2wgZmxvdy5cbiAgICAgIC8vIDEuIEV4aXRTdGF0dXMsIHdoaWNoIGlzIHRocm93biBieSBleGl0KClcbiAgICAgIC8vIDIuIFwidW53aW5kXCIsIHdoaWNoIGlzIHRocm93biBieSBlbXNjcmlwdGVuX3Vud2luZF90b19qc19ldmVudF9sb29wKCkgYW5kIG90aGVyc1xuICAgICAgLy8gICAgdGhhdCB3aXNoIHRvIHJldHVybiB0byBKUyBldmVudCBsb29wLlxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzIHx8IGUgPT0gJ3Vud2luZCcpIHtcbiAgICAgICAgcmV0dXJuIEVYSVRTVEFUVVM7XG4gICAgICB9XG4gICAgICBxdWl0XygxLCBlKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24ganNTdGFja1RyYWNlKCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICBpZiAoIWVycm9yLnN0YWNrKSB7XG4gICAgICAgIC8vIElFMTArIHNwZWNpYWwgY2FzZXM6IEl0IGRvZXMgaGF2ZSBjYWxsc3RhY2sgaW5mbywgYnV0IGl0IGlzIG9ubHkgcG9wdWxhdGVkIGlmIGFuIEVycm9yIG9iamVjdCBpcyB0aHJvd24sXG4gICAgICAgIC8vIHNvIHRyeSB0aGF0IGFzIGEgc3BlY2lhbC1jYXNlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvci5zdGFjaykge1xuICAgICAgICAgIHJldHVybiAnKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3Iuc3RhY2sudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXNtanNNYW5nbGUoeCkge1xuICAgICAgdmFyIHVubWFuZ2xlZFN5bWJvbHMgPSBbJ3N0YWNrQWxsb2MnLCdzdGFja1NhdmUnLCdzdGFja1Jlc3RvcmUnXTtcbiAgICAgIHJldHVybiB4LmluZGV4T2YoJ2R5bkNhbGxfJykgPT0gMCB8fCB1bm1hbmdsZWRTeW1ib2xzLmluY2x1ZGVzKHgpID8geCA6ICdfJyArIHg7XG4gICAgfVxuICBmdW5jdGlvbiBtZXJnZUxpYlN5bWJvbHMoZXhwb3J0cywgbGliTmFtZSkge1xuICAgICAgLy8gYWRkIHN5bWJvbHMgaW50byBnbG9iYWwgbmFtZXNwYWNlIFRPRE86IHdlYWsgbGlua2luZyBldGMuXG4gICAgICBmb3IgKHZhciBzeW0gaW4gZXhwb3J0cykge1xuICAgICAgICBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoc3ltKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBXaGVuIFJUTERfR0xPQkFMIGlzIGVuYWJsZSwgdGhlIHN5bWJvbHMgZGVmaW5lZCBieSB0aGlzIHNoYXJlZCBvYmplY3Qgd2lsbCBiZSBtYWRlXG4gICAgICAgIC8vIGF2YWlsYWJsZSBmb3Igc3ltYm9sIHJlc29sdXRpb24gb2Ygc3Vic2VxdWVudGx5IGxvYWRlZCBzaGFyZWQgb2JqZWN0cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvcHkgdGhlIHN5bWJvbHMgKHdoaWNoIGluY2x1ZGUgbWV0aG9kcyBhbmQgdmFyaWFibGVzKSBmcm9tIFNJREVfTU9EVUxFIHRvIE1BSU5fTU9EVUxFLlxuICBcbiAgICAgICAgaWYgKCFhc21MaWJyYXJ5QXJnLmhhc093blByb3BlcnR5KHN5bSkpIHtcbiAgICAgICAgICBhc21MaWJyYXJ5QXJnW3N5bV0gPSBleHBvcnRzW3N5bV07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIEV4cG9ydCBuYXRpdmUgZXhwb3J0IG9uIHRoZSBNb2R1bGUgb2JqZWN0LlxuICAgICAgICAvLyBUT0RPKHNiYyk6IERvIGFsbCB1c2VycyB3YW50IHRoaXM/ICBTaG91bGQgd2Ugc2tpcCB0aGlzIGJ5IGRlZmF1bHQ/XG4gICAgICAgIHZhciBtb2R1bGVfc3ltID0gYXNtanNNYW5nbGUoc3ltKTtcbiAgICAgICAgaWYgKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobW9kdWxlX3N5bSkpIHtcbiAgICAgICAgICBNb2R1bGVbbW9kdWxlX3N5bV0gPSBleHBvcnRzW3N5bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgdmFyIExEU08gPSB7bG9hZGVkTGlic0J5TmFtZTp7fSxsb2FkZWRMaWJzQnlIYW5kbGU6e319O1xuICBcbiAgZnVuY3Rpb24gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncykge1xuICAgICAgYXNzZXJ0KCgnZHluQ2FsbF8nICsgc2lnKSBpbiBNb2R1bGUsICdiYWQgZnVuY3Rpb24gcG9pbnRlciB0eXBlIC0gbm8gdGFibGUgZm9yIHNpZyBcXCcnICsgc2lnICsgJ1xcJycpO1xuICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gaiAoNjQtYml0IGludGVnZXIpIG11c3QgYmUgcGFzc2VkIGluIGFzIHR3byBudW1iZXJzIFtsb3cgMzIsIGhpZ2ggMzJdLlxuICAgICAgICBhc3NlcnQoYXJncy5sZW5ndGggPT09IHNpZy5zdWJzdHJpbmcoMSkucmVwbGFjZSgvai9nLCAnLS0nKS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHNpZy5sZW5ndGggPT0gMSk7XG4gICAgICB9XG4gICAgICB2YXIgZiA9IE1vZHVsZVtcImR5bkNhbGxfXCIgKyBzaWddO1xuICAgICAgcmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPyBmLmFwcGx5KG51bGwsIFtwdHJdLmNvbmNhdChhcmdzKSkgOiBmLmNhbGwobnVsbCwgcHRyKTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge09iamVjdD19IGFyZ3MgKi9cbiAgZnVuY3Rpb24gZHluQ2FsbChzaWcsIHB0ciwgYXJncykge1xuICAgICAgLy8gV2l0aG91dCBXQVNNX0JJR0lOVCBzdXBwb3J0IHdlIGNhbm5vdCBkaXJlY3RseSBjYWxsIGZ1bmN0aW9uIHdpdGggaTY0IGFzXG4gICAgICAvLyBwYXJ0IG9mIHRoaWVyIHNpZ25hdHVyZSwgc28gd2UgcmVseSB0aGUgZHluQ2FsbCBmdW5jdGlvbnMgZ2VuZXJhdGVkIGJ5XG4gICAgICAvLyB3YXNtLWVtc2NyaXB0ZW4tZmluYWxpemVcbiAgICAgIGlmIChzaWcuaW5jbHVkZXMoJ2onKSkge1xuICAgICAgICByZXR1cm4gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncyk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoZ2V0V2FzbVRhYmxlRW50cnkocHRyKSwgJ21pc3NpbmcgdGFibGUgZW50cnkgaW4gZHluQ2FsbDogJyArIHB0cik7XG4gICAgICByZXR1cm4gZ2V0V2FzbVRhYmxlRW50cnkocHRyKS5hcHBseShudWxsLCBhcmdzKVxuICAgIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW52b2tlRnVuY3Rpb24oc2lnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBkeW5DYWxsKHNpZywgYXJndW1lbnRzWzBdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICAgICAgICAvLyBFeGNlcHRpb25zIHRocm93biBmcm9tIEMrKyBleGNlcHRpb24gd2lsbCBiZSBpbnRlZ2VyIG51bWJlcnMuXG4gICAgICAgICAgLy8gbG9uZ2ptcCB3aWxsIHRocm93IHRoZSBudW1iZXIgSW5maW5pdHkuIFJlLXRocm93IG90aGVyIHR5cGVzIG9mXG4gICAgICAgICAgLy8gZXhjZXB0aW9ucyB1c2luZyBhIGNvbXBhY3QgYW5kIGZhc3QgY2hlY2suXG4gICAgICAgICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICAgICAgICBfc2V0VGhyZXcoMSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICB2YXIgX19faGVhcF9iYXNlID0gNjI4NDc4NDtcbiAgZnVuY3Rpb24gZ2V0TWVtb3J5KHNpemUpIHtcbiAgICAgIC8vIEFmdGVyIHRoZSBydW50aW1lIGlzIGluaXRpYWxpemVkLCB3ZSBtdXN0IG9ubHkgdXNlIHNicmsoKSBub3JtYWxseS5cbiAgICAgIGlmIChydW50aW1lSW5pdGlhbGl6ZWQpXG4gICAgICAgIHJldHVybiBfbWFsbG9jKHNpemUpO1xuICAgICAgdmFyIHJldCA9IF9fX2hlYXBfYmFzZTtcbiAgICAgIHZhciBlbmQgPSAocmV0ICsgc2l6ZSArIDE1KSAmIC0xNjtcbiAgICAgIGFzc2VydChlbmQgPD0gSEVBUDgubGVuZ3RoLCAnZmFpbHVyZSB0byBnZXRNZW1vcnkgLSBtZW1vcnkgZ3Jvd3RoIGV0Yy4gaXMgbm90IHN1cHBvcnRlZCB0aGVyZSwgY2FsbCBtYWxsb2Mvc2JyayBkaXJlY3RseSBvciBpbmNyZWFzZSBJTklUSUFMX01FTU9SWScpO1xuICAgICAgX19faGVhcF9iYXNlID0gZW5kO1xuICAgICAgR09UWydfX2hlYXBfYmFzZSddLnZhbHVlID0gZW5kO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBpc0ludGVybmFsU3ltKHN5bU5hbWUpIHtcbiAgICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gbWFyayB0aGVzZSBpbiB0aGUgYmluYXJ5IG9yIGF2b2lkIGV4cG9ydGluZyB0aGVtLlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ19fY3BwX2V4Y2VwdGlvbicsXG4gICAgICAgICdfX2NfbG9uZ2ptcCcsXG4gICAgICAgICdfX3dhc21fYXBwbHlfZGF0YV9yZWxvY3MnLFxuICAgICAgICAnX19kc29faGFuZGxlJyxcbiAgICAgICAgJ19fdGxzX3NpemUnLFxuICAgICAgICAnX190bHNfYWxpZ24nLFxuICAgICAgICAnX19zZXRfc3RhY2tfbGltaXRzJyxcbiAgICAgICAgJ2Vtc2NyaXB0ZW5fdGxzX2luaXQnLFxuICAgICAgICAnX193YXNtX2luaXRfdGxzJyxcbiAgICAgICAgJ19fd2FzbV9jYWxsX2N0b3JzJyxcbiAgICAgIF0uaW5jbHVkZXMoc3ltTmFtZSlcbiAgICAgIDtcbiAgICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUdPVChleHBvcnRzLCByZXBsYWNlKSB7XG4gICAgICBmb3IgKHZhciBzeW1OYW1lIGluIGV4cG9ydHMpIHtcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxTeW0oc3ltTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0c1tzeW1OYW1lXTtcbiAgICAgICAgaWYgKHN5bU5hbWUuc3RhcnRzV2l0aCgnb3JpZyQnKSkge1xuICAgICAgICAgIHN5bU5hbWUgPSBzeW1OYW1lLnNwbGl0KCckJylbMV07XG4gICAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICghR09UW3N5bU5hbWVdKSB7XG4gICAgICAgICAgR09UW3N5bU5hbWVdID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlIHx8IEdPVFtzeW1OYW1lXS52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBhZGRGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIEdPVFtzeW1OYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIoXCJ1bmhhbmRsZWQgZXhwb3J0IHR5cGUgZm9yIGBcIiArIHN5bU5hbWUgKyBcImA6IFwiICsgKHR5cGVvZiB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IHJlcGxhY2UgKi9cbiAgZnVuY3Rpb24gcmVsb2NhdGVFeHBvcnRzKGV4cG9ydHMsIG1lbW9yeUJhc2UsIHJlcGxhY2UpIHtcbiAgICAgIHZhciByZWxvY2F0ZWQgPSB7fTtcbiAgXG4gICAgICBmb3IgKHZhciBlIGluIGV4cG9ydHMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0c1tlXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGEgYnJlYWtpbmcgY2hhbmdlIGluIHRoZSB3YXNtIHNwZWMsIGdsb2JhbHMgYXJlIG5vdyBvYmplY3RzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L211dGFibGUtZ2xvYmFsL2lzc3Vlcy8xXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgKz0gbWVtb3J5QmFzZTtcbiAgICAgICAgfVxuICAgICAgICByZWxvY2F0ZWRbZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUdPVChyZWxvY2F0ZWQsIHJlcGxhY2UpO1xuICAgICAgcmV0dXJuIHJlbG9jYXRlZDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiByZXNvbHZlR2xvYmFsU3ltYm9sKHN5bU5hbWUsIGRpcmVjdCkge1xuICAgICAgdmFyIHN5bTtcbiAgICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgLy8gRmlyc3QgbG9vayBmb3IgdGhlIG9yaWckIHN5bWJvbCB3aGljaCBpcyB0aGUgc3ltYm9scyB3aXRob3V0XG4gICAgICAgIC8vIGFueSBsZWdhbGl6YXRpb24gcGVyZm9ybWVkLlxuICAgICAgICBzeW0gPSBhc21MaWJyYXJ5QXJnWydvcmlnJCcgKyBzeW1OYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICghc3ltKSB7XG4gICAgICAgIHN5bSA9IGFzbUxpYnJhcnlBcmdbc3ltTmFtZV07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzeW1ib2wgb24gdGhlIE1vZHVsZSBvYmplY3QuICBUaGlzIGlzIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdG8gZHluYW1pY2FsbHkgYWNjZXNzIEpTIGxpYnJhcnkgc3ltYm9scyB0aGF0IHdlcmUgbm90XG4gICAgICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBtYWluIG1vZHVsZSAoYW5kIHRoZXJlZm9yZSBub3QgcGFydCBvZiB0aGVcbiAgICAgIC8vIGluaXRpYWwgc2V0IG9mIHN5bWJvbHMgaW5jbHVkZWQgaW4gYXNtTGlicmFyeUFyZyB3aGVuIGl0XG4gICAgICAvLyB3YXMgZGVjbGFyZWQuXG4gICAgICBpZiAoIXN5bSkge1xuICAgICAgICBzeW0gPSBNb2R1bGVbYXNtanNNYW5nbGUoc3ltTmFtZSldO1xuICAgICAgfVxuICBcbiAgICAgIGlmICghc3ltICYmIHN5bU5hbWUuc3RhcnRzV2l0aCgnaW52b2tlXycpKSB7XG4gICAgICAgIHN5bSA9IGNyZWF0ZUludm9rZUZ1bmN0aW9uKHN5bU5hbWUuc3BsaXQoJ18nKVsxXSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHN5bTtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBhbGlnbm1lbnQpIHtcbiAgICAgIGFzc2VydChhbGlnbm1lbnQsIFwiYWxpZ25tZW50IGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gYWxpZ25tZW50KSAqIGFsaWdubWVudDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiAgICAgIEhFQVBVOC5maWxsKDAsIGFkZHJlc3MsIGFkZHJlc3MgKyBzaXplKTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge251bWJlcj19IGhhbmRsZSAqL1xuICBmdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUoYmluYXJ5LCBmbGFncywgaGFuZGxlKSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBnZXREeWxpbmtNZXRhZGF0YShiaW5hcnkpO1xuICAgICAgdmFyIG9yaWdpbmFsVGFibGUgPSB3YXNtVGFibGU7XG4gIFxuICAgICAgLy8gbG9hZE1vZHVsZSBsb2FkcyB0aGUgd2FzbSBtb2R1bGUgYWZ0ZXIgYWxsIGl0cyBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAgICAgIC8vIGNhbiBiZSBjYWxsZWQgYm90aCBzeW5jL2FzeW5jLlxuICAgICAgZnVuY3Rpb24gbG9hZE1vZHVsZSgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRocmVhZCB0byBsb2FkIGEgZ2l2ZW4gbW9kdWxlIG5lZWRzIHRvIGFsbG9jYXRlIHRoZSBzdGF0aWNcbiAgICAgICAgLy8gdGFibGUgYW5kIG1lbW9yeSByZWdpb25zLiAgTGF0ZXIgdGhyZWFkcyByZS11c2UgdGhlIHNhbWUgdGFibGUgcmVnaW9uXG4gICAgICAgIC8vIGFuZCBjYW4gaWdub3JlIHRoZSBtZW1vcnkgcmVnaW9uIChzaW5jZSBtZW1vcnkgaXMgc2hhcmVkIGJldHdlZW5cbiAgICAgICAgLy8gdGhyZWFkcyBhbHJlYWR5KS5cbiAgICAgICAgdmFyIG5lZWRzQWxsb2NhdGlvbiA9ICFoYW5kbGUgfHwgIUhFQVA4WygoKGhhbmRsZSkrKDI0KSk+PjApXTtcbiAgICAgICAgaWYgKG5lZWRzQWxsb2NhdGlvbikge1xuICAgICAgICAgIC8vIGFsaWdubWVudHMgYXJlIHBvd2VycyBvZiAyXG4gICAgICAgICAgdmFyIG1lbUFsaWduID0gTWF0aC5wb3coMiwgbWV0YWRhdGEubWVtb3J5QWxpZ24pO1xuICAgICAgICAgIC8vIGZpbmFsaXplIGFsaWdubWVudHMgYW5kIHZlcmlmeSB0aGVtXG4gICAgICAgICAgbWVtQWxpZ24gPSBNYXRoLm1heChtZW1BbGlnbiwgU1RBQ0tfQUxJR04pOyAvLyB3ZSBhdCBsZWFzdCBuZWVkIHN0YWNrIGFsaWdubWVudFxuICAgICAgICAgIC8vIHByZXBhcmUgbWVtb3J5XG4gICAgICAgICAgdmFyIG1lbW9yeUJhc2UgPSBtZXRhZGF0YS5tZW1vcnlTaXplID8gYWxpZ25NZW1vcnkoZ2V0TWVtb3J5KG1ldGFkYXRhLm1lbW9yeVNpemUgKyBtZW1BbGlnbiksIG1lbUFsaWduKSA6IDA7IC8vIFRPRE86IGFkZCB0byBjbGVhbnVwc1xuICAgICAgICAgIHZhciB0YWJsZUJhc2UgPSBtZXRhZGF0YS50YWJsZVNpemUgPyB3YXNtVGFibGUubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBIRUFQOFsoKChoYW5kbGUpKygyNCkpPj4wKV0gPSAxO1xuICAgICAgICAgICAgSEVBUDMyWygoKGhhbmRsZSkrKDI4KSk+PjIpXSA9IG1lbW9yeUJhc2U7XG4gICAgICAgICAgICBIRUFQMzJbKCgoaGFuZGxlKSsoMzIpKT4+MildID0gbWV0YWRhdGEubWVtb3J5U2l6ZTtcbiAgICAgICAgICAgIEhFQVAzMlsoKChoYW5kbGUpKygzNikpPj4yKV0gPSB0YWJsZUJhc2U7XG4gICAgICAgICAgICBIRUFQMzJbKCgoaGFuZGxlKSsoNDApKT4+MildID0gbWV0YWRhdGEudGFibGVTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW1vcnlCYXNlID0gSEVBUDMyWygoKGhhbmRsZSkrKDI4KSk+PjIpXTtcbiAgICAgICAgICB0YWJsZUJhc2UgPSBIRUFQMzJbKCgoaGFuZGxlKSsoMzYpKT4+MildO1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgdGFibGVHcm93dGhOZWVkZWQgPSB0YWJsZUJhc2UgKyBtZXRhZGF0YS50YWJsZVNpemUgLSB3YXNtVGFibGUubGVuZ3RoO1xuICAgICAgICBpZiAodGFibGVHcm93dGhOZWVkZWQgPiAwKSB7XG4gICAgICAgICAgd2FzbVRhYmxlLmdyb3codGFibGVHcm93dGhOZWVkZWQpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBleHBvcnQgbWFwIHRoYXQgd2UgdWx0aW1hdGVseSByZXR1cm4uICBXZSBkZWNsYXJlIGl0IGhlcmVcbiAgICAgICAgLy8gc28gaXQgY2FuIGJlIHVzZWQgd2l0aGluIHJlc29sdmVTeW1ib2wuICBXZSByZXNvbHZlIHN5bWJvbHMgYWdhaW5zdFxuICAgICAgICAvLyB0aGlzIGxvY2FsIHN5bWJvbCBtYXAgaW4gdGhlIGNhc2UgdGhlcmUgdGhleSBhcmUgbm90IHByZXNlbnQgb24gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBNb2R1bGUgb2JqZWN0LiAgV2UgbmVlZCB0aGlzIGZhbGxiYWNrIGJlY2F1c2U6XG4gICAgICAgIC8vIGEpIE1vZHVsZXMgc29tZXRpbWUgbmVlZCB0byBpbXBvcnQgdGhlaXIgb3duIHN5bWJvbHNcbiAgICAgICAgLy8gYikgU3ltYm9scyBmcm9tIHNpZGUgbW9kdWxlcyBhcmUgbm90IGFsd2F5cyBhZGRlZCB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgdmFyIG1vZHVsZUV4cG9ydHM7XG4gIFxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlU3ltYm9sKHN5bSkge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVHbG9iYWxTeW1ib2woc3ltLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBtb2R1bGVFeHBvcnRzW3N5bV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydChyZXNvbHZlZCwgJ3VuZGVmaW5lZCBzeW1ib2wgYCcgKyBzeW0gKyAnYC4gcGVyaGFwcyBhIHNpZGUgbW9kdWxlIHdhcyBub3QgbGlua2VkIGluPyBpZiB0aGlzIGdsb2JhbCB3YXMgZXhwZWN0ZWQgdG8gYXJyaXZlIGZyb20gYSBzeXN0ZW0gbGlicmFyeSwgdHJ5IHRvIGJ1aWxkIHRoZSBNQUlOX01PRFVMRSB3aXRoIEVNQ0NfRk9SQ0VfU1RETElCUz0xIGluIHRoZSBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gVE9ETyBraWxsIOKGk+KGk+KGkyAoZXhjZXB0IFwic3ltYm9scyBsb2NhbCB0byB0aGlzIG1vZHVsZVwiLCBpdCB3aWxsIGxpa2VseSBiZVxuICAgICAgICAvLyBub3QgbmVlZGVkIGlmIHdlIHJlcXVpcmUgdGhhdCBpZiBBIHdhbnRzIHN5bWJvbHMgZnJvbSBCIGl0IGhhcyB0byBsaW5rXG4gICAgICAgIC8vIHRvIEIgZXhwbGljaXRseTogc2ltaWxhcmx5IHRvIC1XbCwtLW5vLXVuZGVmaW5lZClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gd2FzbSBkeW5hbWljIGxpYnJhcmllcyBhcmUgcHVyZSB3YXNtLCBzbyB0aGV5IGNhbm5vdCBhc3Npc3QgaW5cbiAgICAgICAgLy8gdGhlaXIgb3duIGxvYWRpbmcuIFdoZW4gc2lkZSBtb2R1bGUgQSB3YW50cyB0byBpbXBvcnQgc29tZXRoaW5nXG4gICAgICAgIC8vIHByb3ZpZGVkIGJ5IGEgc2lkZSBtb2R1bGUgQiB0aGF0IGlzIGxvYWRlZCBsYXRlciwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYSBsYXllciBvZiBpbmRpcmVjdGlvbiwgYnV0IHdvcnNlLCB3ZSBjYW4ndCBldmVuIHRlbGwgd2hhdFxuICAgICAgICAvLyB0byBhZGQgdGhlIGluZGlyZWN0aW9uIGZvciwgd2l0aG91dCBpbnNwZWN0aW5nIHdoYXQgQSdzIGltcG9ydHNcbiAgICAgICAgLy8gYXJlLiBUbyBkbyB0aGF0IGhlcmUsIHdlIHVzZSBhIEpTIHByb3h5IChhbm90aGVyIG9wdGlvbiB3b3VsZFxuICAgICAgICAvLyBiZSB0byBpbnNwZWN0IHRoZSBiaW5hcnkgZGlyZWN0bHkpLlxuICAgICAgICB2YXIgcHJveHlIYW5kbGVyID0ge1xuICAgICAgICAgICdnZXQnOiBmdW5jdGlvbihzdHVicywgcHJvcCkge1xuICAgICAgICAgICAgLy8gc3ltYm9scyB0aGF0IHNob3VsZCBiZSBsb2NhbCB0byB0aGlzIG1vZHVsZVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ19fbWVtb3J5X2Jhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vcnlCYXNlO1xuICAgICAgICAgICAgICBjYXNlICdfX3RhYmxlX2Jhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZUJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBhc21MaWJyYXJ5QXJnKSB7XG4gICAgICAgICAgICAgIC8vIE5vIHN0dWIgbmVlZGVkLCBzeW1ib2wgYWxyZWFkeSBleGlzdHMgaW4gc3ltYm9sIHRhYmxlXG4gICAgICAgICAgICAgIHJldHVybiBhc21MaWJyYXJ5QXJnW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3R1YiBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzb2x2ZSB0aGUgc3ltYm9sXG4gICAgICAgICAgICAvLyB3aGVuIGZpcnN0IGNhbGxlZC5cbiAgICAgICAgICAgIGlmICghKHByb3AgaW4gc3R1YnMpKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvbHZlZDtcbiAgICAgICAgICAgICAgc3R1YnNbcHJvcF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKSByZXNvbHZlZCA9IHJlc29sdmVTeW1ib2wocHJvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R1YnNbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJveHkgPSBuZXcgUHJveHkoe30sIHByb3h5SGFuZGxlcik7XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICdHT1QubWVtJzogbmV3IFByb3h5KHt9LCBHT1RIYW5kbGVyKSxcbiAgICAgICAgICAnR09ULmZ1bmMnOiBuZXcgUHJveHkoe30sIEdPVEhhbmRsZXIpLFxuICAgICAgICAgICdlbnYnOiBwcm94eSxcbiAgICAgICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiBwcm94eSxcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIGZ1bmN0aW9uIHBvc3RJbnN0YW50aWF0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgICAgLy9GSVhNRSA6IFNldCB0aGlzIGluZm9ybWF0aW9uIGluIGN1c3RvbSBzZWN0aW9uXG4gICAgICAgICAgY29uc3QgZmlsdGVyX2VudHJ5ID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykuZmlsdGVyKGZuID0+IGZuLmVuZHNXaXRoKFwiX3JlZ2lzdGVyXCIpKTtcbiAgICAgICAgICBmaWx0ZXJfZW50cmllcyA9IGZpbHRlcl9lbnRyaWVzLmNvbmNhdChmaWx0ZXJfZW50cnkpO1xuICAgICAgICAgIGNvbnN0IG1vZHVsZV9lbnRyeSA9IE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpLmZpbHRlcihmbiA9PiBmbi5zdGFydHNXaXRoKFwiZ2ZfcmVnaXN0ZXJfbW9kdWxlX1wiKSk7XG4gICAgICAgICAgbW9kdWxlX2VudHJpZXMgPSBtb2R1bGVfZW50cmllcy5jb25jYXQobW9kdWxlX2VudHJ5KTtcbiAgICAgICAgICAvLyB0aGUgdGFibGUgc2hvdWxkIGJlIHVuY2hhbmdlZFxuICAgICAgICAgIGFzc2VydCh3YXNtVGFibGUgPT09IG9yaWdpbmFsVGFibGUpO1xuICAgICAgICAgIC8vIGFkZCBuZXcgZW50cmllcyB0byBmdW5jdGlvbnNJblRhYmxlTWFwXG4gICAgICAgICAgdXBkYXRlVGFibGVNYXAodGFibGVCYXNlLCBtZXRhZGF0YS50YWJsZVNpemUpO1xuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSByZWxvY2F0ZUV4cG9ydHMoaW5zdGFuY2UuZXhwb3J0cywgbWVtb3J5QmFzZSk7XG4gICAgICAgICAgaWYgKCFmbGFncy5hbGxvd1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVwb3J0VW5kZWZpbmVkU3ltYm9scygpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgbW9kdWxlXG4gICAgICAgICAgICB2YXIgaW5pdCA9IG1vZHVsZUV4cG9ydHNbJ19fd2FzbV9jYWxsX2N0b3JzJ107XG4gICAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgICBpZiAocnVudGltZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZW4ndCByZWFkeSB0byBydW4gY29tcGlsZWQgY29kZSB5ZXRcbiAgICAgICAgICAgICAgICBfX0FUSU5JVF9fLnB1c2goaW5pdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGZsYWdzLmxvYWRBc3luYykge1xuICAgICAgICAgIGlmIChiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShiaW5hcnksIGluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3N0SW5zdGFudGlhdGlvbihpbnN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RJbnN0YW50aWF0aW9uKHJlc3VsdC5pbnN0YW5jZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb2R1bGUgPSBiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUgPyBiaW5hcnkgOiBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGJpbmFyeSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGluZm8pO1xuICAgICAgICByZXR1cm4gcG9zdEluc3RhbnRpYXRpb24oaW5zdGFuY2UpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIG5vdyBsb2FkIG5lZWRlZCBsaWJyYXJpZXMgYW5kIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAgICAgaWYgKGZsYWdzLmxvYWRBc3luYykge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEubmVlZGVkRHlubGlicy5yZWR1Y2UoZnVuY3Rpb24oY2hhaW4sIGR5bk5lZWRlZCkge1xuICAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShkeW5OZWVkZWQsIGZsYWdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRNb2R1bGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgbWV0YWRhdGEubmVlZGVkRHlubGlicy5mb3JFYWNoKGZ1bmN0aW9uKGR5bk5lZWRlZCkge1xuICAgICAgICBsb2FkRHluYW1pY0xpYnJhcnkoZHluTmVlZGVkLCBmbGFncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsb2FkTW9kdWxlKCk7XG4gICAgfVxuICAvKiogQHBhcmFtIHtudW1iZXI9fSBoYW5kbGUgKi9cbiAgZnVuY3Rpb24gbG9hZER5bmFtaWNMaWJyYXJ5KGxpYiwgZmxhZ3MsIGhhbmRsZSkge1xuICAgICAgaWYgKGxpYiA9PSAnX19tYWluX18nICYmICFMRFNPLmxvYWRlZExpYnNCeU5hbWVbbGliXSkge1xuICAgICAgICBMRFNPLmxvYWRlZExpYnNCeU5hbWVbbGliXSA9IHtcbiAgICAgICAgICByZWZjb3VudDogSW5maW5pdHksICAgLy8gPSBub2RlbGV0ZVxuICAgICAgICAgIG5hbWU6ICAgICAnX19tYWluX18nLFxuICAgICAgICAgIG1vZHVsZTogICBNb2R1bGVbJ2FzbSddLFxuICAgICAgICAgIGdsb2JhbDogICB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gd2hlbiBsb2FkRHluYW1pY0xpYnJhcnkgZGlkIG5vdCBoYXZlIGZsYWdzLCBsaWJyYXJpZXMgd2VyZSBsb2FkZWRcbiAgICAgIC8vIGdsb2JhbGx5ICYgcGVybWFuZW50bHlcbiAgICAgIGZsYWdzID0gZmxhZ3MgfHwge2dsb2JhbDogdHJ1ZSwgbm9kZWxldGU6IHRydWV9XG4gIFxuICAgICAgdmFyIGRzbyA9IExEU08ubG9hZGVkTGlic0J5TmFtZVtsaWJdO1xuICAgICAgaWYgKGRzbykge1xuICAgICAgICAvLyB0aGUgbGlicmFyeSBpcyBiZWluZyBsb2FkZWQgb3IgaGFzIGJlZW4gbG9hZGVkIGFscmVhZHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGhvd2V2ZXIgaXQgY291bGQgYmUgcHJldmlvdXNseSBsb2FkZWQgb25seSBsb2NhbGx5IGFuZCBpZiB3ZSBnZXRcbiAgICAgICAgLy8gbG9hZCByZXF1ZXN0IHdpdGggZ2xvYmFsPXRydWUgd2UgaGF2ZSB0byBtYWtlIGl0IGdsb2JhbGx5IHZpc2libGUgbm93LlxuICAgICAgICBpZiAoZmxhZ3MuZ2xvYmFsICYmICFkc28uZ2xvYmFsKSB7XG4gICAgICAgICAgZHNvLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgaWYgKGRzby5tb2R1bGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgLy8gXl5eIGlmIG1vZHVsZSBpcyAnbG9hZGluZycgLSBzeW1ib2xzIG1lcmdpbmcgd2lsbCBiZSBldmVudHVhbGx5IGRvbmUgYnkgdGhlIGxvYWRlci5cbiAgICAgICAgICAgIG1lcmdlTGliU3ltYm9scyhkc28ubW9kdWxlLCBsaWIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNhbWUgZm9yIFwibm9kZWxldGVcIlxuICAgICAgICBpZiAoZmxhZ3Mubm9kZWxldGUgJiYgZHNvLnJlZmNvdW50ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgIGRzby5yZWZjb3VudCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGRzby5yZWZjb3VudCsrXG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdID0gZHNvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUodHJ1ZSkgOiB0cnVlO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGFsbG9jYXRlIG5ldyBEU09cbiAgICAgIGRzbyA9IHtcbiAgICAgICAgcmVmY291bnQ6IGZsYWdzLm5vZGVsZXRlID8gSW5maW5pdHkgOiAxLFxuICAgICAgICBuYW1lOiAgICAgbGliLFxuICAgICAgICBtb2R1bGU6ICAgJ2xvYWRpbmcnLFxuICAgICAgICBnbG9iYWw6ICAgZmxhZ3MuZ2xvYmFsLFxuICAgICAgfTtcbiAgICAgIExEU08ubG9hZGVkTGlic0J5TmFtZVtsaWJdID0gZHNvO1xuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdID0gZHNvO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGxpYkRhdGEgPC0gbGliRmlsZVxuICAgICAgZnVuY3Rpb24gbG9hZExpYkRhdGEobGliRmlsZSkge1xuICAgICAgICAvLyBmb3Igd2FzbSwgd2UgY2FuIHVzZSBmZXRjaCBmb3IgYXN5bmMsIGJ1dCBmb3IgZnMgbW9kZSB3ZSBjYW4gb25seSBpbWl0YXRlIGl0XG4gICAgICAgIGlmIChmbGFncy5mcyAmJiBmbGFncy5mcy5maW5kT2JqZWN0KGxpYkZpbGUpKSB7XG4gICAgICAgICAgdmFyIGxpYkRhdGEgPSBmbGFncy5mcy5yZWFkRmlsZShsaWJGaWxlLCB7ZW5jb2Rpbmc6ICdiaW5hcnknfSk7XG4gICAgICAgICAgaWYgKCEobGliRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBsaWJEYXRhID0gbmV3IFVpbnQ4QXJyYXkobGliRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUobGliRGF0YSkgOiBsaWJEYXRhO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoZmxhZ3MubG9hZEFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVhZEFzeW5jKGxpYkZpbGUsIGZ1bmN0aW9uKGRhdGEpIHsgcmVzb2x2ZShuZXcgVWludDhBcnJheShkYXRhKSk7IH0sIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGxvYWQgdGhlIGJpbmFyeSBzeW5jaHJvbm91c2x5XG4gICAgICAgIGlmICghcmVhZEJpbmFyeSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsaWJGaWxlICsgJzogZmlsZSBub3QgZm91bmQsIGFuZCBzeW5jaHJvbm91cyBsb2FkaW5nIG9mIGV4dGVybmFsIGZpbGVzIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZEJpbmFyeShsaWJGaWxlKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBsaWJNb2R1bGUgPC0gbGliXG4gICAgICBmdW5jdGlvbiBnZXRMaWJNb2R1bGUoKSB7XG4gICAgICAgIC8vIGxvb2t1cCBwcmVsb2FkZWQgY2FjaGUgZmlyc3RcbiAgICAgICAgaWYgKE1vZHVsZVsncHJlbG9hZGVkV2FzbSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIE1vZHVsZVsncHJlbG9hZGVkV2FzbSddW2xpYl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBsaWJNb2R1bGUgPSBNb2R1bGVbJ3ByZWxvYWRlZFdhc20nXVtsaWJdO1xuICAgICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUobGliTW9kdWxlKSA6IGxpYk1vZHVsZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gbW9kdWxlIG5vdCBwcmVsb2FkZWQgLSBsb2FkIGxpYiBkYXRhIGFuZCBjcmVhdGUgbmV3IG1vZHVsZSBmcm9tIGl0XG4gICAgICAgIGlmIChmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZExpYkRhdGEobGliKS50aGVuKGZ1bmN0aW9uKGxpYkRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUobGliRGF0YSwgZmxhZ3MsIGhhbmRsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUobG9hZExpYkRhdGEobGliKSwgZmxhZ3MsIGhhbmRsZSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gbW9kdWxlIGZvciBsaWIgaXMgbG9hZGVkIC0gdXBkYXRlIHRoZSBkc28gJiBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICBmdW5jdGlvbiBtb2R1bGVMb2FkZWQobGliTW9kdWxlKSB7XG4gICAgICAgIGlmIChkc28uZ2xvYmFsKSB7XG4gICAgICAgICAgbWVyZ2VMaWJTeW1ib2xzKGxpYk1vZHVsZSwgbGliKTtcbiAgICAgICAgfVxuICAgICAgICBkc28ubW9kdWxlID0gbGliTW9kdWxlO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIGdldExpYk1vZHVsZSgpLnRoZW4oZnVuY3Rpb24obGliTW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlTG9hZGVkKGxpYk1vZHVsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICBcbiAgICAgIG1vZHVsZUxvYWRlZChnZXRMaWJNb2R1bGUoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiByZXBvcnRVbmRlZmluZWRTeW1ib2xzKCkge1xuICAgICAgZm9yICh2YXIgc3ltTmFtZSBpbiBHT1QpIHtcbiAgICAgICAgaWYgKEdPVFtzeW1OYW1lXS52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZUdsb2JhbFN5bWJvbChzeW1OYW1lLCB0cnVlKVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSwgJ3VuZGVmaW5lZCBzeW1ib2wgYCcgKyBzeW1OYW1lICsgJ2AuIHBlcmhhcHMgYSBzaWRlIG1vZHVsZSB3YXMgbm90IGxpbmtlZCBpbj8gaWYgdGhpcyBnbG9iYWwgd2FzIGV4cGVjdGVkIHRvIGFycml2ZSBmcm9tIGEgc3lzdGVtIGxpYnJhcnksIHRyeSB0byBidWlsZCB0aGUgTUFJTl9NT0RVTEUgd2l0aCBFTUNDX0ZPUkNFX1NURExJQlM9MSBpbiB0aGUgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBhZGRGdW5jdGlvbih2YWx1ZSwgdmFsdWUuc2lnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgR09UW3N5bU5hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGV4cG9ydCB0eXBlIGZvciBgJyArIHN5bU5hbWUgKyAnYDogJyArICh0eXBlb2YgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfZmlsZV9pbygpe1xuICAgICAgbWVtaW8uZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgeC52YWx1ZSA9IGFkZEZ1bmN0aW9uKHgsIHguc2lnKTtcbiAgICAgIH0pXG4gICAgfVxuXG4gIGZ1bmN0aW9uIHByZWxvYWREeWxpYnMoKSB7XG4gICAgICBpZiAoIWR5bmFtaWNMaWJyYXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlcG9ydFVuZGVmaW5lZFN5bWJvbHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIC8vIExvYWQgYmluYXJpZXMgYXN5bmNocm9ub3VzbHlcbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3ByZWxvYWREeWxpYnMnKTtcbiAgICAgIGR5bmFtaWNMaWJyYXJpZXMucmVkdWNlKGZ1bmN0aW9uKGNoYWluLCBsaWIpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShzY3JpcHREaXJlY3RvcnkgKyBsaWIsIHtsb2FkQXN5bmM6IHRydWUsIGdsb2JhbDogdHJ1ZSwgbm9kZWxldGU6IHRydWUsIGFsbG93VW5kZWZpbmVkOiB0cnVlfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIGdvdCB0aGVtIGFsbCwgd29uZGVyZnVsXG4gICAgICAgIHJlcG9ydFVuZGVmaW5lZFN5bWJvbHMoKTtcbiAgICAgICAgYWRkX2ZpbGVfaW8oKTtcbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgncHJlbG9hZER5bGlicycpO1xuICAgICAgfSk7XG4gICAgfVxuXG5cblxuICBmdW5jdGlvbiBzZXRXYXNtVGFibGVFbnRyeShpZHgsIGZ1bmMpIHtcbiAgICAgIHdhc21UYWJsZS5zZXQoaWR4LCBmdW5jKTtcbiAgICAgIHdhc21UYWJsZU1pcnJvcltpZHhdID0gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gc3RhY2tUcmFjZSgpIHtcbiAgICAgIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpO1xuICAgICAgaWYgKE1vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10pIGpzICs9ICdcXG4nICsgTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSgpO1xuICAgICAgcmV0dXJuIGRlbWFuZ2xlQWxsKGpzKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX19fYXNzZXJ0X2ZhaWwoY29uZGl0aW9uLCBmaWxlbmFtZSwgbGluZSwgZnVuYykge1xuICAgICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBVVEY4VG9TdHJpbmcoY29uZGl0aW9uKSArICcsIGF0OiAnICsgW2ZpbGVuYW1lID8gVVRGOFRvU3RyaW5nKGZpbGVuYW1lKSA6ICd1bmtub3duIGZpbGVuYW1lJywgbGluZSwgZnVuYyA/IFVURjhUb1N0cmluZyhmdW5jKSA6ICd1bmtub3duIGZ1bmN0aW9uJ10pO1xuICAgIH1cbiAgX19fYXNzZXJ0X2ZhaWwuc2lnID0gJ3ZpaWlpJztcblxuICBmdW5jdGlvbiBfX19jYWxsX3NpZ2hhbmRsZXIoZnAsIHNpZykge1xuICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnApKHNpZyk7XG4gICAgfVxuXG5cbiAgdmFyIF9fX21lbW9yeV9iYXNlID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogZmFsc2V9LCAxMDI0KTtcblxuICB2YXIgX19fc3RhY2tfcG9pbnRlciA9IG5ldyBXZWJBc3NlbWJseS5HbG9iYWwoeyd2YWx1ZSc6ICdpMzInLCAnbXV0YWJsZSc6IHRydWV9LCA2Mjg0Nzg0KTtcblxuICB2YXIgUEFUSCA9IHtzcGxpdFBhdGg6ZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbiAgICAgIH0sbm9ybWFsaXplQXJyYXk6ZnVuY3Rpb24ocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxub3JtYWxpemU6ZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLycsXG4gICAgICAgICAgICB0cmFpbGluZ1NsYXNoID0gcGF0aC5zdWJzdHIoLTEpID09PSAnLyc7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gISFwO1xuICAgICAgICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sZGlybmFtZTpmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSxcbiAgICAgICAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCArIGRpcjtcbiAgICAgIH0sYmFzZW5hbWU6ZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAvLyBFTVNDUklQVEVOIHJldHVybiAnLycnIGZvciAnLycsIG5vdCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKGxhc3RTbGFzaCsxKTtcbiAgICAgIH0sZXh0bmFtZTpmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBQQVRILnNwbGl0UGF0aChwYXRoKVszXTtcbiAgICAgIH0sam9pbjpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oJy8nKSk7XG4gICAgICB9LGpvaW4yOmZ1bmN0aW9uKGwsIHIpIHtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgICAgIH19O1xuICBcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tRGV2aWNlKCkge1xuICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBmb3IgbW9kZXJuIHdlYiBicm93c2Vyc1xuICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CdWZmZXIpOyByZXR1cm4gcmFuZG9tQnVmZmVyWzBdOyB9O1xuICAgICAgfSBlbHNlXG4gICAgICAvLyBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgLy8gICAvLyBmb3Igbm9kZWpzIHdpdGggb3Igd2l0aG91dCBjcnlwdG8gc3VwcG9ydCBpbmNsdWRlZFxuICAgICAgLy8gICB0cnkge1xuICAgICAgLy8gICAgIHZhciBjcnlwdG9fbW9kdWxlID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICAvLyAgICAgLy8gbm9kZWpzIGhhcyBjcnlwdG8gc3VwcG9ydFxuICAgICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGNyeXB0b19tb2R1bGVbJ3JhbmRvbUJ5dGVzJ10oMSlbMF07IH07XG4gICAgICAvLyAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vICAgICAvLyBub2RlanMgZG9lc24ndCBoYXZlIGNyeXB0byBzdXBwb3J0XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICAgIC8vIHdlIGNvdWxkbid0IGZpbmQgYSBwcm9wZXIgaW1wbGVtZW50YXRpb24sIGFzIE1hdGgucmFuZG9tKCkgaXMgbm90IHN1aXRhYmxlIGZvciAvZGV2L3JhbmRvbSwgc2VlIGVtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3B1bGwvNzA5NlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydChcIm5vIGNyeXB0b2dyYXBoaWMgc3VwcG9ydCBmb3VuZCBmb3IgcmFuZG9tRGV2aWNlLiBjb25zaWRlciBwb2x5ZmlsbGluZyBpdCBpZiB5b3Ugd2FudCB0byB1c2Ugc29tZXRoaW5nIGluc2VjdXJlIGxpa2UgTWF0aC5yYW5kb20oKSwgZS5nLiBwdXQgdGhpcyBpbiBhIC0tcHJlLWpzOiB2YXIgY3J5cHRvID0geyBnZXRSYW5kb21WYWx1ZXM6IGZ1bmN0aW9uKGFycmF5KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqMjU2KXwwIH0gfTtcIik7IH07XG4gICAgfVxuICBcbiAgdmFyIFBBVEhfRlMgPSB7cmVzb2x2ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogRlMuY3dkKCk7XG4gICAgICAgICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJzsgLy8gYW4gaW52YWxpZCBwb3J0aW9uIGludmFsaWRhdGVzIHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAgICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gISFwO1xuICAgICAgICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xuICAgICAgfSxyZWxhdGl2ZTpmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfX07XG4gIFxuICB2YXIgVFRZID0ge3R0eXM6W10saW5pdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9wdWxsLzE1NTVcbiAgICAgICAgLy8gaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiAgICAgICAgLy8gICAvLyBjdXJyZW50bHksIEZTLmluaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2ggaWYgcHJvY2Vzcy5zdGRpbiBpcyBhIGZpbGUgb3IgVFRZXG4gICAgICAgIC8vICAgLy8gZGV2aWNlLCBpdCBhbHdheXMgYXNzdW1lcyBpdCdzIGEgVFRZIGRldmljZS4gYmVjYXVzZSBvZiB0aGlzLCB3ZSdyZSBmb3JjaW5nXG4gICAgICAgIC8vICAgLy8gcHJvY2Vzcy5zdGRpbiB0byBVVEY4IGVuY29kaW5nIHRvIGF0IGxlYXN0IG1ha2Ugc3RkaW4gcmVhZGluZyBjb21wYXRpYmxlXG4gICAgICAgIC8vICAgLy8gd2l0aCB0ZXh0IGZpbGVzIHVudGlsIEZTLmluaXQgY2FuIGJlIHJlZmFjdG9yZWQuXG4gICAgICAgIC8vICAgcHJvY2Vzc1snc3RkaW4nXVsnc2V0RW5jb2RpbmcnXSgndXRmOCcpO1xuICAgICAgICAvLyB9XG4gICAgICB9LHNodXRkb3duOmZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vcHVsbC8xNTU1XG4gICAgICAgIC8vIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgIC8vICAgLy8gaW5vbGVuOiBhbnkgaWRlYSBhcyB0byB3aHkgbm9kZSAtZSAncHJvY2Vzcy5zdGRpbi5yZWFkKCknIHdvdWxkbid0IGV4aXQgaW1tZWRpYXRlbHkgKHdpdGggcHJvY2Vzcy5zdGRpbiBiZWluZyBhIHR0eSk/XG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBiZWNhdXNlIG5vdyBpdCdzIHJlYWRpbmcgZnJvbSB0aGUgc3RyZWFtLCB5b3UndmUgZXhwcmVzc2VkIGludGVyZXN0IGluIGl0LCBzbyB0aGF0IHJlYWQoKSBraWNrcyBvZmYgYSBfcmVhZCgpIHdoaWNoIGNyZWF0ZXMgYSBSZWFkUmVxIG9wZXJhdGlvblxuICAgICAgICAvLyAgIC8vIGlub2xlbjogSSB0aG91Z2h0IHJlYWQoKSBpbiB0aGF0IGNhc2Ugd2FzIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uIHRoYXQganVzdCBncmFiYmVkIHNvbWUgYW1vdW50IG9mIGJ1ZmZlcmVkIGRhdGEgaWYgaXQgZXhpc3RzP1xuICAgICAgICAvLyAgIC8vIGlzYWFjczogaXQgaXMuIGJ1dCBpdCBhbHNvIHRyaWdnZXJzIGEgX3JlYWQoKSBjYWxsLCB3aGljaCBjYWxscyByZWFkU3RhcnQoKSBvbiB0aGUgaGFuZGxlXG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBkbyBwcm9jZXNzLnN0ZGluLnBhdXNlKCkgYW5kIGknZCB0aGluayBpdCdkIHByb2JhYmx5IGNsb3NlIHRoZSBwZW5kaW5nIGNhbGxcbiAgICAgICAgLy8gICBwcm9jZXNzWydzdGRpbiddWydwYXVzZSddKCk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0scmVnaXN0ZXI6ZnVuY3Rpb24oZGV2LCBvcHMpIHtcbiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9O1xuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIFRUWS5zdHJlYW1fb3BzKTtcbiAgICAgIH0sc3RyZWFtX29wczp7b3BlbjpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgdHR5ID0gVFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07XG4gICAgICAgICAgaWYgKCF0dHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLnR0eSA9IHR0eTtcbiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICAvLyBmbHVzaCBhbnkgcGVuZGluZyBsaW5lIGRhdGFcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTtcbiAgICAgICAgfSxmbHVzaDpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTtcbiAgICAgICAgfSxyZWFkOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICB9LHdyaXRlOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9fSxkZWZhdWx0X3R0eV9vcHM6e2dldF9jaGFyOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICghdHR5LmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHJlYWQgZGF0YSBieSBjaHVua3Mgb2YgQlVGU0laRVxuICAgICAgICAgICAgICB2YXIgQlVGU0laRSA9IDI1NjtcbiAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhCVUZTSVpFKTtcbiAgICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gIFxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKHByb2Nlc3Muc3RkaW4uZmQsIGJ1ZiwgMCwgQlVGU0laRSwgLTEpO1xuICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9zcy1wbGF0Zm9ybSBkaWZmZXJlbmNlczogb24gV2luZG93cywgcmVhZGluZyBFT0YgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYnV0IG9uIG90aGVyIE9TZXMsXG4gICAgICAgICAgICAgICAgLy8gcmVhZGluZyBFT0YgcmV0dXJucyAwLiBVbmlmb3JtaXplIGJlaGF2aW9yIGJ5IHRyZWF0aW5nIHRoZSBFT0YgZXhjZXB0aW9uIHRvIHJldHVybiAwLlxuICAgICAgICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ0VPRicpKSBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBidWYuc2xpY2UoMCwgYnl0ZXNSZWFkKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQnJvd3Nlci5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpOyAgLy8gcmV0dXJucyBudWxsIG9uIGNhbmNlbFxuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkbGluZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIENvbW1hbmQgbGluZS5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVhZGxpbmUoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dHkuaW5wdXQgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR0eS5pbnB1dC5zaGlmdCgpO1xuICAgICAgICB9LHB1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpOyAvLyB2YWwgPT0gMCB3b3VsZCBjdXQgdGV4dCBvdXRwdXQgb2ZmIGluIHRoZSBtaWRkbGUuXG4gICAgICAgICAgfVxuICAgICAgICB9LGZsdXNoOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH19LGRlZmF1bHRfdHR5MV9vcHM6e3B1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxmbHVzaDpmdW5jdGlvbih0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9fX07XG4gIFxuICBmdW5jdGlvbiBtbWFwQWxsb2Moc2l6ZSkge1xuICAgICAgYWJvcnQoJ2ludGVybmFsIGVycm9yOiBtbWFwQWxsb2MgY2FsbGVkIGJ1dCBgZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduYCBuYXRpdmUgc3ltYm9sIG5vdCBleHBvcnRlZCcpO1xuICAgIH1cbiAgdmFyIE1FTUZTID0ge29wc190YWJsZTpudWxsLG1vdW50OmZ1bmN0aW9uKG1vdW50KSB7XG4gICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsICcvJywgMTYzODQgfCA1MTEgLyogMDc3NyAqLywgMCk7XG4gICAgICB9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIC8vIG5vIHN1cHBvcnRlZFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1FTUZTLm9wc190YWJsZSkge1xuICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHtcbiAgICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0clxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICAgIHJlYWQ6IE1FTUZTLnN0cmVhbV9vcHMucmVhZCxcbiAgICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSxcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxcbiAgICAgICAgICAgICAgICBtbWFwOiBNRU1GUy5zdHJlYW1fb3BzLm1tYXAsXG4gICAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNocmRldjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwOyAvLyBUaGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB1c2VkIGluIHRoZSB0eXBlZCBhcnJheSwgYXMgb3Bwb3NlZCB0byBjb250ZW50cy5sZW5ndGggd2hpY2ggZ2l2ZXMgdGhlIHdob2xlIGNhcGFjaXR5LlxuICAgICAgICAgIC8vIFdoZW4gdGhlIGJ5dGUgZGF0YSBvZiB0aGUgZmlsZSBpcyBwb3B1bGF0ZWQsIHRoaXMgd2lsbCBwb2ludCB0byBlaXRoZXIgYSB0eXBlZCBhcnJheSwgb3IgYSBub3JtYWwgSlMgYXJyYXkuIFR5cGVkIGFycmF5cyBhcmUgcHJlZmVycmVkXG4gICAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlLCBhbmQgdXNlZCBieSBkZWZhdWx0LiBIb3dldmVyLCB0eXBlZCBhcnJheXMgYXJlIG5vdCByZXNpemFibGUgbGlrZSBub3JtYWwgSlMgYXJyYXlzIGFyZSwgc28gdGhlcmUgaXMgYSBzbWFsbCBkaXNrIHNpemVcbiAgICAgICAgICAvLyBwZW5hbHR5IGludm9sdmVkIGZvciBhcHBlbmRpbmcgZmlsZSB3cml0ZXMgdGhhdCBjb250aW51b3VzbHkgZ3JvdyBhIGZpbGUgc2ltaWxhciB0byBzdGQ6OnZlY3RvciBjYXBhY2l0eSB2cyB1c2VkIC1zY2hlbWUuXG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IFxuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgbm9kZSB0byB0aGUgcGFyZW50XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY29udGVudHNbbmFtZV0gPSBub2RlO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBub2RlLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKTsgLy8gTWFrZSBzdXJlIHRvIG5vdCByZXR1cm4gZXhjZXNzIHVudXNlZCBieXRlcy5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xuICAgICAgfSxleHBhbmRGaWxlU3RvcmFnZTpmdW5jdGlvbihub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuOyAvLyBObyBuZWVkIHRvIGV4cGFuZCwgdGhlIHN0b3JhZ2Ugd2FzIGFscmVhZHkgbGFyZ2UgZW5vdWdoLlxuICAgICAgICAvLyBEb24ndCBleHBhbmQgc3RyaWN0bHkgdG8gdGhlIGdpdmVuIHJlcXVlc3RlZCBsaW1pdCBpZiBpdCdzIG9ubHkgYSB2ZXJ5IHNtYWxsIGluY3JlYXNlLCBidXQgaW5zdGVhZCBnZW9tZXRyaWNhbGx5IGdyb3cgY2FwYWNpdHkuXG4gICAgICAgIC8vIEZvciBzbWFsbCBmaWxlc2l6ZXMgKDwxTUIpLCBwZXJmb3JtIHNpemUqMiBnZW9tZXRyaWMgaW5jcmVhc2UsIGJ1dCBmb3IgbGFyZ2Ugc2l6ZXMsIGRvIGEgbXVjaCBtb3JlIGNvbnNlcnZhdGl2ZSBzaXplKjEuMTI1IGluY3JlYXNlIHRvXG4gICAgICAgIC8vIGF2b2lkIG92ZXJzaG9vdGluZyB0aGUgYWxsb2NhdGlvbiBjYXAgYnkgYSB2ZXJ5IGxhcmdlIG1hcmdpbi5cbiAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0O1xuICAgICAgICBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAocHJldkNhcGFjaXR5ICogKHByZXZDYXBhY2l0eSA8IENBUEFDSVRZX0RPVUJMSU5HX01BWCA/IDIuMCA6IDEuMTI1KSkgPj4+IDApO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ICE9IDApIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIDI1Nik7IC8vIEF0IG1pbmltdW0gYWxsb2NhdGUgMjU2YiBmb3IgZWFjaCBmaWxlIHdoZW4gZXhwYW5kaW5nLlxuICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpOyAvLyBBbGxvY2F0ZSBuZXcgc3RvcmFnZS5cbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMCkgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTsgLy8gQ29weSBvbGQgZGF0YSBvdmVyIHRvIHRoZSBuZXcgc3RvcmFnZS5cbiAgICAgIH0scmVzaXplRmlsZVN0b3JhZ2U6ZnVuY3Rpb24obm9kZSwgbmV3U2l6ZSkge1xuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPT0gbmV3U2l6ZSkgcmV0dXJuO1xuICAgICAgICBpZiAobmV3U2l6ZSA9PSAwKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IC8vIEZ1bGx5IGRlY29tbWl0IHdoZW4gcmVxdWVzdGluZyBhIHJlc2l6ZSB0byB6ZXJvLlxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTsgLy8gQWxsb2NhdGUgbmV3IHN0b3JhZ2UuXG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBNYXRoLm1pbihuZXdTaXplLCBub2RlLnVzZWRCeXRlcykpKTsgLy8gQ29weSBvbGQgZGF0YSBvdmVyIHRvIHRoZSBuZXcgc3RvcmFnZS5cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplO1xuICAgICAgICB9XG4gICAgICB9LG5vZGVfb3BzOntnZXRhdHRyOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgIC8vIGRldmljZSBudW1iZXJzIHJldXNlIGlub2RlIG51bWJlcnMuXG4gICAgICAgICAgYXR0ci5kZXYgPSBGUy5pc0NocmRldihub2RlLm1vZGUpID8gbm9kZS5pZCA6IDE7XG4gICAgICAgICAgYXR0ci5pbm8gPSBub2RlLmlkO1xuICAgICAgICAgIGF0dHIubW9kZSA9IG5vZGUubW9kZTtcbiAgICAgICAgICBhdHRyLm5saW5rID0gMTtcbiAgICAgICAgICBhdHRyLnVpZCA9IDA7XG4gICAgICAgICAgYXR0ci5naWQgPSAwO1xuICAgICAgICAgIGF0dHIucmRldiA9IG5vZGUucmRldjtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gNDA5NjtcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLnVzZWRCeXRlcztcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLmxpbmsubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyLmF0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIubXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYXR0ci5jdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICAvLyBOT1RFOiBJbiBvdXIgaW1wbGVtZW50YXRpb24sIHN0X2Jsb2NrcyA9IE1hdGguY2VpbChzdF9zaXplL3N0X2Jsa3NpemUpLFxuICAgICAgICAgIC8vICAgICAgIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCBieSB0aGUgc3RhbmRhcmQuXG4gICAgICAgICAgYXR0ci5ibGtzaXplID0gNDA5NjtcbiAgICAgICAgICBhdHRyLmJsb2NrcyA9IE1hdGguY2VpbChhdHRyLnNpemUgLyBhdHRyLmJsa3NpemUpO1xuICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9LHNldGF0dHI6ZnVuY3Rpb24obm9kZSwgYXR0cikge1xuICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLCBhdHRyLnNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxsb29rdXA6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1s0NF07XG4gICAgICAgIH0sbWtub2Q6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIH0scmVuYW1lOmZ1bmN0aW9uKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSkge1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIG92ZXJ3cml0aW5nIGEgZGlyZWN0b3J5IGF0IG5ld19uYW1lLCBtYWtlIHN1cmUgaXQncyBlbXB0eS5cbiAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3X25vZGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkbyB0aGUgaW50ZXJuYWwgcmV3aXJpbmdcbiAgICAgICAgICBkZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lO1xuICAgICAgICAgIG5ld19kaXIuY29udGVudHNbbmV3X25hbWVdID0gb2xkX25vZGU7XG4gICAgICAgICAgbmV3X2Rpci50aW1lc3RhbXAgPSBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudCA9IG5ld19kaXI7XG4gICAgICAgIH0sdW5saW5rOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scm1kaXI6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scmVhZGRpcjpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbJy4nLCAnLi4nXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sc3ltbGluazpmdW5jdGlvbihwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgLyogMDc3NyAqLyB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LHJlYWRsaW5rOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH19LHN0cmVhbV9vcHM6e3JlYWQ6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgYXNzZXJ0KHNpemUgPj0gMCk7XG4gICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7IC8vIG5vbi10cml2aWFsLCBhbmQgdHlwZWQgYXJyYXlcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgICAgICAvLyBUaGUgZGF0YSBidWZmZXIgc2hvdWxkIGJlIGEgdHlwZWQgYXJyYXkgdmlld1xuICAgICAgICAgIGFzc2VydCghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSk7XG4gIFxuICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbS5ub2RlO1xuICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHsgLy8gVGhpcyB3cml0ZSBpcyBmcm9tIGEgdHlwZWQgYXJyYXkgdG8gYSB0eXBlZCBhcnJheT9cbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KHBvc2l0aW9uID09PSAwLCAnY2FuT3duIG11c3QgaW1wbHkgbm8gd2VpcmQgcG9zaXRpb24gaW5zaWRlIHRoZSBmaWxlJyk7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS51c2VkQnl0ZXMgPT09IDAgJiYgcG9zaXRpb24gPT09IDApIHsgLy8gSWYgdGhpcyBpcyBhIHNpbXBsZSBmaXJzdCB3cml0ZSB0byBhbiBlbXB0eSBmaWxlLCBkbyBhIGZhc3Qgc2V0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gY2FyZSBhYm91dCBvbGQgZGF0YS5cbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiArIGxlbmd0aCA8PSBub2RlLnVzZWRCeXRlcykgeyAvLyBXcml0aW5nIHRvIGFuIGFscmVhZHkgYWxsb2NhdGVkIGFuZCB1c2VkIHN1YnJhbmdlIG9mIHRoZSBmaWxlP1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBBcHBlbmRpbmcgdG8gYW4gZXhpc3RpbmcgZmlsZSBhbmQgd2UgbmVlZCB0byByZWFsbG9jYXRlLCBvciBzb3VyY2UgZGF0YSBkaWQgbm90IGNvbWUgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbitsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgLy8gVXNlIHR5cGVkIGFycmF5IHdyaXRlIHdoaWNoIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsgLy8gT3IgZmFsbCBiYWNrIHRvIG1hbnVhbCB3cml0ZSBpZiBub3QuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LGxsc2VlazpmdW5jdGlvbihzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LGFsbG9jYXRlOmZ1bmN0aW9uKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChzdHJlYW0ubm9kZS51c2VkQnl0ZXMsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sbW1hcDpmdW5jdGlvbihzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICAgICAgaWYgKGFkZHJlc3MgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGxvY2F0aW9uIGhpbnRzIGZvciB0aGUgYWRkcmVzcyBvZiB0aGUgbWFwcGluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHRyO1xuICAgICAgICAgIHZhciBhbGxvY2F0ZWQ7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgLy8gT25seSBtYWtlIGEgbmV3IGNvcHkgd2hlbiBNQVBfUFJJVkFURSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cy5idWZmZXIgPT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZW11bGF0ZSBNQVBfU0hBUkVEIHdoZW4gdGhlIGZpbGUgaXMgbm90IGJhY2tlZCBieSB0aGUgYnVmZmVyXG4gICAgICAgICAgICAvLyB3ZSdyZSBtYXBwaW5nIHRvIChlLmcuIHRoZSBIRUFQIGJ1ZmZlcikuXG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHB0ciA9IGNvbnRlbnRzLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBzbGljZXMuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiAwIHx8IHBvc2l0aW9uICsgbGVuZ3RoIDwgY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgICAgICB9LG1zeW5jOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1tYXBGbGFncyAmIDIpIHtcbiAgICAgICAgICAgIC8vIE1BUF9QUklWQVRFIGNhbGxzIG5lZWQgbm90IHRvIGJlIHN5bmNlZCBiYWNrIHRvIHVuZGVybHlpbmcgZnNcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIDAsIGxlbmd0aCwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgLy8gc2hvdWxkIHdlIGNoZWNrIGlmIGJ5dGVzV3JpdHRlbiBhbmQgbGVuZ3RoIGFyZSB0aGUgc2FtZT9cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfX19O1xuICBcbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IG5vUnVuRGVwICovXG4gIGZ1bmN0aW9uIGFzeW5jTG9hZCh1cmwsIG9ubG9hZCwgb25lcnJvciwgbm9SdW5EZXApIHtcbiAgICAgIHZhciBkZXAgPSAhbm9SdW5EZXAgPyBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdhbCAnICsgdXJsKSA6ICcnO1xuICAgICAgcmVhZEFzeW5jKHVybCwgZnVuY3Rpb24oYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYXNzZXJ0KGFycmF5QnVmZmVyLCAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicpO1xuICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgaWYgKGRlcCkgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgfSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0xvYWRpbmcgZGF0YSBmaWxlIFwiJyArIHVybCArICdcIiBmYWlsZWQuJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGVwKSBhZGRSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgfVxuICBcbiAgdmFyIEVSUk5PX01FU1NBR0VTID0gezA6XCJTdWNjZXNzXCIsMTpcIkFyZyBsaXN0IHRvbyBsb25nXCIsMjpcIlBlcm1pc3Npb24gZGVuaWVkXCIsMzpcIkFkZHJlc3MgYWxyZWFkeSBpbiB1c2VcIiw0OlwiQWRkcmVzcyBub3QgYXZhaWxhYmxlXCIsNTpcIkFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wgZmFtaWx5XCIsNjpcIk5vIG1vcmUgcHJvY2Vzc2VzXCIsNzpcIlNvY2tldCBhbHJlYWR5IGNvbm5lY3RlZFwiLDg6XCJCYWQgZmlsZSBudW1iZXJcIiw5OlwiVHJ5aW5nIHRvIHJlYWQgdW5yZWFkYWJsZSBtZXNzYWdlXCIsMTA6XCJNb3VudCBkZXZpY2UgYnVzeVwiLDExOlwiT3BlcmF0aW9uIGNhbmNlbGVkXCIsMTI6XCJObyBjaGlsZHJlblwiLDEzOlwiQ29ubmVjdGlvbiBhYm9ydGVkXCIsMTQ6XCJDb25uZWN0aW9uIHJlZnVzZWRcIiwxNTpcIkNvbm5lY3Rpb24gcmVzZXQgYnkgcGVlclwiLDE2OlwiRmlsZSBsb2NraW5nIGRlYWRsb2NrIGVycm9yXCIsMTc6XCJEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkXCIsMTg6XCJNYXRoIGFyZyBvdXQgb2YgZG9tYWluIG9mIGZ1bmNcIiwxOTpcIlF1b3RhIGV4Y2VlZGVkXCIsMjA6XCJGaWxlIGV4aXN0c1wiLDIxOlwiQmFkIGFkZHJlc3NcIiwyMjpcIkZpbGUgdG9vIGxhcmdlXCIsMjM6XCJIb3N0IGlzIHVucmVhY2hhYmxlXCIsMjQ6XCJJZGVudGlmaWVyIHJlbW92ZWRcIiwyNTpcIklsbGVnYWwgYnl0ZSBzZXF1ZW5jZVwiLDI2OlwiQ29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsMjc6XCJJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbFwiLDI4OlwiSW52YWxpZCBhcmd1bWVudFwiLDI5OlwiSS9PIGVycm9yXCIsMzA6XCJTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWRcIiwzMTpcIklzIGEgZGlyZWN0b3J5XCIsMzI6XCJUb28gbWFueSBzeW1ib2xpYyBsaW5rc1wiLDMzOlwiVG9vIG1hbnkgb3BlbiBmaWxlc1wiLDM0OlwiVG9vIG1hbnkgbGlua3NcIiwzNTpcIk1lc3NhZ2UgdG9vIGxvbmdcIiwzNjpcIk11bHRpaG9wIGF0dGVtcHRlZFwiLDM3OlwiRmlsZSBvciBwYXRoIG5hbWUgdG9vIGxvbmdcIiwzODpcIk5ldHdvcmsgaW50ZXJmYWNlIGlzIG5vdCBjb25maWd1cmVkXCIsMzk6XCJDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmtcIiw0MDpcIk5ldHdvcmsgaXMgdW5yZWFjaGFibGVcIiw0MTpcIlRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtXCIsNDI6XCJObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlXCIsNDM6XCJObyBzdWNoIGRldmljZVwiLDQ0OlwiTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiLDQ1OlwiRXhlYyBmb3JtYXQgZXJyb3JcIiw0NjpcIk5vIHJlY29yZCBsb2NrcyBhdmFpbGFibGVcIiw0NzpcIlRoZSBsaW5rIGhhcyBiZWVuIHNldmVyZWRcIiw0ODpcIk5vdCBlbm91Z2ggY29yZVwiLDQ5OlwiTm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGVcIiw1MDpcIlByb3RvY29sIG5vdCBhdmFpbGFibGVcIiw1MTpcIk5vIHNwYWNlIGxlZnQgb24gZGV2aWNlXCIsNTI6XCJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWRcIiw1MzpcIlNvY2tldCBpcyBub3QgY29ubmVjdGVkXCIsNTQ6XCJOb3QgYSBkaXJlY3RvcnlcIiw1NTpcIkRpcmVjdG9yeSBub3QgZW1wdHlcIiw1NjpcIlN0YXRlIG5vdCByZWNvdmVyYWJsZVwiLDU3OlwiU29ja2V0IG9wZXJhdGlvbiBvbiBub24tc29ja2V0XCIsNTk6XCJOb3QgYSB0eXBld3JpdGVyXCIsNjA6XCJObyBzdWNoIGRldmljZSBvciBhZGRyZXNzXCIsNjE6XCJWYWx1ZSB0b28gbGFyZ2UgZm9yIGRlZmluZWQgZGF0YSB0eXBlXCIsNjI6XCJQcmV2aW91cyBvd25lciBkaWVkXCIsNjM6XCJOb3Qgc3VwZXItdXNlclwiLDY0OlwiQnJva2VuIHBpcGVcIiw2NTpcIlByb3RvY29sIGVycm9yXCIsNjY6XCJVbmtub3duIHByb3RvY29sXCIsNjc6XCJQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXRcIiw2ODpcIk1hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlXCIsNjk6XCJSZWFkIG9ubHkgZmlsZSBzeXN0ZW1cIiw3MDpcIklsbGVnYWwgc2Vla1wiLDcxOlwiTm8gc3VjaCBwcm9jZXNzXCIsNzI6XCJTdGFsZSBmaWxlIGhhbmRsZVwiLDczOlwiQ29ubmVjdGlvbiB0aW1lZCBvdXRcIiw3NDpcIlRleHQgZmlsZSBidXN5XCIsNzU6XCJDcm9zcy1kZXZpY2UgbGlua1wiLDEwMDpcIkRldmljZSBub3QgYSBzdHJlYW1cIiwxMDE6XCJCYWQgZm9udCBmaWxlIGZtdFwiLDEwMjpcIkludmFsaWQgc2xvdFwiLDEwMzpcIkludmFsaWQgcmVxdWVzdCBjb2RlXCIsMTA0OlwiTm8gYW5vZGVcIiwxMDU6XCJCbG9jayBkZXZpY2UgcmVxdWlyZWRcIiwxMDY6XCJDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2VcIiwxMDc6XCJMZXZlbCAzIGhhbHRlZFwiLDEwODpcIkxldmVsIDMgcmVzZXRcIiwxMDk6XCJMaW5rIG51bWJlciBvdXQgb2YgcmFuZ2VcIiwxMTA6XCJQcm90b2NvbCBkcml2ZXIgbm90IGF0dGFjaGVkXCIsMTExOlwiTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGVcIiwxMTI6XCJMZXZlbCAyIGhhbHRlZFwiLDExMzpcIkludmFsaWQgZXhjaGFuZ2VcIiwxMTQ6XCJJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvclwiLDExNTpcIkV4Y2hhbmdlIGZ1bGxcIiwxMTY6XCJObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pXCIsMTE3OlwiVGltZXIgZXhwaXJlZFwiLDExODpcIk91dCBvZiBzdHJlYW1zIHJlc291cmNlc1wiLDExOTpcIk1hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrXCIsMTIwOlwiUGFja2FnZSBub3QgaW5zdGFsbGVkXCIsMTIxOlwiVGhlIG9iamVjdCBpcyByZW1vdGVcIiwxMjI6XCJBZHZlcnRpc2UgZXJyb3JcIiwxMjM6XCJTcm1vdW50IGVycm9yXCIsMTI0OlwiQ29tbXVuaWNhdGlvbiBlcnJvciBvbiBzZW5kXCIsMTI1OlwiQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpXCIsMTI2OlwiR2l2ZW4gbG9nLiBuYW1lIG5vdCB1bmlxdWVcIiwxMjc6XCJmLmQuIGludmFsaWQgZm9yIHRoaXMgb3BlcmF0aW9uXCIsMTI4OlwiUmVtb3RlIGFkZHJlc3MgY2hhbmdlZFwiLDEyOTpcIkNhbiAgIGFjY2VzcyBhIG5lZWRlZCBzaGFyZWQgbGliXCIsMTMwOlwiQWNjZXNzaW5nIGEgY29ycnVwdGVkIHNoYXJlZCBsaWJcIiwxMzE6XCIubGliIHNlY3Rpb24gaW4gYS5vdXQgY29ycnVwdGVkXCIsMTMyOlwiQXR0ZW1wdGluZyB0byBsaW5rIGluIHRvbyBtYW55IGxpYnNcIiwxMzM6XCJBdHRlbXB0aW5nIHRvIGV4ZWMgYSBzaGFyZWQgbGlicmFyeVwiLDEzNTpcIlN0cmVhbXMgcGlwZSBlcnJvclwiLDEzNjpcIlRvbyBtYW55IHVzZXJzXCIsMTM3OlwiU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZFwiLDEzODpcIk5vdCBzdXBwb3J0ZWRcIiwxMzk6XCJQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZFwiLDE0MDpcIkNhbid0IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duXCIsMTQxOlwiVG9vIG1hbnkgcmVmZXJlbmNlc1wiLDE0MjpcIkhvc3QgaXMgZG93blwiLDE0ODpcIk5vIG1lZGl1bSAoaW4gdGFwZSBkcml2ZSlcIiwxNTY6XCJMZXZlbCAyIG5vdCBzeW5jaHJvbml6ZWRcIn07XG4gIFxuICB2YXIgRVJSTk9fQ09ERVMgPSB7fTtcbiAgdmFyIEZTID0ge3Jvb3Q6bnVsbCxtb3VudHM6W10sZGV2aWNlczp7fSxzdHJlYW1zOltdLG5leHRJbm9kZToxLG5hbWVUYWJsZTpudWxsLGN1cnJlbnRQYXRoOlwiL1wiLGluaXRpYWxpemVkOmZhbHNlLGlnbm9yZVBlcm1pc3Npb25zOnRydWUsRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGxvb2t1cFBhdGg6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKEZTLmN3ZCgpLCBwYXRoKTtcbiAgXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcbiAgXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBmb2xsb3dfbW91bnQ6IHRydWUsXG4gICAgICAgICAgcmVjdXJzZV9jb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cylcbiAgXG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7ICAvLyBtYXggcmVjdXJzaXZlIGxvb2t1cCBvZiA4XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBzcGxpdCB0aGUgcGF0aFxuICAgICAgICB2YXIgcGFydHMgPSBQQVRILm5vcm1hbGl6ZUFycmF5KHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCksIGZhbHNlKTtcbiAgXG4gICAgICAgIC8vIHN0YXJ0IGF0IHRoZSByb290XG4gICAgICAgIHZhciBjdXJyZW50ID0gRlMucm9vdDtcbiAgICAgICAgdmFyIGN1cnJlbnRfcGF0aCA9ICcvJztcbiAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gKGkgPT09IHBhcnRzLmxlbmd0aC0xKTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBzdG9wIHJlc29sdmluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcbiAgXG4gICAgICAgICAgLy8ganVtcCB0byB0aGUgbW91bnQncyByb290IG5vZGUgaWYgdGhpcyBpcyBhIG1vdW50cG9pbnRcbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tb3VudGVkLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBieSBkZWZhdWx0LCBsb29rdXBQYXRoIHdpbGwgbm90IGZvbGxvdyBhIHN5bWxpbmsgaWYgaXQgaXMgdGhlIGZpbmFsIHBhdGggY29tcG9uZW50LlxuICAgICAgICAgIC8vIHNldHRpbmcgb3B0cy5mb2xsb3cgPSB0cnVlIHdpbGwgb3ZlcnJpZGUgdGhpcyBiZWhhdmlvci5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG4gIFxuICAgICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChjdXJyZW50X3BhdGgsIHsgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSB9KTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkgeyAgLy8gbGltaXQgbWF4IGNvbnNlY3V0aXZlIHN5bWxpbmtzIHRvIDQwIChTWU1MT09QX01BWCkuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgICAgIH0sZ2V0UGF0aDoobm9kZSkgPT4ge1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBtb3VudFttb3VudC5sZW5ndGgtMV0gIT09ICcvJyA/IG1vdW50ICsgJy8nICsgcGF0aCA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxoYXNoTmFtZToocGFyZW50aWQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gICAgICB9LGhhc2hBZGROb2RlOihub2RlKSA9PiB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlO1xuICAgICAgfSxoYXNoUmVtb3ZlTm9kZToobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XG4gICAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5hbWVfbmV4dCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sbG9va3VwTm9kZToocGFyZW50LCBuYW1lKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7XG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBGUy5uYW1lVGFibGVbaGFzaF07IG5vZGU7IG5vZGUgPSBub2RlLm5hbWVfbmV4dCkge1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGZhaWxlZCB0byBmaW5kIGl0IGluIHRoZSBjYWNoZSwgY2FsbCBpbnRvIHRoZSBWRlNcbiAgICAgICAgcmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxjcmVhdGVOb2RlOihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpID0+IHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXJlbnQgPT0gJ29iamVjdCcpXG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuICBcbiAgICAgICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7XG4gIFxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZGVzdHJveU5vZGU6KG5vZGUpID0+IHtcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7XG4gICAgICB9LGlzUm9vdDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gbm9kZS5wYXJlbnQ7XG4gICAgICB9LGlzTW91bnRwb2ludDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gISFub2RlLm1vdW50ZWQ7XG4gICAgICB9LGlzRmlsZToobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDMyNzY4O1xuICAgICAgfSxpc0RpcjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDE2Mzg0O1xuICAgICAgfSxpc0xpbms6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2MDtcbiAgICAgIH0saXNDaHJkZXY6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA4MTkyO1xuICAgICAgfSxpc0Jsa2RldjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDI0NTc2O1xuICAgICAgfSxpc0ZJRk86KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2O1xuICAgICAgfSxpc1NvY2tldDoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA0OTE1MikgPT09IDQ5MTUyO1xuICAgICAgfSxmbGFnTW9kZXM6e1wiclwiOjAsXCJyK1wiOjIsXCJ3XCI6NTc3LFwidytcIjo1NzgsXCJhXCI6MTA4OSxcImErXCI6MTA5MH0sbW9kZVN0cmluZ1RvRmxhZ3M6KHN0cikgPT4ge1xuICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfSxmbGFnc1RvUGVybWlzc2lvblN0cmluZzooZmxhZykgPT4ge1xuICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTtcbiAgICAgICAgaWYgKChmbGFnICYgNTEyKSkge1xuICAgICAgICAgIHBlcm1zICs9ICd3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVybXM7XG4gICAgICB9LG5vZGVQZXJtaXNzaW9uczoobm9kZSwgcGVybXMpID0+IHtcbiAgICAgICAgaWYgKEZTLmlnbm9yZVBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIDAgaWYgYW55IHVzZXIsIGdyb3VwIG9yIG93bmVyIGJpdHMgYXJlIHNldC5cbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LG1heUxvb2t1cDooZGlyKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5Q3JlYXRlOihkaXIsIG5hbWUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICB9LG1heURlbGV0ZTooZGlyLCBuYW1lLCBpc2RpcikgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNkaXIpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA1NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSB8fCBGUy5nZXRQYXRoKG5vZGUpID09PSBGUy5jd2QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5T3Blbjoobm9kZSwgZmxhZ3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIDQ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IC8vIG9wZW5pbmcgZm9yIHdyaXRlXG4gICAgICAgICAgICAgIChmbGFncyAmIDUxMikpIHsgLy8gVE9ETzogY2hlY2sgZm9yIE9fU0VBUkNIPyAoPT0gc2VhcmNoIGZvciBkaXIgb25seSlcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6KGZkX3N0YXJ0ID0gMCwgZmRfZW5kID0gRlMuTUFYX09QRU5fRkRTKSA9PiB7XG4gICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykge1xuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpO1xuICAgICAgfSxnZXRTdHJlYW06KGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxjcmVhdGVTdHJlYW06KHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICAgICAgRlMuRlNTdHJlYW0gPSAvKiogQGNvbnN0cnVjdG9yICovIGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgICBGUy5GU1N0cmVhbS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZTsgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5ub2RlID0gdmFsOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWFkOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNXcml0ZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMDsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXBwZW5kOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEwMjQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbG9uZSBpdCwgc28gd2UgY2FuIHJldHVybiBhbiBpbnN0YW5jZSBvZiBGU1N0cmVhbVxuICAgICAgICBzdHJlYW0gPSBPYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSgpLCBzdHJlYW0pO1xuICAgICAgICB2YXIgZmQgPSBGUy5uZXh0ZmQoZmRfc3RhcnQsIGZkX2VuZCk7XG4gICAgICAgIHN0cmVhbS5mZCA9IGZkO1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sY2xvc2VTdHJlYW06KGZkKSA9PiB7XG4gICAgICAgIEZTLnN0cmVhbXNbZmRdID0gbnVsbDtcbiAgICAgIH0sY2hyZGV2X3N0cmVhbV9vcHM6e29wZW46KHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG4gICAgICAgICAgLy8gb3ZlcnJpZGUgbm9kZSdzIHN0cmVhbSBvcHMgd2l0aCB0aGUgZGV2aWNlJ3NcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuICAgICAgICAgIC8vIGZvcndhcmQgdGhlIG9wZW4gY2FsbFxuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGxsc2VlazooKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9fSxtYWpvcjooZGV2KSA9PiAoKGRldikgPj4gOCksbWlub3I6KGRldikgPT4gKChkZXYpICYgMHhmZiksbWFrZWRldjoobWEsIG1pKSA9PiAoKG1hKSA8PCA4IHwgKG1pKSkscmVnaXN0ZXJEZXZpY2U6KGRldiwgb3BzKSA9PiB7XG4gICAgICAgIEZTLmRldmljZXNbZGV2XSA9IHsgc3RyZWFtX29wczogb3BzIH07XG4gICAgICB9LGdldERldmljZTooZGV2KSA9PiBGUy5kZXZpY2VzW2Rldl0sZ2V0TW91bnRzOihtb3VudCkgPT4ge1xuICAgICAgICB2YXIgbW91bnRzID0gW107XG4gICAgICAgIHZhciBjaGVjayA9IFttb3VudF07XG4gIFxuICAgICAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG0gPSBjaGVjay5wb3AoKTtcbiAgXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG4gIFxuICAgICAgICAgIGNoZWNrLnB1c2guYXBwbHkoY2hlY2ssIG0ubW91bnRzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG1vdW50cztcbiAgICAgIH0sc3luY2ZzOihwb3B1bGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3B1bGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBwb3B1bGF0ZTtcbiAgICAgICAgICBwb3B1bGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gIFxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuICBcbiAgICAgICAgaWYgKEZTLnN5bmNGU1JlcXVlc3RzID4gMSkge1xuICAgICAgICAgIGVycignd2FybmluZzogJyArIEZTLnN5bmNGU1JlcXVlc3RzICsgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICBcbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgYXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzID4gMCk7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyQ29kZSkge1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWRvbmUuZXJyb3JlZCkge1xuICAgICAgICAgICAgICBkb25lLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsrY29tcGxldGVkID49IG1vdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICBcbiAgICAgICAgLy8gc3luYyBhbGwgbW91bnRzXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sbW91bnQ6KHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpbGVzeXN0ZW0gd2FzIG5vdCBpbmNsdWRlZCwgYW5kIGluc3RlYWQgd2UgaGF2ZSBhbiBlcnJvclxuICAgICAgICAgIC8vIG1lc3NhZ2Ugc3RvcmVkIGluIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICB0aHJvdyB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbW91bnRwb2ludCA9PT0gJy8nO1xuICAgICAgICB2YXIgcHNldWRvID0gIW1vdW50cG9pbnQ7XG4gICAgICAgIHZhciBub2RlO1xuICBcbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm9vdCAmJiAhcHNldWRvKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgICBtb3VudHBvaW50ID0gbG9va3VwLnBhdGg7ICAvLyB1c2UgdGhlIGFic29sdXRlIHBhdGhcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1vdW50ID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICBtb3VudHBvaW50OiBtb3VudHBvaW50LFxuICAgICAgICAgIG1vdW50czogW11cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvb3Qgbm9kZSBmb3IgdGhlIGZzXG4gICAgICAgIHZhciBtb3VudFJvb3QgPSB0eXBlLm1vdW50KG1vdW50KTtcbiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XG4gICAgICAgIG1vdW50LnJvb3QgPSBtb3VudFJvb3Q7XG4gIFxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIEZTLnJvb3QgPSBtb3VudFJvb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgICAgIC8vIHNldCBhcyBhIG1vdW50cG9pbnRcbiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDtcbiAgXG4gICAgICAgICAgLy8gYWRkIHRoZSBuZXcgbW91bnQgdG8gdGhlIGN1cnJlbnQgbW91bnQncyBjaGlsZHJlblxuICAgICAgICAgIGlmIChub2RlLm1vdW50KSB7XG4gICAgICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBtb3VudFJvb3Q7XG4gICAgICB9LHVubW91bnQ6KG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBkZXN0cm95IHRoZSBub2RlcyBmb3IgdGhpcyBtb3VudCwgYW5kIGFsbCBpdHMgY2hpbGQgbW91bnRzXG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnRlZDtcbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhtb3VudCk7XG4gIFxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uYW1lX25leHQ7XG4gIFxuICAgICAgICAgICAgaWYgKG1vdW50cy5pbmNsdWRlcyhjdXJyZW50Lm1vdW50KSkge1xuICAgICAgICAgICAgICBGUy5kZXN0cm95Tm9kZShjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgLy8gbm8gbG9uZ2VyIGEgbW91bnRwb2ludFxuICAgICAgICBub2RlLm1vdW50ZWQgPSBudWxsO1xuICBcbiAgICAgICAgLy8gcmVtb3ZlIHRoaXMgbW91bnQgZnJvbSB0aGUgY2hpbGQgbW91bnRzXG4gICAgICAgIHZhciBpZHggPSBub2RlLm1vdW50Lm1vdW50cy5pbmRleE9mKG1vdW50KTtcbiAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sbG9va3VwOihwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sbWtub2Q6KHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgfSxjcmVhdGU6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0MzggLyogMDY2NiAqLztcbiAgICAgICAgbW9kZSAmPSA0MDk1O1xuICAgICAgICBtb2RlIHw9IDMyNzY4O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNTExIC8qIDA3NzcgKi87XG4gICAgICAgIG1vZGUgJj0gNTExIHwgNTEyO1xuICAgICAgICBtb2RlIHw9IDE2Mzg0O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyVHJlZToocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZTtcbiAgICAgICAgICBkICs9ICcvJyArIGRpcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LG1rZGV2OihwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0MzggLyogMDY2NiAqLztcbiAgICAgICAgfVxuICAgICAgICBtb2RlIHw9IDgxOTI7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxzeW1saW5rOihvbGRwYXRoLCBuZXdwYXRoKSA9PiB7XG4gICAgICAgIGlmICghUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXduYW1lID0gUEFUSC5iYXNlbmFtZShuZXdwYXRoKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMuc3ltbGluayhwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpO1xuICAgICAgfSxyZW5hbWU6KG9sZF9wYXRoLCBuZXdfcGF0aCkgPT4ge1xuICAgICAgICB2YXIgb2xkX2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpO1xuICAgICAgICB2YXIgb2xkX25hbWUgPSBQQVRILmJhc2VuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gUEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7XG4gICAgICAgIC8vIHBhcmVudHMgbXVzdCBleGlzdFxuICAgICAgICB2YXIgbG9va3VwLCBvbGRfZGlyLCBuZXdfZGlyO1xuICBcbiAgICAgICAgLy8gbGV0IHRoZSBlcnJvcnMgZnJvbSBub24gZXhpc3RhbnQgZGlyZWN0b3JpZXMgcGVyY29sYXRlIHVwXG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBvbGRfZGlyID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3X3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICBpZiAoIW9sZF9kaXIgfHwgIW5ld19kaXIpIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgLy8gbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBzYW1lIG1vdW50XG4gICAgICAgIGlmIChvbGRfZGlyLm1vdW50ICE9PSBuZXdfZGlyLm1vdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvdXJjZSBtdXN0IGV4aXN0XG4gICAgICAgIHZhciBvbGRfbm9kZSA9IEZTLmxvb2t1cE5vZGUob2xkX2Rpciwgb2xkX25hbWUpO1xuICAgICAgICAvLyBvbGQgcGF0aCBzaG91bGQgbm90IGJlIGFuIGFuY2VzdG9yIG9mIHRoZSBuZXcgcGF0aFxuICAgICAgICB2YXIgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG9sZF9wYXRoLCBuZXdfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZXcgcGF0aCBzaG91bGQgbm90IGJlIGFuIGFuY2VzdG9yIG9mIHRoZSBvbGQgcGF0aFxuICAgICAgICByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0aGUgbmV3IHBhdGggYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub3QgZmF0YWxcbiAgICAgICAgfVxuICAgICAgICAvLyBlYXJseSBvdXQgaWYgbm90aGluZyBuZWVkcyB0byBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSdsbCBuZWVkIHRvIGRlbGV0ZSB0aGUgb2xkIGVudHJ5XG4gICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgZGVsZXRlIHBlcm1pc3Npb25zIGlmIHdlJ2xsIGJlIG92ZXJ3cml0aW5nLlxuICAgICAgICAvLyBuZWVkIGNyZWF0ZSBwZXJtaXNzaW9ucyBpZiBuZXcgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICBlcnJDb2RlID0gbmV3X25vZGUgP1xuICAgICAgICAgIEZTLm1heURlbGV0ZShuZXdfZGlyLCBuZXdfbmFtZSwgaXNkaXIpIDpcbiAgICAgICAgICBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSkgfHwgKG5ld19ub2RlICYmIEZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBnb2luZyB0byBjaGFuZ2UgdGhlIHBhcmVudCwgY2hlY2sgd3JpdGUgcGVybWlzc2lvbnNcbiAgICAgICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHtcbiAgICAgICAgICBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsICd3Jyk7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgbG9va3VwIGhhc2hcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xuICAgICAgICAvLyBkbyB0aGUgdW5kZXJseWluZyBmcyByZW5hbWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZShvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG5vZGUgYmFjayB0byB0aGUgaGFzaCAoaW4gY2FzZSBub2RlX29wcy5yZW5hbWVcbiAgICAgICAgICAvLyBjaGFuZ2VkIGl0cyBuYW1lKVxuICAgICAgICAgIEZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxybWRpcjoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnJtZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkZGlyOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMucmVhZGRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5yZWFkZGlyKG5vZGUpO1xuICAgICAgfSx1bmxpbms6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIFBPU0lYLCB3ZSBzaG91bGQgbWFwIEVJU0RJUiB0byBFUEVSTSwgYnV0XG4gICAgICAgICAgLy8gd2UgaW5zdGVhZCBkbyB3aGF0IExpbnV4IGRvZXMgKGFuZCB3ZSBtdXN0LCBhcyB3ZSB1c2VcbiAgICAgICAgICAvLyB0aGUgbXVzbCBsaW51eCBsaWJjKS5cbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkbGluazoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLCBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspKTtcbiAgICAgIH0sc3RhdDoocGF0aCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpO1xuICAgICAgfSxsc3RhdDoocGF0aCkgPT4ge1xuICAgICAgICByZXR1cm4gRlMuc3RhdChwYXRoLCB0cnVlKTtcbiAgICAgIH0sY2htb2Q6KHBhdGgsIG1vZGUsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBtb2RlOiAobW9kZSAmIDQwOTUpIHwgKG5vZGUubW9kZSAmIH40MDk1KSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG1vZDoocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBGUy5jaG1vZChwYXRoLCBtb2RlLCB0cnVlKTtcbiAgICAgIH0sZmNobW9kOihmZCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7XG4gICAgICB9LGNob3duOihwYXRoLCB1aWQsIGdpZCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgdWlkIC8gZ2lkIGZvciBub3dcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG93bjoocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpO1xuICAgICAgfSxmY2hvd246KGZkLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG93bihzdHJlYW0ubm9kZSwgdWlkLCBnaWQpO1xuICAgICAgfSx0cnVuY2F0ZToocGF0aCwgbGVuKSA9PiB7XG4gICAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCAndycpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgc2l6ZTogbGVuLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sZnRydW5jYXRlOihmZCwgbGVuKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7XG4gICAgICB9LHV0aW1lOihwYXRoLCBhdGltZSwgbXRpbWUpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSxvcGVuOihwYXRoLCBmbGFncywgbW9kZSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IHR5cGVvZiBmbGFncyA9PSAnc3RyaW5nJyA/IEZTLm1vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzO1xuICAgICAgICBtb2RlID0gdHlwZW9mIG1vZGUgPT0gJ3VuZGVmaW5lZCcgPyA0MzggLyogMDY2NiAqLyA6IG1vZGU7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NCkpIHtcbiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHtcbiAgICAgICAgICAgICAgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmhhcHMgd2UgbmVlZCB0byBjcmVhdGUgdGhlIG5vZGVcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAvLyBpZiBPX0NSRUFUIGFuZCBPX0VYQ0wgYXJlIHNldCwgZXJyb3Igb3V0IGlmIHRoZSBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMTI4KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vZGUgZG9lc24ndCBleGlzdCwgdHJ5IHRvIGNyZWF0ZSBpdFxuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW4ndCB0cnVuY2F0ZSBhIGRldmljZVxuICAgICAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGZsYWdzICY9IH41MTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYXNrZWQgb25seSBmb3IgYSBkaXJlY3RvcnksIHRoZW4gdGhpcyBtdXN0IGJlIG9uZVxuICAgICAgICBpZiAoKGZsYWdzICYgNjU1MzYpICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHBlcm1pc3Npb25zLCBpZiB0aGlzIGlzIG5vdCBhIGZpbGUgd2UganVzdCBjcmVhdGVkIG5vdyAoaXQgaXMgb2sgdG9cbiAgICAgICAgLy8gY3JlYXRlIGFuZCB3cml0ZSB0byBhIGZpbGUgd2l0aCByZWFkLW9ubHkgcGVybWlzc2lvbnM7IGl0IGlzIHJlYWQtb25seVxuICAgICAgICAvLyBmb3IgbGF0ZXIgdXNlKVxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gdHJ1bmNhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKChmbGFncyAmIDUxMikpIHtcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlc2UsIGRvbid0IHBhc3MgZG93biB0byB0aGUgdW5kZXJseWluZyB2ZnNcbiAgICAgICAgZmxhZ3MgJj0gfigxMjggfCA1MTIgfCAxMzEwNzIpO1xuICBcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0cmVhbSB3aXRoIHRoZSBmaWxlc3lzdGVtXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgcGF0aDogRlMuZ2V0UGF0aChub2RlKSwgIC8vIHdlIHdhbnQgdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIG5vZGVcbiAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgc2Vla2FibGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3RyZWFtX29wczogbm9kZS5zdHJlYW1fb3BzLFxuICAgICAgICAgIC8vIHVzZWQgYnkgdGhlIGZpbGUgZmFtaWx5IGxpYmMgY2FsbHMgKGZvcGVuLCBmd3JpdGUsIGZlcnJvciwgZXRjLilcbiAgICAgICAgICB1bmdvdHRlbjogW10sXG4gICAgICAgICAgZXJyb3I6IGZhbHNlXG4gICAgICAgIH0sIGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgICAgICAvLyBjYWxsIHRoZSBuZXcgc3RyZWFtJ3Mgb3BlbiBmdW5jdGlvblxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHtcbiAgICAgICAgICBpZiAoIUZTLnJlYWRGaWxlcykgRlMucmVhZEZpbGVzID0ge307XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxjbG9zZTooc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgLy8gZnJlZSByZWFkZGlyIHN0YXRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBudWxsO1xuICAgICAgfSxpc0Nsb3NlZDooc3RyZWFtKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZmQgPT09IG51bGw7XG4gICAgICB9LGxsc2Vlazooc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgPT4ge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZW5jZSAhPSAwICYmIHdoZW5jZSAhPSAxICYmIHdoZW5jZSAhPSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3NpdGlvbiA9IHN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107XG4gICAgICAgIHJldHVybiBzdHJlYW0ucG9zaXRpb247XG4gICAgICB9LHJlYWQ6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IHN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgIH0sd3JpdGU6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgLy8gc2VlayB0byB0aGUgZW5kIGJlZm9yZSB3cml0aW5nIGluIGFwcGVuZCBtb2RlXG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sYWxsb2NhdGU6KHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxtbWFwOihzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgIC8vIFVzZXIgcmVxdWVzdHMgd3JpdGluZyB0byBmaWxlIChwcm90ICYgUFJPVF9XUklURSAhPSAwKS5cbiAgICAgICAgLy8gQ2hlY2tpbmcgaWYgd2UgaGF2ZSBwZXJtaXNzaW9ucyB0byB3cml0ZSB0byB0aGUgZmlsZSB1bmxlc3NcbiAgICAgICAgLy8gTUFQX1BSSVZBVEUgZmxhZyBpcyBzZXQuIEFjY29yZGluZyB0byBQT1NJWCBzcGVjIGl0IGlzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRvIHdyaXRlIHRvIGZpbGUgb3BlbmVkIGluIHJlYWQtb25seSBtb2RlIHdpdGggTUFQX1BSSVZBVEUgZmxhZyxcbiAgICAgICAgLy8gYXMgYWxsIG1vZGlmaWNhdGlvbnMgd2lsbCBiZSB2aXNpYmxlIG9ubHkgaW4gdGhlIG1lbW9yeSBvZlxuICAgICAgICAvLyB0aGUgY3VycmVudCBwcm9jZXNzLlxuICAgICAgICBpZiAoKHByb3QgJiAyKSAhPT0gMFxuICAgICAgICAgICAgJiYgKGZsYWdzICYgMikgPT09IDBcbiAgICAgICAgICAgICYmIChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLm1tYXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1tYXAoc3RyZWFtLCBhZGRyZXNzLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncyk7XG4gICAgICB9LG1zeW5jOihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCAhc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpO1xuICAgICAgfSxtdW5tYXA6KHN0cmVhbSkgPT4gMCxpb2N0bDooc3RyZWFtLCBjbWQsIGFyZykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKTtcbiAgICAgIH0scmVhZEZpbGU6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAwO1xuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJyArIG9wdHMuZW5jb2RpbmcgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzKTtcbiAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTtcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgIHJldCA9IFVURjhBcnJheVRvU3RyaW5nKGJ1ZiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICByZXQgPSBidWY7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sd3JpdGVGaWxlOihwYXRoLCBkYXRhLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgNTc3O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzLCBvcHRzLm1vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpKzEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxjd2Q6KCkgPT4gRlMuY3VycmVudFBhdGgsY2hkaXI6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICB9LGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczooKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sY3JlYXRlRGVmYXVsdERldmljZXM6KCkgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgL2RldlxuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuICAgICAgICAvLyBzZXR1cCAvZGV2L251bGxcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLCAzKSwge1xuICAgICAgICAgIHJlYWQ6ICgpID0+IDAsXG4gICAgICAgICAgd3JpdGU6IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgPT4gbGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvbnVsbCcsIEZTLm1ha2VkZXYoMSwgMykpO1xuICAgICAgICAvLyBzZXR1cCAvZGV2L3R0eSBhbmQgL2Rldi90dHkxXG4gICAgICAgIC8vIHN0ZGVyciBuZWVkcyB0byBwcmludCBvdXRwdXQgdXNpbmcgZXJyKCkgcmF0aGVyIHRoYW4gb3V0KClcbiAgICAgICAgLy8gc28gd2UgcmVnaXN0ZXIgYSBzZWNvbmQgdHR5IGp1c3QgZm9yIGl0LlxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG4gICAgICAgIC8vIHNldHVwIC9kZXYvW3VdcmFuZG9tXG4gICAgICAgIHZhciByYW5kb21fZGV2aWNlID0gZ2V0UmFuZG9tRGV2aWNlKCk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3VyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgLy8gd2UncmUgbm90IGdvaW5nIHRvIGVtdWxhdGUgdGhlIGFjdHVhbCBzaG0gZGV2aWNlLFxuICAgICAgICAvLyBqdXN0IGNyZWF0ZSB0aGUgdG1wIGRpcnMgdGhhdCByZXNpZGUgaW4gaXQgY29tbW9ubHlcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobS90bXAnKTtcbiAgICAgIH0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOigpID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIC9wcm9jL3NlbGYvZmQgd2hpY2ggYWxsb3dzIC9wcm9jL3NlbGYvZmQvNiA9PiByZWFkbGluayBnaXZlcyB0aGVcbiAgICAgICAgLy8gbmFtZSBvZiB0aGUgc3RyZWFtIGZvciBmZCA2IChzZWUgdGVzdF91bmlzdGRfdHR5bmFtZSlcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jJyk7XG4gICAgICAgIHZhciBwcm9jX3NlbGYgPSBGUy5ta2RpcignL3Byb2Mvc2VsZicpO1xuICAgICAgICBGUy5ta2RpcignL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgICBGUy5tb3VudCh7XG4gICAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsICdmZCcsIDE2Mzg0IHwgNTExIC8qIDA3NzcgKi8sIDczKTtcbiAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICAgIGxvb2t1cDogKHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgbW91bnQ6IHsgbW91bnRwb2ludDogJ2Zha2UnIH0sXG4gICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7IC8vIG1ha2UgaXQgbG9vayBsaWtlIGEgc2ltcGxlIHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHt9LCAnL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgfSxjcmVhdGVTdGFuZGFyZFN0cmVhbXM6KCkgPT4ge1xuICAgICAgICAvLyBUT0RPIGRlcHJlY2F0ZSB0aGUgb2xkIGZ1bmN0aW9uYWxpdHkgb2YgYSBzaW5nbGVcbiAgICAgICAgLy8gaW5wdXQgLyBvdXRwdXQgY2FsbGJhY2sgYW5kIHRoYXQgdXRpbGl6ZXMgRlMuY3JlYXRlRGV2aWNlXG4gICAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlcXVpcmUgYSB1bmlxdWUgc2V0IG9mIHN0cmVhbSBvcHNcbiAgXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIHdlIHN5bWxpbmsgdGhlIHN0YW5kYXJkIHN0cmVhbXMgdG8gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgdHR5IGRldmljZXMuIGhvd2V2ZXIsIGlmIHRoZSBzdGFuZGFyZCBzdHJlYW1zXG4gICAgICAgIC8vIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiB3ZSBjcmVhdGUgYSB1bmlxdWUgZGV2aWNlIGZvclxuICAgICAgICAvLyB0aGVtIGluc3RlYWQuXG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGluJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBNb2R1bGVbJ3N0ZG91dCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBvcGVuIGRlZmF1bHQgc3RyZWFtcyBmb3IgdGhlIHN0ZGluLCBzdGRvdXQgYW5kIHN0ZGVyciBkZXZpY2VzXG4gICAgICAgIHZhciBzdGRpbiA9IEZTLm9wZW4oJy9kZXYvc3RkaW4nLCAwKTtcbiAgICAgICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgMSk7XG4gICAgICAgIHZhciBzdGRlcnIgPSBGUy5vcGVuKCcvZGV2L3N0ZGVycicsIDEpO1xuICAgICAgICBhc3NlcnQoc3RkaW4uZmQgPT09IDAsICdpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW4gKCcgKyBzdGRpbi5mZCArICcpJyk7XG4gICAgICAgIGFzc2VydChzdGRvdXQuZmQgPT09IDEsICdpbnZhbGlkIGhhbmRsZSBmb3Igc3Rkb3V0ICgnICsgc3Rkb3V0LmZkICsgJyknKTtcbiAgICAgICAgYXNzZXJ0KHN0ZGVyci5mZCA9PT0gMiwgJ2ludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCcgKyBzdGRlcnIuZmQgKyAnKScpO1xuICAgICAgfSxlbnN1cmVFcnJub0Vycm9yOigpID0+IHtcbiAgICAgICAgaWYgKEZTLkVycm5vRXJyb3IpIHJldHVybjtcbiAgICAgICAgRlMuRXJybm9FcnJvciA9IC8qKiBAdGhpc3tPYmplY3R9ICovIGZ1bmN0aW9uIEVycm5vRXJyb3IoZXJybm8sIG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAgIHRoaXMuc2V0RXJybm8gPSAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbihlcnJubykge1xuICAgICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIEVSUk5PX0NPREVTKSB7XG4gICAgICAgICAgICAgIGlmIChFUlJOT19DT0RFU1trZXldID09PSBlcnJubykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZSA9IGtleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gRVJSTk9fTUVTU0FHRVNbZXJybm9dO1xuICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGEgbWF4aW1hbGx5IGhlbHBmdWwgc3RhY2sgdHJhY2UuIE9uIE5vZGUuanMsIGdldHRpbmcgRXJyb3Iuc3RhY2tcbiAgICAgICAgICAvLyBub3cgZW5zdXJlcyBpdCBzaG93cyB3aGF0IHdlIHdhbnQuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgc3RhY2sgcHJvcGVydHkgZm9yIE5vZGUuanMgNCwgd2hpY2ggb3RoZXJ3aXNlIGVycm9ycyBvbiB0aGUgbmV4dCBsaW5lLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogKG5ldyBFcnJvcikuc3RhY2ssIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGRlbWFuZ2xlQWxsKHRoaXMuc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGUy5FcnJub0Vycm9yO1xuICAgICAgICAvLyBTb21lIGVycm9ycyBtYXkgaGFwcGVuIHF1aXRlIGEgYml0LCB0byBhdm9pZCBvdmVyaGVhZCB3ZSByZXVzZSB0aGVtIChhbmQgc3VmZmVyIGEgbGFjayBvZiBzdGFjayBpbmZvKVxuICAgICAgICBbNDRdLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdID0gbmV3IEZTLkVycm5vRXJyb3IoY29kZSk7XG4gICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjayA9ICc8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+JztcbiAgICAgICAgfSk7XG4gICAgICB9LHN0YXRpY0luaXQ6KCkgPT4ge1xuICAgICAgICBGUy5lbnN1cmVFcnJub0Vycm9yKCk7XG4gIFxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG4gIFxuICAgICAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7XG4gIFxuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7XG4gIFxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICAnTUVNRlMnOiBNRU1GUyxcbiAgICAgICAgfTtcbiAgICAgIH0saW5pdDooaW5wdXQsIG91dHB1dCwgZXJyb3IpID0+IHtcbiAgICAgICAgYXNzZXJ0KCFGUy5pbml0LmluaXRpYWxpemVkLCAnRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKScpO1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgXG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcbiAgXG4gICAgICAgIC8vIEFsbG93IE1vZHVsZS5zdGRpbiBldGMuIHRvIHByb3ZpZGUgZGVmYXVsdHMsIGlmIG5vbmUgZXhwbGljaXRseSBwYXNzZWQgdG8gdXMgaGVyZVxuICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTtcbiAgICAgICAgTW9kdWxlWydzdGRlcnInXSA9IGVycm9yIHx8IE1vZHVsZVsnc3RkZXJyJ107XG4gIFxuICAgICAgICBGUy5jcmVhdGVTdGFuZGFyZFN0cmVhbXMoKTtcbiAgICAgIH0scXVpdDooKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FsbCBtdXNsLWludGVybmFsIGZ1bmN0aW9uIHRvIGNsb3NlIGFsbCBzdGRpbyBzdHJlYW1zLCBzbyBub3RoaW5nIGlzXG4gICAgICAgIC8vIGxlZnQgaW4gaW50ZXJuYWwgYnVmZmVycy5cbiAgICAgICAgX19fc3RkaW9fZXhpdCgpO1xuICAgICAgICAvLyBjbG9zZSBhbGwgb2Ygb3VyIHN0cmVhbXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LGdldE1vZGU6KGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBtb2RlID0gMDtcbiAgICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxmaW5kT2JqZWN0OihwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKHJldC5leGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmV0Lm9iamVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxhbmFseXplUGF0aDoocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykgPT4ge1xuICAgICAgICAvLyBvcGVyYXRlIGZyb20gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBzeW1saW5rJ3MgdGFyZ2V0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgaXNSb290OiBmYWxzZSwgZXhpc3RzOiBmYWxzZSwgZXJyb3I6IDAsIG5hbWU6IG51bGwsIHBhdGg6IG51bGwsIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLCBwYXJlbnRQYXRoOiBudWxsLCBwYXJlbnRPYmplY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICByZXQucGFyZW50RXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGFyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgcmV0LnBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgICByZXQub2JqZWN0ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xuICAgICAgICAgIHJldC5pc1Jvb3QgPSBsb29rdXAucGF0aCA9PT0gJy8nO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0LmVycm9yID0gZS5lcnJubztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sY3JlYXRlUGF0aDoocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gUEFUSC5qb2luMihwYXJlbnQsIHBhcnQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgRUVYSVNUXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9LGNyZWF0ZUZpbGU6KHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICByZXR1cm4gRlMuY3JlYXRlKHBhdGgsIG1vZGUpO1xuICAgICAgfSxjcmVhdGVEYXRhRmlsZToocGFyZW50LCBuYW1lLCBkYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgICAgcGF0aCA9IG5hbWUgPyBQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkgOiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBkYXRhID0gYXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2FuIHdyaXRlIHRvIHRoZSBmaWxlXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZURldmljZToocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTtcbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKCEhaW5wdXQsICEhb3V0cHV0KTtcbiAgICAgICAgaWYgKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpIEZTLmNyZWF0ZURldmljZS5tYWpvciA9IDY0O1xuICAgICAgICB2YXIgZGV2ID0gRlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywgMCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGZha2UgZGV2aWNlIHRoYXQgYSBzZXQgb2Ygc3RyZWFtIG9wcyB0byBlbXVsYXRlXG4gICAgICAgIC8vIHRoZSBvbGQgYmVoYXZpb3IuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwge1xuICAgICAgICAgIG9wZW46IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGFueSBwZW5kaW5nIGxpbmUgZGF0YVxuICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBvdXRwdXQuYnVmZmVyICYmIG91dHB1dC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG91dHB1dCgxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWFkOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MgLyogaWdub3JlZCAqLykgPT4ge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBGUy5ta2RldihwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxmb3JjZUxvYWRGaWxlOihvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5pc0RldmljZSB8fCBvYmouaXNGb2xkZXIgfHwgb2JqLmxpbmsgfHwgb2JqLmNvbnRlbnRzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkXykge1xuICAgICAgICAgIC8vIENvbW1hbmQtbGluZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV0FSTklORzogQ2FuJ3QgcmVhZCBiaW5hcnkgZmlsZXMgaW4gVjgncyBkOCBvciB0cmFjZW1vbmtleSdzIGpzLCBhc1xuICAgICAgICAgICAgLy8gICAgICAgICAgcmVhZCgpIHdpbGwgdHJ5IHRvIHBhcnNlIFVURjguXG4gICAgICAgICAgICBvYmouY29udGVudHMgPSBpbnRBcnJheUZyb21TdHJpbmcocmVhZF8ob2JqLnVybCksIHRydWUpO1xuICAgICAgICAgICAgb2JqLnVzZWRCeXRlcyA9IG9iai5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICB9LGNyZWF0ZUxhenlGaWxlOihwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgLy8gTGF6eSBjaHVua2VkIFVpbnQ4QXJyYXkgKGltcGxlbWVudHMgZ2V0IGFuZCBsZW5ndGggZnJvbSBVaW50OEFycmF5KS4gQWN0dWFsIGdldHRpbmcgaXMgYWJzdHJhY3RlZCBhd2F5IGZvciBldmVudHVhbCByZXVzZS5cbiAgICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgICAgICBmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsgLy8gTG9hZGVkIGNodW5rcy4gSW5kZXggaXMgdGhlIGNodW5rIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoLTEgfHwgaWR4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaWR4ICUgdGhpcy5jaHVua1NpemU7XG4gICAgICAgICAgdmFyIGNodW5rTnVtID0gKGlkeCAvIHRoaXMuY2h1bmtTaXplKXwwO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuc2V0RGF0YUdldHRlciA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgdGhpcy5nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aCA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgIC8vIEZpbmQgbGVuZ3RoXG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgaWYgKCEoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiICsgdXJsICsgXCIuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICB2YXIgZGF0YWxlbmd0aCA9IE51bWJlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LWxlbmd0aFwiKSk7XG4gICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkgJiYgaGVhZGVyID09PSBcImJ5dGVzXCI7XG4gICAgICAgICAgdmFyIHVzZXNHemlwID0gKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikpICYmIGhlYWRlciA9PT0gXCJnemlwXCI7XG4gIFxuICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0KjEwMjQ7IC8vIENodW5rIHNpemUgaW4gYnl0ZXNcbiAgXG4gICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcbiAgXG4gICAgICAgICAgLy8gRnVuY3Rpb24gdG8gZ2V0IGEgcmFuZ2UgZnJvbSB0aGUgcmVtb3RlIFVSTC5cbiAgICAgICAgICB2YXIgZG9YSFIgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gdG8pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiICsgZnJvbSArIFwiLCBcIiArIHRvICsgXCIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCFcIik7XG4gICAgICAgICAgICBpZiAodG8gPiBkYXRhbGVuZ3RoLTEpIHRocm93IG5ldyBFcnJvcihcIm9ubHkgXCIgKyBkYXRhbGVuZ3RoICsgXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiKTtcbiAgXG4gICAgICAgICAgICAvLyBUT0RPOiBVc2UgbW96UmVzcG9uc2VBcnJheUJ1ZmZlciwgcmVzcG9uc2VTdHJlYW0sIGV0Yy4gaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGRhdGFsZW5ndGggIT09IGNodW5rU2l6ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiICsgZnJvbSArIFwiLVwiICsgdG8pO1xuICBcbiAgICAgICAgICAgIC8vIFNvbWUgaGludHMgdG8gdGhlIGJyb3dzZXIgdGhhdCB3ZSB3YW50IGJpbmFyeSBkYXRhLlxuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgIGlmICghKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXtBcnJheTxudW1iZXI+fSAqLyh4aHIucmVzcG9uc2UgfHwgW10pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpcztcbiAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNodW5rTnVtICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSsxKSAqIGNodW5rU2l6ZSAtIDE7IC8vIGluY2x1ZGluZyB0aGlzIGJ5dGVcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aC0xKTsgLy8gaWYgZGF0YWxlbmd0aC0xIGlzIHNlbGVjdGVkLCB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID0gZG9YSFIoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RvWEhSIGZhaWxlZCEnKTtcbiAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcbiAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2VydmVyIHVzZXMgZ3ppcCBvciBkb2Vzbid0IHN1cHBseSB0aGUgbGVuZ3RoLCB3ZSBoYXZlIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBmaWxlIHRvIGdldCB0aGUgKHVuY29tcHJlc3NlZCkgbGVuZ3RoXG4gICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoID0gMTsgLy8gdGhpcyB3aWxsIGZvcmNlIGdldHRlcigwKS9kb1hIUiBkbyBkb3dubG9hZCB0aGUgd2hvbGUgZmlsZVxuICAgICAgICAgICAgZGF0YWxlbmd0aCA9IHRoaXMuZ2V0dGVyKDApLmxlbmd0aDtcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICBvdXQoXCJMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWRcIik7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgIGdldDogLyoqIEB0aGlze09iamVjdH0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaHVua1NpemU6IHtcbiAgICAgICAgICAgICAgZ2V0OiAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgdG90YWwgaGFjaywgYnV0IEkgd2FudCB0byBnZXQgdGhpcyBsYXp5IGZpbGUgY29kZSBvdXQgb2YgdGhlXG4gICAgICAgIC8vIGNvcmUgb2YgTUVNRlMuIElmIHdlIHdhbnQgdG8ga2VlcCB0aGlzIGxhenkgZmlsZSBjb25jZXB0IEkgZmVlbCBpdCBzaG91bGRcbiAgICAgICAgLy8gYmUgaXRzIG93biB0aGluIExBWllGUyBwcm94eWluZyBjYWxscyB0byBNRU1GUy5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY29udGVudHMpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gcHJvcGVydGllcy5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnVybCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgIG5vZGUudXJsID0gcHJvcGVydGllcy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgZnVuY3Rpb24gdGhhdCBkZWZlcnMgcXVlcnlpbmcgdGhlIGZpbGUgc2l6ZSB1bnRpbCBpdCBpcyBhc2tlZCB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwge1xuICAgICAgICAgIHVzZWRCeXRlczoge1xuICAgICAgICAgICAgZ2V0OiAvKiogQHRoaXMge0ZTTm9kZX0gKi8gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG92ZXJyaWRlIGVhY2ggc3RyZWFtIG9wIHdpdGggb25lIHRoYXQgdHJpZXMgdG8gZm9yY2UgbG9hZCB0aGUgbGF6eSBmaWxlIGZpcnN0XG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSBmdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpIHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXNlIGEgY3VzdG9tIHJlYWQgZnVuY3Rpb25cbiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKGNvbnRlbnRzLmxlbmd0aCAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgIGFzc2VydChzaXplID49IDApO1xuICAgICAgICAgIGlmIChjb250ZW50cy5zbGljZSkgeyAvLyBub3JtYWwgYXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7IC8vIExhenlVaW50OEFycmF5IGZyb20gc3luYyBiaW5hcnkgWEhSXG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzLmdldChwb3NpdGlvbiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gc3RyZWFtX29wcztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZVByZWxvYWRlZEZpbGU6KHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSwgb25sb2FkLCBvbmVycm9yLCBkb250Q3JlYXRlRmlsZSwgY2FuT3duLCBwcmVGaW5pc2gpID0+IHtcbiAgICAgICAgLy8gVE9ETyB3ZSBzaG91bGQgYWxsb3cgcGVvcGxlIHRvIGp1c3QgcGFzcyBpbiBhIGNvbXBsZXRlIGZpbGVuYW1lIGluc3RlYWRcbiAgICAgICAgLy8gb2YgcGFyZW50IGFuZCBuYW1lIGJlaW5nIHRoYXQgd2UganVzdCBqb2luIHRoZW0gYW55d2F5c1xuICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSF9GUy5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7XG4gICAgICAgIHZhciBkZXAgPSBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdjcCAnICsgZnVsbG5hbWUpOyAvLyBtaWdodCBoYXZlIHNldmVyYWwgYWN0aXZlIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBmdWxsbmFtZVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAocHJlRmluaXNoKSBwcmVGaW5pc2goKTtcbiAgICAgICAgICAgIGlmICghZG9udENyZWF0ZUZpbGUpIHtcbiAgICAgICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBieXRlQXJyYXksIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ubG9hZCkgb25sb2FkKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChCcm93c2VyLmhhbmRsZWRCeVByZWxvYWRQbHVnaW4oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcigpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhc3luY0xvYWQodXJsLCAoYnl0ZUFycmF5KSA9PiBwcm9jZXNzRGF0YShieXRlQXJyYXkpLCBvbmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9LGluZGV4ZWREQjooKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93LndlYmtpdEluZGV4ZWREQiB8fCB3aW5kb3cubXNJbmRleGVkREI7XG4gICAgICB9LERCX05BTUU6KCkgPT4ge1xuICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB9LERCX1ZFUlNJT046MjAsREJfU1RPUkVfTkFNRTpcIkZJTEVfREFUQVwiLHNhdmVGaWxlc1RvREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgICAgIG91dCgnY3JlYXRpbmcgZGInKTtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgdmFyIG9rID0gMCwgZmFpbCA9IDAsIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOyBlbHNlIG9uZXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBmaWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLCBwYXRoKTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4geyBvaysrOyBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKSB9O1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4geyBmYWlsKys7IGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfSxsb2FkRmlsZXNGcm9tREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjsgLy8gbm8gZGF0YWJhc2UgdG8gbG9hZCBmcm9tXG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLCBmYWlsID0gMCwgdG90YWwgPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7IGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFBBVEguZGlybmFtZShwYXRoKSwgUEFUSC5iYXNlbmFtZShwYXRoKSwgZ2V0UmVxdWVzdC5yZXN1bHQsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBvaysrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7IGZhaWwrKzsgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCkgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICB9LGFic29sdXRlUGF0aDooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5hYnNvbHV0ZVBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEhfRlMucmVzb2x2ZSBpbnN0ZWFkJyk7XG4gICAgICB9LGNyZWF0ZUZvbGRlcjooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVGb2xkZXIgaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIEZTLm1rZGlyIGluc3RlYWQnKTtcbiAgICAgIH0sY3JlYXRlTGluazooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVMaW5rIGhhcyBiZWVuIHJlbW92ZWQ7IHVzZSBGUy5zeW1saW5rIGluc3RlYWQnKTtcbiAgICAgIH0sam9pblBhdGg6KCkgPT4ge1xuICAgICAgICBhYm9ydCgnRlMuam9pblBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEguam9pbiBpbnN0ZWFkJyk7XG4gICAgICB9LG1tYXBBbGxvYzooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5tbWFwQWxsb2MgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiBtbWFwQWxsb2MnKTtcbiAgICAgIH0sc3RhbmRhcmRpemVQYXRoOigpID0+IHtcbiAgICAgICAgYWJvcnQoJ0ZTLnN0YW5kYXJkaXplUGF0aCBoYXMgYmVlbiByZW1vdmVkOyB1c2UgUEFUSC5ub3JtYWxpemUgaW5zdGVhZCcpO1xuICAgICAgfX07XG4gIHZhciBTWVNDQUxMUyA9IHtERUZBVUxUX1BPTExNQVNLOjUsY2FsY3VsYXRlQXQ6ZnVuY3Rpb24oZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpIHtcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbGF0aXZlIHBhdGhcbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IEZTLmdldFN0cmVhbShkaXJmZCk7XG4gICAgICAgICAgaWYgKCFkaXJzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICAgIGRpciA9IGRpcnN0cmVhbS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVRILmpvaW4yKGRpciwgcGF0aCk7XG4gICAgICB9LGRvU3RhdDpmdW5jdGlvbihmdW5jLCBwYXRoLCBidWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RhdCA9IGZ1bmMocGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLm5vZGUgJiYgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSkpIHtcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb29rIHVwIHRoZSBwYXRoOyB3ZSBzaG91bGQganVzdCByZXBvcnQgRU5PVERJUlxuICAgICAgICAgICAgcmV0dXJuIC01NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKChidWYpPj4yKV0gPSBzdGF0LmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDQpKT4+MildID0gMDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDgpKT4+MildID0gc3RhdC5pbm87XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygxMikpPj4yKV0gPSBzdGF0Lm1vZGU7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygxNikpPj4yKV0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMjApKT4+MildID0gc3RhdC51aWQ7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyNCkpPj4yKV0gPSBzdGF0LmdpZDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDI4KSk+PjIpXSA9IHN0YXQucmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDMyKSk+PjIpXSA9IDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW3N0YXQuc2l6ZT4+PjAsKHRlbXBEb3VibGU9c3RhdC5zaXplLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDQwKSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDQ0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNDgpKT4+MildID0gNDA5NjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDUyKSk+PjIpXSA9IHN0YXQuYmxvY2tzO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNTYpKT4+MildID0gKHN0YXQuYXRpbWUuZ2V0VGltZSgpIC8gMTAwMCl8MDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDYwKSk+PjIpXSA9IDA7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg2NCkpPj4yKV0gPSAoc3RhdC5tdGltZS5nZXRUaW1lKCkgLyAxMDAwKXwwO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNjgpKT4+MildID0gMDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDcyKSk+PjIpXSA9IChzdGF0LmN0aW1lLmdldFRpbWUoKSAvIDEwMDApfDA7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg3NikpPj4yKV0gPSAwO1xuICAgICAgICAodGVtcEk2NCA9IFtzdGF0Lmlubz4+PjAsKHRlbXBEb3VibGU9c3RhdC5pbm8sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoODApKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoODQpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxkb01zeW5jOmZ1bmN0aW9uKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBIRUFQVTguc2xpY2UoYWRkciwgYWRkciArIGxlbik7XG4gICAgICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICAgICAgfSxkb01rZGlyOmZ1bmN0aW9uKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGEgdHJhaWxpbmcgc2xhc2gsIGlmIG9uZSAtIC9hL2IvIGhhcyBiYXNlbmFtZSBvZiAnJywgYnV0XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY3JlYXRlIGIgaW4gdGhlIGNvbnRleHQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoLTFdID09PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aC0xKTtcbiAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxkb01rbm9kOmZ1bmN0aW9uKHBhdGgsIG1vZGUsIGRldikge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoaXMgaW4gdGhlIEpTIEFQSSBhcyBpdCB1c2VzIG1rbm9kIHRvIGNyZWF0ZSBhbGwgbm9kZXMuXG4gICAgICAgIHN3aXRjaCAobW9kZSAmIDYxNDQwKSB7XG4gICAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgICAgY2FzZSAyNDU3NjpcbiAgICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgICAgY2FzZSA0OTE1MjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAtMjg7XG4gICAgICAgIH1cbiAgICAgICAgRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LGRvUmVhZGxpbms6ZnVuY3Rpb24ocGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgICAgIGlmIChidWZzaXplIDw9IDApIHJldHVybiAtMjg7XG4gICAgICAgIHZhciByZXQgPSBGUy5yZWFkbGluayhwYXRoKTtcbiAgXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihidWZzaXplLCBsZW5ndGhCeXRlc1VURjgocmV0KSk7XG4gICAgICAgIHZhciBlbmRDaGFyID0gSEVBUDhbYnVmK2xlbl07XG4gICAgICAgIHN0cmluZ1RvVVRGOChyZXQsIGJ1ZiwgYnVmc2l6ZSsxKTtcbiAgICAgICAgLy8gcmVhZGxpbmsgaXMgb25lIG9mIHRoZSByYXJlIGZ1bmN0aW9ucyB0aGF0IHdyaXRlIG91dCBhIEMgc3RyaW5nLCBidXQgZG9lcyBuZXZlciBhcHBlbmQgYSBudWxsIHRvIHRoZSBvdXRwdXQgYnVmZmVyKCEpXG4gICAgICAgIC8vIHN0cmluZ1RvVVRGOCgpIGFsd2F5cyBhcHBlbmRzIGEgbnVsbCBieXRlLCBzbyByZXN0b3JlIHRoZSBjaGFyYWN0ZXIgdW5kZXIgdGhlIG51bGwgYnl0ZSBhZnRlciB0aGUgd3JpdGUuXG4gICAgICAgIEhFQVA4W2J1ZitsZW5dID0gZW5kQ2hhcjtcbiAgXG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICB9LGRvQWNjZXNzOmZ1bmN0aW9uKHBhdGgsIGFtb2RlKSB7XG4gICAgICAgIGlmIChhbW9kZSAmIH43KSB7XG4gICAgICAgICAgLy8gbmVlZCBhIHZhbGlkIG1vZGVcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgICBpZiAocGVybXMgLyogb3RoZXJ3aXNlLCB0aGV5J3ZlIGp1c3QgcGFzc2VkIEZfT0sgKi8gJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sZG9SZWFkdjpmdW5jdGlvbihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgICB2YXIgcHRyID0gSEVBUDMyWygoKGlvdikrKGkqOCkpPj4yKV07XG4gICAgICAgICAgdmFyIGxlbiA9IEhFQVAzMlsoKChpb3YpKyhpKjggKyA0KSk+PjIpXTtcbiAgICAgICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCxwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7IC8vIG5vdGhpbmcgbW9yZSB0byByZWFkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZG9Xcml0ZXY6ZnVuY3Rpb24oc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHB0ciA9IEhFQVAzMlsoKChpb3YpKyhpKjgpKT4+MildO1xuICAgICAgICAgIHZhciBsZW4gPSBIRUFQMzJbKCgoaW92KSsoaSo4ICsgNCkpPj4yKV07XG4gICAgICAgICAgdmFyIGN1cnIgPSBGUy53cml0ZShzdHJlYW0sIEhFQVA4LHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LHZhcmFyZ3M6dW5kZWZpbmVkLGdldDpmdW5jdGlvbigpIHtcbiAgICAgICAgYXNzZXJ0KFNZU0NBTExTLnZhcmFyZ3MgIT0gdW5kZWZpbmVkKTtcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWygoKFNZU0NBTExTLnZhcmFyZ3MpLSg0KSk+PjIpXTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZ2V0U3RyOmZ1bmN0aW9uKHB0cikge1xuICAgICAgICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LGdldFN0cmVhbUZyb21GRDpmdW5jdGlvbihmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxnZXQ2NDpmdW5jdGlvbihsb3csIGhpZ2gpIHtcbiAgICAgICAgaWYgKGxvdyA+PSAwKSBhc3NlcnQoaGlnaCA9PT0gMCk7XG4gICAgICAgIGVsc2UgYXNzZXJ0KGhpZ2ggPT09IC0xKTtcbiAgICAgICAgcmV0dXJuIGxvdztcbiAgICAgIH19O1xuICBmdW5jdGlvbiBfX19zeXNjYWxsX19uZXdzZWxlY3QobmZkcywgcmVhZGZkcywgd3JpdGVmZHMsIGV4Y2VwdGZkcywgdGltZW91dCkge1xuICB0cnkge1xuICBcbiAgICAgIC8vIHJlYWRmZHMgYXJlIHN1cHBvcnRlZCxcbiAgICAgIC8vIHdyaXRlZmRzIGNoZWNrcyBzb2NrZXQgb3BlbiBzdGF0dXNcbiAgICAgIC8vIGV4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkXG4gICAgICAvLyB0aW1lb3V0IGlzIGFsd2F5cyAwIC0gZnVsbHkgYXN5bmNcbiAgICAgIGFzc2VydChuZmRzIDw9IDY0LCAnbmZkcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2NCcpOyAgLy8gZmQgc2V0cyBoYXZlIDY0IGJpdHMgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSAxMDI0IGJhc2VkIG9uIGN1cnJlbnQgbXVzbCBoZWFkZXJzXG4gICAgICBhc3NlcnQoIWV4Y2VwdGZkcywgJ2V4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkJyk7XG4gIFxuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIFxuICAgICAgdmFyIHNyY1JlYWRMb3cgPSAocmVhZGZkcyA/IEhFQVAzMlsoKHJlYWRmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNSZWFkSGlnaCA9IChyZWFkZmRzID8gSEVBUDMyWygoKHJlYWRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICAgICAgdmFyIHNyY1dyaXRlTG93ID0gKHdyaXRlZmRzID8gSEVBUDMyWygod3JpdGVmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNXcml0ZUhpZ2ggPSAod3JpdGVmZHMgPyBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA6IDApO1xuICAgICAgdmFyIHNyY0V4Y2VwdExvdyA9IChleGNlcHRmZHMgPyBIRUFQMzJbKChleGNlcHRmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNFeGNlcHRIaWdoID0gKGV4Y2VwdGZkcyA/IEhFQVAzMlsoKChleGNlcHRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICBcbiAgICAgIHZhciBkc3RSZWFkTG93ID0gMCxcbiAgICAgICAgICBkc3RSZWFkSGlnaCA9IDA7XG4gICAgICB2YXIgZHN0V3JpdGVMb3cgPSAwLFxuICAgICAgICAgIGRzdFdyaXRlSGlnaCA9IDA7XG4gICAgICB2YXIgZHN0RXhjZXB0TG93ID0gMCxcbiAgICAgICAgICBkc3RFeGNlcHRIaWdoID0gMDtcbiAgXG4gICAgICB2YXIgYWxsTG93ID0gKHJlYWRmZHMgPyBIRUFQMzJbKChyZWFkZmRzKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICh3cml0ZWZkcyA/IEhFQVAzMlsoKHdyaXRlZmRzKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgIChleGNlcHRmZHMgPyBIRUFQMzJbKChleGNlcHRmZHMpPj4yKV0gOiAwKTtcbiAgICAgIHZhciBhbGxIaWdoID0gKHJlYWRmZHMgPyBIRUFQMzJbKCgocmVhZGZkcykrKDQpKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAod3JpdGVmZHMgPyBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgKGV4Y2VwdGZkcyA/IEhFQVAzMlsoKChleGNlcHRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICBcbiAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uKGZkLCBsb3csIGhpZ2gsIHZhbCkge1xuICAgICAgICByZXR1cm4gKGZkIDwgMzIgPyAobG93ICYgdmFsKSA6IChoaWdoICYgdmFsKSk7XG4gICAgICB9O1xuICBcbiAgICAgIGZvciAodmFyIGZkID0gMDsgZmQgPCBuZmRzOyBmZCsrKSB7XG4gICAgICAgIHZhciBtYXNrID0gMSA8PCAoZmQgJSAzMik7XG4gICAgICAgIGlmICghKGNoZWNrKGZkLCBhbGxMb3csIGFsbEhpZ2gsIG1hc2spKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAgLy8gaW5kZXggaXNuJ3QgaW4gdGhlIHNldFxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICBcbiAgICAgICAgdmFyIGZsYWdzID0gU1lTQ0FMTFMuREVGQVVMVF9QT0xMTUFTSztcbiAgXG4gICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5wb2xsKSB7XG4gICAgICAgICAgZmxhZ3MgPSBzdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICgoZmxhZ3MgJiAxKSAmJiBjaGVjayhmZCwgc3JjUmVhZExvdywgc3JjUmVhZEhpZ2gsIG1hc2spKSB7XG4gICAgICAgICAgZmQgPCAzMiA/IChkc3RSZWFkTG93ID0gZHN0UmVhZExvdyB8IG1hc2spIDogKGRzdFJlYWRIaWdoID0gZHN0UmVhZEhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmxhZ3MgJiA0KSAmJiBjaGVjayhmZCwgc3JjV3JpdGVMb3csIHNyY1dyaXRlSGlnaCwgbWFzaykpIHtcbiAgICAgICAgICBmZCA8IDMyID8gKGRzdFdyaXRlTG93ID0gZHN0V3JpdGVMb3cgfCBtYXNrKSA6IChkc3RXcml0ZUhpZ2ggPSBkc3RXcml0ZUhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmxhZ3MgJiAyKSAmJiBjaGVjayhmZCwgc3JjRXhjZXB0TG93LCBzcmNFeGNlcHRIaWdoLCBtYXNrKSkge1xuICAgICAgICAgIGZkIDwgMzIgPyAoZHN0RXhjZXB0TG93ID0gZHN0RXhjZXB0TG93IHwgbWFzaykgOiAoZHN0RXhjZXB0SGlnaCA9IGRzdEV4Y2VwdEhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHJlYWRmZHMpIHtcbiAgICAgICAgSEVBUDMyWygocmVhZGZkcyk+PjIpXSA9IGRzdFJlYWRMb3c7XG4gICAgICAgIEhFQVAzMlsoKChyZWFkZmRzKSsoNCkpPj4yKV0gPSBkc3RSZWFkSGlnaDtcbiAgICAgIH1cbiAgICAgIGlmICh3cml0ZWZkcykge1xuICAgICAgICBIRUFQMzJbKCh3cml0ZWZkcyk+PjIpXSA9IGRzdFdyaXRlTG93O1xuICAgICAgICBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA9IGRzdFdyaXRlSGlnaDtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRmZHMpIHtcbiAgICAgICAgSEVBUDMyWygoZXhjZXB0ZmRzKT4+MildID0gZHN0RXhjZXB0TG93O1xuICAgICAgICBIRUFQMzJbKCgoZXhjZXB0ZmRzKSsoNCkpPj4yKV0gPSBkc3RFeGNlcHRIaWdoO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBTT0NLRlMgPSB7bW91bnQ6ZnVuY3Rpb24obW91bnQpIHtcbiAgICAgICAgLy8gSWYgTW9kdWxlWyd3ZWJzb2NrZXQnXSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgKGUuZy4gZm9yIGNvbmZpZ3VyaW5nXG4gICAgICAgIC8vIHRoZSBzdWJwcm90b2NvbC91cmwpIHVzZSB0aGF0LCBpZiBub3QgaW5pdGlhbGlzZSBpdCB0byBhIG5ldyBvYmplY3QuXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10gPSAoTW9kdWxlWyd3ZWJzb2NrZXQnXSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJ29iamVjdCcgPT09IHR5cGVvZiBNb2R1bGVbJ3dlYnNvY2tldCddKSkgPyBNb2R1bGVbJ3dlYnNvY2tldCddIDoge307XG4gIFxuICAgICAgICAvLyBBZGQgdGhlIEV2ZW50IHJlZ2lzdHJhdGlvbiBtZWNoYW5pc20gdG8gdGhlIGV4cG9ydGVkIHdlYnNvY2tldCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIG9iamVjdCBzbyB3ZSBjYW4gcmVnaXN0ZXIgbmV0d29yayBjYWxsYmFja3MgZnJvbSBuYXRpdmUgSmF2YVNjcmlwdCB0b28uXG4gICAgICAgIC8vIEZvciBtb3JlIGRvY3VtZW50YXRpb24gc2VlIHN5c3RlbS9pbmNsdWRlL2Vtc2NyaXB0ZW4vZW1zY3JpcHRlbi5oXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddWydvbiddID0gLyoqIEB0aGlze09iamVjdH0gKi8gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCA9IC8qKiBAdGhpc3tPYmplY3R9ICovIGZ1bmN0aW9uKGV2ZW50LCBwYXJhbSkge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5jYWxsKHRoaXMsIHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gIFxuICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkIHJlZ2lzdGVyIHNpbXBsZSBkZWZhdWx0IGxvZ2dpbmcgY2FsbGJhY2tzIGZvciBlYWNoIEV2ZW50LlxuICBcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAvKiAwNzc3ICovLCAwKTtcbiAgICAgIH0sY3JlYXRlU29ja2V0OmZ1bmN0aW9uKGZhbWlseSwgdHlwZSwgcHJvdG9jb2wpIHtcbiAgICAgICAgdHlwZSAmPSB+NTI2MzM2OyAvLyBTb21lIGFwcGxpY2F0aW9ucyBtYXkgcGFzcyBpdDsgaXQgbWFrZXMgbm8gc2Vuc2UgZm9yIGEgc2luZ2xlIHByb2Nlc3MuXG4gICAgICAgIHZhciBzdHJlYW1pbmcgPSB0eXBlID09IDE7XG4gICAgICAgIGlmIChzdHJlYW1pbmcgJiYgcHJvdG9jb2wgJiYgcHJvdG9jb2wgIT0gNikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDY2KTsgLy8gaWYgU09DS19TVFJFQU0sIG11c3QgYmUgdGNwIG9yIDAuXG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgaW50ZXJuYWwgc29ja2V0IHN0cnVjdHVyZVxuICAgICAgICB2YXIgc29jayA9IHtcbiAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICAgICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICAgICAgZXJyb3I6IG51bGwsIC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0XG4gICAgICAgICAgcGVlcnM6IHt9LFxuICAgICAgICAgIHBlbmRpbmc6IFtdLFxuICAgICAgICAgIHJlY3ZfcXVldWU6IFtdLFxuICAgICAgICAgIHNvY2tfb3BzOiBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzXG4gICAgICAgIH07XG4gIFxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZpbGVzeXN0ZW0gbm9kZSB0byBzdG9yZSB0aGUgc29ja2V0IHN0cnVjdHVyZVxuICAgICAgICB2YXIgbmFtZSA9IFNPQ0tGUy5uZXh0bmFtZSgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUoU09DS0ZTLnJvb3QsIG5hbWUsIDQ5MTUyLCAwKTtcbiAgICAgICAgbm9kZS5zb2NrID0gc29jaztcbiAgXG4gICAgICAgIC8vIGFuZCB0aGUgd3JhcHBpbmcgc3RyZWFtIHRoYXQgZW5hYmxlcyBsaWJyYXJ5IGZ1bmN0aW9ucyBzdWNoXG4gICAgICAgIC8vIGFzIHJlYWQgYW5kIHdyaXRlIHRvIGluZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgc29ja2V0XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIHBhdGg6IG5hbWUsXG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBmbGFnczogMixcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogU09DS0ZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICAvLyBtYXAgdGhlIG5ldyBzdHJlYW0gdG8gdGhlIHNvY2tldCBzdHJ1Y3R1cmUgKHNvY2tldHMgaGF2ZSBhIDE6MVxuICAgICAgICAvLyByZWxhdGlvbnNoaXAgd2l0aCBhIHN0cmVhbSlcbiAgICAgICAgc29jay5zdHJlYW0gPSBzdHJlYW07XG4gIFxuICAgICAgICByZXR1cm4gc29jaztcbiAgICAgIH0sZ2V0U29ja2V0OmZ1bmN0aW9uKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCAhRlMuaXNTb2NrZXQoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLm5vZGUuc29jaztcbiAgICAgIH0sc3RyZWFtX29wczp7cG9sbDpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMucG9sbChzb2NrKTtcbiAgICAgICAgfSxpb2N0bDpmdW5jdGlvbihzdHJlYW0sIHJlcXVlc3QsIHZhcmFyZ3MpIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMuaW9jdGwoc29jaywgcmVxdWVzdCwgdmFyYXJncyk7XG4gICAgICAgIH0scmVhZDpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgdmFyIG1zZyA9IHNvY2suc29ja19vcHMucmVjdm1zZyhzb2NrLCBsZW5ndGgpO1xuICAgICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICAvLyBzb2NrZXQgaXMgY2xvc2VkXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLnNldChtc2cuYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgIHJldHVybiBtc2cuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMuc2VuZG1zZyhzb2NrLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgc29jay5zb2NrX29wcy5jbG9zZShzb2NrKTtcbiAgICAgICAgfX0sbmV4dG5hbWU6ZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghU09DS0ZTLm5leHRuYW1lLmN1cnJlbnQpIHtcbiAgICAgICAgICBTT0NLRlMubmV4dG5hbWUuY3VycmVudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdzb2NrZXRbJyArIChTT0NLRlMubmV4dG5hbWUuY3VycmVudCsrKSArICddJztcbiAgICAgIH0sd2Vic29ja2V0X3NvY2tfb3BzOntjcmVhdGVQZWVyOmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICB2YXIgd3M7XG4gIFxuICAgICAgICAgIGlmICh0eXBlb2YgYWRkciA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgd3MgPSBhZGRyO1xuICAgICAgICAgICAgYWRkciA9IG51bGw7XG4gICAgICAgICAgICBwb3J0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgLy8gZm9yIHNvY2tldHMgdGhhdCd2ZSBhbHJlYWR5IGNvbm5lY3RlZCAoZS5nLiB3ZSdyZSB0aGUgc2VydmVyKVxuICAgICAgICAgICAgLy8gd2UgY2FuIGluc3BlY3QgdGhlIF9zb2NrZXQgcHJvcGVydHkgZm9yIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBpZiAod3MuX3NvY2tldCkge1xuICAgICAgICAgICAgICBhZGRyID0gd3MuX3NvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgICBwb3J0ID0gd3MuX3NvY2tldC5yZW1vdGVQb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UncmUganVzdCBub3cgaW5pdGlhbGl6aW5nIGEgY29ubmVjdGlvbiB0byB0aGUgcmVtb3RlLFxuICAgICAgICAgICAgLy8gaW5zcGVjdCB0aGUgdXJsIHByb3BlcnR5XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IC93c1tzXT86XFwvXFwvKFteOl0rKTooXFxkKykvLmV4ZWMod3MudXJsKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBVUkwgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IHdzKHMpOi8vYWRkcmVzczpwb3J0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkciA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFjdHVhbCB3ZWJzb2NrZXQgb2JqZWN0IGFuZCBjb25uZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBydW50aW1lQ29uZmlnIGdldHMgc2V0IHRvIHRydWUgaWYgV2ViU29ja2V0IHJ1bnRpbWUgY29uZmlndXJhdGlvbiBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgIHZhciBydW50aW1lQ29uZmlnID0gKE1vZHVsZVsnd2Vic29ja2V0J10gJiYgKCdvYmplY3QnID09PSB0eXBlb2YgTW9kdWxlWyd3ZWJzb2NrZXQnXSkpO1xuICBcbiAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ3dzOi8vJyB0aGUgcmVwbGFjZSBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgY29tcGlsZXIgcmVwbGFjZXMgJy8vJyBjb21tZW50cyB3aXRoICcjJ1xuICAgICAgICAgICAgICAvLyBjb21tZW50cyB3aXRob3V0IGNoZWNraW5nIGNvbnRleHQsIHNvIHdlJ2QgZW5kIHVwIHdpdGggd3M6IywgdGhlIHJlcGxhY2Ugc3dhcHMgdGhlICcjJyBmb3IgJy8vJyBhZ2Fpbi5cbiAgICAgICAgICAgICAgdmFyIHVybCA9ICd3czojJy5yZXBsYWNlKCcjJywgJy8vJyk7XG4gIFxuICAgICAgICAgICAgICBpZiAocnVudGltZUNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIE1vZHVsZVsnd2Vic29ja2V0J11bJ3VybCddKSB7XG4gICAgICAgICAgICAgICAgICB1cmwgPSBNb2R1bGVbJ3dlYnNvY2tldCddWyd1cmwnXTsgLy8gRmV0Y2ggcnVudGltZSBXZWJTb2NrZXQgVVJMIGNvbmZpZy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAgIGlmICh1cmwgPT09ICd3czovLycgfHwgdXJsID09PSAnd3NzOi8vJykgeyAvLyBJcyB0aGUgc3VwcGxpZWQgVVJMIGNvbmZpZyBqdXN0IGEgcHJlZml4LCBpZiBzbyBjb21wbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBhZGRyLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgcGFydHNbMF0gKyBcIjpcIiArIHBvcnQgKyBcIi9cIiArIHBhcnRzLnNsaWNlKDEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgV2ViU29ja2V0IHN1YnByb3RvY29sIChTZWMtV2ViU29ja2V0LVByb3RvY29sKSBkZWZhdWx0IHRvIGJpbmFyeSBpZiBubyBjb25maWd1cmF0aW9uIGlzIHNldC5cbiAgICAgICAgICAgICAgdmFyIHN1YlByb3RvY29scyA9ICdiaW5hcnknOyAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYmluYXJ5J1xuICBcbiAgICAgICAgICAgICAgaWYgKHJ1bnRpbWVDb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBNb2R1bGVbJ3dlYnNvY2tldCddWydzdWJwcm90b2NvbCddKSB7XG4gICAgICAgICAgICAgICAgICBzdWJQcm90b2NvbHMgPSBNb2R1bGVbJ3dlYnNvY2tldCddWydzdWJwcm90b2NvbCddOyAvLyBGZXRjaCBydW50aW1lIFdlYlNvY2tldCBzdWJwcm90b2NvbCBjb25maWcuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBXZWJTb2NrZXQgb3B0aW9uc1xuICAgICAgICAgICAgICB2YXIgb3B0cyA9IHVuZGVmaW5lZDtcbiAgXG4gICAgICAgICAgICAgIGlmIChzdWJQcm90b2NvbHMgIT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZWdleCB0cmltcyB0aGUgc3RyaW5nIChyZW1vdmVzIHNwYWNlcyBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQsIHRoZW4gc3BsaXRzIHRoZSBzdHJpbmcgYnlcbiAgICAgICAgICAgICAgICAvLyA8YW55IHNwYWNlPiw8YW55IHNwYWNlPiBpbnRvIGFuIEFycmF5LiBXaGl0ZXNwYWNlIHJlbW92YWwgaXMgaW1wb3J0YW50IGZvciBXZWJzb2NraWZ5IGFuZCB3cy5cbiAgICAgICAgICAgICAgICBzdWJQcm90b2NvbHMgPSBzdWJQcm90b2NvbHMucmVwbGFjZSgvXiArfCArJC9nLFwiXCIpLnNwbGl0KC8gKiwgKi8pO1xuICBcbiAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZSB3cyBsaWJyYXJ5IEFQSSBmb3Igc3BlY2lmeWluZyBvcHRpb25hbCBzdWJwcm90b2NvbCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiB0aGUgYnJvd3NlcidzLlxuICAgICAgICAgICAgICAgIG9wdHMgPSBFTlZJUk9OTUVOVF9JU19OT0RFID8geydwcm90b2NvbCc6IHN1YlByb3RvY29scy50b1N0cmluZygpfSA6IHN1YlByb3RvY29scztcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgLy8gc29tZSB3ZWJzZXJ2ZXJzIChhenVyZSkgZG9lcyBub3Qgc3VwcG9ydCBzdWJwcm90b2NvbCBoZWFkZXJcbiAgICAgICAgICAgICAgaWYgKHJ1bnRpbWVDb25maWcgJiYgbnVsbCA9PT0gTW9kdWxlWyd3ZWJzb2NrZXQnXVsnc3VicHJvdG9jb2wnXSkge1xuICAgICAgICAgICAgICAgIHN1YlByb3RvY29scyA9ICdudWxsJztcbiAgICAgICAgICAgICAgICBvcHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAvLyBJZiBub2RlIHdlIHVzZSB0aGUgd3MgbGlicmFyeS5cbiAgICAgICAgICAgICAgdmFyIFdlYlNvY2tldENvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgICAgICAgICAgIFdlYlNvY2tldENvbnN0cnVjdG9yID0gLyoqIEB0eXBleyh0eXBlb2YgV2ViU29ja2V0KX0gKi8ocmVxdWlyZSgnd3MnKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgV2ViU29ja2V0Q29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3MgPSBuZXcgV2ViU29ja2V0Q29uc3RydWN0b3IodXJsLCBvcHRzKTtcbiAgICAgICAgICAgICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHZhciBwZWVyID0ge1xuICAgICAgICAgICAgYWRkcjogYWRkcixcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICAgICAgICBzb2NrZXQ6IHdzLFxuICAgICAgICAgICAgZGdyYW1fc2VuZF9xdWV1ZTogW11cbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmFkZFBlZXIoc29jaywgcGVlcik7XG4gICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5oYW5kbGVQZWVyRXZlbnRzKHNvY2ssIHBlZXIpO1xuICBcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYm91bmQgZGdyYW0gc29ja2V0LCBzZW5kIHRoZSBwb3J0IG51bWJlciBmaXJzdCB0byBhbGxvd1xuICAgICAgICAgIC8vIHVzIHRvIG92ZXJyaWRlIHRoZSBlcGhlbWVyYWwgcG9ydCByZXBvcnRlZCB0byB1cyBieSByZW1vdGVQb3J0IG9uIHRoZVxuICAgICAgICAgIC8vIHJlbW90ZSBlbmQuXG4gICAgICAgICAgaWYgKHNvY2sudHlwZSA9PT0gMiAmJiB0eXBlb2Ygc29jay5zcG9ydCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGVlci5kZ3JhbV9zZW5kX3F1ZXVlLnB1c2gobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgIDI1NSwgMjU1LCAyNTUsIDI1NSxcbiAgICAgICAgICAgICAgICAncCcuY2hhckNvZGVBdCgwKSwgJ28nLmNoYXJDb2RlQXQoMCksICdyJy5jaGFyQ29kZUF0KDApLCAndCcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgICAgICAoKHNvY2suc3BvcnQgJiAweGZmMDApID4+IDgpICwgKHNvY2suc3BvcnQgJiAweGZmKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcmV0dXJuIHBlZXI7XG4gICAgICAgIH0sZ2V0UGVlcjpmdW5jdGlvbihzb2NrLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgICAgcmV0dXJuIHNvY2sucGVlcnNbYWRkciArICc6JyArIHBvcnRdO1xuICAgICAgICB9LGFkZFBlZXI6ZnVuY3Rpb24oc29jaywgcGVlcikge1xuICAgICAgICAgIHNvY2sucGVlcnNbcGVlci5hZGRyICsgJzonICsgcGVlci5wb3J0XSA9IHBlZXI7XG4gICAgICAgIH0scmVtb3ZlUGVlcjpmdW5jdGlvbihzb2NrLCBwZWVyKSB7XG4gICAgICAgICAgZGVsZXRlIHNvY2sucGVlcnNbcGVlci5hZGRyICsgJzonICsgcGVlci5wb3J0XTtcbiAgICAgICAgfSxoYW5kbGVQZWVyRXZlbnRzOmZ1bmN0aW9uKHNvY2ssIHBlZXIpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICBcbiAgICAgICAgICB2YXIgaGFuZGxlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgXG4gICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ29wZW4nLCBzb2NrLnN0cmVhbS5mZCk7XG4gIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXVlZCA9IHBlZXIuZGdyYW1fc2VuZF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB3aGlsZSAocXVldWVkKSB7XG4gICAgICAgICAgICAgICAgcGVlci5zb2NrZXQuc2VuZChxdWV1ZWQpO1xuICAgICAgICAgICAgICAgIHF1ZXVlZCA9IHBlZXIuZGdyYW1fc2VuZF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBtdWNoIHdlIGNhbiBkbyBoZXJlIGluIHRoZSB3YXkgb2YgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGFzIHdlJ3ZlIGFscmVhZHlcbiAgICAgICAgICAgICAgLy8gbGllZCBhbmQgc2FpZCB0aGlzIGRhdGEgd2FzIHNlbnQuIHNodXQgaXQgZG93bi5cbiAgICAgICAgICAgICAgcGVlci5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YXIgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBzaG91bGQgYmUgdXRmLThcbiAgICAgICAgICAgICAgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGRhdGEpOyAvLyBtYWtlIGEgdHlwZWQgYXJyYXkgZnJvbSB0aGUgc3RyaW5nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhc3NlcnQoZGF0YS5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQpOyAvLyBtdXN0IHJlY2VpdmUgYW4gQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgQXJyYXlCdWZmZXIgd2lsbCBlbWl0IGEgcHNldWRvIGRpc2Nvbm5lY3QgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBhcyByZWN2L3JlY3Ztc2cgd2lsbCByZXR1cm4gemVybyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBhIHNvY2tldFxuICAgICAgICAgICAgICAgIC8vIGhhcyBwZXJmb3JtZWQgYSBzaHV0ZG93biBhbHRob3VnaCB0aGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZGlzY29ubmVjdGVkIHlldC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBtYWtlIGEgdHlwZWQgYXJyYXkgdmlldyBvbiB0aGUgYXJyYXkgYnVmZmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBwb3J0IG1lc3NhZ2UsIG92ZXJyaWRlIHRoZSBwZWVyJ3MgcG9ydCB3aXRoIGl0XG4gICAgICAgICAgICB2YXIgd2FzZmlyc3QgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod2FzZmlyc3QgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9PT0gMTAgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMjU1ICYmIGRhdGFbMl0gPT09IDI1NSAmJiBkYXRhWzNdID09PSAyNTUgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzRdID09PSAncCcuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzVdID09PSAnbycuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzZdID09PSAncicuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzddID09PSAndCcuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBlZXIncyBwb3J0IGFuZCBpdCdzIGtleSBpbiB0aGUgcGVlciBtYXBcbiAgICAgICAgICAgICAgdmFyIG5ld3BvcnQgPSAoKGRhdGFbOF0gPDwgOCkgfCBkYXRhWzldKTtcbiAgICAgICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5yZW1vdmVQZWVyKHNvY2ssIHBlZXIpO1xuICAgICAgICAgICAgICBwZWVyLnBvcnQgPSBuZXdwb3J0O1xuICAgICAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmFkZFBlZXIoc29jaywgcGVlcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBzb2NrLnJlY3ZfcXVldWUucHVzaCh7IGFkZHI6IHBlZXIuYWRkciwgcG9ydDogcGVlci5wb3J0LCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdtZXNzYWdlJywgc29jay5zdHJlYW0uZmQpO1xuICAgICAgICAgIH07XG4gIFxuICAgICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihkYXRhLCBmbGFncykge1xuICAgICAgICAgICAgICBpZiAoIWZsYWdzLmJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlKChuZXcgVWludDhBcnJheShkYXRhKSkuYnVmZmVyKTsgIC8vIGNvcHkgZnJvbSBub2RlIEJ1ZmZlciAtPiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdjbG9zZScsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggdGhlIHdzIGxpYnJhcnkgbWF5IHBhc3MgZXJyb3JzIHRoYXQgbWF5IGJlIG1vcmUgZGVzY3JpcHRpdmUgdGhhblxuICAgICAgICAgICAgICAvLyBFQ09OTlJFRlVTRUQgdGhleSBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIGUuZy4gXG4gICAgICAgICAgICAgIC8vIEVOT1RGT1VORCBvbiBnZXRhZGRyaW5mbyBzZWVtcyB0byBiZSBub2RlLmpzIHNwZWNpZmljLCBzbyB1c2luZyBFQ09OTlJFRlVTRURcbiAgICAgICAgICAgICAgLy8gaXMgc3RpbGwgcHJvYmFibHkgdGhlIG1vc3QgdXNlZnVsIHRoaW5nIHRvIGRvLlxuICAgICAgICAgICAgICBzb2NrLmVycm9yID0gMTQ7IC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0LlxuICAgICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Vycm9yJywgW3NvY2suc3RyZWFtLmZkLCBzb2NrLmVycm9yLCAnRUNPTk5SRUZVU0VEOiBDb25uZWN0aW9uIHJlZnVzZWQnXSk7XG4gICAgICAgICAgICAgIC8vIGRvbid0IHRocm93XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub25vcGVuID0gaGFuZGxlT3BlbjtcbiAgICAgICAgICAgIHBlZXIuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdjbG9zZScsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBwZWVyX3NvY2tldF9vbm1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIFdlYlNvY2tldCBzcGVjIG9ubHkgYWxsb3dzIGEgJ3NpbXBsZSBldmVudCcgdG8gYmUgdGhyb3duIG9uIGVycm9yLFxuICAgICAgICAgICAgICAvLyBzbyB3ZSBvbmx5IHJlYWxseSBrbm93IGFzIG11Y2ggYXMgRUNPTk5SRUZVU0VELlxuICAgICAgICAgICAgICBzb2NrLmVycm9yID0gMTQ7IC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0LlxuICAgICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Vycm9yJywgW3NvY2suc3RyZWFtLmZkLCBzb2NrLmVycm9yLCAnRUNPTk5SRUZVU0VEOiBDb25uZWN0aW9uIHJlZnVzZWQnXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxwb2xsOmZ1bmN0aW9uKHNvY2spIHtcbiAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxICYmIHNvY2suc2VydmVyKSB7XG4gICAgICAgICAgICAvLyBsaXN0ZW4gc29ja2V0cyBzaG91bGQgb25seSBzYXkgdGhleSdyZSBhdmFpbGFibGUgZm9yIHJlYWRpbmdcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwZW5kaW5nIGNsaWVudHMuXG4gICAgICAgICAgICByZXR1cm4gc29jay5wZW5kaW5nLmxlbmd0aCA/ICg2NCB8IDEpIDogMDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHZhciBtYXNrID0gMDtcbiAgICAgICAgICB2YXIgZGVzdCA9IHNvY2sudHlwZSA9PT0gMSA/ICAvLyB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhlIHNvY2tldCBzdGF0ZSBmb3IgY29ubmVjdGlvbi1iYXNlZCBzb2NrZXRzXG4gICAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgc29jay5kYWRkciwgc29jay5kcG9ydCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgXG4gICAgICAgICAgaWYgKHNvY2sucmVjdl9xdWV1ZS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgIWRlc3QgfHwgIC8vIGNvbm5lY3Rpb24tbGVzcyBzb2NrZXRzIGFyZSBhbHdheXMgcmVhZHkgdG8gcmVhZFxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TSU5HKSB8fFxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpKSB7ICAvLyBsZXQgcmVjdiByZXR1cm4gMCBvbmNlIGNsb3NlZFxuICAgICAgICAgICAgbWFzayB8PSAoNjQgfCAxKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghZGVzdCB8fCAgLy8gY29ubmVjdGlvbi1sZXNzIHNvY2tldHMgYXJlIGFsd2F5cyByZWFkeSB0byB3cml0ZVxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5PUEVOKSkge1xuICAgICAgICAgICAgbWFzayB8PSA0O1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKChkZXN0ICYmIGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NJTkcpIHx8XG4gICAgICAgICAgICAgIChkZXN0ICYmIGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NFRCkpIHtcbiAgICAgICAgICAgIG1hc2sgfD0gMTY7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICByZXR1cm4gbWFzaztcbiAgICAgICAgfSxpb2N0bDpmdW5jdGlvbihzb2NrLCByZXF1ZXN0LCBhcmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNhc2UgMjE1MzE6XG4gICAgICAgICAgICAgIHZhciBieXRlcyA9IDA7XG4gICAgICAgICAgICAgIGlmIChzb2NrLnJlY3ZfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBzb2NrLnJlY3ZfcXVldWVbMF0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSEVBUDMyWygoYXJnKT4+MildID0gYnl0ZXM7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzb2NrKSB7XG4gICAgICAgICAgLy8gaWYgd2UndmUgc3Bhd25lZCBhIGxpc3RlbiBzZXJ2ZXIsIGNsb3NlIGl0XG4gICAgICAgICAgaWYgKHNvY2suc2VydmVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzb2NrLnNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjbG9zZSBhbnkgcGVlciBjb25uZWN0aW9uc1xuICAgICAgICAgIHZhciBwZWVycyA9IE9iamVjdC5rZXlzKHNvY2sucGVlcnMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwZWVyID0gc29jay5wZWVyc1twZWVyc1tpXV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwZWVyLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5yZW1vdmVQZWVyKHNvY2ssIHBlZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxiaW5kOmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNvY2suc2FkZHIgIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNvY2suc3BvcnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTsgIC8vIGFscmVhZHkgYm91bmRcbiAgICAgICAgICB9XG4gICAgICAgICAgc29jay5zYWRkciA9IGFkZHI7XG4gICAgICAgICAgc29jay5zcG9ydCA9IHBvcnQ7XG4gICAgICAgICAgLy8gaW4gb3JkZXIgdG8gZW11bGF0ZSBkZ3JhbSBzb2NrZXRzLCB3ZSBuZWVkIHRvIGxhdW5jaCBhIGxpc3RlbiBzZXJ2ZXIgd2hlblxuICAgICAgICAgIC8vIGJpbmRpbmcgb24gYSBjb25uZWN0aW9uLWxlc3Mgc29ja2V0XG4gICAgICAgICAgLy8gbm90ZTogdGhpcyBpcyBvbmx5IHJlcXVpcmVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBleGlzdGluZyBzZXJ2ZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgc29jay5zZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3dhbGxvdyBlcnJvciBvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBlcnJvciB0aGF0IG9jY3VycyB3aGVuIGJpbmRpbmcgaW4gdGhlXG4gICAgICAgICAgICAvLyBicm93c2VyIHdoZXJlIHRoaXMgaXNuJ3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzb2NrLnNvY2tfb3BzLmxpc3Rlbihzb2NrLCAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICAgICAgICBpZiAoZS5lcnJubyAhPT0gMTM4KSB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxjb25uZWN0OmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICBpZiAoc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBUT0RPIGF1dG9iaW5kXG4gICAgICAgICAgLy8gaWYgKCFzb2NrLmFkZHIgJiYgc29jay50eXBlID09IDIpIHtcbiAgICAgICAgICAvLyB9XG4gIFxuICAgICAgICAgIC8vIGVhcmx5IG91dCBpZiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZCAvIGluIHRoZSBtaWRkbGUgb2YgY29ubmVjdGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc29jay5kYWRkciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc29jay5kcG9ydCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgc29jay5kYWRkciwgc29jay5kcG9ydCk7XG4gICAgICAgICAgICBpZiAoZGVzdCkge1xuICAgICAgICAgICAgICBpZiAoZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgLy8gYWRkIHRoZSBzb2NrZXQgdG8gb3VyIHBlZXIgbGlzdCBhbmQgc2V0IG91clxuICAgICAgICAgIC8vIGRlc3RpbmF0aW9uIGFkZHJlc3MgLyBwb3J0IHRvIG1hdGNoXG4gICAgICAgICAgdmFyIHBlZXIgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmNyZWF0ZVBlZXIoc29jaywgYWRkciwgcG9ydCk7XG4gICAgICAgICAgc29jay5kYWRkciA9IHBlZXIuYWRkcjtcbiAgICAgICAgICBzb2NrLmRwb3J0ID0gcGVlci5wb3J0O1xuICBcbiAgICAgICAgICAvLyBhbHdheXMgXCJmYWlsXCIgaW4gbm9uLWJsb2NraW5nIG1vZGVcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyNik7XG4gICAgICAgIH0sbGlzdGVuOmZ1bmN0aW9uKHNvY2ssIGJhY2tsb2cpIHtcbiAgICAgICAgICBpZiAoIUVOVklST05NRU5UX0lTX05PREUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb2NrLnNlcnZlcikge1xuICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTsgIC8vIGFscmVhZHkgbGlzdGVuaW5nXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBXZWJTb2NrZXRTZXJ2ZXIgPSByZXF1aXJlKCd3cycpLlNlcnZlcjtcbiAgICAgICAgICB2YXIgaG9zdCA9IHNvY2suc2FkZHI7XG4gICAgICAgICAgc29jay5zZXJ2ZXIgPSBuZXcgV2ViU29ja2V0U2VydmVyKHtcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICBwb3J0OiBzb2NrLnNwb3J0XG4gICAgICAgICAgICAvLyBUT0RPIHN1cHBvcnQgYmFja2xvZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnbGlzdGVuJywgc29jay5zdHJlYW0uZmQpOyAvLyBTZW5kIEV2ZW50IHdpdGggbGlzdGVuIGZkLlxuICBcbiAgICAgICAgICBzb2NrLnNlcnZlci5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uKHdzKSB7XG4gICAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdzb2NrID0gU09DS0ZTLmNyZWF0ZVNvY2tldChzb2NrLmZhbWlseSwgc29jay50eXBlLCBzb2NrLnByb3RvY29sKTtcbiAgXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBlZXIgb24gdGhlIG5ldyBzb2NrZXRcbiAgICAgICAgICAgICAgdmFyIHBlZXIgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmNyZWF0ZVBlZXIobmV3c29jaywgd3MpO1xuICAgICAgICAgICAgICBuZXdzb2NrLmRhZGRyID0gcGVlci5hZGRyO1xuICAgICAgICAgICAgICBuZXdzb2NrLmRwb3J0ID0gcGVlci5wb3J0O1xuICBcbiAgICAgICAgICAgICAgLy8gcHVzaCB0byBxdWV1ZSBmb3IgYWNjZXB0IHRvIHBpY2sgdXBcbiAgICAgICAgICAgICAgc29jay5wZW5kaW5nLnB1c2gobmV3c29jayk7XG4gICAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnY29ubmVjdGlvbicsIG5ld3NvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBlZXIgb24gdGhlIGxpc3RlbiBzb2NrZXQgc28gY2FsbGluZyBzZW5kdG9cbiAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgbGlzdGVuIHNvY2tldCBhbmQgYW4gYWRkcmVzcyB3aWxsIHJlc29sdmVcbiAgICAgICAgICAgICAgLy8gdG8gdGhlIGNvcnJlY3QgY2xpZW50XG4gICAgICAgICAgICAgIFNPQ0tGUy53ZWJzb2NrZXRfc29ja19vcHMuY3JlYXRlUGVlcihzb2NrLCB3cyk7XG4gICAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnY29ubmVjdGlvbicsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb2NrLnNlcnZlci5vbignY2xvc2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Nsb3NlJywgc29jay5zdHJlYW0uZmQpO1xuICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNvY2suc2VydmVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBBbHRob3VnaCB0aGUgd3MgbGlicmFyeSBtYXkgcGFzcyBlcnJvcnMgdGhhdCBtYXkgYmUgbW9yZSBkZXNjcmlwdGl2ZSB0aGFuXG4gICAgICAgICAgICAvLyBFQ09OTlJFRlVTRUQgdGhleSBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIGUuZy4gXG4gICAgICAgICAgICAvLyBFTk9URk9VTkQgb24gZ2V0YWRkcmluZm8gc2VlbXMgdG8gYmUgbm9kZS5qcyBzcGVjaWZpYywgc28gdXNpbmcgRUhPU1RVTlJFQUNIXG4gICAgICAgICAgICAvLyBpcyBzdGlsbCBwcm9iYWJseSB0aGUgbW9zdCB1c2VmdWwgdGhpbmcgdG8gZG8uIFRoaXMgZXJyb3Igc2hvdWxkbid0XG4gICAgICAgICAgICAvLyBvY2N1ciBpbiBhIHdlbGwgd3JpdHRlbiBhcHAgYXMgZXJyb3JzIHNob3VsZCBnZXQgdHJhcHBlZCBpbiB0aGUgY29tcGlsZWRcbiAgICAgICAgICAgIC8vIGFwcCdzIG93biBnZXRhZGRyaW5mbyBjYWxsLlxuICAgICAgICAgICAgc29jay5lcnJvciA9IDIzOyAvLyBVc2VkIGluIGdldHNvY2tvcHQgZm9yIFNPTF9TT0NLRVQvU09fRVJST1IgdGVzdC5cbiAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnZXJyb3InLCBbc29jay5zdHJlYW0uZmQsIHNvY2suZXJyb3IsICdFSE9TVFVOUkVBQ0g6IEhvc3QgaXMgdW5yZWFjaGFibGUnXSk7XG4gICAgICAgICAgICAvLyBkb24ndCB0aHJvd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LGFjY2VwdDpmdW5jdGlvbihsaXN0ZW5zb2NrKSB7XG4gICAgICAgICAgaWYgKCFsaXN0ZW5zb2NrLnNlcnZlciB8fCAhbGlzdGVuc29jay5wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV3c29jayA9IGxpc3RlbnNvY2sucGVuZGluZy5zaGlmdCgpO1xuICAgICAgICAgIG5ld3NvY2suc3RyZWFtLmZsYWdzID0gbGlzdGVuc29jay5zdHJlYW0uZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIG5ld3NvY2s7XG4gICAgICAgIH0sZ2V0bmFtZTpmdW5jdGlvbihzb2NrLCBwZWVyKSB7XG4gICAgICAgICAgdmFyIGFkZHIsIHBvcnQ7XG4gICAgICAgICAgaWYgKHBlZXIpIHtcbiAgICAgICAgICAgIGlmIChzb2NrLmRhZGRyID09PSB1bmRlZmluZWQgfHwgc29jay5kcG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDUzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHIgPSBzb2NrLmRhZGRyO1xuICAgICAgICAgICAgcG9ydCA9IHNvY2suZHBvcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2FkZHIgYW5kIHNwb3J0IHdpbGwgYmUgc2V0IGZvciBiaW5kKCknZCBVRFAgc29ja2V0cywgYnV0IHdoYXRcbiAgICAgICAgICAgIC8vIHNob3VsZCB3ZSBiZSByZXR1cm5pbmcgZm9yIFRDUCBzb2NrZXRzIHRoYXQndmUgYmVlbiBjb25uZWN0KCknZD9cbiAgICAgICAgICAgIGFkZHIgPSBzb2NrLnNhZGRyIHx8IDA7XG4gICAgICAgICAgICBwb3J0ID0gc29jay5zcG9ydCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBhZGRyOiBhZGRyLCBwb3J0OiBwb3J0IH07XG4gICAgICAgIH0sc2VuZG1zZzpmdW5jdGlvbihzb2NrLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgICAgaWYgKHNvY2sudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgLy8gY29ubmVjdGlvbi1sZXNzIHNvY2tldHMgd2lsbCBob25vciB0aGUgbWVzc2FnZSBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gYW5kIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIGJvdW5kIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChhZGRyID09PSB1bmRlZmluZWQgfHwgcG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGFkZHIgPSBzb2NrLmRhZGRyO1xuICAgICAgICAgICAgICBwb3J0ID0gc29jay5kcG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBhZGRyZXNzIHRvIGZhbGwgYmFjayB0bywgZXJyb3Igb3V0XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gdW5kZWZpbmVkIHx8IHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24tYmFzZWQgc29ja2V0cyB3aWxsIG9ubHkgdXNlIHRoZSBib3VuZFxuICAgICAgICAgICAgYWRkciA9IHNvY2suZGFkZHI7XG4gICAgICAgICAgICBwb3J0ID0gc29jay5kcG9ydDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8vIGZpbmQgdGhlIHBlZXIgZm9yIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gICAgICAgICAgdmFyIGRlc3QgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgYWRkciwgcG9ydCk7XG4gIFxuICAgICAgICAgIC8vIGVhcmx5IG91dCBpZiBub3QgY29ubmVjdGVkIHdpdGggYSBjb25uZWN0aW9uLWJhc2VkIHNvY2tldFxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghZGVzdCB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TSU5HIHx8IGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1Myk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5IG9mIHRoZSBpbmNvbWluZyBkYXRhIHRvIHNlbmQsIGFzIHRoZSBXZWJTb2NrZXQgQVBJXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGVudGlyZWx5IHdpdGggYW4gQXJyYXlCdWZmZXJWaWV3LCBpdCdsbCBqdXN0IHNlbmRcbiAgICAgICAgICAvLyB0aGUgZW50aXJlIHVuZGVybHlpbmcgYnVmZmVyXG4gICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgXG4gICAgICAgICAgLy8gaWYgd2UncmUgZW11bGF0aW5nIGEgY29ubmVjdGlvbi1sZXNzIGRncmFtIHNvY2tldCBhbmQgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGEgY2FjaGVkIGNvbm5lY3Rpb24sIHF1ZXVlIHRoZSBidWZmZXIgdG8gc2VuZCB1cG9uIGNvbm5lY3QgYW5kXG4gICAgICAgICAgLy8gbGllLCBzYXlpbmcgdGhlIGRhdGEgd2FzIHNlbnQgbm93LlxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIGlmICghZGVzdCB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlICE9PSBkZXN0LnNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIG9wZW4gYSBuZXcgY29ubmVjdGlvblxuICAgICAgICAgICAgICBpZiAoIWRlc3QgfHwgZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ0xPU0lORyB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICBkZXN0ID0gU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5jcmVhdGVQZWVyKHNvY2ssIGFkZHIsIHBvcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlc3QuZGdyYW1fc2VuZF9xdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIGFjdHVhbCBkYXRhXG4gICAgICAgICAgICBkZXN0LnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LHJlY3Ztc2c6ZnVuY3Rpb24oc29jaywgbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzc5MDg3OTkveG5zL3JlY3Ztc2cuaHRtbFxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDEgJiYgc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIHRjcCBzZXJ2ZXJzIHNob3VsZCBub3QgYmUgcmVjdigpJ2luZyBvbiB0aGUgbGlzdGVuIHNvY2tldFxuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTMpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIHF1ZXVlZCA9IHNvY2sucmVjdl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIGlmICghcXVldWVkKSB7XG4gICAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBkZXN0ID0gU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5nZXRQZWVyKHNvY2ssIHNvY2suZGFkZHIsIHNvY2suZHBvcnQpO1xuICBcbiAgICAgICAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGRlc3RpbmF0aW9uIGFkZHJlc3MgYnV0IGFyZSBub3QgY29ubmVjdGVkLCBlcnJvciBvdXRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1Myk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ0xPU0lORyB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbCBpZiB0aGUgc29ja2V0IGhhcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlLCBvdXIgc29ja2V0IGlzIGluIGEgdmFsaWQgc3RhdGUgYnV0IHRydWx5IGhhcyBub3RoaW5nIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8vIHF1ZXVlZC5kYXRhIHdpbGwgYmUgYW4gQXJyYXlCdWZmZXIgaWYgaXQncyB1bmFkdWx0ZXJhdGVkLCBidXQgaWYgaXQnc1xuICAgICAgICAgIC8vIHJlcXVldWVkIFRDUCBkYXRhIGl0J2xsIGJlIGFuIEFycmF5QnVmZmVyVmlld1xuICAgICAgICAgIHZhciBxdWV1ZWRMZW5ndGggPSBxdWV1ZWQuZGF0YS5ieXRlTGVuZ3RoIHx8IHF1ZXVlZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgICB2YXIgcXVldWVkT2Zmc2V0ID0gcXVldWVkLmRhdGEuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICAgIHZhciBxdWV1ZWRCdWZmZXIgPSBxdWV1ZWQuZGF0YS5idWZmZXIgfHwgcXVldWVkLmRhdGE7XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IE1hdGgubWluKGxlbmd0aCwgcXVldWVkTGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShxdWV1ZWRCdWZmZXIsIHF1ZXVlZE9mZnNldCwgYnl0ZXNSZWFkKSxcbiAgICAgICAgICAgIGFkZHI6IHF1ZXVlZC5hZGRyLFxuICAgICAgICAgICAgcG9ydDogcXVldWVkLnBvcnRcbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICAvLyBwdXNoIGJhY2sgYW55IHVucmVhZCBkYXRhIGZvciBUQ1AgY29ubmVjdGlvbnNcbiAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxICYmIGJ5dGVzUmVhZCA8IHF1ZXVlZExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVtYWluaW5nID0gcXVldWVkTGVuZ3RoIC0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgcXVldWVkLmRhdGEgPSBuZXcgVWludDhBcnJheShxdWV1ZWRCdWZmZXIsIHF1ZXVlZE9mZnNldCArIGJ5dGVzUmVhZCwgYnl0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgc29jay5yZWN2X3F1ZXVlLnVuc2hpZnQocXVldWVkKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH19fTtcbiAgZnVuY3Rpb24gZ2V0U29ja2V0RnJvbUZEKGZkKSB7XG4gICAgICB2YXIgc29ja2V0ID0gU09DS0ZTLmdldFNvY2tldChmZCk7XG4gICAgICBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKSB7XG4gICAgICBIRUFQMzJbKChfX19lcnJub19sb2NhdGlvbigpKT4+MildID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB2YXIgU29ja2V0cyA9IHtCVUZGRVJfU0laRToxMDI0MCxNQVhfQlVGRkVSX1NJWkU6MTA0ODU3NjAsbmV4dEZkOjEsZmRzOnt9LG5leHRwb3J0OjEsbWF4cG9ydDo2NTUzNSxwZWVyOm51bGwsY29ubmVjdGlvbnM6e30scG9ydG1hcDp7fSxsb2NhbEFkZHI6NDI2MTQxMjg3NCxhZGRyUG9vbDpbMzM1NTQ0NDIsNTAzMzE2NTgsNjcxMDg4NzQsODM4ODYwOTAsMTAwNjYzMzA2LDExNzQ0MDUyMiwxMzQyMTc3MzgsMTUwOTk0OTU0LDE2Nzc3MjE3MCwxODQ1NDkzODYsMjAxMzI2NjAyLDIxODEwMzgxOCwyMzQ4ODEwMzRdfTtcbiAgXG4gIGZ1bmN0aW9uIGluZXRQdG9uNChzdHIpIHtcbiAgICAgIHZhciBiID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gTnVtYmVyKGJbaV0pO1xuICAgICAgICBpZiAoaXNOYU4odG1wKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGJbaV0gPSB0bXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGJbMF0gfCAoYlsxXSA8PCA4KSB8IChiWzJdIDw8IDE2KSB8IChiWzNdIDw8IDI0KSkgPj4+IDA7XG4gICAgfVxuICBcbiAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgZnVuY3Rpb24ganN0b2lfcShzdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIpO1xuICAgIH1cbiAgZnVuY3Rpb24gaW5ldFB0b242KHN0cikge1xuICAgICAgdmFyIHdvcmRzO1xuICAgICAgdmFyIHcsIG9mZnNldCwgeiwgaTtcbiAgICAgIC8qIGh0dHA6Ly9ob21lLmRlZHMubmwvfmFlcm9uL3JlZ2V4LyAqL1xuICAgICAgdmFyIHZhbGlkNnJlZ3ggPSAvXigoPz0uKjo6KSg/IS4qOjouKzo6KSg6Oik/KFtcXGRBLUZdezEsNH06KDp8XFxiKXwpezV9fChbXFxkQS1GXXsxLDR9Oil7Nn0pKCgoW1xcZEEtRl17MSw0fSgoPyFcXDMpOjp8OlxcYnwkKSl8KD8hXFwyXFwzKSl7Mn18KCgoMlswLTRdfDFcXGR8WzEtOV0pP1xcZHwyNVswLTVdKVxcLj9cXGIpezR9KSQvaVxuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICBpZiAoIXZhbGlkNnJlZ3gudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciA9PT0gXCI6OlwiKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICAvLyBaIHBsYWNlaG9sZGVyIHRvIGtlZXAgdHJhY2sgb2YgemVyb3Mgd2hlbiBzcGxpdHRpbmcgdGhlIHN0cmluZyBvbiBcIjpcIlxuICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIlo6XCIpOyAvLyBsZWFkaW5nIHplcm9zIGNhc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiOjpcIiwgXCI6WjpcIik7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHN0ci5pbmRleE9mKFwiLlwiKSA+IDApIHtcbiAgICAgICAgLy8gcGFyc2UgSVB2NCBlbWJlZGRlZCBzdHJlc3NcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnWy5dJywgJ2cnKSwgXCI6XCIpO1xuICAgICAgICB3b3JkcyA9IHN0ci5zcGxpdChcIjpcIik7XG4gICAgICAgIHdvcmRzW3dvcmRzLmxlbmd0aC00XSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTRdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTNdKSoyNTY7XG4gICAgICAgIHdvcmRzW3dvcmRzLmxlbmd0aC0zXSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTJdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTFdKSoyNTY7XG4gICAgICAgIHdvcmRzID0gd29yZHMuc2xpY2UoMCwgd29yZHMubGVuZ3RoLTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuICAgICAgfVxuICBcbiAgICAgIG9mZnNldCA9IDA7IHogPSAwO1xuICAgICAgZm9yICh3PTA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICBpZiAodHlwZW9mIHdvcmRzW3ddID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHdvcmRzW3ddID09PSAnWicpIHtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgemVyb3MgLSB3cml0ZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgemVybyB3b3Jkc1xuICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8ICg4IC0gd29yZHMubGVuZ3RoKzEpOyB6KyspIHtcbiAgICAgICAgICAgICAgcGFydHNbdyt6XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB6LTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGhleCB0byBmaWVsZCB0byAxNi1iaXQgdmFsdWUgYW5kIHdyaXRlIGl0IGluIG5ldHdvcmsgYnl0ZS1vcmRlclxuICAgICAgICAgICAgcGFydHNbdytvZmZzZXRdID0gX2h0b25zKHBhcnNlSW50KHdvcmRzW3ddLDE2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBhcnNlZCBJUHY0IHdvcmRzXG4gICAgICAgICAgcGFydHNbdytvZmZzZXRdID0gd29yZHNbd107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIChwYXJ0c1sxXSA8PCAxNikgfCBwYXJ0c1swXSxcbiAgICAgICAgKHBhcnRzWzNdIDw8IDE2KSB8IHBhcnRzWzJdLFxuICAgICAgICAocGFydHNbNV0gPDwgMTYpIHwgcGFydHNbNF0sXG4gICAgICAgIChwYXJ0c1s3XSA8PCAxNikgfCBwYXJ0c1s2XVxuICAgICAgXTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge251bWJlcj19IGFkZHJsZW4gKi9cbiAgZnVuY3Rpb24gd3JpdGVTb2NrYWRkcihzYSwgZmFtaWx5LCBhZGRyLCBwb3J0LCBhZGRybGVuKSB7XG4gICAgICBzd2l0Y2ggKGZhbWlseSkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYWRkciA9IGluZXRQdG9uNChhZGRyKTtcbiAgICAgICAgICB6ZXJvTWVtb3J5KHNhLCAxNik7XG4gICAgICAgICAgaWYgKGFkZHJsZW4pIHtcbiAgICAgICAgICAgIEhFQVAzMlsoKGFkZHJsZW4pPj4yKV0gPSAxNjtcbiAgICAgICAgICB9XG4gICAgICAgICAgSEVBUDE2Wygoc2EpPj4xKV0gPSBmYW1pbHk7XG4gICAgICAgICAgSEVBUDMyWygoKHNhKSsoNCkpPj4yKV0gPSBhZGRyO1xuICAgICAgICAgIEhFQVAxNlsoKChzYSkrKDIpKT4+MSldID0gX2h0b25zKHBvcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGFkZHIgPSBpbmV0UHRvbjYoYWRkcik7XG4gICAgICAgICAgemVyb01lbW9yeShzYSwgMjgpO1xuICAgICAgICAgIGlmIChhZGRybGVuKSB7XG4gICAgICAgICAgICBIRUFQMzJbKChhZGRybGVuKT4+MildID0gMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIEhFQVAzMlsoKHNhKT4+MildID0gZmFtaWx5O1xuICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDgpKT4+MildID0gYWRkclswXTtcbiAgICAgICAgICBIRUFQMzJbKCgoc2EpKygxMikpPj4yKV0gPSBhZGRyWzFdO1xuICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDE2KSk+PjIpXSA9IGFkZHJbMl07XG4gICAgICAgICAgSEVBUDMyWygoKHNhKSsoMjApKT4+MildID0gYWRkclszXTtcbiAgICAgICAgICBIRUFQMTZbKCgoc2EpKygyKSk+PjEpXSA9IF9odG9ucyhwb3J0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gIHZhciBETlMgPSB7YWRkcmVzc19tYXA6e2lkOjEsYWRkcnM6e30sbmFtZXM6e319LGxvb2t1cF9uYW1lOmZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGlzIGFscmVhZHkgYSB2YWxpZCBpcHY0IC8gaXB2NiBhZGRyZXNzLCBkb24ndCBnZW5lcmF0ZSBhIGZha2Ugb25lLlxuICAgICAgICB2YXIgcmVzID0gaW5ldFB0b240KG5hbWUpO1xuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gaW5ldFB0b242KG5hbWUpO1xuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIFNlZSBpZiB0aGlzIG5hbWUgaXMgYWxyZWFkeSBtYXBwZWQuXG4gICAgICAgIHZhciBhZGRyO1xuICBcbiAgICAgICAgaWYgKEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSkge1xuICAgICAgICAgIGFkZHIgPSBETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlkID0gRE5TLmFkZHJlc3NfbWFwLmlkKys7XG4gICAgICAgICAgYXNzZXJ0KGlkIDwgNjU1MzUsICdleGNlZWRlZCBtYXggYWRkcmVzcyBtYXBwaW5ncyBvZiA2NTUzNScpO1xuICBcbiAgICAgICAgICBhZGRyID0gJzE3Mi4yOS4nICsgKGlkICYgMHhmZikgKyAnLicgKyAoaWQgJiAweGZmMDApO1xuICBcbiAgICAgICAgICBETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl0gPSBuYW1lO1xuICAgICAgICAgIEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSA9IGFkZHI7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgfSxsb29rdXBfYWRkcjpmdW5jdGlvbiAoYWRkcikge1xuICAgICAgICBpZiAoRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdKSB7XG4gICAgICAgICAgcmV0dXJuIEROUy5hZGRyZXNzX21hcC5uYW1lc1thZGRyXTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9fTtcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9hY2NlcHQ0KGZkLCBhZGRyLCBhZGRybGVuLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBuZXdzb2NrID0gc29jay5zb2NrX29wcy5hY2NlcHQoc29jayk7XG4gICAgICBpZiAoYWRkcikge1xuICAgICAgICB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIG5ld3NvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUobmV3c29jay5kYWRkciksIG5ld3NvY2suZHBvcnQsIGFkZHJsZW4pO1xuICAgICAgICBhc3NlcnQoIWVycm5vKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdzb2NrLnN0cmVhbS5mZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZXROdG9wNChhZGRyKSB7XG4gICAgICByZXR1cm4gKGFkZHIgJiAweGZmKSArICcuJyArICgoYWRkciA+PiA4KSAmIDB4ZmYpICsgJy4nICsgKChhZGRyID4+IDE2KSAmIDB4ZmYpICsgJy4nICsgKChhZGRyID4+IDI0KSAmIDB4ZmYpXG4gICAgfVxuICBcbiAgZnVuY3Rpb24gaW5ldE50b3A2KGludHMpIHtcbiAgICAgIC8vICByZWY6ICBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzczLnR4dCAtIHNlY3Rpb24gMi41LjRcbiAgICAgIC8vICBGb3JtYXQgZm9yIElQdjQgY29tcGF0aWJsZSBhbmQgbWFwcGVkICAxMjgtYml0IElQdjYgQWRkcmVzc2VzXG4gICAgICAvLyAgMTI4LWJpdHMgYXJlIHNwbGl0IGludG8gZWlnaHQgMTYtYml0IHdvcmRzXG4gICAgICAvLyAgc3RvcmVkIGluIG5ldHdvcmsgYnl0ZSBvcmRlciAoYmlnLWVuZGlhbilcbiAgICAgIC8vICB8ICAgICAgICAgICAgICAgIDgwIGJpdHMgICAgICAgICAgICAgICB8IDE2IHwgICAgICAzMiBiaXRzICAgICAgICB8XG4gICAgICAvLyAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgLy8gIHwgICAgICAgICAgICAgICAxMCBieXRlcyAgICAgICAgICAgICAgIHwgIDIgfCAgICAgIDQgYnl0ZXMgICAgICAgIHxcbiAgICAgIC8vICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAvLyAgKyAgICAgICAgICAgICAgIDUgd29yZHMgICAgICAgICAgICAgICAgfCAgMSB8ICAgICAgMiB3b3JkcyAgICAgICAgfFxuICAgICAgLy8gICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgIC8vICB8MDAwMC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLjAwMDB8MDAwMHwgICAgSVB2NCBBRERSRVNTICAgICB8IChjb21wYXRpYmxlKVxuICAgICAgLy8gICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgIC8vICB8MDAwMC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLjAwMDB8RkZGRnwgICAgSVB2NCBBRERSRVNTICAgICB8IChtYXBwZWQpXG4gICAgICAvLyAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgd29yZCA9IDA7XG4gICAgICB2YXIgbG9uZ2VzdCA9IDA7XG4gICAgICB2YXIgbGFzdHplcm8gPSAwO1xuICAgICAgdmFyIHpzdGFydCA9IDA7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBwYXJ0cyA9IFtcbiAgICAgICAgaW50c1swXSAmIDB4ZmZmZixcbiAgICAgICAgKGludHNbMF0gPj4gMTYpLFxuICAgICAgICBpbnRzWzFdICYgMHhmZmZmLFxuICAgICAgICAoaW50c1sxXSA+PiAxNiksXG4gICAgICAgIGludHNbMl0gJiAweGZmZmYsXG4gICAgICAgIChpbnRzWzJdID4+IDE2KSxcbiAgICAgICAgaW50c1szXSAmIDB4ZmZmZixcbiAgICAgICAgKGludHNbM10gPj4gMTYpXG4gICAgICBdO1xuICBcbiAgICAgIC8vIEhhbmRsZSBJUHY0LWNvbXBhdGlibGUsIElQdjQtbWFwcGVkLCBsb29wYmFjayBhbmQgYW55L3Vuc3BlY2lmaWVkIGFkZHJlc3Nlc1xuICBcbiAgICAgIHZhciBoYXNpcHY0ID0gdHJ1ZTtcbiAgICAgIHZhciB2NHBhcnQgPSBcIlwiO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIDEwIGhpZ2gtb3JkZXIgYnl0ZXMgYXJlIGFsbCB6ZXJvcyAoZmlyc3QgNSB3b3JkcylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldICE9PSAwKSB7IGhhc2lwdjQgPSBmYWxzZTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgXG4gICAgICBpZiAoaGFzaXB2NCkge1xuICAgICAgICAvLyBsb3ctb3JkZXIgMzItYml0cyBzdG9yZSBhbiBJUHY0IGFkZHJlc3MgKGJ5dGVzIDEzIHRvIDE2KSAobGFzdCAyIHdvcmRzKVxuICAgICAgICB2NHBhcnQgPSBpbmV0TnRvcDQocGFydHNbNl0gfCAocGFydHNbN10gPDwgMTYpKTtcbiAgICAgICAgLy8gSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzIGlmIDE2LWJpdCB2YWx1ZSAoYnl0ZXMgMTEgYW5kIDEyKSA9PSAweEZGRkYgKDZ0aCB3b3JkKVxuICAgICAgICBpZiAocGFydHNbNV0gPT09IC0xKSB7XG4gICAgICAgICAgc3RyID0gXCI6OmZmZmY6XCI7XG4gICAgICAgICAgc3RyICs9IHY0cGFydDtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIElQdjQtY29tcGF0aWJsZSBJUHY2IGFkZHJlc3MgaWYgMTYtYml0IHZhbHVlIChieXRlcyAxMSBhbmQgMTIpID09IDB4MDAwMCAoNnRoIHdvcmQpXG4gICAgICAgIGlmIChwYXJ0c1s1XSA9PT0gMCkge1xuICAgICAgICAgIHN0ciA9IFwiOjpcIjtcbiAgICAgICAgICAvL3NwZWNpYWwgY2FzZSBJUHY2IGFkZHJlc3Nlc1xuICAgICAgICAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMFwiKSB2NHBhcnQgPSBcIlwiOyAvLyBhbnkvdW5zcGVjaWZpZWQgYWRkcmVzc1xuICAgICAgICAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMVwiKSB2NHBhcnQgPSBcIjFcIjsvLyBsb29wYmFjayBhZGRyZXNzXG4gICAgICAgICAgc3RyICs9IHY0cGFydDtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgLy8gSGFuZGxlIGFsbCBvdGhlciBJUHY2IGFkZHJlc3Nlc1xuICBcbiAgICAgIC8vIGZpcnN0IHJ1biB0byBmaW5kIHRoZSBsb25nZXN0IGNvbnRpZ3VvdXMgemVybyB3b3Jkc1xuICAgICAgZm9yICh3b3JkID0gMDsgd29yZCA8IDg7IHdvcmQrKykge1xuICAgICAgICBpZiAocGFydHNbd29yZF0gPT09IDApIHtcbiAgICAgICAgICBpZiAod29yZCAtIGxhc3R6ZXJvID4gMSkge1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdHplcm8gPSB3b3JkO1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiBsb25nZXN0KSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IGxlbjtcbiAgICAgICAgICB6c3RhcnQgPSB3b3JkIC0gbG9uZ2VzdCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBmb3IgKHdvcmQgPSAwOyB3b3JkIDwgODsgd29yZCsrKSB7XG4gICAgICAgIGlmIChsb25nZXN0ID4gMSkge1xuICAgICAgICAgIC8vIGNvbXByZXNzIGNvbnRpZ3VvdXMgemVyb3MgLSB0byBwcm9kdWNlIFwiOjpcIlxuICAgICAgICAgIGlmIChwYXJ0c1t3b3JkXSA9PT0gMCAmJiB3b3JkID49IHpzdGFydCAmJiB3b3JkIDwgKHpzdGFydCArIGxvbmdlc3QpICkge1xuICAgICAgICAgICAgaWYgKHdvcmQgPT09IHpzdGFydCkge1xuICAgICAgICAgICAgICBzdHIgKz0gXCI6XCI7XG4gICAgICAgICAgICAgIGlmICh6c3RhcnQgPT09IDApIHN0ciArPSBcIjpcIjsgLy9sZWFkaW5nIHplcm9zIGNhc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0cyAxNi1iaXQgd29yZHMgZnJvbSBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYmVmb3JlIGNvbnZlcnRpbmcgdG8gaGV4IHN0cmluZ1xuICAgICAgICBzdHIgKz0gTnVtYmVyKF9udG9ocyhwYXJ0c1t3b3JkXSAmIDB4ZmZmZikpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgc3RyICs9IHdvcmQgPCA3ID8gXCI6XCIgOiBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGZ1bmN0aW9uIHJlYWRTb2NrYWRkcihzYSwgc2FsZW4pIHtcbiAgICAgIC8vIGZhbWlseSAvIHBvcnQgb2Zmc2V0cyBhcmUgY29tbW9uIHRvIGJvdGggc29ja2FkZHJfaW4gYW5kIHNvY2thZGRyX2luNlxuICAgICAgdmFyIGZhbWlseSA9IEhFQVAxNlsoKHNhKT4+MSldO1xuICAgICAgdmFyIHBvcnQgPSBfbnRvaHMoSEVBUFUxNlsoKChzYSkrKDIpKT4+MSldKTtcbiAgICAgIHZhciBhZGRyO1xuICBcbiAgICAgIHN3aXRjaCAoZmFtaWx5KSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoc2FsZW4gIT09IDE2KSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJubzogMjggfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkciA9IEhFQVAzMlsoKChzYSkrKDQpKT4+MildO1xuICAgICAgICAgIGFkZHIgPSBpbmV0TnRvcDQoYWRkcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgaWYgKHNhbGVuICE9PSAyOCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJybm86IDI4IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZHIgPSBbXG4gICAgICAgICAgICBIRUFQMzJbKCgoc2EpKyg4KSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDE2KSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDIwKSk+PjIpXVxuICAgICAgICAgIF07XG4gICAgICAgICAgYWRkciA9IGluZXROdG9wNihhZGRyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyBlcnJubzogNSB9O1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB7IGZhbWlseTogZmFtaWx5LCBhZGRyOiBhZGRyLCBwb3J0OiBwb3J0IH07XG4gICAgfVxuICAvKiogQHBhcmFtIHtib29sZWFuPX0gYWxsb3dOdWxsICovXG4gIGZ1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsIGFkZHJsZW4sIGFsbG93TnVsbCkge1xuICAgICAgaWYgKGFsbG93TnVsbCAmJiBhZGRycCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgaW5mbyA9IHJlYWRTb2NrYWRkcihhZGRycCwgYWRkcmxlbik7XG4gICAgICBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubyk7XG4gICAgICBpbmZvLmFkZHIgPSBETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKSB8fCBpbmZvLmFkZHI7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfYmluZChmZCwgYWRkciwgYWRkcmxlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0U29ja2V0QWRkcmVzcyhhZGRyLCBhZGRybGVuKTtcbiAgICAgIHNvY2suc29ja19vcHMuYmluZChzb2NrLCBpbmZvLmFkZHIsIGluZm8ucG9ydCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2hkaXIocGF0aCkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBGUy5jaGRpcihwYXRoKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9jb25uZWN0KGZkLCBhZGRyLCBhZGRybGVuKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuICAgICAgdmFyIGluZm8gPSBnZXRTb2NrZXRBZGRyZXNzKGFkZHIsIGFkZHJsZW4pO1xuICAgICAgc29jay5zb2NrX29wcy5jb25uZWN0KHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9kdXAoZmQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgb2xkID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHJldHVybiBGUy5vcGVuKG9sZC5wYXRoLCBvbGQuZmxhZ3MsIDApLmZkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9kdXAzKGZkLCBzdWdnZXN0RkQsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIG9sZCA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBhc3NlcnQoIWZsYWdzKTtcbiAgICAgIGlmIChvbGQuZmQgPT09IHN1Z2dlc3RGRCkgcmV0dXJuIC0yODtcbiAgICAgIHZhciBzdWdnZXN0ID0gRlMuZ2V0U3RyZWFtKHN1Z2dlc3RGRCk7XG4gICAgICBpZiAoc3VnZ2VzdCkgRlMuY2xvc2Uoc3VnZ2VzdCk7XG4gICAgICByZXR1cm4gRlMub3BlbihvbGQucGF0aCwgb2xkLmZsYWdzLCAwLCBzdWdnZXN0RkQsIHN1Z2dlc3RGRCkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCwgcGF0aCwgYW1vZGUsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIGFzc2VydChmbGFncyA9PT0gMCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvQWNjZXNzKHBhdGgsIGFtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIGlmIChhcmcgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV3U3RyZWFtO1xuICAgICAgICAgIG5ld1N0cmVhbSA9IEZTLm9wZW4oc3RyZWFtLnBhdGgsIHN0cmVhbS5mbGFncywgMCwgYXJnKTtcbiAgICAgICAgICByZXR1cm4gbmV3U3RyZWFtLmZkO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAwOyAgLy8gRkRfQ0xPRVhFQyBtYWtlcyBubyBzZW5zZSBmb3IgYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgLyogY2FzZSA1OiBDdXJyZW50bHkgaW4gbXVzbCBGX0dFVExLNjQgaGFzIHNhbWUgdmFsdWUgYXMgRl9HRVRMSywgc28gb21pdHRlZCB0byBhdm9pZCBkdXBsaWNhdGUgY2FzZSBibG9ja3MuIElmIHRoYXQgY2hhbmdlcywgdW5jb21tZW50IHRoaXMgKi8ge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAvLyBXZSdyZSBhbHdheXMgdW5sb2NrZWQuXG4gICAgICAgICAgSEVBUDE2WygoKGFyZykrKG9mZnNldCkpPj4xKV0gPSAyO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAvKiBjYXNlIDY6IEN1cnJlbnRseSBpbiBtdXNsIEZfU0VUTEs2NCBoYXMgc2FtZSB2YWx1ZSBhcyBGX1NFVExLLCBzbyBvbWl0dGVkIHRvIGF2b2lkIGR1cGxpY2F0ZSBjYXNlIGJsb2Nrcy4gSWYgdGhhdCBjaGFuZ2VzLCB1bmNvbW1lbnQgdGhpcyAqL1xuICAgICAgICAvKiBjYXNlIDc6IEN1cnJlbnRseSBpbiBtdXNsIEZfU0VUTEtXNjQgaGFzIHNhbWUgdmFsdWUgYXMgRl9TRVRMS1csIHNvIG9taXR0ZWQgdG8gYXZvaWQgZHVwbGljYXRlIGNhc2UgYmxvY2tzLiBJZiB0aGF0IGNoYW5nZXMsIHVuY29tbWVudCB0aGlzICovXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIDA7IC8vIFByZXRlbmQgdGhhdCB0aGUgbG9ja2luZyBpcyBzdWNjZXNzZnVsLlxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIC0yODsgLy8gVGhlc2UgYXJlIGZvciBzb2NrZXRzLiBXZSBkb24ndCBoYXZlIHRoZW0gZnVsbHkgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgLy8gbXVzbCB0cnVzdHMgZ2V0b3duIHJldHVybiB2YWx1ZXMsIGR1ZSB0byBhIGJ1ZyB3aGVyZSB0aGV5IG11c3QgYmUsIGFzIHRoZXkgb3ZlcmxhcCB3aXRoIGVycm9ycy4ganVzdCByZXR1cm4gLTEgaGVyZSwgc28gZm5jdGwoKSByZXR1cm5zIHRoYXQsIGFuZCB3ZSBzZXQgZXJybm8gb3Vyc2VsdmVzLlxuICAgICAgICAgIHNldEVyck5vKDI4KTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0Y3dkKGJ1Ziwgc2l6ZSkge1xuICB0cnkge1xuICBcbiAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLTI4O1xuICAgICAgdmFyIGN3ZCA9IEZTLmN3ZCgpO1xuICAgICAgdmFyIGN3ZExlbmd0aEluQnl0ZXMgPSBsZW5ndGhCeXRlc1VURjgoY3dkKTtcbiAgICAgIGlmIChzaXplIDwgY3dkTGVuZ3RoSW5CeXRlcyArIDEpIHJldHVybiAtNjg7XG4gICAgICBzdHJpbmdUb1VURjgoY3dkLCBidWYsIHNpemUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0ZGVudHM2NChmZCwgZGlycCwgY291bnQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKVxuICAgICAgaWYgKCFzdHJlYW0uZ2V0ZGVudHMpIHtcbiAgICAgICAgc3RyZWFtLmdldGRlbnRzID0gRlMucmVhZGRpcihzdHJlYW0ucGF0aCk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHN0cnVjdF9zaXplID0gMjgwO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgb2ZmID0gRlMubGxzZWVrKHN0cmVhbSwgMCwgMSk7XG4gIFxuICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3Iob2ZmIC8gc3RydWN0X3NpemUpO1xuICBcbiAgICAgIHdoaWxlIChpZHggPCBzdHJlYW0uZ2V0ZGVudHMubGVuZ3RoICYmIHBvcyArIHN0cnVjdF9zaXplIDw9IGNvdW50KSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBuYW1lID0gc3RyZWFtLmdldGRlbnRzW2lkeF07XG4gICAgICAgIGlmIChuYW1lID09PSAnLicpIHtcbiAgICAgICAgICBpZCA9IHN0cmVhbS5ub2RlLmlkO1xuICAgICAgICAgIHR5cGUgPSA0OyAvLyBEVF9ESVJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnLi4nKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoc3RyZWFtLnBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIGlkID0gbG9va3VwLm5vZGUuaWQ7XG4gICAgICAgICAgdHlwZSA9IDQ7IC8vIERUX0RJUlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZCA9IEZTLmxvb2t1cE5vZGUoc3RyZWFtLm5vZGUsIG5hbWUpO1xuICAgICAgICAgIGlkID0gY2hpbGQuaWQ7XG4gICAgICAgICAgdHlwZSA9IEZTLmlzQ2hyZGV2KGNoaWxkLm1vZGUpID8gMiA6ICAvLyBEVF9DSFIsIGNoYXJhY3RlciBkZXZpY2UuXG4gICAgICAgICAgICAgICAgIEZTLmlzRGlyKGNoaWxkLm1vZGUpID8gNCA6ICAgICAvLyBEVF9ESVIsIGRpcmVjdG9yeS5cbiAgICAgICAgICAgICAgICAgRlMuaXNMaW5rKGNoaWxkLm1vZGUpID8gMTAgOiAgIC8vIERUX0xOSywgc3ltYm9saWMgbGluay5cbiAgICAgICAgICAgICAgICAgODsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERUX1JFRywgcmVndWxhciBmaWxlLlxuICAgICAgICB9XG4gICAgICAgIGFzc2VydChpZCk7XG4gICAgICAgICh0ZW1wSTY0ID0gW2lkPj4+MCwodGVtcERvdWJsZT1pZCwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKGRpcnAgKyBwb3MpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChkaXJwICsgcG9zKSsoNCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgKHRlbXBJNjQgPSBbKGlkeCArIDEpICogc3RydWN0X3NpemU+Pj4wLCh0ZW1wRG91YmxlPShpZHggKyAxKSAqIHN0cnVjdF9zaXplLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGRpcnAgKyBwb3MpKyg4KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGRpcnAgKyBwb3MpKygxMikpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUDE2WygoKGRpcnAgKyBwb3MpKygxNikpPj4xKV0gPSAyODA7XG4gICAgICAgIEhFQVA4WygoKGRpcnAgKyBwb3MpKygxOCkpPj4wKV0gPSB0eXBlO1xuICAgICAgICBzdHJpbmdUb1VURjgobmFtZSwgZGlycCArIHBvcyArIDE5LCAyNTYpO1xuICAgICAgICBwb3MgKz0gc3RydWN0X3NpemU7XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgaWR4ICogc3RydWN0X3NpemUsIDApO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0c29ja25hbWUoZmQsIGFkZHIsIGFkZHJsZW4pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBlcnIoXCJfX3N5c2NhbGxfZ2V0c29ja25hbWUgXCIgKyBmZCk7XG4gICAgICB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gICAgICAvLyBUT0RPOiBzb2NrLnNhZGRyIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQsIHNlZSBUT0RPIGluIHdlYnNvY2tldF9zb2NrX29wcy5nZXRuYW1lXG4gICAgICB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUoc29jay5zYWRkciB8fCAnMC4wLjAuMCcpLCBzb2NrLnNwb3J0LCBhZGRybGVuKTtcbiAgICAgIGFzc2VydCghZXJybm8pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsIGxldmVsLCBvcHRuYW1lLCBvcHR2YWwsIG9wdGxlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIC8vIE1pbmltYWwgZ2V0c29ja29wdCBhaW1lZCBhdCByZXNvbHZpbmcgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8yMjExXG4gICAgICAvLyBzbyBvbmx5IHN1cHBvcnRzIFNPTF9TT0NLRVQgd2l0aCBTT19FUlJPUi5cbiAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICBpZiAob3B0bmFtZSA9PT0gNCkge1xuICAgICAgICAgIEhFQVAzMlsoKG9wdHZhbCk+PjIpXSA9IHNvY2suZXJyb3I7XG4gICAgICAgICAgSEVBUDMyWygob3B0bGVuKT4+MildID0gNDtcbiAgICAgICAgICBzb2NrLmVycm9yID0gbnVsbDsgLy8gQ2xlYXIgdGhlIGVycm9yIChUaGUgU09fRVJST1Igb3B0aW9uIG9idGFpbnMgYW5kIHRoZW4gY2xlYXJzIHRoaXMgZmllbGQpLlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTUwOyAvLyBUaGUgb3B0aW9uIGlzIHVua25vd24gYXQgdGhlIGxldmVsIGluZGljYXRlZC5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIDIxNTA5OlxuICAgICAgICBjYXNlIDIxNTA1OiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MTA6XG4gICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgIGNhc2UgMjE1MTI6XG4gICAgICAgIGNhc2UgMjE1MDY6XG4gICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgIGNhc2UgMjE1MDg6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIG5vLW9wLCBub3QgYWN0dWFsbHkgYWRqdXN0aW5nIHRlcm1pbmFsIHNldHRpbmdzXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUxOToge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIEhFQVAzMlsoKGFyZ3ApPj4yKV0gPSAwO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MjA6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIC0yODsgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MzE6IHtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTIzOiB7XG4gICAgICAgICAgLy8gVE9ETzogaW4gdGhlb3J5IHdlIHNob3VsZCB3cml0ZSB0byB0aGUgd2luc2l6ZSBzdHJ1Y3QgdGhhdCBnZXRzXG4gICAgICAgICAgLy8gcGFzc2VkIGluLCBidXQgZm9yIG5vdyBtdXNsIGRvZXNuJ3QgcmVhZCBhbnl0aGluZyBvbiBpdFxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTI0OiB7XG4gICAgICAgICAgLy8gVE9ETzogdGVjaG5pY2FsbHksIHRoaXMgaW9jdGwgY2FsbCBzaG91bGQgY2hhbmdlIHRoZSB3aW5kb3cgc2l6ZS5cbiAgICAgICAgICAvLyBidXQsIHNpbmNlIGVtc2NyaXB0ZW4gZG9lc24ndCBoYXZlIGFueSBjb25jZXB0IG9mIGEgdGVybWluYWwgd2luZG93XG4gICAgICAgICAgLy8geWV0LCB3ZSdsbCBqdXN0IHNpbGVudGx5IHRocm93IGl0IGF3YXkgYXMgd2UgZG8gVElPQ0dXSU5TWlxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiBhYm9ydCgnYmFkIGlvY3RsIHN5c2NhbGwgJyArIG9wKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbGlzdGVuKGZkLCBiYWNrbG9nKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuICAgICAgc29jay5zb2NrX29wcy5saXN0ZW4oc29jaywgYmFja2xvZyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5sc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXIocGF0aCwgbW9kZSkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9Na2RpcihwYXRoLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtub2QocGF0aCwgbW9kZSwgZGV2KSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb01rbm9kKHBhdGgsIG1vZGUsIGRldik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX25ld2ZzdGF0YXQoZGlyZmQsIHBhdGgsIGJ1ZiwgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgdmFyIG5vZm9sbG93ID0gZmxhZ3MgJiAyNTY7XG4gICAgICB2YXIgYWxsb3dFbXB0eSA9IGZsYWdzICYgNDA5NjtcbiAgICAgIGZsYWdzID0gZmxhZ3MgJiAofjQzNTIpO1xuICAgICAgYXNzZXJ0KCFmbGFncywgZmxhZ3MpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQobm9mb2xsb3cgPyBGUy5sc3RhdCA6IEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICB2YXIgbW9kZSA9IHZhcmFyZ3MgPyBTWVNDQUxMUy5nZXQoKSA6IDA7XG4gICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICB2YXIgUElQRUZTID0ge0JVQ0tFVF9CVUZGRVJfU0laRTo4MTkyLG1vdW50OmZ1bmN0aW9uIChtb3VudCkge1xuICAgICAgICAvLyBEbyBub3QgcG9sbHV0ZSB0aGUgcmVhbCByb290IGRpcmVjdG9yeSBvciBpdHMgY2hpbGQgbm9kZXMgd2l0aCBwaXBlc1xuICAgICAgICAvLyBMb29rcyBsaWtlIGl0IGlzIE9LIHRvIGNyZWF0ZSBhbm90aGVyIHBzZXVkby1yb290IG5vZGUgbm90IGxpbmtlZCB0byB0aGUgRlMucm9vdCBoaWVyYXJjaHkgdGhpcyB3YXlcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAvKiAwNzc3ICovLCAwKTtcbiAgICAgIH0sY3JlYXRlUGlwZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaXBlID0ge1xuICAgICAgICAgIGJ1Y2tldHM6IFtdLFxuICAgICAgICAgIC8vIHJlZmNudCAyIGJlY2F1c2UgcGlwZSBoYXMgYSByZWFkIGVuZCBhbmQgYSB3cml0ZSBlbmQuIFdlIG5lZWQgdG8gYmVcbiAgICAgICAgICAvLyBhYmxlIHRvIHJlYWQgZnJvbSB0aGUgcmVhZCBlbmQgYWZ0ZXIgd3JpdGUgZW5kIGlzIGNsb3NlZC5cbiAgICAgICAgICByZWZjbnQgOiAyLFxuICAgICAgICB9O1xuICBcbiAgICAgICAgcGlwZS5idWNrZXRzLnB1c2goe1xuICAgICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSksXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICB2YXIgck5hbWUgPSBQSVBFRlMubmV4dG5hbWUoKTtcbiAgICAgICAgdmFyIHdOYW1lID0gUElQRUZTLm5leHRuYW1lKCk7XG4gICAgICAgIHZhciByTm9kZSA9IEZTLmNyZWF0ZU5vZGUoUElQRUZTLnJvb3QsIHJOYW1lLCA0MDk2LCAwKTtcbiAgICAgICAgdmFyIHdOb2RlID0gRlMuY3JlYXRlTm9kZShQSVBFRlMucm9vdCwgd05hbWUsIDQwOTYsIDApO1xuICBcbiAgICAgICAgck5vZGUucGlwZSA9IHBpcGU7XG4gICAgICAgIHdOb2RlLnBpcGUgPSBwaXBlO1xuICBcbiAgICAgICAgdmFyIHJlYWRhYmxlU3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBwYXRoOiByTmFtZSxcbiAgICAgICAgICBub2RlOiByTm9kZSxcbiAgICAgICAgICBmbGFnczogMCxcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogUElQRUZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJOb2RlLnN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICBcbiAgICAgICAgdmFyIHdyaXRhYmxlU3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBwYXRoOiB3TmFtZSxcbiAgICAgICAgICBub2RlOiB3Tm9kZSxcbiAgICAgICAgICBmbGFnczogMSxcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogUElQRUZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gICAgICAgIHdOb2RlLnN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xuICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWFkYWJsZV9mZDogcmVhZGFibGVTdHJlYW0uZmQsXG4gICAgICAgICAgd3JpdGFibGVfZmQ6IHdyaXRhYmxlU3RyZWFtLmZkXG4gICAgICAgIH07XG4gICAgICB9LHN0cmVhbV9vcHM6e3BvbGw6ZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgXG4gICAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICgyNTYgfCA0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBpcGUuYnVja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGlwZS5idWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IHBpcGUuYnVja2V0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0Lm9mZnNldCAtIGJ1Y2tldC5yb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICg2NCB8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0saW9jdGw6ZnVuY3Rpb24gKHN0cmVhbSwgcmVxdWVzdCwgdmFyYXJncykge1xuICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfSxmc3luYzpmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9LHJlYWQ6ZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24gLyogaWdub3JlZCAqLykge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IDA7XG4gIFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGlwZS5idWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gcGlwZS5idWNrZXRzW2ldO1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBidWNrZXQub2Zmc2V0IC0gYnVja2V0LnJvZmZzZXQ7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBhc3NlcnQoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpO1xuICAgICAgICAgIHZhciBkYXRhID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgXG4gICAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gQmVoYXZlIGFzIGlmIHRoZSByZWFkIGVuZCBpcyBhbHdheXMgbm9uLWJsb2NraW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvUmVhZCA9IE1hdGgubWluKGN1cnJlbnRMZW5ndGgsIGxlbmd0aCk7XG4gIFxuICAgICAgICAgIHZhciB0b3RhbFJlYWQgPSB0b1JlYWQ7XG4gICAgICAgICAgdmFyIHRvUmVtb3ZlID0gMDtcbiAgXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaXBlLmJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyQnVja2V0ID0gcGlwZS5idWNrZXRzW2ldO1xuICAgICAgICAgICAgdmFyIGJ1Y2tldFNpemUgPSBjdXJyQnVja2V0Lm9mZnNldCAtIGN1cnJCdWNrZXQucm9mZnNldDtcbiAgXG4gICAgICAgICAgICBpZiAodG9SZWFkIDw9IGJ1Y2tldFNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIHRtcFNsaWNlID0gY3VyckJ1Y2tldC5idWZmZXIuc3ViYXJyYXkoY3VyckJ1Y2tldC5yb2Zmc2V0LCBjdXJyQnVja2V0Lm9mZnNldCk7XG4gICAgICAgICAgICAgIGlmICh0b1JlYWQgPCBidWNrZXRTaXplKSB7XG4gICAgICAgICAgICAgICAgdG1wU2xpY2UgPSB0bXBTbGljZS5zdWJhcnJheSgwLCB0b1JlYWQpO1xuICAgICAgICAgICAgICAgIGN1cnJCdWNrZXQucm9mZnNldCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhLnNldCh0bXBTbGljZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHRtcFNsaWNlID0gY3VyckJ1Y2tldC5idWZmZXIuc3ViYXJyYXkoY3VyckJ1Y2tldC5yb2Zmc2V0LCBjdXJyQnVja2V0Lm9mZnNldCk7XG4gICAgICAgICAgICAgIGRhdGEuc2V0KHRtcFNsaWNlKTtcbiAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkodG1wU2xpY2UuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHRvUmVhZCAtPSB0bXBTbGljZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB0b1JlbW92ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlID09IHBpcGUuYnVja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBnZW5lcmF0ZSBleGNlc3NpdmUgZ2FyYmFnZSBpbiB1c2UgY2FzZXMgc3VjaCBhc1xuICAgICAgICAgICAgLy8gd3JpdGUgc2V2ZXJhbCBieXRlcywgcmVhZCBldmVyeXRoaW5nLCB3cml0ZSBzZXZlcmFsIGJ5dGVzLCByZWFkIGV2ZXJ5dGhpbmcuLi5cbiAgICAgICAgICAgIHRvUmVtb3ZlLS07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHNbdG9SZW1vdmVdLm9mZnNldCA9IDA7XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHNbdG9SZW1vdmVdLnJvZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcGlwZS5idWNrZXRzLnNwbGljZSgwLCB0b1JlbW92ZSk7XG4gIFxuICAgICAgICAgIHJldHVybiB0b3RhbFJlYWQ7XG4gICAgICAgIH0sd3JpdGU6ZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24gLyogaWdub3JlZCAqLykge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgXG4gICAgICAgICAgYXNzZXJ0KGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gIFxuICAgICAgICAgIHZhciBkYXRhTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmIChkYXRhTGVuIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGN1cnJCdWNrZXQgPSBudWxsO1xuICBcbiAgICAgICAgICBpZiAocGlwZS5idWNrZXRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBjdXJyQnVja2V0ID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChjdXJyQnVja2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckJ1Y2tldCA9IHBpcGUuYnVja2V0c1twaXBlLmJ1Y2tldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBhc3NlcnQoY3VyckJ1Y2tldC5vZmZzZXQgPD0gUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSk7XG4gIFxuICAgICAgICAgIHZhciBmcmVlQnl0ZXNJbkN1cnJCdWZmZXIgPSBQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFIC0gY3VyckJ1Y2tldC5vZmZzZXQ7XG4gICAgICAgICAgaWYgKGZyZWVCeXRlc0luQ3VyckJ1ZmZlciA+PSBkYXRhTGVuKSB7XG4gICAgICAgICAgICBjdXJyQnVja2V0LmJ1ZmZlci5zZXQoZGF0YSwgY3VyckJ1Y2tldC5vZmZzZXQpO1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5vZmZzZXQgKz0gZGF0YUxlbjtcbiAgICAgICAgICAgIHJldHVybiBkYXRhTGVuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJlZUJ5dGVzSW5DdXJyQnVmZmVyID4gMCkge1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5idWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJlZUJ5dGVzSW5DdXJyQnVmZmVyKSwgY3VyckJ1Y2tldC5vZmZzZXQpO1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5vZmZzZXQgKz0gZnJlZUJ5dGVzSW5DdXJyQnVmZmVyO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkoZnJlZUJ5dGVzSW5DdXJyQnVmZmVyLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIG51bUJ1Y2tldHMgPSAoZGF0YS5ieXRlTGVuZ3RoIC8gUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSkgfCAwO1xuICAgICAgICAgIHZhciByZW1FbGVtZW50cyA9IGRhdGEuYnl0ZUxlbmd0aCAlIFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkU7XG4gIFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQnVja2V0czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3QnVja2V0ID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChuZXdCdWNrZXQpO1xuICAgICAgICAgICAgbmV3QnVja2V0LmJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheSgwLCBQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFKSk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zdWJhcnJheShQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKHJlbUVsZW1lbnRzID4gMCkge1xuICAgICAgICAgICAgdmFyIG5ld0J1Y2tldCA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFKSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChuZXdCdWNrZXQpO1xuICAgICAgICAgICAgbmV3QnVja2V0LmJ1ZmZlci5zZXQoZGF0YSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICByZXR1cm4gZGF0YUxlbjtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHBpcGUgPSBzdHJlYW0ubm9kZS5waXBlO1xuICAgICAgICAgIHBpcGUucmVmY250LS07XG4gICAgICAgICAgaWYgKHBpcGUucmVmY250ID09PSAwKSB7XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfX0sbmV4dG5hbWU6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIVBJUEVGUy5uZXh0bmFtZS5jdXJyZW50KSB7XG4gICAgICAgICAgUElQRUZTLm5leHRuYW1lLmN1cnJlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncGlwZVsnICsgKFBJUEVGUy5uZXh0bmFtZS5jdXJyZW50KyspICsgJ10nO1xuICAgICAgfX07XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcGlwZShmZFB0cikge1xuICB0cnkge1xuICBcbiAgICAgIGlmIChmZFB0ciA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIxKTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgcmVzID0gUElQRUZTLmNyZWF0ZVBpcGUoKTtcbiAgXG4gICAgICBIRUFQMzJbKChmZFB0cik+PjIpXSA9IHJlcy5yZWFkYWJsZV9mZDtcbiAgICAgIEhFQVAzMlsoKChmZFB0cikrKDQpKT4+MildID0gcmVzLndyaXRhYmxlX2ZkO1xuICBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9yZWFkbGlua2F0KGRpcmZkLCBwYXRoLCBidWYsIGJ1ZnNpemUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1JlYWRsaW5rKHBhdGgsIGJ1ZiwgYnVmc2l6ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JlY3Zmcm9tKGZkLCBidWYsIGxlbiwgZmxhZ3MsIGFkZHIsIGFkZHJsZW4pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gICAgICB2YXIgbXNnID0gc29jay5zb2NrX29wcy5yZWN2bXNnKHNvY2ssIGxlbik7XG4gICAgICBpZiAoIW1zZykgcmV0dXJuIDA7IC8vIHNvY2tldCBpcyBjbG9zZWRcbiAgICAgIGlmIChhZGRyKSB7XG4gICAgICAgIHZhciBlcnJubyA9IHdyaXRlU29ja2FkZHIoYWRkciwgc29jay5mYW1pbHksIEROUy5sb29rdXBfbmFtZShtc2cuYWRkciksIG1zZy5wb3J0LCBhZGRybGVuKTtcbiAgICAgICAgYXNzZXJ0KCFlcnJubyk7XG4gICAgICB9XG4gICAgICBIRUFQVTguc2V0KG1zZy5idWZmZXIsIGJ1Zik7XG4gICAgICByZXR1cm4gbXNnLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9yZW5hbWVhdChvbGRkaXJmZCwgb2xkcGF0aCwgbmV3ZGlyZmQsIG5ld3BhdGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBvbGRwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKG9sZHBhdGgpO1xuICAgICAgbmV3cGF0aCA9IFNZU0NBTExTLmdldFN0cihuZXdwYXRoKTtcbiAgICAgIG9sZHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChvbGRkaXJmZCwgb2xkcGF0aCk7XG4gICAgICBuZXdwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQobmV3ZGlyZmQsIG5ld3BhdGgpO1xuICAgICAgRlMucmVuYW1lKG9sZHBhdGgsIG5ld3BhdGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JtZGlyKHBhdGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc2VuZHRvKGZkLCBtZXNzYWdlLCBsZW5ndGgsIGZsYWdzLCBhZGRyLCBhZGRyX2xlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBkZXN0ID0gZ2V0U29ja2V0QWRkcmVzcyhhZGRyLCBhZGRyX2xlbiwgdHJ1ZSk7XG4gICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgLy8gc2VuZCwgbm8gYWRkcmVzcyBwcm92aWRlZFxuICAgICAgICByZXR1cm4gRlMud3JpdGUoc29jay5zdHJlYW0sIEhFQVA4LG1lc3NhZ2UsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZW5kdG8gYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gc29jay5zb2NrX29wcy5zZW5kbXNnKHNvY2ssIEhFQVA4LG1lc3NhZ2UsIGxlbmd0aCwgZGVzdC5hZGRyLCBkZXN0LnBvcnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLCB0eXBlLCBwcm90b2NvbCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gU09DS0ZTLmNyZWF0ZVNvY2tldChkb21haW4sIHR5cGUsIHByb3RvY29sKTtcbiAgICAgIGFzc2VydChzb2NrLnN0cmVhbS5mZCA8IDY0KTsgLy8gWFhYID8gc2VsZWN0KCkgYXNzdW1lcyBzb2NrZXQgZmQgdmFsdWVzIGFyZSBpbiAwLi42M1xuICAgICAgcmV0dXJuIHNvY2suc3RyZWFtLmZkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc3ltbGluayh0YXJnZXQsIGxpbmtwYXRoKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdGFyZ2V0ID0gU1lTQ0FMTFMuZ2V0U3RyKHRhcmdldCk7XG4gICAgICBsaW5rcGF0aCA9IFNZU0NBTExTLmdldFN0cihsaW5rcGF0aCk7XG4gICAgICBGUy5zeW1saW5rKHRhcmdldCwgbGlua3BhdGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgPT09IDUxMikge1xuICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFib3J0KCdJbnZhbGlkIGZsYWdzIHBhc3NlZCB0byB1bmxpbmthdCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3V0aW1lbnNhdChkaXJmZCwgcGF0aCwgdGltZXMsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIGFzc2VydChmbGFncyA9PT0gMCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIHRydWUpO1xuICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICB2YXIgYXRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbXRpbWUgPSBhdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWNvbmRzID0gSEVBUDMyWygodGltZXMpPj4yKV07XG4gICAgICAgIHZhciBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDQpKT4+MildO1xuICAgICAgICBhdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgICAgdGltZXMgKz0gODtcbiAgICAgICAgc2Vjb25kcyA9IEhFQVAzMlsoKHRpbWVzKT4+MildO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDQpKT4+MildO1xuICAgICAgICBtdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgIH1cbiAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBfX190YWJsZV9iYXNlID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogZmFsc2V9LCAxKTtcblxuICB2YXIgRU5WID0ge307XG4gIFxuICBmdW5jdGlvbiBkbFNldEVycm9yKG1zZykge1xuICAgICAgd2l0aFN0YWNrU2F2ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNtc2cgPSBhbGxvY2F0ZVVURjhPblN0YWNrKG1zZyk7XG4gICAgICAgIF9fX2RsX3NldGVycihjbXNnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZnVuY3Rpb24gZGxvcGVuSW50ZXJuYWwoaGFuZGxlLCBqc2ZsYWdzKSB7XG4gICAgICAvLyB2b2lkICpkbG9wZW4oY29uc3QgY2hhciAqZmlsZSwgaW50IG1vZGUpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvZGxvcGVuLmh0bWxcbiAgICAgIHZhciBmaWxlbmFtZSA9IFVURjhUb1N0cmluZyhoYW5kbGUgKyA0NCk7XG4gICAgICB2YXIgZmxhZ3MgPSBIRUFQMzJbKCgoaGFuZGxlKSsoMjApKT4+MildO1xuICAgICAgZmlsZW5hbWUgPSBQQVRILm5vcm1hbGl6ZShmaWxlbmFtZSk7XG4gICAgICB2YXIgc2VhcmNocGF0aHMgPSBbXTtcbiAgXG4gICAgICB2YXIgaXNWYWxpZEZpbGUgPSAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHRhcmdldCA9IEZTLmZpbmRPYmplY3QoZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0ICYmICF0YXJnZXQuaXNGb2xkZXIgJiYgIXRhcmdldC5pc0RldmljZTtcbiAgICAgIH07XG4gIFxuICAgICAgaWYgKCFpc1ZhbGlkRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgICAgaWYgKEVOVlsnTERfTElCUkFSWV9QQVRIJ10pIHtcbiAgICAgICAgICBzZWFyY2hwYXRocyA9IEVOVlsnTERfTElCUkFSWV9QQVRIJ10uc3BsaXQoJzonKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZm9yICh2YXIgaWRlbnQgaW4gc2VhcmNocGF0aHMpIHtcbiAgICAgICAgICB2YXIgc2VhcmNoZmlsZSA9IFBBVEguam9pbjIoc2VhcmNocGF0aHNbaWRlbnRdLCBmaWxlbmFtZSk7XG4gICAgICAgICAgaWYgKGlzVmFsaWRGaWxlKHNlYXJjaGZpbGUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHNlYXJjaGZpbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IFJUTERfTk9XIGFuZCBSVExEX0xBWlkuXG4gICAgICB2YXIgY29tYmluZWRGbGFncyA9IHtcbiAgICAgICAgZ2xvYmFsOiAgICBCb29sZWFuKGZsYWdzICYgMjU2KSxcbiAgICAgICAgbm9kZWxldGU6ICBCb29sZWFuKGZsYWdzICYgNDA5NiksXG4gICAgICAgIGxvYWRBc3luYzoganNmbGFncy5sb2FkQXN5bmMsXG4gICAgICAgIGZzOiAgICAgICAganNmbGFncy5mcyxcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoanNmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShmaWxlbmFtZSwgY29tYmluZWRGbGFncywgaGFuZGxlKTtcbiAgICAgIH1cbiAgXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9hZER5bmFtaWNMaWJyYXJ5KGZpbGVuYW1lLCBjb21iaW5lZEZsYWdzLCBoYW5kbGUpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycignRXJyb3IgaW4gbG9hZGluZyBkeW5hbWljIGxpYnJhcnkgJyArIGZpbGVuYW1lICsgXCI6IFwiICsgZSk7XG4gICAgICAgIGRsU2V0RXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGR5bmFtaWMgbGliOiAnICsgZmlsZW5hbWUgKyAnXFxuJyArIGUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGZ1bmN0aW9uIF9fZGxvcGVuX2pzKGhhbmRsZSkge1xuICAgICAgdmFyIGpzZmxhZ3MgPSB7XG4gICAgICAgIGxvYWRBc3luYzogZmFsc2UsXG4gICAgICAgIGZzOiBGUywgLy8gbG9hZCBsaWJyYXJpZXMgZnJvbSBwcm92aWRlZCBmaWxlc3lzdGVtXG4gICAgICB9XG4gICAgICByZXR1cm4gZGxvcGVuSW50ZXJuYWwoaGFuZGxlLCBqc2ZsYWdzKTtcbiAgICB9XG4gIF9fZGxvcGVuX2pzLnNpZyA9ICdpaWlpJztcblxuICBmdW5jdGlvbiBfX2Rsc3ltX2pzKGhhbmRsZSwgc3ltYm9sKSB7XG4gICAgICAvLyB2b2lkICpkbHN5bSh2b2lkICpyZXN0cmljdCBoYW5kbGUsIGNvbnN0IGNoYXIgKnJlc3RyaWN0IG5hbWUpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvZGxzeW0uaHRtbFxuICAgICAgc3ltYm9sID0gVVRGOFRvU3RyaW5nKHN5bWJvbCk7XG4gICAgICB2YXIgcmVzdWx0O1xuICBcbiAgICAgIGlmIChoYW5kbGUgPT0gMCkge1xuICAgICAgICByZXN1bHQgPSByZXNvbHZlR2xvYmFsU3ltYm9sKHN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGxTZXRFcnJvcignVHJpZWQgdG8gbG9va3VwIHVua25vd24gc3ltYm9sIFwiJyArIHN5bWJvbCArICdcIiBpbiBkeW5hbWljIGxpYjogUlRMRF9ERUZBVUxUJyk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaWIgPSBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICBhc3NlcnQobGliLCAnVHJpZWQgdG8gZGxzeW0oKSBmcm9tIGFuIHVub3BlbmVkIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICAgIGlmICghbGliLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2wpKSB7XG4gICAgICAgICAgZGxTZXRFcnJvcignVHJpZWQgdG8gbG9va3VwIHVua25vd24gc3ltYm9sIFwiJyArIHN5bWJvbCArICdcIiBpbiBkeW5hbWljIGxpYjogJyArIGxpYi5uYW1lKVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpYi5tb2R1bGVbJ29yaWckJyArIHN5bWJvbF07XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICByZXN1bHQgPSBsaWIubW9kdWxlW3N5bWJvbF07XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGZ1bmN0aW9uIGludG8gdGhlIHdhc20gdGFibGUuICBJZiBpdHMgYSBkaXJlY3Qgd2FzbSBmdW5jdGlvblxuICAgICAgICAvLyB0aGUgc2Vjb25kIGFyZ3VtZW50IHdpbGwgbm90IGJlIG5lZWRlZC4gIElmIGl0cyBhIEpTIGZ1bmN0aW9uIHdlIHJlbHlcbiAgICAgICAgLy8gb24gdGhlIGBzaWdgIGF0dHJpYnV0ZSBiZWluZyBzZXQgYmFzZWQgb24gdGhlIGA8ZnVuYz5fX3NpZ2Agc3BlY2lmaWVkXG4gICAgICAgIC8vIGluIGxpYnJhcnkgSlMgZmlsZS5cbiAgICAgICAgcmVzdWx0ID0gYWRkRnVuY3Rpb24ocmVzdWx0LCByZXN1bHQuc2lnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBfX2Rsc3ltX2pzLnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9kYXRlX25vdygpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cbiAgX19lbXNjcmlwdGVuX2RhdGVfbm93LnNpZyA9ICdqJztcblxuICB2YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlOztcbiAgZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuICAgICAgcmV0dXJuIG5vd0lzTW9ub3RvbmljO1xuICAgIH1cblxuICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fdGhyb3dfbG9uZ2ptcCgpIHsgdGhyb3cgSW5maW5pdHk7IH1cbiAgX19lbXNjcmlwdGVuX3Rocm93X2xvbmdqbXAuc2lnID0gJ3YnO1xuXG4gIGZ1bmN0aW9uIF9fZ210aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKEhFQVAzMlsoKHRpbWUpPj4yKV0qMTAwMCk7XG4gICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoNCkpPj4yKV0gPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDgpKT4+MildID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTIpKT4+MildID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCktMTkwMDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApO1xuICAgICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICB9XG4gIF9fZ210aW1lX2pzLnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKEhFQVAzMlsoKHRpbWUpPj4yKV0qMTAwMCk7XG4gICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoNCkpPj4yKV0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDgpKT4+MildID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTIpKT4+MildID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0gPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gPSBkYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0RGF5KCk7XG4gIFxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciB5ZGF5ID0gKChkYXRlLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyOCkpPj4yKV0gPSB5ZGF5O1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzYpKT4+MildID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG4gIFxuICAgICAgLy8gQXR0ZW50aW9uOiBEU1QgaXMgaW4gRGVjZW1iZXIgaW4gU291dGgsIGFuZCBzb21lIHJlZ2lvbnMgZG9uJ3QgaGF2ZSBEU1QgYXQgYWxsLlxuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdCA9IChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygzMikpPj4yKV0gPSBkc3Q7XG4gICAgfVxuICBfX2xvY2FsdGltZV9qcy5zaWcgPSAnaWlpJztcblxuICBmdW5jdGlvbiBfX21rdGltZV9qcyh0bVB0cikge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gKyAxOTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gIFxuICAgICAgLy8gVGhlcmUncyBhbiBhbWJpZ3VvdXMgaG91ciB3aGVuIHRoZSB0aW1lIGdvZXMgYmFjazsgdGhlIHRtX2lzZHN0IGZpZWxkIGlzXG4gICAgICAvLyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBpdC4gIERhdGUoKSBiYXNpY2FsbHkgZ3Vlc3Nlcywgc28gd2UgZml4IGl0IHVwIGlmIGl0XG4gICAgICAvLyBndWVzc2VkIHdyb25nLCBvciBmaWxsIGluIHRtX2lzZHN0IHdpdGggdGhlIGd1ZXNzIGlmIGl0J3MgLTEuXG4gICAgICB2YXIgZHN0ID0gSEVBUDMyWygoKHRtUHRyKSsoMzIpKT4+MildO1xuICAgICAgdmFyIGd1ZXNzZWRPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdE9mZnNldCA9IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTsgLy8gRFNUIGlzIGluIERlY2VtYmVyIGluIFNvdXRoXG4gICAgICBpZiAoZHN0IDwgMCkge1xuICAgICAgICAvLyBBdHRlbnRpb246IHNvbWUgcmVnaW9ucyBkb24ndCBoYXZlIERTVCBhdCBhbGwuXG4gICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDMyKSk+PjIpXSA9IE51bWJlcihzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRzdE9mZnNldCA9PSBndWVzc2VkT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoKGRzdCA+IDApICE9IChkc3RPZmZzZXQgPT0gZ3Vlc3NlZE9mZnNldCkpIHtcbiAgICAgICAgdmFyIG5vbkRzdE9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiAgICAgICAgdmFyIHRydWVPZmZzZXQgPSBkc3QgPiAwID8gZHN0T2Zmc2V0IDogbm9uRHN0T2Zmc2V0O1xuICAgICAgICAvLyBEb24ndCB0cnkgc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIC4uLikgLS0gaXQncyBtZXNzZWQgdXAuXG4gICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICh0cnVlT2Zmc2V0IC0gZ3Vlc3NlZE9mZnNldCkqNjAwMDApO1xuICAgICAgfVxuICBcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICB2YXIgeWRheSA9ICgoZGF0ZS5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICAgIC8vIFRvIG1hdGNoIGV4cGVjdGVkIGJlaGF2aW9yLCB1cGRhdGUgZmllbGRzIGZyb20gZGF0ZVxuICAgICAgSEVBUDMyWygodG1QdHIpPj4yKV0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg4KSk+PjIpXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTYpKT4+MildID0gZGF0ZS5nZXRNb250aCgpO1xuICBcbiAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKXwwO1xuICAgIH1cbiAgX19ta3RpbWVfanMuc2lnID0gJ2lpJztcblxuICBmdW5jdGlvbiBfX3RpbWVnbV9qcyh0bVB0cikge1xuICAgICAgdmFyIHRpbWUgPSBEYXRlLlVUQyhIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gKyAxOTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICBcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApO1xuICAgICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgXG4gICAgICByZXR1cm4gKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCl8MDtcbiAgICB9XG4gIF9fdGltZWdtX2pzLnNpZyA9ICdpaSc7XG5cbiAgZnVuY3Rpb24gX3R6c2V0X2ltcGwodGltZXpvbmUsIGRheWxpZ2h0LCB0em5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBcbiAgICAgIC8vIExvY2FsIHN0YW5kYXJkIHRpbWV6b25lIG9mZnNldC4gTG9jYWwgc3RhbmRhcmQgdGltZSBpcyBub3QgYWRqdXN0ZWQgZm9yIGRheWxpZ2h0IHNhdmluZ3MuXG4gICAgICAvLyBUaGlzIGNvZGUgdXNlcyB0aGUgZmFjdCB0aGF0IGdldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBncmVhdGVyIHZhbHVlIGR1cmluZyBTdGFuZGFyZCBUaW1lIHZlcnN1cyBEYXlsaWdodCBTYXZpbmcgVGltZSAoRFNUKS5cbiAgICAgIC8vIFRodXMgaXQgZGV0ZXJtaW5lcyB0aGUgZXhwZWN0ZWQgb3V0cHV0IGR1cmluZyBTdGFuZGFyZCBUaW1lLCBhbmQgaXQgY29tcGFyZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBkYXRlIHRoZSBzYW1lIChTdGFuZGFyZCkgb3IgbGVzcyAoRFNUKS5cbiAgICAgIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICAvLyB0aW1lem9uZSBpcyBzcGVjaWZpZWQgYXMgc2Vjb25kcyB3ZXN0IG9mIFVUQyAoXCJUaGUgZXh0ZXJuYWwgdmFyaWFibGVcbiAgICAgIC8vIGB0aW1lem9uZWAgc2hhbGwgYmUgc2V0IHRvIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBiZXR3ZWVuXG4gICAgICAvLyBDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZSAoVVRDKSBhbmQgbG9jYWwgc3RhbmRhcmQgdGltZS5cIiksIHRoZSBzYW1lXG4gICAgICAvLyBhcyByZXR1cm5lZCBieSBzdGRUaW1lem9uZU9mZnNldC5cbiAgICAgIC8vIFNlZSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDA5Njk1Mzk5L2Z1bmN0aW9ucy90enNldC5odG1sXG4gICAgICBIRUFQMzJbKCh0aW1lem9uZSk+PjIpXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG4gIFxuICAgICAgSEVBUDMyWygoZGF5bGlnaHQpPj4yKV0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogXCJHTVRcIjtcbiAgICAgIH07XG4gICAgICB2YXIgd2ludGVyTmFtZSA9IGV4dHJhY3Rab25lKHdpbnRlcik7XG4gICAgICB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lcik7XG4gICAgICB2YXIgd2ludGVyTmFtZVB0ciA9IGFsbG9jYXRlVVRGOCh3aW50ZXJOYW1lKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHN1bW1lck5hbWUpO1xuICAgICAgaWYgKHN1bW1lck9mZnNldCA8IHdpbnRlck9mZnNldCkge1xuICAgICAgICAvLyBOb3J0aGVybiBoZW1pc3BoZXJlXG4gICAgICAgIEhFQVAzMlsoKHR6bmFtZSk+PjIpXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICAgIEhFQVAzMlsoKCh0em5hbWUpKyg0KSk+PjIpXSA9IHN1bW1lck5hbWVQdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIRUFQMzJbKCh0em5hbWUpPj4yKV0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgICBIRUFQMzJbKCgodHpuYW1lKSsoNCkpPj4yKV0gPSB3aW50ZXJOYW1lUHRyO1xuICAgICAgfVxuICAgIH1cbiAgX3R6c2V0X2ltcGwuc2lnID0gJ3ZpaWknO1xuICBmdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gICAgICAvLyBUT0RPOiBVc2UgKG1hbGxlYWJsZSkgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluc3RlYWQgb2Ygc3lzdGVtIHNldHRpbmdzLlxuICAgICAgaWYgKF9fdHpzZXRfanMuY2FsbGVkKSByZXR1cm47XG4gICAgICBfX3R6c2V0X2pzLmNhbGxlZCA9IHRydWU7XG4gICAgICBfdHpzZXRfaW1wbCh0aW1lem9uZSwgZGF5bGlnaHQsIHR6bmFtZSk7XG4gICAgfVxuICBfX3R6c2V0X2pzLnNpZyA9ICd2aWlpJztcblxuICBmdW5jdGlvbiBfYWJvcnQoKSB7XG4gICAgICBhYm9ydCgnbmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KCknKTtcbiAgICB9XG4gIF9hYm9ydC5zaWcgPSAndic7XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcihzdHIpIHtcbiAgICAgIGFzc2VydCh0eXBlb2Ygc3RyID09ICdudW1iZXInKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoVVRGOFRvU3RyaW5nKHN0cikpO1xuICAgIH1cbiAgX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvci5zaWcgPSAndmknO1xuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpIHtcbiAgICAgIHJldHVybiBIRUFQVTgubGVuZ3RoO1xuICAgIH1cblxuICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiB7XG4gICAgICB2YXIgdCA9IHByb2Nlc3NbJ2hydGltZSddKCk7XG4gICAgICByZXR1cm4gdFswXSAqIDFlMyArIHRbMV0gLyAxZTY7XG4gICAgfTtcbiAgfSBlbHNlIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgO1xuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiAgICAgIEhFQVBVOC5jb3B5V2l0aGluKGRlc3QsIHNyYywgc3JjICsgbnVtKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgYWJvcnQoJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMgdG8gc2l6ZSAnICsgcmVxdWVzdGVkU2l6ZSArICcgYnl0ZXMgKE9PTSkuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBJTklUSUFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgJyArIEhFQVA4Lmxlbmd0aCArICcsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICcpO1xuICAgIH1cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuICAgICAgcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7XG4gICAgICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeShyZXF1ZXN0ZWRTaXplKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgICB9XG4gIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgLy8gQnJvd3NlciBsYW5ndWFnZSBkZXRlY3Rpb24gIzg3NTFcbiAgICAgICAgdmFyIGxhbmcgPSAoKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fCAnQycpLnJlcGxhY2UoJy0nLCAnXycpICsgJy5VVEYtOCc7XG4gICAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgICAgJ1VTRVInOiAnd2ViX3VzZXInLFxuICAgICAgICAgICdMT0dOQU1FJzogJ3dlYl91c2VyJyxcbiAgICAgICAgICAnUEFUSCc6ICcvJyxcbiAgICAgICAgICAnUFdEJzogJy8nLFxuICAgICAgICAgICdIT01FJzogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICAnTEFORyc6IGxhbmcsXG4gICAgICAgICAgJ18nOiBnZXRFeGVjdXRhYmxlTmFtZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFwcGx5IHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlcywgaWYgYW55LlxuICAgICAgICBmb3IgKHZhciB4IGluIEVOVikge1xuICAgICAgICAgIC8vIHggaXMgYSBrZXkgaW4gRU5WOyBpZiBFTlZbeF0gaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIGl0IHdhc1xuICAgICAgICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRvIGJlIHNvLiBXZSBhbGxvdyB1c2VyIGNvZGUgdG8gZG8gdGhhdCB0b1xuICAgICAgICAgIC8vIGZvcmNlIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHQgdmFsdWVzIHRvIHJlbWFpbiB1bnNldC5cbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfVxuICBmdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLCBpKSB7XG4gICAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICAgIEhFQVAzMlsoKChfX2Vudmlyb24pKyhpICogNCkpPj4yKV0gPSBwdHI7XG4gICAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgX2Vudmlyb25fZ2V0LnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgICAgSEVBUDMyWygocGVudmlyb25fY291bnQpPj4yKV0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgSEVBUDMyWygocGVudmlyb25fYnVmX3NpemUpPj4yKV0gPSBidWZTaXplO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBfZW52aXJvbl9zaXplc19nZXQuc2lnID0gJ2lpaSc7XG5cbiAgZnVuY3Rpb24gX2V4aXQoc3RhdHVzKSB7XG4gICAgICAvLyB2b2lkIF9leGl0KGludCBzdGF0dXMpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwMDA5NTM5OS9mdW5jdGlvbnMvZXhpdC5odG1sXG4gICAgICBleGl0KHN0YXR1cyk7XG4gICAgfVxuICBfZXhpdC5zaWcgPSAndmknO1xuXG4gIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX2Nsb3NlLnNpZyA9ICdpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIC8vIEFsbCBjaGFyYWN0ZXIgZGV2aWNlcyBhcmUgdGVybWluYWxzIChvdGhlciB0aGluZ3MgYSBMaW51eCBzeXN0ZW0gd291bGRcbiAgICAgIC8vIGFzc3VtZSBpcyBhIGNoYXJhY3RlciBkZXZpY2UsIGxpa2UgdGhlIG1vdXNlLCB3ZSBoYXZlIHNwZWNpYWwgQVBJcyBmb3IpLlxuICAgICAgdmFyIHR5cGUgPSBzdHJlYW0udHR5ID8gMiA6XG4gICAgICAgICAgICAgICAgIEZTLmlzRGlyKHN0cmVhbS5tb2RlKSA/IDMgOlxuICAgICAgICAgICAgICAgICBGUy5pc0xpbmsoc3RyZWFtLm1vZGUpID8gNyA6XG4gICAgICAgICAgICAgICAgIDQ7XG4gICAgICBIRUFQOFsoKHBidWYpPj4wKV0gPSB0eXBlO1xuICAgICAgLy8gVE9ETyBIRUFQMTZbKCgocGJ1ZikrKDIpKT4+MSldID0gPztcbiAgICAgIC8vIFRPRE8gKHRlbXBJNjQgPSBbPz4+PjAsKHRlbXBEb3VibGU9PywoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChwYnVmKSsoOCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChwYnVmKSsoMTIpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAvLyBUT0RPICh0ZW1wSTY0ID0gWz8+Pj4wLCh0ZW1wRG91YmxlPT8sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgocGJ1ZikrKDE2KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKHBidWYpKygyMCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX2Zkc3RhdF9nZXQuc2lnID0gJ2lpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX3JlYWQoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgbnVtID0gU1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgIEhFQVAzMlsoKHBudW0pPj4yKV0gPSBudW07XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG4gIF9mZF9yZWFkLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX3NlZWsoZmQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCB3aGVuY2UsIG5ld09mZnNldCkge1xuICB0cnkge1xuICBcbiAgICAgIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgSElHSF9PRkZTRVQgPSAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgICAgLy8gdXNlIGFuIHVuc2lnbmVkIG9wZXJhdG9yIG9uIGxvdyBhbmQgc2hpZnQgaGlnaCBieSAzMi1iaXRzXG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0X2hpZ2ggKiBISUdIX09GRlNFVCArIChvZmZzZXRfbG93ID4+PiAwKTtcbiAgXG4gICAgICB2YXIgRE9VQkxFX0xJTUlUID0gMHgyMDAwMDAwMDAwMDAwMDsgLy8gMl41M1xuICAgICAgLy8gd2UgYWxzbyBjaGVjayBmb3IgZXF1YWxpdHkgc2luY2UgRE9VQkxFX0xJTUlUICsgMSA9PSBET1VCTEVfTElNSVRcbiAgICAgIGlmIChvZmZzZXQgPD0gLURPVUJMRV9MSU1JVCB8fCBvZmZzZXQgPj0gRE9VQkxFX0xJTUlUKSB7XG4gICAgICAgIHJldHVybiAtNjE7XG4gICAgICB9XG4gIFxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgKHRlbXBJNjQgPSBbc3RyZWFtLnBvc2l0aW9uPj4+MCwodGVtcERvdWJsZT1zdHJlYW0ucG9zaXRpb24sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChuZXdPZmZzZXQpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChuZXdPZmZzZXQpKyg0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyAvLyByZXNldCByZWFkZGlyIHN0YXRlXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICB0cnkge1xuICBcbiAgICAgIDtcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIG51bSA9IFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgSEVBUDMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX3dyaXRlLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2dldFRlbXBSZXQwKCkge1xuICAgICAgcmV0dXJuIGdldFRlbXBSZXQwKCk7XG4gICAgfVxuICBfZ2V0VGVtcFJldDAuc2lnID0gJ2knO1xuXG4gIGZ1bmN0aW9uIF9nZXRhZGRyaW5mbyhub2RlLCBzZXJ2aWNlLCBoaW50LCBvdXQpIHtcbiAgICAgIC8vIE5vdGUgZ2V0YWRkcmluZm8gY3VycmVudGx5IG9ubHkgcmV0dXJucyBhIHNpbmdsZSBhZGRyaW5mbyB3aXRoIGFpX25leHQgZGVmYXVsdGluZyB0byBOVUxMLiBXaGVuIE5VTExcbiAgICAgIC8vIGhpbnRzIGFyZSBzcGVjaWZpZWQgb3IgYWlfZmFtaWx5IHNldCB0byBBRl9VTlNQRUMgb3IgYWlfc29ja3R5cGUgb3IgYWlfcHJvdG9jb2wgc2V0IHRvIDAgdGhlbiB3ZVxuICAgICAgLy8gcmVhbGx5IHNob3VsZCBwcm92aWRlIGEgbGlua2VkIGxpc3Qgb2Ygc3VpdGFibGUgYWRkcmluZm8gdmFsdWVzLlxuICAgICAgdmFyIGFkZHJzID0gW107XG4gICAgICB2YXIgY2Fub24gPSBudWxsO1xuICAgICAgdmFyIGFkZHIgPSAwO1xuICAgICAgdmFyIHBvcnQgPSAwO1xuICAgICAgdmFyIGZsYWdzID0gMDtcbiAgICAgIHZhciBmYW1pbHkgPSAwO1xuICAgICAgdmFyIHR5cGUgPSAwO1xuICAgICAgdmFyIHByb3RvID0gMDtcbiAgICAgIHZhciBhaSwgbGFzdDtcbiAgXG4gICAgICBmdW5jdGlvbiBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIGNhbm9uLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgIHZhciBzYSwgc2FsZW4sIGFpO1xuICAgICAgICB2YXIgZXJybm87XG4gIFxuICAgICAgICBzYWxlbiA9IGZhbWlseSA9PT0gMTAgP1xuICAgICAgICAgIDI4IDpcbiAgICAgICAgICAxNjtcbiAgICAgICAgYWRkciA9IGZhbWlseSA9PT0gMTAgP1xuICAgICAgICAgIGluZXROdG9wNihhZGRyKSA6XG4gICAgICAgICAgaW5ldE50b3A0KGFkZHIpO1xuICAgICAgICBzYSA9IF9tYWxsb2Moc2FsZW4pO1xuICAgICAgICBlcnJubyA9IHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCk7XG4gICAgICAgIGFzc2VydCghZXJybm8pO1xuICBcbiAgICAgICAgYWkgPSBfbWFsbG9jKDMyKTtcbiAgICAgICAgSEVBUDMyWygoKGFpKSsoNCkpPj4yKV0gPSBmYW1pbHk7XG4gICAgICAgIEhFQVAzMlsoKChhaSkrKDgpKT4+MildID0gdHlwZTtcbiAgICAgICAgSEVBUDMyWygoKGFpKSsoMTIpKT4+MildID0gcHJvdG87XG4gICAgICAgIEhFQVAzMlsoKChhaSkrKDI0KSk+PjIpXSA9IGNhbm9uO1xuICAgICAgICBIRUFQMzJbKCgoYWkpKygyMCkpPj4yKV0gPSBzYTtcbiAgICAgICAgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgICAgICAgICBIRUFQMzJbKCgoYWkpKygxNikpPj4yKV0gPSAyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBIRUFQMzJbKCgoYWkpKygxNikpPj4yKV0gPSAxNjtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKCgoYWkpKygyOCkpPj4yKV0gPSAwO1xuICBcbiAgICAgICAgcmV0dXJuIGFpO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChoaW50KSB7XG4gICAgICAgIGZsYWdzID0gSEVBUDMyWygoaGludCk+PjIpXTtcbiAgICAgICAgZmFtaWx5ID0gSEVBUDMyWygoKGhpbnQpKyg0KSk+PjIpXTtcbiAgICAgICAgdHlwZSA9IEhFQVAzMlsoKChoaW50KSsoOCkpPj4yKV07XG4gICAgICAgIHByb3RvID0gSEVBUDMyWygoKGhpbnQpKygxMikpPj4yKV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAmJiAhcHJvdG8pIHtcbiAgICAgICAgcHJvdG8gPSB0eXBlID09PSAyID8gMTcgOiA2O1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlICYmIHByb3RvKSB7XG4gICAgICAgIHR5cGUgPSBwcm90byA9PT0gMTcgPyAyIDogMTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBJZiB0eXBlIG9yIHByb3RvIGFyZSBzZXQgdG8gemVybyBpbiBoaW50cyB3ZSBzaG91bGQgcmVhbGx5IGJlIHJldHVybmluZyBtdWx0aXBsZSBhZGRyaW5mbyB2YWx1ZXMsIGJ1dCBmb3JcbiAgICAgIC8vIG5vdyBkZWZhdWx0IHRvIGEgVENQIFNUUkVBTSBzb2NrZXQgc28gd2UgY2FuIGF0IGxlYXN0IHJldHVybiBhIHNlbnNpYmxlIGFkZHJpbmZvIGdpdmVuIE5VTEwgaGludHMuXG4gICAgICBpZiAocHJvdG8gPT09IDApIHtcbiAgICAgICAgcHJvdG8gPSA2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgdHlwZSA9IDE7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCFub2RlICYmICFzZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIH4oMXwyfDR8XG4gICAgICAgICAgMTAyNHw4fDE2fDMyKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoaGludCAhPT0gMCAmJiAoSEVBUDMyWygoaGludCk+PjIpXSAmIDIpICYmICFub2RlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIDMyKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSAmJiB0eXBlICE9PSAyKSB7XG4gICAgICAgIHJldHVybiAtNztcbiAgICAgIH1cbiAgICAgIGlmIChmYW1pbHkgIT09IDAgJiYgZmFtaWx5ICE9PSAyICYmIGZhbWlseSAhPT0gMTApIHtcbiAgICAgICAgcmV0dXJuIC02O1xuICAgICAgfVxuICBcbiAgICAgIGlmIChzZXJ2aWNlKSB7XG4gICAgICAgIHNlcnZpY2UgPSBVVEY4VG9TdHJpbmcoc2VydmljZSk7XG4gICAgICAgIHBvcnQgPSBwYXJzZUludChzZXJ2aWNlLCAxMCk7XG4gIFxuICAgICAgICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCByZXNvbHZpbmcgd2VsbC1rbm93biBzZXJ2aWNlIG5hbWVzIGZyb206XG4gICAgICAgICAgLy8gaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zZXJ2aWNlLW5hbWVzLXBvcnQtbnVtYmVycy9zZXJ2aWNlLW5hbWVzLXBvcnQtbnVtYmVycy50eHRcbiAgICAgICAgICByZXR1cm4gLTg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgaWYgKGZhbWlseSA9PT0gMCkge1xuICAgICAgICAgIGZhbWlseSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmbGFncyAmIDEpID09PSAwKSB7XG4gICAgICAgICAgaWYgKGZhbWlseSA9PT0gMikge1xuICAgICAgICAgICAgYWRkciA9IF9odG9ubCgyMTMwNzA2NDMzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkciA9IFswLCAwLCAwLCAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG51bGwsIGFkZHIsIHBvcnQpO1xuICAgICAgICBIRUFQMzJbKChvdXQpPj4yKV0gPSBhaTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gIFxuICAgICAgLy9cbiAgICAgIC8vIHRyeSBhcyBhIG51bWVyaWMgYWRkcmVzc1xuICAgICAgLy9cbiAgICAgIG5vZGUgPSBVVEY4VG9TdHJpbmcobm9kZSk7XG4gICAgICBhZGRyID0gaW5ldFB0b240KG5vZGUpO1xuICAgICAgaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5jb21pbmcgbm9kZSBpcyBhIHZhbGlkIGlwdjQgYWRkcmVzc1xuICAgICAgICBpZiAoZmFtaWx5ID09PSAwIHx8IGZhbWlseSA9PT0gMikge1xuICAgICAgICAgIGZhbWlseSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmFtaWx5ID09PSAxMCAmJiAoZmxhZ3MgJiA4KSkge1xuICAgICAgICAgIGFkZHIgPSBbMCwgMCwgX2h0b25sKDB4ZmZmZiksIGFkZHJdO1xuICAgICAgICAgIGZhbWlseSA9IDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkciA9IGluZXRQdG9uNihub2RlKTtcbiAgICAgICAgaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpbmNvbWluZyBub2RlIGlzIGEgdmFsaWQgaXB2NiBhZGRyZXNzXG4gICAgICAgICAgaWYgKGZhbWlseSA9PT0gMCB8fCBmYW1pbHkgPT09IDEwKSB7XG4gICAgICAgICAgICBmYW1pbHkgPSAxMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbm9kZSwgYWRkciwgcG9ydCk7XG4gICAgICAgIEhFQVAzMlsoKG91dCk+PjIpXSA9IGFpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgfVxuICBcbiAgICAgIC8vXG4gICAgICAvLyB0cnkgYXMgYSBob3N0bmFtZVxuICAgICAgLy9cbiAgICAgIC8vIHJlc29sdmUgdGhlIGhvc3RuYW1lIHRvIGEgdGVtcG9yYXJ5IGZha2UgYWRkcmVzc1xuICAgICAgbm9kZSA9IEROUy5sb29rdXBfbmFtZShub2RlKTtcbiAgICAgIGFkZHIgPSBpbmV0UHRvbjQobm9kZSk7XG4gICAgICBpZiAoZmFtaWx5ID09PSAwKSB7XG4gICAgICAgIGZhbWlseSA9IDI7XG4gICAgICB9IGVsc2UgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgICAgICAgYWRkciA9IFswLCAwLCBfaHRvbmwoMHhmZmZmKSwgYWRkcl07XG4gICAgICB9XG4gICAgICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbnVsbCwgYWRkciwgcG9ydCk7XG4gICAgICBIRUFQMzJbKChvdXQpPj4yKV0gPSBhaTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgX2dldGFkZHJpbmZvLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2dldG5hbWVpbmZvKHNhLCBzYWxlbiwgbm9kZSwgbm9kZWxlbiwgc2Vydiwgc2VydmxlbiwgZmxhZ3MpIHtcbiAgICAgIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKHNhLCBzYWxlbik7XG4gICAgICBpZiAoaW5mby5lcnJubykge1xuICAgICAgICByZXR1cm4gLTY7XG4gICAgICB9XG4gICAgICB2YXIgcG9ydCA9IGluZm8ucG9ydDtcbiAgICAgIHZhciBhZGRyID0gaW5mby5hZGRyO1xuICBcbiAgICAgIHZhciBvdmVyZmxvd2VkID0gZmFsc2U7XG4gIFxuICAgICAgaWYgKG5vZGUgJiYgbm9kZWxlbikge1xuICAgICAgICB2YXIgbG9va3VwO1xuICAgICAgICBpZiAoKGZsYWdzICYgMSkgfHwgIShsb29rdXAgPSBETlMubG9va3VwX2FkZHIoYWRkcikpKSB7XG4gICAgICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRyID0gbG9va3VwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IHN0cmluZ1RvVVRGOChhZGRyLCBub2RlLCBub2RlbGVuKTtcbiAgXG4gICAgICAgIGlmIChudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCsxID49IG5vZGVsZW4pIHtcbiAgICAgICAgICBvdmVyZmxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIGlmIChzZXJ2ICYmIHNlcnZsZW4pIHtcbiAgICAgICAgcG9ydCA9ICcnICsgcG9ydDtcbiAgICAgICAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gc3RyaW5nVG9VVEY4KHBvcnQsIHNlcnYsIHNlcnZsZW4pO1xuICBcbiAgICAgICAgaWYgKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsKzEgPj0gc2Vydmxlbikge1xuICAgICAgICAgIG92ZXJmbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgaWYgKG92ZXJmbG93ZWQpIHtcbiAgICAgICAgLy8gTm90ZTogZXZlbiB3aGVuIHdlIG92ZXJmbG93LCBnZXRuYW1laW5mbygpIGlzIHNwZWNjZWQgdG8gd3JpdGUgb3V0IHRoZSB0cnVuY2F0ZWQgcmVzdWx0cy5cbiAgICAgICAgcmV0dXJuIC0xMjtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gICAgICBwcm9jRXhpdChjb2RlKTtcbiAgICB9XG4gIF9wcm9jX2V4aXQuc2lnID0gJ3ZpJztcblxuICBmdW5jdGlvbiBfcHRocmVhZF9zZXRzY2hlZHBhcmFtKFxuICApIHtcbiAgaWYgKCFNb2R1bGVbJ19wdGhyZWFkX3NldHNjaGVkcGFyYW0nXSkgYWJvcnQoXCJleHRlcm5hbCBzeW1ib2wgJ3B0aHJlYWRfc2V0c2NoZWRwYXJhbScgaXMgbWlzc2luZy4gcGVyaGFwcyBhIHNpZGUgbW9kdWxlIHdhcyBub3QgbGlua2VkIGluPyBpZiB0aGlzIGZ1bmN0aW9uIHdhcyBleHBlY3RlZCB0byBhcnJpdmUgZnJvbSBhIHN5c3RlbSBsaWJyYXJ5LCB0cnkgdG8gYnVpbGQgdGhlIE1BSU5fTU9EVUxFIHdpdGggRU1DQ19GT1JDRV9TVERMSUJTPTEgaW4gdGhlIGVudmlyb25tZW50XCIpO1xuICByZXR1cm4gTW9kdWxlWydfcHRocmVhZF9zZXRzY2hlZHBhcmFtJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZW1fdGltZWR3YWl0KFxuICApIHtcbiAgaWYgKCFNb2R1bGVbJ19zZW1fdGltZWR3YWl0J10pIGFib3J0KFwiZXh0ZXJuYWwgc3ltYm9sICdzZW1fdGltZWR3YWl0JyBpcyBtaXNzaW5nLiBwZXJoYXBzIGEgc2lkZSBtb2R1bGUgd2FzIG5vdCBsaW5rZWQgaW4/IGlmIHRoaXMgZnVuY3Rpb24gd2FzIGV4cGVjdGVkIHRvIGFycml2ZSBmcm9tIGEgc3lzdGVtIGxpYnJhcnksIHRyeSB0byBidWlsZCB0aGUgTUFJTl9NT0RVTEUgd2l0aCBFTUNDX0ZPUkNFX1NURExJQlM9MSBpbiB0aGUgZW52aXJvbm1lbnRcIik7XG4gIHJldHVybiBNb2R1bGVbJ19zZW1fdGltZWR3YWl0J10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRUZW1wUmV0MCh2YWwpIHtcbiAgICAgIHNldFRlbXBSZXQwKHZhbCk7XG4gICAgfVxuICBfc2V0VGVtcFJldDAuc2lnID0gJ3ZpJztcblxuICBmdW5jdGlvbiBfc3lzdGVtKGNvbW1hbmQpIHtcbiAgICAgIC8vIGludCBzeXN0ZW0oY29uc3QgY2hhciAqY29tbWFuZCk7XG4gICAgICAvLyBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDAwMDk1Mzk5L2Z1bmN0aW9ucy9zeXN0ZW0uaHRtbFxuICAgICAgLy8gQ2FuJ3QgY2FsbCBleHRlcm5hbCBwcm9ncmFtcy5cbiAgICAgIGlmICghY29tbWFuZCkgcmV0dXJuIDA7IC8vIG5vIHNoZWxsIGF2YWlsYWJsZVxuICAgICAgc2V0RXJyTm8oNTIpO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICB2YXIgRlNOb2RlID0gLyoqIEBjb25zdHJ1Y3RvciAqLyBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcGFyZW50ID0gdGhpczsgIC8vIHJvb3Qgbm9kZSBzZXRzIHBhcmVudCB0byBpdHNlbGZcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5tb3VudCA9IHBhcmVudC5tb3VudDtcbiAgICB0aGlzLm1vdW50ZWQgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgIHRoaXMuc3RyZWFtX29wcyA9IHt9O1xuICAgIHRoaXMucmRldiA9IHJkZXY7XG4gIH07XG4gIHZhciByZWFkTW9kZSA9IDI5Mi8qMjkyKi8gfCA3My8qNzMqLztcbiAgdmFyIHdyaXRlTW9kZSA9IDE0Ni8qMTQ2Ki87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTTm9kZS5wcm90b3R5cGUsIHtcbiAgIHJlYWQ6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgcmVhZE1vZGUpID09PSByZWFkTW9kZTtcbiAgICB9LFxuICAgIHNldDogLyoqIEB0aGlze0ZTTm9kZX0gKi9mdW5jdGlvbih2YWwpIHtcbiAgICAgdmFsID8gdGhpcy5tb2RlIHw9IHJlYWRNb2RlIDogdGhpcy5tb2RlICY9IH5yZWFkTW9kZTtcbiAgICB9XG4gICB9LFxuICAgd3JpdGU6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgd3JpdGVNb2RlKSA9PT0gd3JpdGVNb2RlO1xuICAgIH0sXG4gICAgc2V0OiAvKiogQHRoaXN7RlNOb2RlfSAqL2Z1bmN0aW9uKHZhbCkge1xuICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gd3JpdGVNb2RlIDogdGhpcy5tb2RlICY9IH53cml0ZU1vZGU7XG4gICAgfVxuICAgfSxcbiAgIGlzRm9sZGVyOiB7XG4gICAgZ2V0OiAvKiogQHRoaXN7RlNOb2RlfSAqL2Z1bmN0aW9uKCkge1xuICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKTtcbiAgICB9XG4gICB9LFxuICAgaXNEZXZpY2U6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpO1xuICAgIH1cbiAgIH1cbiAgfSk7XG4gIEZTLkZTTm9kZSA9IEZTTm9kZTtcbiAgRlMuc3RhdGljSW5pdCgpOztcbkVSUk5PX0NPREVTID0ge1xuICAgICAgJ0VQRVJNJzogNjMsXG4gICAgICAnRU5PRU5UJzogNDQsXG4gICAgICAnRVNSQ0gnOiA3MSxcbiAgICAgICdFSU5UUic6IDI3LFxuICAgICAgJ0VJTyc6IDI5LFxuICAgICAgJ0VOWElPJzogNjAsXG4gICAgICAnRTJCSUcnOiAxLFxuICAgICAgJ0VOT0VYRUMnOiA0NSxcbiAgICAgICdFQkFERic6IDgsXG4gICAgICAnRUNISUxEJzogMTIsXG4gICAgICAnRUFHQUlOJzogNixcbiAgICAgICdFV09VTERCTE9DSyc6IDYsXG4gICAgICAnRU5PTUVNJzogNDgsXG4gICAgICAnRUFDQ0VTJzogMixcbiAgICAgICdFRkFVTFQnOiAyMSxcbiAgICAgICdFTk9UQkxLJzogMTA1LFxuICAgICAgJ0VCVVNZJzogMTAsXG4gICAgICAnRUVYSVNUJzogMjAsXG4gICAgICAnRVhERVYnOiA3NSxcbiAgICAgICdFTk9ERVYnOiA0MyxcbiAgICAgICdFTk9URElSJzogNTQsXG4gICAgICAnRUlTRElSJzogMzEsXG4gICAgICAnRUlOVkFMJzogMjgsXG4gICAgICAnRU5GSUxFJzogNDEsXG4gICAgICAnRU1GSUxFJzogMzMsXG4gICAgICAnRU5PVFRZJzogNTksXG4gICAgICAnRVRYVEJTWSc6IDc0LFxuICAgICAgJ0VGQklHJzogMjIsXG4gICAgICAnRU5PU1BDJzogNTEsXG4gICAgICAnRVNQSVBFJzogNzAsXG4gICAgICAnRVJPRlMnOiA2OSxcbiAgICAgICdFTUxJTksnOiAzNCxcbiAgICAgICdFUElQRSc6IDY0LFxuICAgICAgJ0VET00nOiAxOCxcbiAgICAgICdFUkFOR0UnOiA2OCxcbiAgICAgICdFTk9NU0cnOiA0OSxcbiAgICAgICdFSURSTSc6IDI0LFxuICAgICAgJ0VDSFJORyc6IDEwNixcbiAgICAgICdFTDJOU1lOQyc6IDE1NixcbiAgICAgICdFTDNITFQnOiAxMDcsXG4gICAgICAnRUwzUlNUJzogMTA4LFxuICAgICAgJ0VMTlJORyc6IDEwOSxcbiAgICAgICdFVU5BVENIJzogMTEwLFxuICAgICAgJ0VOT0NTSSc6IDExMSxcbiAgICAgICdFTDJITFQnOiAxMTIsXG4gICAgICAnRURFQURMSyc6IDE2LFxuICAgICAgJ0VOT0xDSyc6IDQ2LFxuICAgICAgJ0VCQURFJzogMTEzLFxuICAgICAgJ0VCQURSJzogMTE0LFxuICAgICAgJ0VYRlVMTCc6IDExNSxcbiAgICAgICdFTk9BTk8nOiAxMDQsXG4gICAgICAnRUJBRFJRQyc6IDEwMyxcbiAgICAgICdFQkFEU0xUJzogMTAyLFxuICAgICAgJ0VERUFETE9DSyc6IDE2LFxuICAgICAgJ0VCRk9OVCc6IDEwMSxcbiAgICAgICdFTk9TVFInOiAxMDAsXG4gICAgICAnRU5PREFUQSc6IDExNixcbiAgICAgICdFVElNRSc6IDExNyxcbiAgICAgICdFTk9TUic6IDExOCxcbiAgICAgICdFTk9ORVQnOiAxMTksXG4gICAgICAnRU5PUEtHJzogMTIwLFxuICAgICAgJ0VSRU1PVEUnOiAxMjEsXG4gICAgICAnRU5PTElOSyc6IDQ3LFxuICAgICAgJ0VBRFYnOiAxMjIsXG4gICAgICAnRVNSTU5UJzogMTIzLFxuICAgICAgJ0VDT01NJzogMTI0LFxuICAgICAgJ0VQUk9UTyc6IDY1LFxuICAgICAgJ0VNVUxUSUhPUCc6IDM2LFxuICAgICAgJ0VET1RET1QnOiAxMjUsXG4gICAgICAnRUJBRE1TRyc6IDksXG4gICAgICAnRU5PVFVOSVEnOiAxMjYsXG4gICAgICAnRUJBREZEJzogMTI3LFxuICAgICAgJ0VSRU1DSEcnOiAxMjgsXG4gICAgICAnRUxJQkFDQyc6IDEyOSxcbiAgICAgICdFTElCQkFEJzogMTMwLFxuICAgICAgJ0VMSUJTQ04nOiAxMzEsXG4gICAgICAnRUxJQk1BWCc6IDEzMixcbiAgICAgICdFTElCRVhFQyc6IDEzMyxcbiAgICAgICdFTk9TWVMnOiA1MixcbiAgICAgICdFTk9URU1QVFknOiA1NSxcbiAgICAgICdFTkFNRVRPT0xPTkcnOiAzNyxcbiAgICAgICdFTE9PUCc6IDMyLFxuICAgICAgJ0VPUE5PVFNVUFAnOiAxMzgsXG4gICAgICAnRVBGTk9TVVBQT1JUJzogMTM5LFxuICAgICAgJ0VDT05OUkVTRVQnOiAxNSxcbiAgICAgICdFTk9CVUZTJzogNDIsXG4gICAgICAnRUFGTk9TVVBQT1JUJzogNSxcbiAgICAgICdFUFJPVE9UWVBFJzogNjcsXG4gICAgICAnRU5PVFNPQ0snOiA1NyxcbiAgICAgICdFTk9QUk9UT09QVCc6IDUwLFxuICAgICAgJ0VTSFVURE9XTic6IDE0MCxcbiAgICAgICdFQ09OTlJFRlVTRUQnOiAxNCxcbiAgICAgICdFQUREUklOVVNFJzogMyxcbiAgICAgICdFQ09OTkFCT1JURUQnOiAxMyxcbiAgICAgICdFTkVUVU5SRUFDSCc6IDQwLFxuICAgICAgJ0VORVRET1dOJzogMzgsXG4gICAgICAnRVRJTUVET1VUJzogNzMsXG4gICAgICAnRUhPU1RET1dOJzogMTQyLFxuICAgICAgJ0VIT1NUVU5SRUFDSCc6IDIzLFxuICAgICAgJ0VJTlBST0dSRVNTJzogMjYsXG4gICAgICAnRUFMUkVBRFknOiA3LFxuICAgICAgJ0VERVNUQUREUlJFUSc6IDE3LFxuICAgICAgJ0VNU0dTSVpFJzogMzUsXG4gICAgICAnRVBST1RPTk9TVVBQT1JUJzogNjYsXG4gICAgICAnRVNPQ0tUTk9TVVBQT1JUJzogMTM3LFxuICAgICAgJ0VBRERSTk9UQVZBSUwnOiA0LFxuICAgICAgJ0VORVRSRVNFVCc6IDM5LFxuICAgICAgJ0VJU0NPTk4nOiAzMCxcbiAgICAgICdFTk9UQ09OTic6IDUzLFxuICAgICAgJ0VUT09NQU5ZUkVGUyc6IDE0MSxcbiAgICAgICdFVVNFUlMnOiAxMzYsXG4gICAgICAnRURRVU9UJzogMTksXG4gICAgICAnRVNUQUxFJzogNzIsXG4gICAgICAnRU5PVFNVUCc6IDEzOCxcbiAgICAgICdFTk9NRURJVU0nOiAxNDgsXG4gICAgICAnRUlMU0VRJzogMjUsXG4gICAgICAnRU9WRVJGTE9XJzogNjEsXG4gICAgICAnRUNBTkNFTEVEJzogMTEsXG4gICAgICAnRU5PVFJFQ09WRVJBQkxFJzogNTYsXG4gICAgICAnRU9XTkVSREVBRCc6IDYyLFxuICAgICAgJ0VTVFJQSVBFJzogMTM1LFxuICAgIH07O1xudmFyIEFTU0VSVElPTlMgPSB0cnVlO1xuXG5cblxuLyoqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcsIGJvb2xlYW49LCBudW1iZXI9KX0gKi9cbmZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7XG4gIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XG4gIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gIHJldHVybiB1OGFycmF5O1xufVxuXG5mdW5jdGlvbiBpbnRBcnJheVRvU3RyaW5nKGFycmF5KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHIgPSBhcnJheVtpXTtcbiAgICBpZiAoY2hyID4gMHhGRikge1xuICAgICAgaWYgKEFTU0VSVElPTlMpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnQ2hhcmFjdGVyIGNvZGUgJyArIGNociArICcgKCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyAnKSAgYXQgb2Zmc2V0ICcgKyBpICsgJyBub3QgaW4gMHgwMC0weEZGLicpO1xuICAgICAgfVxuICAgICAgY2hyICY9IDB4RkY7XG4gICAgfVxuICAgIHJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuXG5mdW5jdGlvbiBjaGVja0luY29taW5nTW9kdWxlQVBJKCkge1xuICBpZ25vcmVkTW9kdWxlUHJvcCgnZmV0Y2hTZXR0aW5ncycpO1xufVxudmFyIGFzbUxpYnJhcnlBcmcgPSB7XG4gIFwiX19hc3NlcnRfZmFpbFwiOiBfX19hc3NlcnRfZmFpbCxcbiAgXCJfX2NhbGxfc2lnaGFuZGxlclwiOiBfX19jYWxsX3NpZ2hhbmRsZXIsXG4gIFwiX19oZWFwX2Jhc2VcIjogX19faGVhcF9iYXNlLFxuICBcIl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGVcIjogd2FzbVRhYmxlLFxuICBcIl9fbWVtb3J5X2Jhc2VcIjogX19fbWVtb3J5X2Jhc2UsXG4gIFwiX19zdGFja19wb2ludGVyXCI6IF9fX3N0YWNrX3BvaW50ZXIsXG4gIFwiX19zeXNjYWxsX19uZXdzZWxlY3RcIjogX19fc3lzY2FsbF9fbmV3c2VsZWN0LFxuICBcIl9fc3lzY2FsbF9hY2NlcHQ0XCI6IF9fX3N5c2NhbGxfYWNjZXB0NCxcbiAgXCJfX3N5c2NhbGxfYmluZFwiOiBfX19zeXNjYWxsX2JpbmQsXG4gIFwiX19zeXNjYWxsX2NoZGlyXCI6IF9fX3N5c2NhbGxfY2hkaXIsXG4gIFwiX19zeXNjYWxsX2Nvbm5lY3RcIjogX19fc3lzY2FsbF9jb25uZWN0LFxuICBcIl9fc3lzY2FsbF9kdXBcIjogX19fc3lzY2FsbF9kdXAsXG4gIFwiX19zeXNjYWxsX2R1cDNcIjogX19fc3lzY2FsbF9kdXAzLFxuICBcIl9fc3lzY2FsbF9mYWNjZXNzYXRcIjogX19fc3lzY2FsbF9mYWNjZXNzYXQsXG4gIFwiX19zeXNjYWxsX2ZjbnRsNjRcIjogX19fc3lzY2FsbF9mY250bDY0LFxuICBcIl9fc3lzY2FsbF9mc3RhdDY0XCI6IF9fX3N5c2NhbGxfZnN0YXQ2NCxcbiAgXCJfX3N5c2NhbGxfZ2V0Y3dkXCI6IF9fX3N5c2NhbGxfZ2V0Y3dkLFxuICBcIl9fc3lzY2FsbF9nZXRkZW50czY0XCI6IF9fX3N5c2NhbGxfZ2V0ZGVudHM2NCxcbiAgXCJfX3N5c2NhbGxfZ2V0c29ja25hbWVcIjogX19fc3lzY2FsbF9nZXRzb2NrbmFtZSxcbiAgXCJfX3N5c2NhbGxfZ2V0c29ja29wdFwiOiBfX19zeXNjYWxsX2dldHNvY2tvcHQsXG4gIFwiX19zeXNjYWxsX2lvY3RsXCI6IF9fX3N5c2NhbGxfaW9jdGwsXG4gIFwiX19zeXNjYWxsX2xpc3RlblwiOiBfX19zeXNjYWxsX2xpc3RlbixcbiAgXCJfX3N5c2NhbGxfbHN0YXQ2NFwiOiBfX19zeXNjYWxsX2xzdGF0NjQsXG4gIFwiX19zeXNjYWxsX21rZGlyXCI6IF9fX3N5c2NhbGxfbWtkaXIsXG4gIFwiX19zeXNjYWxsX21rbm9kXCI6IF9fX3N5c2NhbGxfbWtub2QsXG4gIFwiX19zeXNjYWxsX25ld2ZzdGF0YXRcIjogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuICBcIl9fc3lzY2FsbF9vcGVuYXRcIjogX19fc3lzY2FsbF9vcGVuYXQsXG4gIFwiX19zeXNjYWxsX3BpcGVcIjogX19fc3lzY2FsbF9waXBlLFxuICBcIl9fc3lzY2FsbF9yZWFkbGlua2F0XCI6IF9fX3N5c2NhbGxfcmVhZGxpbmthdCxcbiAgXCJfX3N5c2NhbGxfcmVjdmZyb21cIjogX19fc3lzY2FsbF9yZWN2ZnJvbSxcbiAgXCJfX3N5c2NhbGxfcmVuYW1lYXRcIjogX19fc3lzY2FsbF9yZW5hbWVhdCxcbiAgXCJfX3N5c2NhbGxfcm1kaXJcIjogX19fc3lzY2FsbF9ybWRpcixcbiAgXCJfX3N5c2NhbGxfc2VuZHRvXCI6IF9fX3N5c2NhbGxfc2VuZHRvLFxuICBcIl9fc3lzY2FsbF9zb2NrZXRcIjogX19fc3lzY2FsbF9zb2NrZXQsXG4gIFwiX19zeXNjYWxsX3N0YXQ2NFwiOiBfX19zeXNjYWxsX3N0YXQ2NCxcbiAgXCJfX3N5c2NhbGxfc3ltbGlua1wiOiBfX19zeXNjYWxsX3N5bWxpbmssXG4gIFwiX19zeXNjYWxsX3VubGlua2F0XCI6IF9fX3N5c2NhbGxfdW5saW5rYXQsXG4gIFwiX19zeXNjYWxsX3V0aW1lbnNhdFwiOiBfX19zeXNjYWxsX3V0aW1lbnNhdCxcbiAgXCJfX3RhYmxlX2Jhc2VcIjogX19fdGFibGVfYmFzZSxcbiAgXCJfZGxvcGVuX2pzXCI6IF9fZGxvcGVuX2pzLFxuICBcIl9kbHN5bV9qc1wiOiBfX2Rsc3ltX2pzLFxuICBcIl9lbXNjcmlwdGVuX2RhdGVfbm93XCI6IF9fZW1zY3JpcHRlbl9kYXRlX25vdyxcbiAgXCJfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pY1wiOiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXG4gIFwiX2Vtc2NyaXB0ZW5fdGhyb3dfbG9uZ2ptcFwiOiBfX2Vtc2NyaXB0ZW5fdGhyb3dfbG9uZ2ptcCxcbiAgXCJfZ210aW1lX2pzXCI6IF9fZ210aW1lX2pzLFxuICBcIl9sb2NhbHRpbWVfanNcIjogX19sb2NhbHRpbWVfanMsXG4gIFwiX21rdGltZV9qc1wiOiBfX21rdGltZV9qcyxcbiAgXCJfdGltZWdtX2pzXCI6IF9fdGltZWdtX2pzLFxuICBcIl90enNldF9qc1wiOiBfX3R6c2V0X2pzLFxuICBcImFib3J0XCI6IF9hYm9ydCxcbiAgXCJlbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3JcIjogX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcixcbiAgXCJlbXNjcmlwdGVuX2dldF9oZWFwX21heFwiOiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gIFwiZW1zY3JpcHRlbl9nZXRfbm93XCI6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gIFwiZW1zY3JpcHRlbl9tZW1jcHlfYmlnXCI6IF9lbXNjcmlwdGVuX21lbWNweV9iaWcsXG4gIFwiZW1zY3JpcHRlbl9yZXNpemVfaGVhcFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiAgXCJlbnZpcm9uX2dldFwiOiBfZW52aXJvbl9nZXQsXG4gIFwiZW52aXJvbl9zaXplc19nZXRcIjogX2Vudmlyb25fc2l6ZXNfZ2V0LFxuICBcImV4aXRcIjogX2V4aXQsXG4gIFwiZmRfY2xvc2VcIjogX2ZkX2Nsb3NlLFxuICBcImZkX2Zkc3RhdF9nZXRcIjogX2ZkX2Zkc3RhdF9nZXQsXG4gIFwiZmRfcmVhZFwiOiBfZmRfcmVhZCxcbiAgXCJmZF9zZWVrXCI6IF9mZF9zZWVrLFxuICBcImZkX3dyaXRlXCI6IF9mZF93cml0ZSxcbiAgXCJnZXRUZW1wUmV0MFwiOiBfZ2V0VGVtcFJldDAsXG4gIFwiZ2V0YWRkcmluZm9cIjogX2dldGFkZHJpbmZvLFxuICBcImdldG5hbWVpbmZvXCI6IF9nZXRuYW1laW5mbyxcbiAgXCJpbnZva2VfaWlcIjogaW52b2tlX2lpLFxuICBcImludm9rZV9paWlcIjogaW52b2tlX2lpaSxcbiAgXCJpbnZva2VfaWlpaVwiOiBpbnZva2VfaWlpaSxcbiAgXCJpbnZva2VfaWlpaWlcIjogaW52b2tlX2lpaWlpLFxuICBcImludm9rZV9paWlpaWlcIjogaW52b2tlX2lpaWlpaSxcbiAgXCJpbnZva2VfdmlcIjogaW52b2tlX3ZpLFxuICBcImludm9rZV92aWlcIjogaW52b2tlX3ZpaSxcbiAgXCJpbnZva2VfdmlpaVwiOiBpbnZva2VfdmlpaSxcbiAgXCJpbnZva2VfdmlpaWlcIjogaW52b2tlX3ZpaWlpLFxuICBcImludm9rZV92aWlpaWlpaWlpXCI6IGludm9rZV92aWlpaWlpaWlpLFxuICBcIm1lbW9yeVwiOiB3YXNtTWVtb3J5LFxuICBcInByb2NfZXhpdFwiOiBfcHJvY19leGl0LFxuICBcInB0aHJlYWRfc2V0c2NoZWRwYXJhbVwiOiBfcHRocmVhZF9zZXRzY2hlZHBhcmFtLFxuICBcInNlbV90aW1lZHdhaXRcIjogX3NlbV90aW1lZHdhaXQsXG4gIFwic2V0VGVtcFJldDBcIjogX3NldFRlbXBSZXQwLFxuICBcInN5c3RlbVwiOiBfc3lzdGVtXG59O1xudmFyIGFzbSA9IGNyZWF0ZVdhc20oKTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX193YXNtX2NhbGxfY3RvcnMgPSBNb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX193YXNtX2NhbGxfY3RvcnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29uc3RydWN0b3IgPSBNb2R1bGVbXCJfY29uc3RydWN0b3JcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiY29uc3RydWN0b3JcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2V0ID0gTW9kdWxlW1wiX3NldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2V0ID0gTW9kdWxlW1wiX2dldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZGVzdHJ1Y3RvciA9IE1vZHVsZVtcIl9kZXN0cnVjdG9yXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImRlc3RydWN0b3JcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnByaW50ZiA9IE1vZHVsZVtcIl9mcHJpbnRmXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY21wID0gTW9kdWxlW1wiX3N0cmNtcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzIgPSBNb2R1bGVbXCJfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsZWlvX3NldF9zdGF0c191MzJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZyZWVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcmVhbGxvYyA9IE1vZHVsZVtcIl9yZWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInJlYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtY3B5ID0gTW9kdWxlW1wiX21lbWNweVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1jcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybGVuID0gTW9kdWxlW1wiX3N0cmxlblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJsZW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtY21wID0gTW9kdWxlW1wiX21lbWNtcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1jbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtbW92ZSA9IE1vZHVsZVtcIl9tZW1tb3ZlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1lbW1vdmVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX25ldyA9IE1vZHVsZVtcIl9nZl9maWxlaW9fbmV3XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbGVpb19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX3VybCA9IE1vZHVsZVtcIl9nZl9maWxlaW9fdXJsXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbGVpb191cmxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX2dldF91ZHRhID0gTW9kdWxlW1wiX2dmX2ZpbGVpb19nZXRfdWR0YVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWxlaW9fZ2V0X3VkdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19lcnJub19sb2NhdGlvbiA9IE1vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fZXJybm9fbG9jYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY3B5ID0gTW9kdWxlW1wiX3N0cmNweVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY2F0ID0gTW9kdWxlW1wiX3N0cmNhdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjYXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY2hyID0gTW9kdWxlW1wiX3N0cmNoclwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjaHJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybmNtcCA9IE1vZHVsZVtcIl9zdHJuY21wXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0cm5jbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3ByaW50ZiA9IE1vZHVsZVtcIl9zcHJpbnRmXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2Zfc3RyZHVwID0gTW9kdWxlW1wiX2dmX3N0cmR1cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9zdHJkdXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdnNucHJpbnRmID0gTW9kdWxlW1wiX3ZzbnByaW50ZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJ2c25wcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZndyaXRlID0gTW9kdWxlW1wiX2Z3cml0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmd3JpdGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdmZwcmludGYgPSBNb2R1bGVbXCJfdmZwcmludGZcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwidmZwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZmZsdXNoID0gTW9kdWxlW1wiX2ZmbHVzaFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmZmx1c2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfbmV3ID0gTW9kdWxlW1wiX2dmX2JzX25ld1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfZGVsID0gTW9kdWxlW1wiX2dmX2JzX2RlbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19kZWxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfcmVhZF9pbnQgPSBNb2R1bGVbXCJfZ2ZfYnNfcmVhZF9pbnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfYnNfcmVhZF9pbnRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfYXZhaWxhYmxlID0gTW9kdWxlW1wiX2dmX2JzX2F2YWlsYWJsZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19hdmFpbGFibGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfZ2V0X3Bvc2l0aW9uID0gTW9kdWxlW1wiX2dmX2JzX2dldF9wb3NpdGlvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19nZXRfcG9zaXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybmNweSA9IE1vZHVsZVtcIl9zdHJuY3B5XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0cm5jcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY2FsbG9jID0gTW9kdWxlW1wiX2NhbGxvY1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJjYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyZHVwID0gTW9kdWxlW1wiX3N0cmR1cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJkdXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfdXJsX2NvbmNhdGVuYXRlID0gTW9kdWxlW1wiX2dmX3VybF9jb25jYXRlbmF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl91cmxfY29uY2F0ZW5hdGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9zZWxmID0gTW9kdWxlW1wiX3B0aHJlYWRfc2VsZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX3NlbGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9pbml0ID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfaW5pdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2luaXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9kZXN0cm95ID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfZGVzdHJveVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2Rlc3Ryb3lcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF91bmxvY2sgPSBNb2R1bGVbXCJfcHRocmVhZF9tdXRleF91bmxvY2tcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwicHRocmVhZF9tdXRleF91bmxvY2tcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9sb2NrID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfbG9ja1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2xvY2tcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2V0ZW52ID0gTW9kdWxlW1wiX2dldGVudlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZXRlbnZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2MgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2NcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfbmV3X3JlZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX25ld19yZWZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZW5kID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2VuZFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NlbmRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfZGF0YSA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX2dldF9kYXRhXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfZ2V0X2RhdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZyA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX3NldF9mcmFtaW5nXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfc2V0X2ZyYW1pbmdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfY3RzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X2N0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X2N0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfdGltZXNjYWxlID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF90aW1lc2NhbGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfc2FwID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9zYXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb24gPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb24gPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfc2Vla19mbGFnID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9zZWVrX2ZsYWdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X3NlZWtfZmxhZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF9zZWVrX2ZsYWdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncyA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX3NldF9kZXBlbmRlbmN5X2ZsYWdzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfc2V0X2RlcGVuZGVuY3lfZmxhZ3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0ID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfZ2V0X3BhY2tldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX2dldF9wYWNrZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9jaGVja19jYXBzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfY2hlY2tfY2Fwc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9zZXRfZnJhbWluZ19tb2RlID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX3NldF9mcmFtaW5nX21vZGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9uZXcgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9uZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29zID0gTW9kdWxlW1wiX2Nvc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJjb3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2luID0gTW9kdWxlW1wiX3NpblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzaW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdGFuID0gTW9kdWxlW1wiX3RhblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJ0YW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYXRhbiA9IE1vZHVsZVtcIl9hdGFuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImF0YW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcG93ID0gTW9kdWxlW1wiX3Bvd1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwb3dcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYWNvcyA9IE1vZHVsZVtcIl9hY29zXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFjb3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfaHRvbmwgPSBNb2R1bGVbXCJfaHRvbmxcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbmxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfaHRvbnMgPSBNb2R1bGVbXCJfaHRvbnNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbnRvaHMgPSBNb2R1bGVbXCJfbnRvaHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibnRvaHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYXNpbiA9IE1vZHVsZVtcIl9hc2luXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFzaW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbG9nID0gTW9kdWxlW1wiX2xvZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJsb2dcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2F2ZVNldGptcCA9IE1vZHVsZVtcIl9zYXZlU2V0am1wXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNhdmVTZXRqbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX2dldF91ZHRhID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9nZXRfdWR0YVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfZ2V0X3VkdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3NldF9uYW1lID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9zZXRfbmFtZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfc2V0X25hbWVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZmFicyA9IE1vZHVsZVtcIl9mYWJzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZhYnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZXhwID0gTW9kdWxlW1wiX2V4cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29zaCA9IE1vZHVsZVtcIl9jb3NoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImNvc2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2luaCA9IE1vZHVsZVtcIl9zaW5oXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNpbmhcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdGFuaCA9IE1vZHVsZVtcIl90YW5oXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInRhbmhcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtc2V0ID0gTW9kdWxlW1wiX21lbXNldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1zZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2lwcmludGYgPSBNb2R1bGVbXCJfc2lwcmludGZcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic2lwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnJleHAgPSBNb2R1bGVbXCJfZnJleHBcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZnJleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19zdGRpb19leGl0ID0gTW9kdWxlW1wiX19fc3RkaW9fZXhpdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX3N0ZGlvX2V4aXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYnNlYXJjaCA9IE1vZHVsZVtcIl9ic2VhcmNoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImJzZWFyY2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19kbF9zZXRlcnIgPSBNb2R1bGVbXCJfX19kbF9zZXRlcnJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19kbF9zZXRlcnJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbGRleHAgPSBNb2R1bGVbXCJfbGRleHBcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibGRleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbGxyaW50ID0gTW9kdWxlW1wiX2xscmludFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJsbHJpbnRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtYWxpZ24gPSBNb2R1bGVbXCJfbWVtYWxpZ25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibWVtYWxpZ25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcG9zaXhfbWVtYWxpZ24gPSBNb2R1bGVbXCJfcG9zaXhfbWVtYWxpZ25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwicG9zaXhfbWVtYWxpZ25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2V0VGhyZXcgPSBNb2R1bGVbXCJfc2V0VGhyZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic2V0VGhyZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHMgPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBzdGFja1NhdmUgPSBNb2R1bGVbXCJzdGFja1NhdmVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic3RhY2tTYXZlXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgc3RhY2tSZXN0b3JlID0gTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrUmVzdG9yZVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIHN0YWNrQWxsb2MgPSBNb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrQWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppID0gTW9kdWxlW1wiZHluQ2FsbF9qaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9paWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF92aWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppamlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaWpcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpamlqamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppamppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqamppaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWpqamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWpqamlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfaWlpamppID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX3ZpaWlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqamlpaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppamlpaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlpaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9paWppampqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlqaWpqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppampqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWlqXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWogPSBNb2R1bGVbXCJkeW5DYWxsX2ppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWpqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19uZXcgPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19uZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19hdmFpbGFibGUgPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19hdmFpbGFibGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19hdmFpbGFibGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19nZXRfcG9zaXRpb24gPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19nZXRfcG9zaXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19nZXRfcG9zaXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHMgPSBNb2R1bGVbXCJfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHMgPSBNb2R1bGVbXCJfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCA9IE1vZHVsZVtcIl9vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm9yaWckZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRsbHJpbnQgPSBNb2R1bGVbXCJfb3JpZyRsbHJpbnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRsbHJpbnRcIik7XG5cblxuZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LGExKSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWkoaW5kZXgsYTEsYTIpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsYTEsYTIsYTMpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfdmkoaW5kZXgsYTEpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfaWlpaShpbmRleCxhMSxhMixhMykge1xuICB2YXIgc3AgPSBzdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfdmlpKGluZGV4LGExLGEyKSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX2lpaWlpKGluZGV4LGExLGEyLGEzLGE0KSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEsYTIsYTMsYTQpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV92aWlpaShpbmRleCxhMSxhMixhMyxhNCkge1xuICB2YXIgc3AgPSBzdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEsYTIsYTMsYTQpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMixhMyxhNCxhNSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5cblxuXG4vLyA9PT0gQXV0by1nZW5lcmF0ZWQgcG9zdGFtYmxlIHNldHVwIGVudHJ5IHN0dWZmID09PVxuXG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdpbnRBcnJheUZyb21TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdpbnRBcnJheVRvU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignY2NhbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjd3JhcCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldFZhbHVlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0VmFsdWUnLCBmYWxzZSk7XG5Nb2R1bGVbXCJhbGxvY2F0ZVwiXSA9IGFsbG9jYXRlO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignVVRGOEFycmF5VG9TdHJpbmcnLCBmYWxzZSk7XG5Nb2R1bGVbXCJVVEY4VG9TdHJpbmdcIl0gPSBVVEY4VG9TdHJpbmc7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjhBcnJheScsIGZhbHNlKTtcbk1vZHVsZVtcInN0cmluZ1RvVVRGOFwiXSA9IHN0cmluZ1RvVVRGODtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2xlbmd0aEJ5dGVzVVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrVHJhY2UnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRPblByZVJ1bicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uSW5pdCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uUHJlTWFpbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uRXhpdCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uUG9zdFJ1bicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlU3RyaW5nVG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3cml0ZUFycmF5VG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3cml0ZUFzY2lpVG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRSdW5EZXBlbmRlbmN5JywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZW1vdmVSdW5EZXBlbmRlbmN5JywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVGb2xkZXInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVQYXRoJywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVEYXRhRmlsZScsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlNfY3JlYXRlUHJlbG9hZGVkRmlsZScsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlNfY3JlYXRlTGF6eUZpbGUnLCB0cnVlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0ZTX2NyZWF0ZUxpbmsnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVEZXZpY2UnLCB0cnVlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0ZTX3VubGluaycsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0TEVCJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RnVuY3Rpb25UYWJsZXMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhbGlnbkZ1bmN0aW9uVGFibGVzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJGdW5jdGlvbnMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRGdW5jdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlbW92ZUZ1bmN0aW9uJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RnVuY1dyYXBwZXInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwcmV0dHlQcmludCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2R5bkNhbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRDb21waWxlclNldHRpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwcmludCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3ByaW50RXJyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0VGVtcFJldDAnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzZXRUZW1wUmV0MCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NhbGxNYWluJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYWJvcnQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdrZWVwUnVudGltZUFsaXZlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignemVyb01lbW9yeScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0cmluZ1RvTmV3VVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Fib3J0T25DYW5ub3RHcm93TWVtb3J5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0VOVicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0VSUk5PX0NPREVTJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRVJSTk9fTUVTU0FHRVMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzZXRFcnJObycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXRQdG9uNCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXROdG9wNCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXRQdG9uNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXROdG9wNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlYWRTb2NrYWRkcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlU29ja2FkZHInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdETlMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRIb3N0QnlOYW1lJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignUHJvdG9jb2xzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU29ja2V0cycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldFJhbmRvbURldmljZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3RyYXZlcnNlU3RhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdVTldJTkRfQ0FDSEUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb252ZXJ0UEN0b1NvdXJjZUxvY2F0aW9uJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEFzbUNvbnN0QXJnc0FycmF5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEFzbUNvbnN0QXJncycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ21haW5UaHJlYWRFTV9BU00nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdqc3RvaV9xJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignanN0b2lfcycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldEV4ZWN1dGFibGVOYW1lJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGlzdGVuT25jZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2F1dG9SZXN1bWVBdWRpb0NvbnRleHQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkeW5DYWxsTGVnYWN5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RHluQ2FsbGVyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZHluQ2FsbCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2hhbmRsZUV4Y2VwdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3J1bnRpbWVLZWVwYWxpdmVQdXNoJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncnVudGltZUtlZXBhbGl2ZVBvcCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NhbGxVc2VyQ2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtYXliZUV4aXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzYWZlU2V0VGltZW91dCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FzbWpzTWFuZ2xlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYXN5bmNMb2FkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYWxpZ25NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtbWFwQWxsb2MnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWFsbHlOZWdhdGl2ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3VuU2lnbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlU2lnbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Zvcm1hdFN0cmluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1BBVEgnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdQQVRIX0ZTJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU1lTQ0FMTFMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRTb2NrZXRGcm9tRkQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRTb2NrZXRBZGRyZXNzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignSlNFdmVudHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlcktleUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzcGVjaWFsSFRNTFRhcmdldHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtYXliZUNTdHJpbmdUb0pzU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmluZEV2ZW50VGFyZ2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmluZENhbnZhc0V2ZW50VGFyZ2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0Qm91bmRpbmdDbGllbnRSZWN0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbE1vdXNlRXZlbnREYXRhJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJNb3VzZUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlcldoZWVsRXZlbnRDYWxsYmFjaycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyVWlFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJGb2N1c0V2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsRGV2aWNlT3JpZW50YXRpb25FdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckRldmljZU9yaWVudGF0aW9uRXZlbnRDYWxsYmFjaycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2ZpbGxEZXZpY2VNb3Rpb25FdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckRldmljZU1vdGlvbkV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzY3JlZW5PcmllbnRhdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2ZpbGxPcmllbnRhdGlvbkNoYW5nZUV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyT3JpZW50YXRpb25DaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbEZ1bGxzY3JlZW5DaGFuZ2VFdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckZ1bGxzY3JlZW5DaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJSZXN0b3JlT2xkU3R5bGUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdoaWRlRXZlcnl0aGluZ0V4Y2VwdEdpdmVuRWxlbWVudCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3Jlc3RvcmVIaWRkZW5FbGVtZW50cycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldExldHRlcmJveCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2N1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3knLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZXN0b3JlT2xkV2luZG93ZWRTdHlsZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NvZnRGdWxsc2NyZWVuUmVzaXplV2ViR0xSZW5kZXJUYXJnZXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkb1JlcXVlc3RGdWxsc2NyZWVuJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbFBvaW50ZXJsb2NrQ2hhbmdlRXZlbnREYXRhJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJQb2ludGVybG9ja0NoYW5nZUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlclBvaW50ZXJsb2NrRXJyb3JFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVxdWVzdFBvaW50ZXJMb2NrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbFZpc2liaWxpdHlDaGFuZ2VFdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJUb3VjaEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsR2FtZXBhZEV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyR2FtZXBhZEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckJlZm9yZVVubG9hZEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsQmF0dGVyeUV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2JhdHRlcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckJhdHRlcnlFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc2V0Q2FudmFzRWxlbWVudFNpemUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRDYW52YXNFbGVtZW50U2l6ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2RlbWFuZ2xlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZGVtYW5nbGVBbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdqc1N0YWNrVHJhY2UnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdGFja1RyYWNlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RW52U3RyaW5ncycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NoZWNrV2FzaUNsb2NrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb0k2NCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlSTUzVG9JNjRDbGFtcGVkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb0k2NFNpZ25hbGluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlSTUzVG9VNjRDbGFtcGVkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb1U2NFNpZ25hbGluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlYWRJNTNGcm9tSTY0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEk1M0Zyb21VNjQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb252ZXJ0STMyUGFpclRvSTUzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignY29udmVydFUzMlBhaXJUb0k1MycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dPVCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0xEU08nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRNZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtZXJnZUxpYlN5bWJvbHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdsb2FkV2ViQXNzZW1ibHlNb2R1bGUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdsb2FkRHluYW1pY0xpYnJhcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkbG9wZW5JbnRlcm5hbCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldEltbWVkaWF0ZVdyYXBwZWQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjbGVhckltbWVkaWF0ZVdyYXBwZWQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwb2x5ZmlsbFNldEltbWVkaWF0ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdleGNlcHRpb25MYXN0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZXhjZXB0aW9uQ2F1Z2h0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRXhjZXB0aW9uSW5mbycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0NhdGNoSW5mbycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2V4Y2VwdGlvbl9hZGRSZWYnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdleGNlcHRpb25fZGVjUmVmJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignQnJvd3NlcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Z1bmNXcmFwcGVycycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldEZ1bmNXcmFwcGVyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc2V0TWFpbkxvb3AnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3Z2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdNRU1GUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1RUWScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1BJUEVGUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1NPQ0tGUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ19zZXROZXR3b3JrQ2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd0ZW1wRml4ZWRMZW5ndGhBcnJheScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ21pbmlUZW1wV2ViR0xGbG9hdEJ1ZmZlcnMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdoZWFwT2JqZWN0Rm9yV2ViR0xUeXBlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignR0wnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdlbXNjcmlwdGVuV2ViR0xHZXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Vtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Vtc2NyaXB0ZW5XZWJHTEdldFVuaWZvcm0nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dlYmdsUHJlcGFyZVVuaWZvcm1Mb2NhdGlvbnNCZWZvcmVGaXJzdFVzZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dlYmdsR2V0TGVmdEJyYWNlUG9zJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZW1zY3JpcHRlbldlYkdMR2V0VmVydGV4QXR0cmliJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVHTEFycmF5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignQUwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdTRExfdW5pY29kZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1NETF90dGZDb250ZXh0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMX2F1ZGlvJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMX2dmeCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dMVVQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdFR0wnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdHTEZXX1dpbmRvdycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dMRlcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdHTEVXJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignSURCU3RvcmUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdydW5BbmRBYm9ydElmRXJyb3InLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3YXJuT25jZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrU2F2ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrUmVzdG9yZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrQWxsb2MnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdBc2NpaVRvU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc3RyaW5nVG9Bc2NpaScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1VURjE2VG9TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjE2JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGVuZ3RoQnl0ZXNVVEYxNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1VURjMyVG9TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjMyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGVuZ3RoQnl0ZXNVVEYzMicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FsbG9jYXRlVVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FsbG9jYXRlVVRGOE9uU3RhY2snLCBmYWxzZSk7XG5Nb2R1bGVbXCJ3cml0ZVN0YWNrQ29va2llXCJdID0gd3JpdGVTdGFja0Nvb2tpZTtcbk1vZHVsZVtcImNoZWNrU3RhY2tDb29raWVcIl0gPSBjaGVja1N0YWNrQ29va2llO1xudW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woJ0FMTE9DX05PUk1BTCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKCdBTExPQ19TVEFDSycsIGZhbHNlKTtcblxudmFyIGNhbGxlZFJ1bjtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtFeGl0U3RhdHVzfVxuICovXG5mdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykge1xuICB0aGlzLm5hbWUgPSBcIkV4aXRTdGF0dXNcIjtcbiAgdGhpcy5tZXNzYWdlID0gXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiICsgc3RhdHVzICsgXCIpXCI7XG4gIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xufVxuXG52YXIgY2FsbGVkTWFpbiA9IGZhbHNlO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gIC8vIElmIHJ1biBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIGFuZCB3ZSBzaG91bGQgY2FsbCBydW4gKElOVk9LRV9SVU4gaXMgdHJ1ZSwgYW5kIE1vZHVsZS5ub0luaXRpYWxSdW4gaXMgbm90IGZhbHNlKVxuICBpZiAoIWNhbGxlZFJ1bikgcnVuKCk7XG4gIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7IC8vIHRyeSB0aGlzIGFnYWluIGxhdGVyLCBhZnRlciBuZXcgZGVwcyBhcmUgZnVsZmlsbGVkXG59O1xuXG5mdW5jdGlvbiBjYWxsTWFpbihhcmdzKSB7XG4gIGFzc2VydChydW5EZXBlbmRlbmNpZXMgPT0gMCwgJ2Nhbm5vdCBjYWxsIG1haW4gd2hlbiBhc3luYyBkZXBlbmRlbmNpZXMgcmVtYWluISAobGlzdGVuIG9uIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKScpO1xuICBhc3NlcnQoX19BVFBSRVJVTl9fLmxlbmd0aCA9PSAwLCAnY2Fubm90IGNhbGwgbWFpbiB3aGVuIHByZVJ1biBmdW5jdGlvbnMgcmVtYWluIHRvIGJlIGNhbGxlZCcpO1xuXG4gIHZhciBlbnRyeUZ1bmN0aW9uID0gTW9kdWxlWydfbWFpbiddO1xuXG4gIC8vIE1haW4gbW9kdWxlcyBjYW4ndCB0ZWxsIGlmIHRoZXkgaGF2ZSBtYWluKCkgYXQgY29tcGlsZSB0aW1lLCBzaW5jZSBpdCBtYXlcbiAgLy8gYXJyaXZlIGZyb20gYSBkeW5hbWljIGxpYnJhcnkuXG4gIGlmICghZW50cnlGdW5jdGlvbikgcmV0dXJuO1xuXG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuXG4gIHZhciBhcmdjID0gYXJncy5sZW5ndGgrMTtcbiAgdmFyIGFyZ3YgPSBzdGFja0FsbG9jKChhcmdjICsgMSkgKiA0KTtcbiAgSEVBUDMyW2FyZ3YgPj4gMl0gPSBhbGxvY2F0ZVVURjhPblN0YWNrKHRoaXNQcm9ncmFtKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdjOyBpKyspIHtcbiAgICBIRUFQMzJbKGFyZ3YgPj4gMikgKyBpXSA9IGFsbG9jYXRlVVRGOE9uU3RhY2soYXJnc1tpIC0gMV0pO1xuICB9XG4gIEhFQVAzMlsoYXJndiA+PiAyKSArIGFyZ2NdID0gMDtcblxuICB0cnkge1xuXG4gICAgdmFyIHJldCA9IGVudHJ5RnVuY3Rpb24oYXJnYywgYXJndik7XG5cbiAgICAvLyBJbiBQUk9YWV9UT19QVEhSRUFEIGJ1aWxkcywgd2Ugc2hvdWxkIG5ldmVyIGV4aXQgdGhlIHJ1bnRpbWUgYmVsb3csIGFzXG4gICAgLy8gZXhlY3V0aW9uIGlzIGFzeW5jaHJvbm91c2x5IGhhbmRlZCBvZmYgdG8gYSBwdGhyZWFkLlxuICAgIC8vIGlmIHdlJ3JlIG5vdCBydW5uaW5nIGFuIGV2ZW50ZWQgbWFpbiBsb29wLCBpdCdzIHRpbWUgdG8gZXhpdFxuICAgIGV4aXQocmV0LCAvKiBpbXBsaWNpdCA9ICovIHRydWUpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpO1xuICB9IGZpbmFsbHkge1xuICAgIGNhbGxlZE1haW4gPSB0cnVlO1xuXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tDaGVja0luaXQoKSB7XG4gIC8vIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIF9fd2FzbV9jYWxsX2N0b3JzIGJ1dCBuZWVkIHRvXG4gIC8vIGdldCB0aGVzZSB2YWx1ZXMgYmVmb3JlIGV2ZW4gcnVubmluZyBhbnkgb2YgdGhlIGN0b3JzIHNvIHdlIGNhbGwgaXQgcmVkdW5kYW50bHlcbiAgLy8gaGVyZS5cbiAgLy8gVE9ETyhzYmMpOiBNb3ZlIHdyaXRlU3RhY2tDb29raWUgdG8gbmF0aXZlIHRvIHRvIGF2b2lkIHRoaXMuXG4gIF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHMoNjI4NDc4NCwgMTA0MTkwNCk7XG4gIHdyaXRlU3RhY2tDb29raWUoKTtcbn1cblxudmFyIGR5bGlic0xvYWRlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKEFycmF5PSl9ICovXG5mdW5jdGlvbiBydW4oYXJncykge1xuICBhcmdzID0gYXJncyB8fCBhcmd1bWVudHNfO1xuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhY2tDaGVja0luaXQoKTtcblxuICBpZiAoIWR5bGlic0xvYWRlZCkge1xuICAvLyBMb2FkaW5nIG9mIGR5bmFtaWMgbGlicmFyaWVzIG5lZWRzIHRvIGhhcHBlbiBvbiBlYWNoIHRocmVhZCwgc28gd2UgY2FuJ3RcbiAgLy8gdXNlIHRoZSBub3JtYWwgX19BVFBSRVJVTl9fIG1lY2hhbmlzbS5cbiAgICBwcmVsb2FkRHlsaWJzKCk7XG4gICAgZHlsaWJzTG9hZGVkID0gdHJ1ZTtcblxuICAgIC8vIExvYWRpbmcgZHlsaWJzIGNhbiBhZGQgcnVuIGRlcGVuZGVuY2llcy5cbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByZVJ1bigpO1xuXG4gIC8vIGEgcHJlUnVuIGFkZGVkIGEgZGVwZW5kZW5jeSwgcnVuIHdpbGwgYmUgY2FsbGVkIGxhdGVyXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgLy8gcnVuIG1heSBoYXZlIGp1c3QgYmVlbiBjYWxsZWQgdGhyb3VnaCBkZXBlbmRlbmNpZXMgYmVpbmcgZnVsZmlsbGVkIGp1c3QgaW4gdGhpcyB2ZXJ5IGZyYW1lLFxuICAgIC8vIG9yIHdoaWxlIHRoZSBhc3luYyBzZXRTdGF0dXMgdGltZSBiZWxvdyB3YXMgaGFwcGVuaW5nXG4gICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgIGluaXRSdW50aW1lKCk7XG5cbiAgICBwcmVNYWluKCk7XG5cbiAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XG5cbiAgICBpZiAoc2hvdWxkUnVuTm93KSBjYWxsTWFpbihhcmdzKTtcblxuICAgIHBvc3RSdW4oKTtcbiAgfVxuXG4gIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcbiAgICAgIH0sIDEpO1xuICAgICAgZG9SdW4oKTtcbiAgICB9LCAxKTtcbiAgfSBlbHNlXG4gIHtcbiAgICBkb1J1bigpO1xuICB9XG4gIGNoZWNrU3RhY2tDb29raWUoKTtcbn1cbk1vZHVsZVsncnVuJ10gPSBydW47XG5cbmZ1bmN0aW9uIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpIHtcbiAgLy8gQ29tcGlsZXIgc2V0dGluZ3MgZG8gbm90IGFsbG93IGV4aXRpbmcgdGhlIHJ1bnRpbWUsIHNvIGZsdXNoaW5nXG4gIC8vIHRoZSBzdHJlYW1zIGlzIG5vdCBwb3NzaWJsZS4gYnV0IGluIEFTU0VSVElPTlMgbW9kZSB3ZSBjaGVja1xuICAvLyBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIHRvIGZsdXNoLCBhbmQgaWYgc28gdGVsbCB0aGUgdXNlciB0aGV5XG4gIC8vIHNob3VsZCByZXF1ZXN0IHRoYXQgdGhlIHJ1bnRpbWUgYmUgZXhpdGFibGUuXG4gIC8vIE5vcm1hbGx5IHdlIHdvdWxkIG5vdCBldmVuIGluY2x1ZGUgZmx1c2goKSBhdCBhbGwsIGJ1dCBpbiBBU1NFUlRJT05TXG4gIC8vIGJ1aWxkcyB3ZSBkbyBzbyBqdXN0IGZvciB0aGlzIGNoZWNrLCBhbmQgaGVyZSB3ZSBzZWUgaWYgdGhlcmUgaXMgYW55XG4gIC8vIGNvbnRlbnQgdG8gZmx1c2gsIHRoYXQgaXMsIHdlIGNoZWNrIGlmIHRoZXJlIHdvdWxkIGhhdmUgYmVlblxuICAvLyBzb21ldGhpbmcgYSBub24tQVNTRVJUSU9OUyBidWlsZCB3b3VsZCBoYXZlIG5vdCBzZWVuLlxuICAvLyBIb3cgd2UgZmx1c2ggdGhlIHN0cmVhbXMgZGVwZW5kcyBvbiB3aGV0aGVyIHdlIGFyZSBpbiBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU09MFxuICAvLyBtb2RlICh3aGljaCBoYXMgaXRzIG93biBzcGVjaWFsIGZ1bmN0aW9uIGZvciB0aGlzOyBvdGhlcndpc2UsIGFsbFxuICAvLyB0aGUgY29kZSBpcyBpbnNpZGUgbGliYylcbiAgdmFyIG9sZE91dCA9IG91dDtcbiAgdmFyIG9sZEVyciA9IGVycjtcbiAgdmFyIGhhcyA9IGZhbHNlO1xuICBvdXQgPSBlcnIgPSAoeCkgPT4ge1xuICAgIGhhcyA9IHRydWU7XG4gIH1cbiAgdHJ5IHsgLy8gaXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgZmFpbHNcbiAgICBfX19zdGRpb19leGl0KCk7XG4gICAgLy8gYWxzbyBmbHVzaCBpbiB0aGUgSlMgRlMgbGF5ZXJcbiAgICBbJ3N0ZG91dCcsICdzdGRlcnInXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpbmZvID0gRlMuYW5hbHl6ZVBhdGgoJy9kZXYvJyArIG5hbWUpO1xuICAgICAgaWYgKCFpbmZvKSByZXR1cm47XG4gICAgICB2YXIgc3RyZWFtID0gaW5mby5vYmplY3Q7XG4gICAgICB2YXIgcmRldiA9IHN0cmVhbS5yZGV2O1xuICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3JkZXZdO1xuICAgICAgaWYgKHR0eSAmJiB0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIGhhcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2goZSkge31cbiAgb3V0ID0gb2xkT3V0O1xuICBlcnIgPSBvbGRFcnI7XG4gIGlmIChoYXMpIHtcbiAgICB3YXJuT25jZSgnc3RkaW8gc3RyZWFtcyBoYWQgY29udGVudCBpbiB0aGVtIHRoYXQgd2FzIG5vdCBmbHVzaGVkLiB5b3Ugc2hvdWxkIHNldCBFWElUX1JVTlRJTUUgdG8gMSAoc2VlIHRoZSBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy4nKTtcbiAgfVxufVxuXG4vKiogQHBhcmFtIHtib29sZWFufG51bWJlcj19IGltcGxpY2l0ICovXG5mdW5jdGlvbiBleGl0KHN0YXR1cywgaW1wbGljaXQpIHtcbiAgRVhJVFNUQVRVUyA9IHN0YXR1cztcblxuICBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTtcblxuICAvLyBpZiBleGl0KCkgd2FzIGNhbGxlZCBleHBsaWNpdGx5LCB3YXJuIHRoZSB1c2VyIGlmIHRoZSBydW50aW1lIGlzbid0IGFjdHVhbGx5IGJlaW5nIHNodXQgZG93blxuICBpZiAoa2VlcFJ1bnRpbWVBbGl2ZSgpICYmICFpbXBsaWNpdCkge1xuICAgIHZhciBtc2cgPSAncHJvZ3JhbSBleGl0ZWQgKHdpdGggc3RhdHVzOiAnICsgc3RhdHVzICsgJyksIGJ1dCBFWElUX1JVTlRJTUUgaXMgbm90IHNldCwgc28gaGFsdGluZyBleGVjdXRpb24gYnV0IG5vdCBleGl0aW5nIHRoZSBydW50aW1lIG9yIHByZXZlbnRpbmcgZnVydGhlciBhc3luYyBleGVjdXRpb24gKGJ1aWxkIHdpdGggRVhJVF9SVU5USU1FPTEsIGlmIHlvdSB3YW50IGEgdHJ1ZSBzaHV0ZG93biknO1xuICAgIHJlYWR5UHJvbWlzZVJlamVjdChtc2cpO1xuICAgIGVycihtc2cpO1xuICB9XG5cbiAgcHJvY0V4aXQoc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gcHJvY0V4aXQoY29kZSkge1xuICBFWElUU1RBVFVTID0gY29kZTtcbiAgaWYgKCFrZWVwUnVudGltZUFsaXZlKCkpIHtcbiAgICBpZiAoTW9kdWxlWydvbkV4aXQnXSkgTW9kdWxlWydvbkV4aXQnXShjb2RlKTtcbiAgICBBQk9SVCA9IHRydWU7XG4gIH1cbiAgcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xufVxuXG5pZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgfVxufVxuXG4vLyBzaG91bGRSdW5Ob3cgcmVmZXJzIHRvIGNhbGxpbmcgbWFpbigpLCBub3QgcnVuKCkuXG52YXIgc2hvdWxkUnVuTm93ID0gdHJ1ZTtcblxuaWYgKE1vZHVsZVsnbm9Jbml0aWFsUnVuJ10pIHNob3VsZFJ1bk5vdyA9IGZhbHNlO1xuXG5ydW4oKTtcblxuXG5cblxuXG5cblxuICByZXR1cm4gTW9kdWxlLnJlYWR5XG59XG4pO1xufSkoKTtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gTW9kdWxlO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW9kdWxlOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgZXhwb3J0c1tcIk1vZHVsZVwiXSA9IE1vZHVsZTtcblxuICBjb25zdCBsb2NhdGlvbiA9IHt9O1xuICBjb25zdCBtZW1pbyA9IFtdO1xuICBleHBvcnQge01vZHVsZSwgbG9jYXRpb24sIG1lbWlvfTsiLCJmdW5jdGlvbiBGRVRDSF9NT0RVTEUoTU9EVUxFX0hFQVAsIE1PRFVMRSwgQUJPUlQsIEVYUE9SVF9XUkFQUEVSLCBTVFJJTkdUT1VURjgsVVRGOFRPU1RSSU5HLEFMTE9DQVRFVVRGOCxXQVNNRU5UUllUQUJMRSkge1xuXG4gICAgLy8gR2xvYmFsIGZ1bmN0aW9uXG4gICAgdmFyIEhFQVAsXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5QnVmZmVyfSAqL1xuICAgICAgICBidWZmZXIsXG4gICAgICAgIC8qKiBAdHlwZSB7IUludDhBcnJheX0gKi9cbiAgICAgICAgSEVBUDgsXG4gICAgICAgIC8qKiBAdHlwZSB7IVVpbnQ4QXJyYXl9ICovXG4gICAgICAgIEhFQVBVOCxcbiAgICAgICAgLyoqIEB0eXBlIHshSW50MTZBcnJheX0gKi9cbiAgICAgICAgSEVBUDE2LFxuICAgICAgICAvKiogQHR5cGUgeyFVaW50MTZBcnJheX0gKi9cbiAgICAgICAgSEVBUFUxNixcbiAgICAgICAgLyoqIEB0eXBlIHshSW50MzJBcnJheX0gKi9cbiAgICAgICAgSEVBUDMyLFxuICAgICAgICAvKiogQHR5cGUgeyFVaW50MzJBcnJheX0gKi9cbiAgICAgICAgSEVBUFUzMixcbiAgICAgICAgLyoqIEB0eXBlIHshRmxvYXQzMkFycmF5fSAqL1xuICAgICAgICBIRUFQRjMyLFxuICAgICAgICAvKiogQHR5cGUgeyFGbG9hdDY0QXJyYXl9ICovXG4gICAgICAgIEhFQVBGNjQ7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmO1xuICAgICAgICBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWYpO1xuICAgICAgICBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gICAgICAgIEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gICAgICAgIEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG4gICAgfVxuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKE1PRFVMRV9IRUFQKTtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKiwgc3RyaW5nPSl9ICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQnICsgKHRleHQgPyAnOiAnICsgdGV4dCA6ICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTW9kdWxlID0gTU9EVUxFO1xuICAgIHZhciBjcmVhdGVFeHBvcnRXcmFwcGVyID0gRVhQT1JUX1dSQVBQRVI7XG4gICAgdmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1hbGxvY1wiKTtcbiAgICB2YXIgZXJyID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgdmFyIFVURjhUb1N0cmluZyA9IFVURjhUT1NUUklORztcbiAgICB2YXIgc3RyaW5nVG9VVEY4ID0gU1RSSU5HVE9VVEY4O1xuICAgIHZhciBhYm9ydCA9IEFCT1JUO1xuICAgIHZhciBnZXRXYXNtVGFibGVFbnRyeSA9IFdBU01FTlRSWVRBQkxFOyBcblxuICAgIHZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nO1xuXG4gICAgdmFyIEZldGNoID0ge1xuICAgICAgICB4aHJzOiBbXSwgc2V0dTY0OiBmdW5jdGlvbiAoYWRkciwgdmFsKSB7XG4gICAgICAgICAgICBIRUFQVTMyW2FkZHIgPj4gMl0gPSB2YWw7XG4gICAgICAgICAgICBIRUFQVTMyW2FkZHIgKyA0ID4+IDJdID0gKHZhbCAvIDQyOTQ5NjcyOTYpIHwgMDtcbiAgICAgICAgfSwgb3BlbkRhdGFiYXNlOiBmdW5jdGlvbiAoZGJuYW1lLCBkYnZlcnNpb24sIG9uc3VjY2Vzcywgb25lcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihkYm5hbWUsIGRidmVyc2lvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldHVybiBvbmVycm9yKGUpOyB9XG5cbiAgICAgICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IC8qKiBAdHlwZSB7SURCRGF0YWJhc2V9ICovIChldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnRklMRVMnKSkge1xuICAgICAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgnRklMRVMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ0ZJTEVTJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiBvbnN1Y2Nlc3MoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICBvcGVuUmVxdWVzdC5vbmVycm9yID0gKGVycm9yKSA9PiBvbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSwgc3RhdGljSW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlzTWFpblRocmVhZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBvbnN1Y2Nlc3MgPSAoZGIpID0+IHtcbiAgICAgICAgICAgICAgICBGZXRjaC5kYkluc3RhbmNlID0gZGI7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ2xpYnJhcnlfZmV0Y2hfaW5pdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBGZXRjaC5kYkluc3RhbmNlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNYWluVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koJ2xpYnJhcnlfZmV0Y2hfaW5pdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGZXRjaC5vcGVuRGF0YWJhc2UoJ2Vtc2NyaXB0ZW5fZmlsZXN5c3RlbScsIDEsIG9uc3VjY2Vzcywgb25lcnJvcik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRU5WSVJPTk1FTlRfSVNfRkVUQ0hfV09SS0VSID09ICd1bmRlZmluZWQnIHx8ICFFTlZJUk9OTUVOVF9JU19GRVRDSF9XT1JLRVIpIGFkZFJ1bkRlcGVuZGVuY3koJ2xpYnJhcnlfZmV0Y2hfaW5pdCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9mZXRjaF9nZXRfcmVzcG9uc2VfaGVhZGVycyhpZCwgZHN0LCBkc3RTaXplQnl0ZXMpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9IEZldGNoLnhocnNbaWQgLSAxXS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgdmFyIGxlbmd0aEJ5dGVzID0gbGVuZ3RoQnl0ZXNVVEY4KHJlc3BvbnNlSGVhZGVycykgKyAxO1xuICAgICAgICBzdHJpbmdUb1VURjgocmVzcG9uc2VIZWFkZXJzLCBkc3QsIGRzdFNpemVCeXRlcyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihsZW5ndGhCeXRlcywgZHN0U2l6ZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZmV0Y2hfZ2V0X3Jlc3BvbnNlX2hlYWRlcnNfbGVuZ3RoKGlkKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGhCeXRlc1VURjgoRmV0Y2gueGhyc1tpZCAtIDFdLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSArIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5faXNfbWFpbl9icm93c2VyX3RocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGOCBieXRlIGFycmF5LCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvciBieXRlLlxuICAgIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBHb3RjaGE6IGNoYXJDb2RlQXQgcmV0dXJucyBhIDE2LWJpdCB3b3JkIHRoYXQgaXMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIG5vdCBhIFVuaWNvZGUgY29kZSBwb2ludCBvZiB0aGUgY2hhcmFjdGVyISBTbyBkZWNvZGUgVVRGMTYtPlVURjMyLT5VVEY4LlxuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICAgICAgICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcbiAgICAgICAgICAgIGlmICh1ID49IDB4RDgwMCAmJiB1IDw9IDB4REZGRikgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNGRik7XG4gICAgICAgICAgICBpZiAodSA8PSAweDdGKSArK2xlbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHUgPD0gMHg3RkYpIGxlbiArPSAyO1xuICAgICAgICAgICAgZWxzZSBpZiAodSA8PSAweEZGRkYpIGxlbiArPSAzO1xuICAgICAgICAgICAgZWxzZSBsZW4gKz0gNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cblxuICAgIHZhciB3YXNtVGFibGVNaXJyb3IgPSBbXTtcbiAgZnVuY3Rpb24gZ2V0V2FzbVRhYmxlRW50cnkoZnVuY1B0cikge1xuICAgICAgdmFyIGZ1bmMgPSB3YXNtVGFibGVNaXJyb3JbZnVuY1B0cl07XG4gICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgaWYgKGZ1bmNQdHIgPj0gd2FzbVRhYmxlTWlycm9yLmxlbmd0aCkgd2FzbVRhYmxlTWlycm9yLmxlbmd0aCA9IGZ1bmNQdHIgKyAxO1xuICAgICAgICB3YXNtVGFibGVNaXJyb3JbZnVuY1B0cl0gPSBmdW5jID0gd2FzbVRhYmxlLmdldChmdW5jUHRyKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydCh3YXNtVGFibGUuZ2V0KGZ1bmNQdHIpID09IGZ1bmMsIFwiSmF2YVNjcmlwdC1zaWRlIFdhc20gZnVuY3Rpb24gdGFibGUgbWlycm9yIGlzIG91dCBvZiBkYXRlIVwiKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cblxuICAgIHZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgICAgICAgdGhyb3cgdG9UaHJvdztcbiAgICAgIH07XG5cbiAgICAvKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRoaXMge0V4aXRTdGF0dXN9XG4gKi9cbiAgICBmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkV4aXRTdGF0dXNcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiICsgc3RhdHVzICsgXCIpXCI7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUV4Y2VwdGlvbihlKSB7XG4gICAgICAgIC8vIENlcnRhaW4gZXhjZXB0aW9uIHR5cGVzIHdlIGRvIG5vdCB0cmVhdCBhcyBlcnJvcnMgc2luY2UgdGhleSBhcmUgdXNlZCBmb3JcbiAgICAgICAgLy8gaW50ZXJuYWwgY29udHJvbCBmbG93LlxuICAgICAgICAvLyAxLiBFeGl0U3RhdHVzLCB3aGljaCBpcyB0aHJvd24gYnkgZXhpdCgpXG4gICAgICAgIC8vIDIuIFwidW53aW5kXCIsIHdoaWNoIGlzIHRocm93biBieSBlbXNjcmlwdGVuX3Vud2luZF90b19qc19ldmVudF9sb29wKCkgYW5kIG90aGVyc1xuICAgICAgICAvLyAgICB0aGF0IHdpc2ggdG8gcmV0dXJuIHRvIEpTIGV2ZW50IGxvb3AuXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXhpdFN0YXR1cyB8fCBlID09ICd1bndpbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gRVhJVFNUQVRVUztcbiAgICAgICAgfVxuICAgICAgICBxdWl0XygxLCBlKTtcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtib29sZWFuPX0gc3luY2hyb25vdXMgKi9cbiAgICBmdW5jdGlvbiBjYWxsVXNlckNhbGxiYWNrKGZ1bmMsIHN5bmNocm9ub3VzKSB7XG4gICAgICAgIGlmIChBQk9SVCkge1xuICAgICAgICAgICAgZXJyKCd1c2VyIGNhbGxiYWNrIHRyaWdnZXJlZCBhZnRlciBydW50aW1lIGV4aXRlZCBvciBhcHBsaWNhdGlvbiBhYm9ydGVkLiAgSWdub3JpbmcuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIHN5bmNocm9ub3VzIGNhbGxzLCBsZXQgYW55IGV4Y2VwdGlvbnMgcHJvcGFnYXRlLCBhbmQgZG9uJ3QgbGV0IHRoZSBydW50aW1lIGV4aXQuXG4gICAgICAgIGlmIChzeW5jaHJvbm91cykge1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUV4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoTG9hZENhY2hlZERhdGEoZGIsIGZldGNoLCBvbnN1Y2Nlc3MsIG9uZXJyb3IpIHtcbiAgICAgICAgaWYgKCFkYikge1xuICAgICAgICAgICAgb25lcnJvcihmZXRjaCwgMCwgJ0luZGV4ZWREQiBub3QgYXZhaWxhYmxlIScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZldGNoX2F0dHIgPSBmZXRjaCArIDExMjtcbiAgICAgICAgdmFyIHBhdGggPSBIRUFQVTMyW2ZldGNoX2F0dHIgKyA2NCA+PiAyXTtcbiAgICAgICAgaWYgKCFwYXRoKSBwYXRoID0gSEVBUFUzMltmZXRjaCArIDggPj4gMl07XG4gICAgICAgIHZhciBwYXRoU3RyID0gVVRGOFRvU3RyaW5nKHBhdGgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbJ0ZJTEVTJ10sICdyZWFkb25seScpO1xuICAgICAgICAgICAgdmFyIHBhY2thZ2VzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ0ZJTEVTJyk7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IHBhY2thZ2VzLmdldChwYXRoU3RyKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggfHwgdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSBwb2ludGVyIG1hbGxvYygpZWQgaGVyZSBoYXMgdGhlIHNhbWUgbGlmZXRpbWUgYXMgdGhlIGVtc2NyaXB0ZW5fZmV0Y2hfdCBzdHJ1Y3R1cmUgaXRzZWxmIGhhcywgYW5kIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGZyZWVkIHdoZW4gZW1zY3JpcHRlbl9mZXRjaF9jbG9zZSgpIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHB0ciA9IF9tYWxsb2MobGVuKTtcbiAgICAgICAgICAgICAgICAgICAgSEVBUFU4LnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIHB0cik7XG4gICAgICAgICAgICAgICAgICAgIEhFQVBVMzJbZmV0Y2ggKyAxMiA+PiAyXSA9IHB0cjtcbiAgICAgICAgICAgICAgICAgICAgRmV0Y2guc2V0dTY0KGZldGNoICsgMTYsIGxlbik7XG4gICAgICAgICAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDI0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgRmV0Y2guc2V0dTY0KGZldGNoICsgMzIsIGxlbik7XG4gICAgICAgICAgICAgICAgICAgIEhFQVBVMTZbZmV0Y2ggKyA0MCA+PiAxXSA9IDQ7IC8vIE1pbWljIFhIUiByZWFkeVN0YXRlIDQgPT09ICdET05FOiBUaGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlJ1xuICAgICAgICAgICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDIgPj4gMV0gPSAyMDA7IC8vIE1pbWljIFhIUiBIVFRQIHN0YXR1cyBjb2RlIDIwMCBcIk9LXCJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nVG9VVEY4KFwiT0tcIiwgZmV0Y2ggKyA0NCwgNjQpO1xuICAgICAgICAgICAgICAgICAgICBvbnN1Y2Nlc3MoZmV0Y2gsIDAsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZWVkZWQgdG8gbG9hZCwgYnV0IHRoZSBsb2FkIGNhbWUgYmFjayB3aXRoIHRoZSB2YWx1ZSBvZiB1bmRlZmluZWQsIHRyZWF0IHRoYXQgYXMgYW4gZXJyb3Igc2luY2Ugd2UgbmV2ZXIgc3RvcmUgdW5kZWZpbmVkIGluIGRiLlxuICAgICAgICAgICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDAgPj4gMV0gPSA0OyAvLyBNaW1pYyBYSFIgcmVhZHlTdGF0ZSA0ID09PSAnRE9ORTogVGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgSEVBUFUxNltmZXRjaCArIDQyID4+IDFdID0gNDA0OyAvLyBNaW1pYyBYSFIgSFRUUCBzdGF0dXMgY29kZSA0MDQgXCJOb3QgRm91bmRcIlxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdUb1VURjgoXCJOb3QgRm91bmRcIiwgZmV0Y2ggKyA0NCwgNjQpO1xuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKGZldGNoLCAwLCAnbm8gZGF0YScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDAgPj4gMV0gPSA0OyAvLyBNaW1pYyBYSFIgcmVhZHlTdGF0ZSA0ID09PSAnRE9ORTogVGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZSdcbiAgICAgICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDIgPj4gMV0gPSA0MDQ7IC8vIE1pbWljIFhIUiBIVFRQIHN0YXR1cyBjb2RlIDQwNCBcIk5vdCBGb3VuZFwiXG4gICAgICAgICAgICAgICAgc3RyaW5nVG9VVEY4KFwiTm90IEZvdW5kXCIsIGZldGNoICsgNDQsIDY0KTtcbiAgICAgICAgICAgICAgICBvbmVycm9yKGZldGNoLCAwLCBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGZldGNoLCAwLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoWEhSKGZldGNoLCBvbnN1Y2Nlc3MsIG9uZXJyb3IsIG9ucHJvZ3Jlc3MsIG9ucmVhZHlzdGF0ZWNoYW5nZSkge1xuICAgICAgICB2YXIgdXJsID0gSEVBUFUzMltmZXRjaCArIDggPj4gMl07XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICBvbmVycm9yKGZldGNoLCAwLCAnbm8gdXJsIHNwZWNpZmllZCEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsXyA9IFVURjhUb1N0cmluZyh1cmwpO1xuXG4gICAgICAgIHZhciBmZXRjaF9hdHRyID0gZmV0Y2ggKyAxMTI7XG4gICAgICAgIHZhciByZXF1ZXN0TWV0aG9kID0gVVRGOFRvU3RyaW5nKGZldGNoX2F0dHIpO1xuICAgICAgICBpZiAoIXJlcXVlc3RNZXRob2QpIHJlcXVlc3RNZXRob2QgPSAnR0VUJztcbiAgICAgICAgdmFyIHVzZXJEYXRhID0gSEVBUFUzMltmZXRjaCArIDQgPj4gMl07XG4gICAgICAgIHZhciBmZXRjaEF0dHJpYnV0ZXMgPSBIRUFQVTMyW2ZldGNoX2F0dHIgKyA1MiA+PiAyXTtcbiAgICAgICAgdmFyIHRpbWVvdXRNc2VjcyA9IEhFQVBVMzJbZmV0Y2hfYXR0ciArIDU2ID4+IDJdO1xuICAgICAgICB2YXIgd2l0aENyZWRlbnRpYWxzID0gISFIRUFQVTMyW2ZldGNoX2F0dHIgKyA2MCA+PiAyXTtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uUGF0aCA9IEhFQVBVMzJbZmV0Y2hfYXR0ciArIDY0ID4+IDJdO1xuICAgICAgICB2YXIgdXNlck5hbWUgPSBIRUFQVTMyW2ZldGNoX2F0dHIgKyA2OCA+PiAyXTtcbiAgICAgICAgdmFyIHBhc3N3b3JkID0gSEVBUFUzMltmZXRjaF9hdHRyICsgNzIgPj4gMl07XG4gICAgICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IEhFQVBVMzJbZmV0Y2hfYXR0ciArIDc2ID4+IDJdO1xuICAgICAgICB2YXIgb3ZlcnJpZGRlbk1pbWVUeXBlID0gSEVBUFUzMltmZXRjaF9hdHRyICsgODAgPj4gMl07XG4gICAgICAgIHZhciBkYXRhUHRyID0gSEVBUFUzMltmZXRjaF9hdHRyICsgODQgPj4gMl07XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gSEVBUFUzMltmZXRjaF9hdHRyICsgODggPj4gMl07XG5cbiAgICAgICAgdmFyIGZldGNoQXR0ckxvYWRUb01lbW9yeSA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDEpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyU3RyZWFtRGF0YSA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDIpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyUGVyc2lzdEZpbGUgPSAhIShmZXRjaEF0dHJpYnV0ZXMgJiA0KTtcbiAgICAgICAgdmFyIGZldGNoQXR0ckFwcGVuZCA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDgpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyUmVwbGFjZSA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDE2KTtcbiAgICAgICAgdmFyIGZldGNoQXR0clN5bmNocm9ub3VzID0gISEoZmV0Y2hBdHRyaWJ1dGVzICYgNjQpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyV2FpdGFibGUgPSAhIShmZXRjaEF0dHJpYnV0ZXMgJiAxMjgpO1xuXG4gICAgICAgIHZhciB1c2VyTmFtZVN0ciA9IHVzZXJOYW1lID8gVVRGOFRvU3RyaW5nKHVzZXJOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHBhc3N3b3JkU3RyID0gcGFzc3dvcmQgPyBVVEY4VG9TdHJpbmcocGFzc3dvcmQpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHdpdGhDcmVkZW50aWFscztcbiAgICAgICAgeGhyLm9wZW4ocmVxdWVzdE1ldGhvZCwgdXJsXywgIWZldGNoQXR0clN5bmNocm9ub3VzLCB1c2VyTmFtZVN0ciwgcGFzc3dvcmRTdHIpO1xuICAgICAgICBpZiAoIWZldGNoQXR0clN5bmNocm9ub3VzKSB4aHIudGltZW91dCA9IHRpbWVvdXRNc2VjczsgLy8gWEhSIHRpbWVvdXQgZmllbGQgaXMgb25seSBhY2Nlc3NpYmxlIGluIGFzeW5jIFhIUnMsIGFuZCBtdXN0IGJlIHNldCBhZnRlciAub3BlbigpIGJ1dCBiZWZvcmUgLnNlbmQoKS5cbiAgICAgICAgeGhyLnVybF8gPSB1cmxfOyAvLyBTYXZlIHRoZSB1cmwgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAoYW5kIGZvciBjb21wYXJpbmcgdG8gdGhlIHJlc3BvbnNlVVJMIHRoYXQgc2VydmVyIHNpZGUgYWR2ZXJ0aXNlZClcbiAgICAgICAgYXNzZXJ0KCFmZXRjaEF0dHJTdHJlYW1EYXRhLCAnc3RyZWFtaW5nIHVzZXMgbW96LWNodW5rZWQtYXJyYXlidWZmZXIgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZDsgVE9ETzogcmV3cml0ZSB1c2luZyBmZXRjaCgpJyk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgICAgIGlmIChvdmVycmlkZGVuTWltZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdmVycmlkZGVuTWltZVR5cGVTdHIgPSBVVEY4VG9TdHJpbmcob3ZlcnJpZGRlbk1pbWVUeXBlKTtcbiAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG92ZXJyaWRkZW5NaW1lVHlwZVN0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKDsgOykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBIRUFQVTMyW3JlcXVlc3RIZWFkZXJzID4+IDJdO1xuICAgICAgICAgICAgICAgIGlmICgha2V5KSBicmVhaztcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBIRUFQVTMyW3JlcXVlc3RIZWFkZXJzICsgNCA+PiAyXTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSBicmVhaztcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycyArPSA4O1xuICAgICAgICAgICAgICAgIHZhciBrZXlTdHIgPSBVVEY4VG9TdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVTdHIgPSBVVEY4VG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleVN0ciwgdmFsdWVTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEZldGNoLnhocnMucHVzaCh4aHIpO1xuICAgICAgICB2YXIgaWQgPSBGZXRjaC54aHJzLmxlbmd0aDtcbiAgICAgICAgSEVBUFUzMltmZXRjaCArIDAgPj4gMl0gPSBpZDtcbiAgICAgICAgdmFyIGRhdGEgPSAoZGF0YVB0ciAmJiBkYXRhTGVuZ3RoKSA/IEhFQVBVOC5zbGljZShkYXRhUHRyLCBkYXRhUHRyICsgZGF0YUxlbmd0aCkgOiBudWxsO1xuICAgICAgICAvLyBUT0RPOiBTdXBwb3J0IHNwZWNpZnlpbmcgY3VzdG9tIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3QuXG5cbiAgICAgICAgLy8gU2hhcmUgdGhlIGNvZGUgdG8gc2F2ZSB0aGUgcmVzcG9uc2UsIGFzIHdlIG5lZWQgdG8gZG8gc28gYm90aCBvbiBzdWNjZXNzXG4gICAgICAgIC8vIGFuZCBvbiBlcnJvciAoZGVzcGl0ZSBhbiBlcnJvciwgdGhlcmUgbWF5IGJlIGEgcmVzcG9uc2UsIGxpa2UgYSA0MDQgcGFnZSkuXG4gICAgICAgIC8vIFRoaXMgcmVjZWl2ZXMgYSBjb25kaXRpb24sIHdoaWNoIGRldGVybWluZXMgd2hldGhlciB0byBzYXZlIHRoZSB4aHInc1xuICAgICAgICAvLyByZXNwb25zZSwgb3IganVzdCAwLlxuICAgICAgICBmdW5jdGlvbiBzYXZlUmVzcG9uc2UoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcHRyID0gMDtcbiAgICAgICAgICAgIHZhciBwdHJMZW4gPSAwO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHB0ckxlbiA9IHhoci5yZXNwb25zZSA/IHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSBwb2ludGVyIG1hbGxvYygpZWQgaGVyZSBoYXMgdGhlIHNhbWUgbGlmZXRpbWUgYXMgdGhlIGVtc2NyaXB0ZW5fZmV0Y2hfdCBzdHJ1Y3R1cmUgaXRzZWxmIGhhcywgYW5kIGlzXG4gICAgICAgICAgICAgICAgLy8gZnJlZWQgd2hlbiBlbXNjcmlwdGVuX2ZldGNoX2Nsb3NlKCkgaXMgY2FsbGVkLlxuICAgICAgICAgICAgICAgIHB0ciA9IF9tYWxsb2MocHRyTGVuKTtcbiAgICAgICAgICAgICAgICBIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXtBcnJheTxudW1iZXI+fSAqLyh4aHIucmVzcG9uc2UpKSwgcHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhFQVBVMzJbZmV0Y2ggKyAxMiA+PiAyXSA9IHB0cjtcbiAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDE2LCBwdHJMZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgeGhyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICBzYXZlUmVzcG9uc2UoZmV0Y2hBdHRyTG9hZFRvTWVtb3J5ICYmICFmZXRjaEF0dHJTdHJlYW1EYXRhKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB4aHIucmVzcG9uc2UgPyB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aCA6IDA7XG4gICAgICAgICAgICBGZXRjaC5zZXR1NjQoZmV0Y2ggKyAyNCwgMCk7XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbmFsIFhIUi5vbmxvYWQgaGFuZGxlciByZWNlaXZlcyB0aGUgYnl0ZWRhdGEgdG8gY29tcHV0ZSB0b3RhbCBsZW5ndGgsIHJlcG9ydCB0aGF0LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBkb24ndCB3cml0ZSBhbnl0aGluZyBvdXQgaGVyZSwgd2hpY2ggd2lsbCByZXRhaW4gdGhlIGxhdGVzdCBieXRlIHNpemUgcmVwb3J0ZWQgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgbW9zdCByZWNlbnQgWEhSLm9ucHJvZ3Jlc3MgaGFuZGxlci5cbiAgICAgICAgICAgICAgICBGZXRjaC5zZXR1NjQoZmV0Y2ggKyAzMiwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhFQVBVMTZbZmV0Y2ggKyA0MCA+PiAxXSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgSEVBUFUxNltmZXRjaCArIDQyID4+IDFdID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzVGV4dCkgc3RyaW5nVG9VVEY4KHhoci5zdGF0dXNUZXh0LCBmZXRjaCArIDQ0LCA2NCk7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIGlmIChvbnN1Y2Nlc3MpIG9uc3VjY2VzcyhmZXRjaCwgeGhyLCBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uZXJyb3IpIG9uZXJyb3IoZmV0Y2gsIHhociwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIHNhdmVSZXNwb25zZShmZXRjaEF0dHJMb2FkVG9NZW1vcnkpO1xuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7IC8vIFhYWCBUT0RPOiBPdmVyd3JpdGluZyB4aHIuc3RhdHVzIGRvZXNuJ3Qgd29yayBoZXJlLCBzbyBkb24ndCBvdmVycmlkZSBhbnl3aGVyZSBlbHNlIGVpdGhlci5cbiAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDI0LCAwKTtcbiAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDMyLCB4aHIucmVzcG9uc2UgPyB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aCA6IDApO1xuICAgICAgICAgICAgSEVBUFUxNltmZXRjaCArIDQwID4+IDFdID0geGhyLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDIgPj4gMV0gPSBzdGF0dXM7XG4gICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcihmZXRjaCwgeGhyLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9udGltZW91dCA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcihmZXRjaCwgeGhyLCBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIHB0ckxlbiA9IChmZXRjaEF0dHJMb2FkVG9NZW1vcnkgJiYgZmV0Y2hBdHRyU3RyZWFtRGF0YSAmJiB4aHIucmVzcG9uc2UpID8geGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHB0ciA9IDA7XG4gICAgICAgICAgICBpZiAoZmV0Y2hBdHRyTG9hZFRvTWVtb3J5ICYmIGZldGNoQXR0clN0cmVhbURhdGEpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQob25wcm9ncmVzcywgJ1doZW4gZG9pbmcgYSBzdHJlYW1pbmcgZmV0Y2gsIHlvdSBzaG91bGQgaGF2ZSBhbiBvbnByb2dyZXNzIGhhbmRsZXIgcmVnaXN0ZXJlZCB0byByZWNlaXZlIHRoZSBjaHVua3MhJyk7XG4gICAgICAgICAgICAgICAgLy8gQWxsb2NhdGUgYnl0ZSBkYXRhIGluIEVtc2NyaXB0ZW4gaGVhcCBmb3IgdGhlIHN0cmVhbWVkIG1lbW9yeSBibG9jayAoZnJlZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgb25wcm9ncmVzcyBjYWxsKVxuICAgICAgICAgICAgICAgIHB0ciA9IF9tYWxsb2MocHRyTGVuKTtcbiAgICAgICAgICAgICAgICBIRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXtBcnJheTxudW1iZXI+fSAqLyh4aHIucmVzcG9uc2UpKSwgcHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhFQVBVMzJbZmV0Y2ggKyAxMiA+PiAyXSA9IHB0cjtcbiAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDE2LCBwdHJMZW4pO1xuICAgICAgICAgICAgRmV0Y2guc2V0dTY0KGZldGNoICsgMjQsIGUubG9hZGVkIC0gcHRyTGVuKTtcbiAgICAgICAgICAgIEZldGNoLnNldHU2NChmZXRjaCArIDMyLCBlLnRvdGFsKTtcbiAgICAgICAgICAgIEhFQVBVMTZbZmV0Y2ggKyA0MCA+PiAxXSA9IHhoci5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgLy8gSWYgbG9hZGluZyBmaWxlcyBmcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgZ2l2ZSBIVFRQIHN0YXR1cyBjb2RlLCBhc3N1bWUgc3VjY2VzcyBpZiB3ZSBnZXQgZGF0YSBieXRlc1xuICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDMgJiYgeGhyLnN0YXR1cyA9PT0gMCAmJiBlLmxvYWRlZCA+IDApIHhoci5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICBIRUFQVTE2W2ZldGNoICsgNDIgPj4gMV0gPSB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXNUZXh0KSBzdHJpbmdUb1VURjgoeGhyLnN0YXR1c1RleHQsIGZldGNoICsgNDQsIDY0KTtcbiAgICAgICAgICAgIGlmIChvbnByb2dyZXNzKSBvbnByb2dyZXNzKGZldGNoLCB4aHIsIGUpO1xuICAgICAgICAgICAgaWYgKHB0cikge1xuICAgICAgICAgICAgICAgIF9mcmVlKHB0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgSEVBUFUxNltmZXRjaCArIDQwID4+IDFdID0geGhyLnJlYWR5U3RhdGU7XG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICAgICAgICAgIEhFQVBVMTZbZmV0Y2ggKyA0MiA+PiAxXSA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25yZWFkeXN0YXRlY2hhbmdlKSBvbnJlYWR5c3RhdGVjaGFuZ2UoZmV0Y2gsIHhociwgZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB4aHIuc2VuZChkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKG9uZXJyb3IpIG9uZXJyb3IoZmV0Y2gsIHhociwgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zdGFydF9mZXRjaChmZXRjaCwgc3VjY2Vzc2NiLCBlcnJvcmNiLCBwcm9ncmVzc2NiLCByZWFkeXN0YXRlY2hhbmdlY2IpIHtcbiAgICAgICAgLy8gQXZvaWQgc2h1dHRpbmcgZG93biB0aGUgcnVudGltZSBzaW5jZSB3ZSB3YW50IHRvIHdhaXQgZm9yIHRoZSBhc3luY1xuICAgICAgICAvLyByZXNwb25zZS5cblxuXG4gICAgICAgIHZhciBmZXRjaF9hdHRyID0gZmV0Y2ggKyAxMTI7XG4gICAgICAgIHZhciByZXF1ZXN0TWV0aG9kID0gVVRGOFRvU3RyaW5nKGZldGNoX2F0dHIpO1xuICAgICAgICB2YXIgb25zdWNjZXNzID0gSEVBUFUzMltmZXRjaF9hdHRyICsgMzYgPj4gMl07XG4gICAgICAgIHZhciBvbmVycm9yID0gSEVBUFUzMltmZXRjaF9hdHRyICsgNDAgPj4gMl07XG4gICAgICAgIHZhciBvbnByb2dyZXNzID0gSEVBUFUzMltmZXRjaF9hdHRyICsgNDQgPj4gMl07XG4gICAgICAgIHZhciBvbnJlYWR5c3RhdGVjaGFuZ2UgPSBIRUFQVTMyW2ZldGNoX2F0dHIgKyA0OCA+PiAyXTtcbiAgICAgICAgdmFyIGZldGNoQXR0cmlidXRlcyA9IEhFQVBVMzJbZmV0Y2hfYXR0ciArIDUyID4+IDJdO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyTG9hZFRvTWVtb3J5ID0gISEoZmV0Y2hBdHRyaWJ1dGVzICYgMSk7XG4gICAgICAgIHZhciBmZXRjaEF0dHJTdHJlYW1EYXRhID0gISEoZmV0Y2hBdHRyaWJ1dGVzICYgMik7XG4gICAgICAgIHZhciBmZXRjaEF0dHJQZXJzaXN0RmlsZSA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDQpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyTm9Eb3dubG9hZCA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDMyKTtcbiAgICAgICAgdmFyIGZldGNoQXR0ckFwcGVuZCA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDgpO1xuICAgICAgICB2YXIgZmV0Y2hBdHRyUmVwbGFjZSA9ICEhKGZldGNoQXR0cmlidXRlcyAmIDE2KTtcbiAgICAgICAgdmFyIGZldGNoQXR0clN5bmNocm9ub3VzID0gISEoZmV0Y2hBdHRyaWJ1dGVzICYgNjQpO1xuXG4gICAgICAgIHZhciByZXBvcnRTdWNjZXNzID0gKGZldGNoLCB4aHIsIGUpID0+IHtcblxuICAgICAgICAgICAgY2FsbFVzZXJDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9uc3VjY2VzcykgZ2V0V2FzbVRhYmxlRW50cnkob25zdWNjZXNzKShmZXRjaCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc2NiKSBzdWNjZXNzY2IoZmV0Y2gpO1xuICAgICAgICAgICAgfSwgZmV0Y2hBdHRyU3luY2hyb25vdXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXBvcnRQcm9ncmVzcyA9IChmZXRjaCwgeGhyLCBlKSA9PiB7XG4gICAgICAgICAgICBjYWxsVXNlckNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob25wcm9ncmVzcykgZ2V0V2FzbVRhYmxlRW50cnkob25wcm9ncmVzcykoZmV0Y2gpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2dyZXNzY2IpIHByb2dyZXNzY2IoZmV0Y2gpO1xuICAgICAgICAgICAgfSwgZmV0Y2hBdHRyU3luY2hyb25vdXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXBvcnRFcnJvciA9IChmZXRjaCwgeGhyLCBlKSA9PiB7XG5cbiAgICAgICAgICAgIGNhbGxVc2VyQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvbmVycm9yKSBnZXRXYXNtVGFibGVFbnRyeShvbmVycm9yKShmZXRjaCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3JjYikgZXJyb3JjYihmZXRjaCk7XG4gICAgICAgICAgICB9LCBmZXRjaEF0dHJTeW5jaHJvbm91cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlcG9ydFJlYWR5U3RhdGVDaGFuZ2UgPSAoZmV0Y2gsIHhociwgZSkgPT4ge1xuICAgICAgICAgICAgY2FsbFVzZXJDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9ucmVhZHlzdGF0ZWNoYW5nZSkgZ2V0V2FzbVRhYmxlRW50cnkob25yZWFkeXN0YXRlY2hhbmdlKShmZXRjaCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVhZHlzdGF0ZWNoYW5nZWNiKSByZWFkeXN0YXRlY2hhbmdlY2IoZmV0Y2gpO1xuICAgICAgICAgICAgfSwgZmV0Y2hBdHRyU3luY2hyb25vdXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwZXJmb3JtVW5jYWNoZWRYaHIgPSAoZmV0Y2gsIHhociwgZSkgPT4ge1xuICAgICAgICAgICAgZmV0Y2hYSFIoZmV0Y2gsIHJlcG9ydFN1Y2Nlc3MsIHJlcG9ydEVycm9yLCByZXBvcnRQcm9ncmVzcywgcmVwb3J0UmVhZHlTdGF0ZUNoYW5nZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNhY2hlUmVzdWx0QW5kUmVwb3J0U3VjY2VzcyA9IChmZXRjaCwgeGhyLCBlKSA9PiB7XG4gICAgICAgICAgICB2YXIgc3RvcmVTdWNjZXNzID0gKGZldGNoLCB4aHIsIGUpID0+IHtcblxuICAgICAgICAgICAgICAgIGNhbGxVc2VyQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25zdWNjZXNzKSBnZXRXYXNtVGFibGVFbnRyeShvbnN1Y2Nlc3MpKGZldGNoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3VjY2Vzc2NiKSBzdWNjZXNzY2IoZmV0Y2gpO1xuICAgICAgICAgICAgICAgIH0sIGZldGNoQXR0clN5bmNocm9ub3VzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3RvcmVFcnJvciA9IChmZXRjaCwgeGhyLCBlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjYWxsVXNlckNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uc3VjY2VzcykgZ2V0V2FzbVRhYmxlRW50cnkob25zdWNjZXNzKShmZXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NjYikgc3VjY2Vzc2NiKGZldGNoKTtcbiAgICAgICAgICAgICAgICB9LCBmZXRjaEF0dHJTeW5jaHJvbm91cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmV0Y2hDYWNoZURhdGEoRmV0Y2guZGJJbnN0YW5jZSwgZmV0Y2gsIHhoci5yZXNwb25zZSwgc3RvcmVTdWNjZXNzLCBzdG9yZUVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGVyZm9ybUNhY2hlZFhociA9IChmZXRjaCwgeGhyLCBlKSA9PiB7XG4gICAgICAgICAgICBmZXRjaFhIUihmZXRjaCwgY2FjaGVSZXN1bHRBbmRSZXBvcnRTdWNjZXNzLCByZXBvcnRFcnJvciwgcmVwb3J0UHJvZ3Jlc3MsIHJlcG9ydFJlYWR5U3RhdGVDaGFuZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXF1ZXN0TWV0aG9kID09PSAnRU1fSURCX1NUT1JFJykge1xuICAgICAgICAgICAgLy8gVE9ETyg/KTogSGVyZSB3ZSBwZXJmb3JtIGEgY2xvbmUgb2YgdGhlIGRhdGEsIGJlY2F1c2Ugc3RvcmluZyBzaGFyZWQgdHlwZWQgYXJyYXlzIHRvIEluZGV4ZWREQiBkb2VzIG5vdCBzZWVtIHRvIGJlIGFsbG93ZWQuXG4gICAgICAgICAgICB2YXIgcHRyID0gSEVBUFUzMltmZXRjaF9hdHRyICsgODQgPj4gMl07XG4gICAgICAgICAgICBmZXRjaENhY2hlRGF0YShGZXRjaC5kYkluc3RhbmNlLCBmZXRjaCwgSEVBUFU4LnNsaWNlKHB0ciwgcHRyICsgSEVBUFUzMltmZXRjaF9hdHRyICsgODggPj4gMl0pLCByZXBvcnRTdWNjZXNzLCByZXBvcnRFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdE1ldGhvZCA9PT0gJ0VNX0lEQl9ERUxFVEUnKSB7XG4gICAgICAgICAgICBmZXRjaERlbGV0ZUNhY2hlZERhdGEoRmV0Y2guZGJJbnN0YW5jZSwgZmV0Y2gsIHJlcG9ydFN1Y2Nlc3MsIHJlcG9ydEVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghZmV0Y2hBdHRyUmVwbGFjZSkge1xuICAgICAgICAgICAgZmV0Y2hMb2FkQ2FjaGVkRGF0YShGZXRjaC5kYkluc3RhbmNlLCBmZXRjaCwgcmVwb3J0U3VjY2VzcywgZmV0Y2hBdHRyTm9Eb3dubG9hZCA/IHJlcG9ydEVycm9yIDogKGZldGNoQXR0clBlcnNpc3RGaWxlID8gcGVyZm9ybUNhY2hlZFhociA6IHBlcmZvcm1VbmNhY2hlZFhocikpO1xuICAgICAgICB9IGVsc2UgaWYgKCFmZXRjaEF0dHJOb0Rvd25sb2FkKSB7XG4gICAgICAgICAgICBmZXRjaFhIUihmZXRjaCwgZmV0Y2hBdHRyUGVyc2lzdEZpbGUgPyBjYWNoZVJlc3VsdEFuZFJlcG9ydFN1Y2Nlc3MgOiByZXBvcnRTdWNjZXNzLCByZXBvcnRFcnJvciwgcmVwb3J0UHJvZ3Jlc3MsIHJlcG9ydFJlYWR5U3RhdGVDaGFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIHRvZG86IGZyZWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX19lbXNjcmlwdGVuX2ZldGNoX2ZyZWUoaWQpIHtcbiAgICAgICAgLy9Ob3RlOiBzaG91bGQganVzdCBiZSBbaWRdLCBidXQgaW5kZXhlcyBvZmYgYnkgMSAoc2VlOiAjODgwMylcbiAgICAgICAgZGVsZXRlIEZldGNoLnhocnNbaWQgLSAxXTtcbiAgICB9XG5cbiAgICB2YXIgZmV0Y2hfZnVuY3Rpb25zID0ge1xuICAgICAgICBcImVtc2NyaXB0ZW5faXNfbWFpbl9icm93c2VyX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9pc19tYWluX2Jyb3dzZXJfdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc3RhcnRfZmV0Y2hcIjogX2Vtc2NyaXB0ZW5fc3RhcnRfZmV0Y2gsXG4gICAgICAgIFwiX2Vtc2NyaXB0ZW5fZmV0Y2hfZnJlZVwiOiBfX2Vtc2NyaXB0ZW5fZmV0Y2hfZnJlZSxcbiAgICAgICAgXCJfZW1zY3JpcHRlbl9mZXRjaF9nZXRfcmVzcG9uc2VfaGVhZGVyc1wiOiBfX2Vtc2NyaXB0ZW5fZmV0Y2hfZ2V0X3Jlc3BvbnNlX2hlYWRlcnMsXG4gICAgICAgIFwiX2Vtc2NyaXB0ZW5fZmV0Y2hfZ2V0X3Jlc3BvbnNlX2hlYWRlcnNfbGVuZ3RoXCI6IF9fZW1zY3JpcHRlbl9mZXRjaF9nZXRfcmVzcG9uc2VfaGVhZGVyc19sZW5ndGgsXG4gICAgfVxuXG5cbiAgICByZXR1cm4gZmV0Y2hfZnVuY3Rpb25zO1xufVxuXG5leHBvcnQgeyBGRVRDSF9NT0RVTEUgfSIsIlxuaW1wb3J0IHsgU0RMX01PRFVMRSB9IGZyb20gXCIuL2NvcmUtc2RsLmpzXCJcbmltcG9ydCB7IEZFVENIX01PRFVMRSB9IGZyb20gXCIuL2NvcmUtZmV0Y2guanNcIlxuXG52YXIgTW9kdWxlID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBfX2ZpbGVuYW1lICE9PSAndW5kZWZpbmVkJykgX3NjcmlwdERpciA9IF9zY3JpcHREaXIgfHwgX19maWxlbmFtZTtcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKE1vZHVsZSkge1xuICBNb2R1bGUgPSBNb2R1bGUgfHwge307XG5cblxuXG4vLyBUaGUgTW9kdWxlIG9iamVjdDogT3VyIGludGVyZmFjZSB0byB0aGUgb3V0c2lkZSB3b3JsZC4gV2UgaW1wb3J0XG4vLyBhbmQgZXhwb3J0IHZhbHVlcyBvbiBpdC4gVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyBNb2R1bGUgY2FuIGJlIHVzZWQ6XG4vLyAxLiBOb3QgZGVmaW5lZC4gV2UgY3JlYXRlIGl0IGhlcmVcbi8vIDIuIEEgZnVuY3Rpb24gcGFyYW1ldGVyLCBmdW5jdGlvbihNb2R1bGUpIHsgLi5nZW5lcmF0ZWQgY29kZS4uIH1cbi8vIDMuIHByZS1ydW4gYXBwZW5kZWQgaXQsIHZhciBNb2R1bGUgPSB7fTsgLi5nZW5lcmF0ZWQgY29kZS4uXG4vLyA0LiBFeHRlcm5hbCBzY3JpcHQgdGFnIGRlZmluZXMgdmFyIE1vZHVsZS5cbi8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgTW9kdWxlIGFscmVhZHkgZXhpc3RzIChlLmcuIGNhc2UgMyBhYm92ZSkuXG4vLyBTdWJzdGl0dXRpb24gd2lsbCBiZSByZXBsYWNlZCB3aXRoIGFjdHVhbCBjb2RlIG9uIGxhdGVyIHN0YWdlIG9mIHRoZSBidWlsZCxcbi8vIHRoaXMgd2F5IENsb3N1cmUgQ29tcGlsZXIgd2lsbCBub3QgbWFuZ2xlIGl0IChlLmcuIGNhc2UgNC4gYWJvdmUpLlxuLy8gTm90ZSB0aGF0IGlmIHlvdSB3YW50IHRvIHJ1biBjbG9zdXJlLCBhbmQgYWxzbyB0byB1c2UgTW9kdWxlXG4vLyBhZnRlciB0aGUgZ2VuZXJhdGVkIGNvZGUsIHlvdSB3aWxsIG5lZWQgdG8gZGVmaW5lICAgdmFyIE1vZHVsZSA9IHt9O1xuLy8gYmVmb3JlIHRoZSBjb2RlLiBUaGVuIHRoYXQgb2JqZWN0IHdpbGwgYmUgdXNlZCBpbiB0aGUgY29kZSwgYW5kIHlvdVxuLy8gY2FuIGNvbnRpbnVlIHRvIHVzZSBNb2R1bGUgYWZ0ZXJ3YXJkcyBhcyB3ZWxsLlxudmFyIE1vZHVsZSA9IHR5cGVvZiBNb2R1bGUgIT0gJ3VuZGVmaW5lZCcgPyBNb2R1bGUgOiB7fTtcbnZhciBmaWx0ZXJfZW50cmllcyA9IE1vZHVsZVsnZmlsdGVyX2VudHJpZXMnXSB8fCBbXTtcbnZhciBtb2R1bGVfZW50cmllcyA9IE1vZHVsZVsnbW9kdWxlX2VudHJpZXMnXSB8fCBbXTtcblxuLy8gU2VlIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfb2JqZWN0X2Fzc2lnblxuXG4vLyBTZXQgdXAgdGhlIHByb21pc2UgdGhhdCBpbmRpY2F0ZXMgdGhlIE1vZHVsZSBpcyBpbml0aWFsaXplZFxudmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcbk1vZHVsZVsncmVhZHknXSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIFwiZmlsdGVyX2VudHJpZXNcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBmaWx0ZXJfZW50cmllcyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgXCJtb2R1bGVfZW50cmllc1wiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZV9lbnRyaWVzIH0gfSk7XG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF91bmxvY2snKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfdW5sb2NrJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3B0aHJlYWRfbXV0ZXhfdW5sb2NrIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X3VubG9jaycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9wdGhyZWFkX211dGV4X3VubG9jayBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9sb2NrJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X2xvY2snLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcHRocmVhZF9tdXRleF9sb2NrIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X2xvY2snLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcHRocmVhZF9tdXRleF9sb2NrIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX3NlbGYnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfc2VsZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9wdGhyZWFkX3NlbGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfc2VsZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9wdGhyZWFkX3NlbGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3NwcmludGYnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3ByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3ByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zcHJpbnRmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ192ZnByaW50ZicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdmZwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfdmZwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3ZmcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3ZmcHJpbnRmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19mcHJpbnRmJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mcHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2ZwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2ZwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZnByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfYnNlYXJjaCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYnNlYXJjaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9ic2VhcmNoIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19ic2VhcmNoJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2JzZWFyY2ggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2ZyZXhwJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mcmV4cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9mcmV4cCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZnJleHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZnJleHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2xscmludCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbGxyaW50JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2xscmludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbGxyaW50JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2xscmludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZndyaXRlJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19md3JpdGUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZndyaXRlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19md3JpdGUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZndyaXRlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19jb3MnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2NvcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9jb3Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2NvcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9jb3Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2Nvc2gnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2Nvc2gnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfY29zaCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfY29zaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9jb3NoIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19hY29zJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19hY29zJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2Fjb3Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2Fjb3MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfYWNvcyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc2luJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zaW4nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc2luIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zaW4nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc2luIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zaW5oJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zaW5oJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3Npbmggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3NpbmgnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc2luaCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfYXNpbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYXNpbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9hc2luIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19hc2luJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2FzaW4gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3RhbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdGFuJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3RhbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdGFuJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3RhbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfdGFuaCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdGFuaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF90YW5oIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ190YW5oJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3Rhbmggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2F0YW4nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2F0YW4nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfYXRhbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfYXRhbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9hdGFuIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19leHAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2V4cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9leHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2V4cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9leHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2xvZycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbG9nJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2xvZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbG9nJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2xvZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZmFicycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZmFicycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9mYWJzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19mYWJzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2ZhYnMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jbXAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RybmNtcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RybmNtcCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJuY21wIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJkdXAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmR1cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zdHJkdXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmR1cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJkdXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfdGltZXNjYWxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfdGltZXNjYWxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9kdXJhdGlvbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb24gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X2R1cmF0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2R1cmF0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fdXJsJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fdXJsJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbGVpb191cmwgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb191cmwnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsZWlvX3VybCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX25ldycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWxlaW9fbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fbmV3JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbGVpb19uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbGVpb19zZXRfc3RhdHNfdTMyJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fc2V0X3N0YXRzX3UzMicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWxlaW9fc2V0X3N0YXRzX3UzMiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzInLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2xkZXhwJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19sZGV4cCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9sZGV4cCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbGRleHAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfbGRleHAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3B0aHJlYWRfbXV0ZXhfZGVzdHJveScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9kZXN0cm95JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3B0aHJlYWRfbXV0ZXhfZGVzdHJveSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9kZXN0cm95JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3B0aHJlYWRfbXV0ZXhfZGVzdHJveSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfcHRocmVhZF9tdXRleF9pbml0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X2luaXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcHRocmVhZF9tdXRleF9pbml0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19wdGhyZWFkX211dGV4X2luaXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfcHRocmVhZF9tdXRleF9pbml0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19wb3NpeF9tZW1hbGlnbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcG9zaXhfbWVtYWxpZ24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcG9zaXhfbWVtYWxpZ24gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3Bvc2l4X21lbWFsaWduJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3Bvc2l4X21lbWFsaWduIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19wb3cnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3BvdycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9wb3cgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3BvdycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9wb3cgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3ZzbnByaW50ZicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdnNucHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3ZzbnByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfdnNucHJpbnRmJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3ZzbnByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2V0ZW52JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZXRlbnYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2V0ZW52IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZXRlbnYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2V0ZW52IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJjbXAnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNtcCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zdHJjbXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNtcCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJjbXAgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3N0cmxlbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RybGVuJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3N0cmxlbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RybGVuJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3N0cmxlbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfc3RyY3B5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RyY3B5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zdHJjcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc3RyY3B5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJjYXQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNhdCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zdHJjYXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNhdCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJjYXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jcHknKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cm5jcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfc3RybmNweSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc3RybmNweScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJuY3B5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19zdHJjaHInKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNocicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zdHJjaHIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3N0cmNocicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9zdHJjaHIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX21lbXNldCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX21lbXNldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfbWVtc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX21lbXNldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfbWVtY3B5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1jcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfbWVtY3B5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1jcHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfbWVtY3B5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19tZW1tb3ZlJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1tb3ZlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX21lbW1vdmUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX21lbW1vdmUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfbWVtbW92ZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfbWVtYWxpZ24nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX21lbWFsaWduJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX21lbWFsaWduIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1hbGlnbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9tZW1hbGlnbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfbWVtY21wJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1jbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfbWVtY21wIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19tZW1jbXAnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfbWVtY21wIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19jYWxsb2MnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2NhbGxvYycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9jYWxsb2Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2NhbGxvYycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9jYWxsb2Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3JlYWxsb2MnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX3JlYWxsb2MnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfcmVhbGxvYyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfcmVhbGxvYycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9yZWFsbG9jIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl91cmxfY29uY2F0ZW5hdGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX3VybF9jb25jYXRlbmF0ZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl91cmxfY29uY2F0ZW5hdGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX3VybF9jb25jYXRlbmF0ZScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl91cmxfY29uY2F0ZW5hdGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX3N0cmR1cCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2Zfc3RyZHVwJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX3N0cmR1cCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2Zfc3RyZHVwJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX3N0cmR1cCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsZWlvX2dldF91ZHRhJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fZ2V0X3VkdGEnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsZWlvX2dldF91ZHRhIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWxlaW9fZ2V0X3VkdGEnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsZWlvX2dldF91ZHRhIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19uZXcnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9ic19uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9ic19uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2F2YWlsYWJsZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfYXZhaWxhYmxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2JzX2F2YWlsYWJsZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfYXZhaWxhYmxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2JzX2F2YWlsYWJsZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfcmVhZF9pbnQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX3JlYWRfaW50JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2JzX3JlYWRfaW50IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19yZWFkX2ludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9ic19yZWFkX2ludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfYnNfZ2V0X3Bvc2l0aW9uJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19nZXRfcG9zaXRpb24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfYnNfZ2V0X3Bvc2l0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19nZXRfcG9zaXRpb24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfYnNfZ2V0X3Bvc2l0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9ic19kZWwnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2RlbCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9ic19kZWwgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2JzX2RlbCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9ic19kZWwgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9nZXRfdWR0YScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX2dldF91ZHRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9nZXRfdWR0YSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX2dldF91ZHRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9nZXRfdWR0YSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2dldF9wYWNrZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2dldF9wYWNrZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9kYXRhJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9kYXRhJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X2RhdGEgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X2RhdGEnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfZGF0YSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHknKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfc2V0X3Byb3BlcnR5JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9waWRfc2V0X3Byb3BlcnR5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX3NldF9wcm9wZXJ0eScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGlkX3NldF9wcm9wZXJ0eSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2MnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfbmV3X2FsbG9jJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfbmV3X2FsbG9jIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX25ld19hbGxvYycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX25ld19hbGxvYyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZW5kJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NlbmQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZW5kIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NlbmQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19zZW5kIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfY2hlY2tfY2FwcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfY2hlY2tfY2FwcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfZ2V0X3Byb3BlcnR5JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2dldF9wcm9wZXJ0eScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX2dldF9wcm9wZXJ0eSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHknLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHkgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfbmV3JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX25ldycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX25ldyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfY29weV9wcm9wZXJ0aWVzJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGlkX2NvcHlfcHJvcGVydGllcycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGlkX2NvcHlfcHJvcGVydGllcyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9zZXRfbmFtZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3NldF9uYW1lJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9zZXRfbmFtZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3NldF9uYW1lJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9zZXRfbmFtZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9kZXBlbmRlbmN5X2ZsYWdzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9kZXBlbmRlbmN5X2ZsYWdzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X2RlcGVuZGVuY3lfZmxhZ3Mgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9zZXRfZnJhbWluZ19tb2RlJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3BpZF9zZXRfZnJhbWluZ19tb2RlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX25ld19yZWYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX25ld19yZWYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9jdHMnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2N0cycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9jdHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2N0cycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9jdHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfc2FwJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfc2FwJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb24nKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2R1cmF0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X2R1cmF0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9kdXJhdGlvbicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9kdXJhdGlvbiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHknKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfZ2V0X3Byb3BlcnR5JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfZ2V0X3Byb3BlcnR5IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9wcm9wZXJ0eScsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX2dldF9wcm9wZXJ0eSBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZycsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9nZl9maWx0ZXJfcGNrX3NldF9mcmFtaW5nIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX3NldF9mcmFtaW5nJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X2ZyYW1pbmcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfc2Vla19mbGFnJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19zZXRfc2Vla19mbGFnJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZyBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9zZWVrX2ZsYWcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZl9maWx0ZXJfcGNrX2dldF9zZWVrX2ZsYWcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19mZmx1c2gnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2ZmbHVzaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9mZmx1c2ggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2ZmbHVzaCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9mZmx1c2ggb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3NpcHJpbnRmJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19zaXByaW50ZicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9zaXByaW50ZiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2lwcmludGYnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfc2lwcmludGYgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX2NvbnN0cnVjdG9yJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19jb25zdHJ1Y3RvcicsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIF9jb25zdHJ1Y3RvciBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfY29uc3RydWN0b3InLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfY29uc3RydWN0b3Igb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4gICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlWydyZWFkeSddLCAnX3NldCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX3NldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX3NldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfZ2V0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfZ2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19nZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZ2V0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19kZXN0cnVjdG9yJykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19kZXN0cnVjdG9yJywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX2Rlc3RydWN0b3Igb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX2Rlc3RydWN0b3InLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfZGVzdHJ1Y3RvciBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfX19zdGRpb19leGl0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19fX3N0ZGlvX2V4aXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfX19zdGRpb19leGl0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19fX3N0ZGlvX2V4aXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfX19zdGRpb19leGl0IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX25ldycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19uZXcnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfb3JpZyRnZl9ic19uZXcgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfbmV3JywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfYnNfbmV3IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX2F2YWlsYWJsZScpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19hdmFpbGFibGUnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfb3JpZyRnZl9ic19hdmFpbGFibGUgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfYXZhaWxhYmxlJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfYnNfYXZhaWxhYmxlIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2JzX2dldF9wb3NpdGlvbicpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9ic19nZXRfcG9zaXRpb24nLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfb3JpZyRnZl9ic19nZXRfcG9zaXRpb24gb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfYnNfZ2V0X3Bvc2l0aW9uJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfYnNfZ2V0X3Bvc2l0aW9uIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2N0cycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfZ2V0X2N0cycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHMnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgZ2V0dGluZyBfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHMgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfZmlsdGVyX3Bja19nZXRfY3RzJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19nZXRfY3RzIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgIH1cbiAgICBcblxuICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0JykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBmdW5jdGlvbigpIHsgYWJvcnQoJ1lvdSBhcmUgc2V0dGluZyBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdfb3JpZyRsbHJpbnQnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlWydyZWFkeSddLCAnX29yaWckbGxyaW50JywgeyBjb25maWd1cmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIGdldHRpbmcgX29yaWckbGxyaW50IG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ19vcmlnJGxscmludCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBzZXR0aW5nIF9vcmlnJGxscmludCBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qcycpIH0gfSk7XG4gICAgICB9XG4gICAgXG5cbiAgICAgIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGVbJ3JlYWR5J10sICdvblJ1bnRpbWVJbml0aWFsaXplZCcpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbJ3JlYWR5J10sICdvblJ1bnRpbWVJbml0aWFsaXplZCcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyBhYm9ydCgnWW91IGFyZSBnZXR0aW5nIG9uUnVudGltZUluaXRpYWxpemVkIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzJykgfSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZVsncmVhZHknXSwgJ29uUnVudGltZUluaXRpYWxpemVkJywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogZnVuY3Rpb24oKSB7IGFib3J0KCdZb3UgYXJlIHNldHRpbmcgb25SdW50aW1lSW5pdGlhbGl6ZWQgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanMnKSB9IH0pO1xuICAgICAgfVxuICAgIFxuXG4vLyAtLXByZS1qc2VzIGFyZSBlbWl0dGVkIGFmdGVyIHRoZSBNb2R1bGUgaW50ZWdyYXRpb24gY29kZSwgc28gdGhhdCB0aGV5IGNhblxuLy8gcmVmZXIgdG8gTW9kdWxlIChpZiB0aGV5IGNob29zZTsgdGhleSBjYW4gYWxzbyBkZWZpbmUgTW9kdWxlKVxuLy8ge3tQUkVfSlNFU319XG5cbi8vIFNvbWV0aW1lcyBhbiBleGlzdGluZyBNb2R1bGUgb2JqZWN0IGV4aXN0cyB3aXRoIHByb3BlcnRpZXNcbi8vIG1lYW50IHRvIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBtb2R1bGUgZnVuY3Rpb25hbGl0eS4gSGVyZVxuLy8gd2UgY29sbGVjdCB0aG9zZSBwcm9wZXJ0aWVzIGFuZCByZWFwcGx5IF9hZnRlcl8gd2UgY29uZmlndXJlXG4vLyB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGRlZmF1bHRzIHRvIGF2b2lkIGhhdmluZyB0byBiZSBzb1xuLy8gZGVmZW5zaXZlIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbnZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG52YXIgYXJndW1lbnRzXyA9IFtdO1xudmFyIHRoaXNQcm9ncmFtID0gJy4vdGhpcy5wcm9ncmFtJztcbnZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgdGhyb3cgdG9UaHJvdztcbn07XG5cbi8vIERldGVybWluZSB0aGUgcnVudGltZSBlbnZpcm9ubWVudCB3ZSBhcmUgaW4uIFlvdSBjYW4gY3VzdG9taXplIHRoaXMgYnlcbi8vIHNldHRpbmcgdGhlIEVOVklST05NRU5UIHNldHRpbmcgYXQgY29tcGlsZSB0aW1lIChzZWUgc2V0dGluZ3MuanMpLlxuXG4vLyBBdHRlbXB0IHRvIGF1dG8tZGV0ZWN0IHRoZSBlbnZpcm9ubWVudFxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCc7XG52YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gZmFsc2U7Ly90eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSAnZnVuY3Rpb24nO1xuLy8gTi5iLiBFbGVjdHJvbi5qcyBlbnZpcm9ubWVudCBpcyBzaW11bHRhbmVvdXNseSBhIE5PREUtZW52aXJvbm1lbnQsIGJ1dFxuLy8gYWxzbyBhIHdlYiBlbnZpcm9ubWVudC5cbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gZmFsc2U7Ly90eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09ICdzdHJpbmcnO1xudmFyIEVOVklST05NRU5UX0lTX1NIRUxMID0gZmFsc2U7Ly8hRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbmlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNb2R1bGUuRU5WSVJPTk1FTlQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVG8gZm9yY2UgdGhlIGVudmlyb25tZW50LCB1c2UgdGhlIEVOVklST05NRU5UIGNvbXBpbGUtdGltZSBvcHRpb24gKGZvciBleGFtcGxlLCAtcyBFTlZJUk9OTUVOVD13ZWIgb3IgLXMgRU5WSVJPTk1FTlQ9bm9kZSknKTtcbn1cblxuLy8gYC9gIHNob3VsZCBiZSBwcmVzZW50IGF0IHRoZSBlbmQgaWYgYHNjcmlwdERpcmVjdG9yeWAgaXMgbm90IGVtcHR5XG52YXIgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiAgaWYgKE1vZHVsZVsnbG9jYXRlRmlsZSddKSB7XG4gICAgcmV0dXJuIE1vZHVsZVsnbG9jYXRlRmlsZSddKHBhdGgsIHNjcmlwdERpcmVjdG9yeSk7XG4gIH1cbiAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG59XG5cbi8vIEhvb2tzIHRoYXQgYXJlIGltcGxlbWVudGVkIGRpZmZlcmVudGx5IGluIGRpZmZlcmVudCBydW50aW1lIGVudmlyb25tZW50cy5cbnZhciByZWFkXyxcbiAgICByZWFkQXN5bmMsXG4gICAgcmVhZEJpbmFyeSxcbiAgICBzZXRXaW5kb3dUaXRsZTtcblxuLy8gTm9ybWFsbHkgd2UgZG9uJ3QgbG9nIGV4Y2VwdGlvbnMgYnV0IGluc3RlYWQgbGV0IHRoZW0gYnViYmxlIG91dCB0aGUgdG9wXG4vLyBsZXZlbCB3aGVyZSB0aGUgZW1iZWRkaW5nIGVudmlyb25tZW50IChlLmcuIHRoZSBicm93c2VyKSBjYW4gaGFuZGxlXG4vLyB0aGVtLlxuLy8gSG93ZXZlciB1bmRlciB2OCBhbmQgbm9kZSB3ZSBzb21ldGltZXMgZXhpdCB0aGUgcHJvY2VzcyBkaXJlY2x5IGluIHdoaWNoIGNhc2Vcbi8vIGl0cyB1cCB0byB1c2UgdXMgdG8gbG9nIHRoZSBleGNlcHRpb24gYmVmb3JlIGV4aXRpbmcuXG4vLyBJZiB3ZSBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8xNTA4MFxuLy8gdGhpcyBtYXkgbm8gbG9uZ2VyIGJlIG5lZWRlZCB1bmRlciBub2RlLlxuZnVuY3Rpb24gbG9nRXhjZXB0aW9uT25FeGl0KGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzKSByZXR1cm47XG4gIGxldCB0b0xvZyA9IGU7XG4gIGlmIChlICYmIHR5cGVvZiBlID09ICdvYmplY3QnICYmIGUuc3RhY2spIHtcbiAgICB0b0xvZyA9IFtlLCBlLnN0YWNrXTtcbiAgfVxuICBlcnIoJ2V4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogJyArIHRvTG9nKTtcbn1cblxudmFyIGZzO1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfU0hFTEwpIHtcblxuICBpZiAoKHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB8fCB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignbm90IGNvbXBpbGVkIGZvciB0aGlzIGVudmlyb25tZW50IChkaWQgeW91IGJ1aWxkIHRvIEhUTUwgYW5kIHRyeSB0byBydW4gaXQgbm90IG9uIHRoZSB3ZWIsIG9yIHNldCBFTlZJUk9OTUVOVCB0byBzb21ldGhpbmcgLSBsaWtlIG5vZGUgLSBhbmQgcnVuIGl0IHNvbWVwbGFjZSBlbHNlIC0gbGlrZSBvbiB0aGUgd2ViPyknKTtcblxuICBpZiAodHlwZW9mIHJlYWQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZWFkXyA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQoZikge1xuICAgICAgcmV0dXJuIHJlYWQoZik7XG4gICAgfTtcbiAgfVxuXG4gIHJlYWRCaW5hcnkgPSBmdW5jdGlvbiByZWFkQmluYXJ5KGYpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAodHlwZW9mIHJlYWRidWZmZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpO1xuICAgIH1cbiAgICBkYXRhID0gcmVhZChmLCAnYmluYXJ5Jyk7XG4gICAgYXNzZXJ0KHR5cGVvZiBkYXRhID09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZWFkQXN5bmMgPSBmdW5jdGlvbiByZWFkQXN5bmMoZiwgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBvbmxvYWQocmVhZEJpbmFyeShmKSksIDApO1xuICB9O1xuXG4gIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSAndW5kZWZpbmVkJykge1xuICAgIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhcmd1bWVudHNfID0gYXJndW1lbnRzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBxdWl0ID09ICdmdW5jdGlvbicpIHtcbiAgICBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgICAgIGxvZ0V4Y2VwdGlvbk9uRXhpdCh0b1Rocm93KTtcbiAgICAgIHF1aXQoc3RhdHVzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmludCAhPSAndW5kZWZpbmVkJykge1xuICAgIC8vIFByZWZlciB0byB1c2UgcHJpbnQvcHJpbnRFcnIgd2hlcmUgdGhleSBleGlzdCwgYXMgdGhleSB1c3VhbGx5IHdvcmsgYmV0dGVyLlxuICAgIGlmICh0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJykgY29uc29sZSA9IC8qKiBAdHlwZXshQ29uc29sZX0gKi8oe30pO1xuICAgIGNvbnNvbGUubG9nID0gLyoqIEB0eXBleyFmdW5jdGlvbih0aGlzOkNvbnNvbGUsIC4uLiopOiB1bmRlZmluZWR9ICovIChwcmludCk7XG4gICAgY29uc29sZS53YXJuID0gY29uc29sZS5lcnJvciA9IC8qKiBAdHlwZXshZnVuY3Rpb24odGhpczpDb25zb2xlLCAuLi4qKTogdW5kZWZpbmVkfSAqLyAodHlwZW9mIHByaW50RXJyICE9ICd1bmRlZmluZWQnID8gcHJpbnRFcnIgOiBwcmludCk7XG4gIH1cblxufSBlbHNlXG5cbi8vIE5vdGUgdGhhdCB0aGlzIGluY2x1ZGVzIE5vZGUuanMgd29ya2VycyB3aGVuIHJlbGV2YW50IChwdGhyZWFkcyBpcyBlbmFibGVkKS5cbi8vIE5vZGUuanMgd29ya2VycyBhcmUgZGV0ZWN0ZWQgYXMgYSBjb21iaW5hdGlvbiBvZiBFTlZJUk9OTUVOVF9JU19XT1JLRVIgYW5kXG4vLyBFTlZJUk9OTUVOVF9JU19OT0RFLlxuaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikgeyAvLyBDaGVjayB3b3JrZXIsIG5vdCB3ZWIsIHNpbmNlIHdpbmRvdyBjb3VsZCBiZSBwb2x5ZmlsbGVkXG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7IC8vIHdlYlxuICAgIHNjcmlwdERpcmVjdG9yeSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjO1xuICB9XG4gIC8vIFdoZW4gTU9EVUxBUklaRSwgdGhpcyBKUyBtYXkgYmUgZXhlY3V0ZWQgbGF0ZXIsIGFmdGVyIGRvY3VtZW50LmN1cnJlbnRTY3JpcHRcbiAgLy8gaXMgZ29uZSwgc28gd2Ugc2F2ZWQgaXQsIGFuZCB3ZSB1c2UgaXQgaGVyZSBpbnN0ZWFkIG9mIGFueSBvdGhlciBpbmZvLlxuICBpZiAoX3NjcmlwdERpcikge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHREaXI7XG4gIH1cbiAgLy8gYmxvYiB1cmxzIGxvb2sgbGlrZSBibG9iOmh0dHA6Ly9zaXRlLmNvbS9ldGMvZXRjIGFuZCB3ZSBjYW5ub3QgaW5mZXIgYW55dGhpbmcgZnJvbSB0aGVtLlxuICAvLyBvdGhlcndpc2UsIHNsaWNlIG9mZiB0aGUgZmluYWwgcGFydCBvZiB0aGUgdXJsIHRvIGZpbmQgdGhlIHNjcmlwdCBkaXJlY3RvcnkuXG4gIC8vIGlmIHNjcmlwdERpcmVjdG9yeSBkb2VzIG5vdCBjb250YWluIGEgc2xhc2gsIGxhc3RJbmRleE9mIHdpbGwgcmV0dXJuIC0xLFxuICAvLyBhbmQgc2NyaXB0RGlyZWN0b3J5IHdpbGwgY29ycmVjdGx5IGJlIHJlcGxhY2VkIHdpdGggYW4gZW1wdHkgc3RyaW5nLlxuICAvLyBJZiBzY3JpcHREaXJlY3RvcnkgY29udGFpbnMgYSBxdWVyeSAoc3RhcnRpbmcgd2l0aCA/KSBvciBhIGZyYWdtZW50IChzdGFydGluZyB3aXRoICMpLFxuICAvLyB0aGV5IGFyZSByZW1vdmVkIGJlY2F1c2UgdGhleSBjb3VsZCBjb250YWluIGEgc2xhc2guXG4gIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZignYmxvYjonKSAhPT0gMCkge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sIFwiXCIpLmxhc3RJbmRleE9mKCcvJykrMSk7XG4gIH0gZWxzZSB7XG4gICAgc2NyaXB0RGlyZWN0b3J5ID0gJyc7XG4gIH1cblxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09ICdmdW5jdGlvbicpKSB0aHJvdyBuZXcgRXJyb3IoJ25vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pJyk7XG5cbiAgLy8gRGlmZmVyZW50aWF0ZSB0aGUgV2ViIFdvcmtlciBmcm9tIHRoZSBOb2RlIFdvcmtlciBjYXNlLCBhcyByZWFkaW5nIG11c3RcbiAgLy8gYmUgZG9uZSBkaWZmZXJlbnRseS5cbiAge1xuLy8gaW5jbHVkZTogd2ViX29yX3dvcmtlcl9zaGVsbF9yZWFkLmpzXG5cblxuICByZWFkXyA9ICh1cmwpID0+IHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gIH1cblxuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgcmVhZEJpbmFyeSA9ICh1cmwpID0+IHtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXshQXJyYXlCdWZmZXJ9ICovKHhoci5yZXNwb25zZSkpO1xuICAgIH07XG4gIH1cblxuICByZWFkQXN5bmMgPSAodXJsLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHhoci5yZXNwb25zZSkpIHsgLy8gZmlsZSBVUkxzIGNhbiByZXR1cm4gMFxuICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25lcnJvcigpO1xuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgIHhoci5zZW5kKG51bGwpO1xuICB9XG5cbi8vIGVuZCBpbmNsdWRlOiB3ZWJfb3Jfd29ya2VyX3NoZWxsX3JlYWQuanNcbiAgfVxuXG4gIHNldFdpbmRvd1RpdGxlID0gKHRpdGxlKSA9PiBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xufSBlbHNlXG57XG4gIHRocm93IG5ldyBFcnJvcignZW52aXJvbm1lbnQgZGV0ZWN0aW9uIGVycm9yJyk7XG59XG5cbnZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbnZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5cbi8vIE1lcmdlIGJhY2sgaW4gdGhlIG92ZXJyaWRlc1xuT2JqZWN0LmFzc2lnbihNb2R1bGUsIG1vZHVsZU92ZXJyaWRlcyk7XG4vLyBGcmVlIHRoZSBvYmplY3QgaGllcmFyY2h5IGNvbnRhaW5lZCBpbiB0aGUgb3ZlcnJpZGVzLCB0aGlzIGxldHMgdGhlIEdDXG4vLyByZWNsYWltIGRhdGEgdXNlZCBlLmcuIGluIG1lbW9yeUluaXRpYWxpemVyUmVxdWVzdCwgd2hpY2ggaXMgYSBsYXJnZSB0eXBlZCBhcnJheS5cbm1vZHVsZU92ZXJyaWRlcyA9IG51bGw7XG5jaGVja0luY29taW5nTW9kdWxlQVBJKCk7XG5cbi8vIEVtaXQgY29kZSB0byBoYW5kbGUgZXhwZWN0ZWQgdmFsdWVzIG9uIHRoZSBNb2R1bGUgb2JqZWN0LiBUaGlzIGFwcGxpZXMgTW9kdWxlLnhcbi8vIHRvIHRoZSBwcm9wZXIgbG9jYWwgeC4gVGhpcyBoYXMgdHdvIGJlbmVmaXRzOiBmaXJzdCwgd2Ugb25seSBlbWl0IGl0IGlmIGl0IGlzXG4vLyBleHBlY3RlZCB0byBhcnJpdmUsIGFuZCBzZWNvbmQsIGJ5IHVzaW5nIGEgbG9jYWwgZXZlcnl3aGVyZSBlbHNlIHRoYXQgY2FuIGJlXG4vLyBtaW5pZmllZC5cblxuaWYgKE1vZHVsZVsnYXJndW1lbnRzJ10pIGFyZ3VtZW50c18gPSBNb2R1bGVbJ2FyZ3VtZW50cyddO2xlZ2FjeU1vZHVsZVByb3AoJ2FyZ3VtZW50cycsICdhcmd1bWVudHNfJyk7XG5cbmlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO2xlZ2FjeU1vZHVsZVByb3AoJ3RoaXNQcm9ncmFtJywgJ3RoaXNQcm9ncmFtJyk7XG5cbmlmIChNb2R1bGVbJ3F1aXQnXSkgcXVpdF8gPSBNb2R1bGVbJ3F1aXQnXTtsZWdhY3lNb2R1bGVQcm9wKCdxdWl0JywgJ3F1aXRfJyk7XG5cbi8vIHBlcmZvcm0gYXNzZXJ0aW9ucyBpbiBzaGVsbC5qcyBhZnRlciB3ZSBzZXQgdXAgb3V0KCkgYW5kIGVycigpLCBhcyBvdGhlcndpc2UgaWYgYW4gYXNzZXJ0aW9uIGZhaWxzIGl0IGNhbm5vdCBwcmludCB0aGUgbWVzc2FnZVxuLy8gQXNzZXJ0aW9ucyBvbiByZW1vdmVkIGluY29taW5nIE1vZHVsZSBKUyBBUElzLlxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ21lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUubWVtb3J5SW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZCcpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3B0aHJlYWRNYWluUHJlZml4VVJMJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucHRocmVhZE1haW5QcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZCcpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ2NkSW5pdGlhbGl6ZXJQcmVmaXhVUkwnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5jZEluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydmaWxlUGFja2FnZVByZWZpeFVSTCddID09ICd1bmRlZmluZWQnLCAnTW9kdWxlLmZpbGVQYWNrYWdlUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWQnKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydyZWFkJ10gPT0gJ3VuZGVmaW5lZCcsICdNb2R1bGUucmVhZCBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkXyBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydyZWFkQXN5bmMnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5yZWFkQXN5bmMgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZEFzeW5jIGluIEpTKScpO1xuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5yZWFkQmluYXJ5IG9wdGlvbiB3YXMgcmVtb3ZlZCAobW9kaWZ5IHJlYWRCaW5hcnkgaW4gSlMpJyk7XG5hc3NlcnQodHlwZW9mIE1vZHVsZVsnc2V0V2luZG93VGl0bGUnXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5zZXRXaW5kb3dUaXRsZSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSBzZXRXaW5kb3dUaXRsZSBpbiBKUyknKTtcbmFzc2VydCh0eXBlb2YgTW9kdWxlWydUT1RBTF9NRU1PUlknXSA9PSAndW5kZWZpbmVkJywgJ01vZHVsZS5UT1RBTF9NRU1PUlkgaGFzIGJlZW4gcmVuYW1lZCBNb2R1bGUuSU5JVElBTF9NRU1PUlknKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ3JlYWQnLCAncmVhZF8nKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ3JlYWRBc3luYycsICdyZWFkQXN5bmMnKTtcbmxlZ2FjeU1vZHVsZVByb3AoJ3JlYWRCaW5hcnknLCAncmVhZEJpbmFyeScpO1xubGVnYWN5TW9kdWxlUHJvcCgnc2V0V2luZG93VGl0bGUnLCAnc2V0V2luZG93VGl0bGUnKTtcbnZhciBJREJGUyA9ICdJREJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGlkYmZzLmpzJztcbnZhciBQUk9YWUZTID0gJ1BST1hZRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWxwcm94eWZzLmpzJztcbnZhciBXT1JLRVJGUyA9ICdXT1JLRVJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbHdvcmtlcmZzLmpzJztcbnZhciBOT0RFRlMgPSAnTk9ERUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sbm9kZWZzLmpzJztcblxuXG5hc3NlcnQoIUVOVklST05NRU5UX0lTX1NIRUxMLCBcInNoZWxsIGVudmlyb25tZW50IGRldGVjdGVkIGJ1dCBub3QgZW5hYmxlZCBhdCBidWlsZCB0aW1lLiAgQWRkICdzaGVsbCcgdG8gYC1zIEVOVklST05NRU5UYCB0byBlbmFibGUuXCIpO1xuXG5cblxuXG52YXIgU1RBQ0tfQUxJR04gPSAxNjtcbnZhciBQT0lOVEVSX1NJWkUgPSA0O1xuXG5mdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2kxJzogY2FzZSAnaTgnOiByZXR1cm4gMTtcbiAgICBjYXNlICdpMTYnOiByZXR1cm4gMjtcbiAgICBjYXNlICdpMzInOiByZXR1cm4gNDtcbiAgICBjYXNlICdpNjQnOiByZXR1cm4gODtcbiAgICBjYXNlICdmbG9hdCc6IHJldHVybiA0O1xuICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiA4O1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGlmICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgICByZXR1cm4gUE9JTlRFUl9TSVpFO1xuICAgICAgfSBlbHNlIGlmICh0eXBlWzBdID09PSAnaScpIHtcbiAgICAgICAgY29uc3QgYml0cyA9IE51bWJlcih0eXBlLnN1YnN0cigxKSk7XG4gICAgICAgIGFzc2VydChiaXRzICUgOCA9PT0gMCwgJ2dldE5hdGl2ZVR5cGVTaXplIGludmFsaWQgYml0cyAnICsgYml0cyArICcsIHR5cGUgJyArIHR5cGUpO1xuICAgICAgICByZXR1cm4gYml0cyAvIDg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uY2UodGV4dCkge1xuICBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xuICBpZiAoIXdhcm5PbmNlLnNob3duW3RleHRdKSB7XG4gICAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xuICAgIGVycih0ZXh0KTtcbiAgfVxufVxuXG4vLyBpbmNsdWRlOiBydW50aW1lX2Z1bmN0aW9ucy5qc1xuXG5cbi8vIFdyYXBzIGEgSlMgZnVuY3Rpb24gYXMgYSB3YXNtIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBzaWduYXR1cmUuXG5mdW5jdGlvbiBjb252ZXJ0SnNGdW5jdGlvblRvV2FzbShmdW5jLCBzaWcpIHtcblxuICAvLyBJZiB0aGUgdHlwZSByZWZsZWN0aW9uIHByb3Bvc2FsIGlzIGF2YWlsYWJsZSwgdXNlIHRoZSBuZXdcbiAgLy8gXCJXZWJBc3NlbWJseS5GdW5jdGlvblwiIGNvbnN0cnVjdG9yLlxuICAvLyBPdGhlcndpc2UsIGNvbnN0cnVjdCBhIG1pbmltYWwgd2FzbSBtb2R1bGUgaW1wb3J0aW5nIHRoZSBKUyBmdW5jdGlvbiBhbmRcbiAgLy8gcmUtZXhwb3J0aW5nIGl0LlxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5LkZ1bmN0aW9uID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciB0eXBlTmFtZXMgPSB7XG4gICAgICAnaSc6ICdpMzInLFxuICAgICAgJ2onOiAnaTY0JyxcbiAgICAgICdmJzogJ2YzMicsXG4gICAgICAnZCc6ICdmNjQnXG4gICAgfTtcbiAgICB2YXIgdHlwZSA9IHtcbiAgICAgIHBhcmFtZXRlcnM6IFtdLFxuICAgICAgcmVzdWx0czogc2lnWzBdID09ICd2JyA/IFtdIDogW3R5cGVOYW1lc1tzaWdbMF1dXVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaWcubGVuZ3RoOyArK2kpIHtcbiAgICAgIHR5cGUucGFyYW1ldGVycy5wdXNoKHR5cGVOYW1lc1tzaWdbaV1dKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBc3NlbWJseS5GdW5jdGlvbih0eXBlLCBmdW5jKTtcbiAgfVxuXG4gIC8vIFRoZSBtb2R1bGUgaXMgc3RhdGljLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIHR5cGUgc2VjdGlvbiwgd2hpY2ggaXNcbiAgLy8gZ2VuZXJhdGVkIGJhc2VkIG9uIHRoZSBzaWduYXR1cmUgcGFzc2VkIGluLlxuICB2YXIgdHlwZVNlY3Rpb24gPSBbXG4gICAgMHgwMSwgLy8gaWQ6IHNlY3Rpb24sXG4gICAgMHgwMCwgLy8gbGVuZ3RoOiAwIChwbGFjZWhvbGRlcilcbiAgICAweDAxLCAvLyBjb3VudDogMVxuICAgIDB4NjAsIC8vIGZvcm06IGZ1bmNcbiAgXTtcbiAgdmFyIHNpZ1JldCA9IHNpZy5zbGljZSgwLCAxKTtcbiAgdmFyIHNpZ1BhcmFtID0gc2lnLnNsaWNlKDEpO1xuICB2YXIgdHlwZUNvZGVzID0ge1xuICAgICdpJzogMHg3ZiwgLy8gaTMyXG4gICAgJ2onOiAweDdlLCAvLyBpNjRcbiAgICAnZic6IDB4N2QsIC8vIGYzMlxuICAgICdkJzogMHg3YywgLy8gZjY0XG4gIH07XG5cbiAgLy8gUGFyYW1ldGVycywgbGVuZ3RoICsgc2lnbmF0dXJlc1xuICB0eXBlU2VjdGlvbi5wdXNoKHNpZ1BhcmFtLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnUGFyYW0ubGVuZ3RoOyArK2kpIHtcbiAgICB0eXBlU2VjdGlvbi5wdXNoKHR5cGVDb2Rlc1tzaWdQYXJhbVtpXV0pO1xuICB9XG5cbiAgLy8gUmV0dXJuIHZhbHVlcywgbGVuZ3RoICsgc2lnbmF0dXJlc1xuICAvLyBXaXRoIG5vIG11bHRpLXJldHVybiBpbiBNVlAsIGVpdGhlciAwICh2b2lkKSBvciAxIChhbnl0aGluZyBlbHNlKVxuICBpZiAoc2lnUmV0ID09ICd2Jykge1xuICAgIHR5cGVTZWN0aW9uLnB1c2goMHgwMCk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZVNlY3Rpb24gPSB0eXBlU2VjdGlvbi5jb25jYXQoWzB4MDEsIHR5cGVDb2Rlc1tzaWdSZXRdXSk7XG4gIH1cblxuICAvLyBXcml0ZSB0aGUgb3ZlcmFsbCBsZW5ndGggb2YgdGhlIHR5cGUgc2VjdGlvbiBiYWNrIGludG8gdGhlIHNlY3Rpb24gaGVhZGVyXG4gIC8vIChleGNlcHRpbmcgdGhlIDIgYnl0ZXMgZm9yIHRoZSBzZWN0aW9uIGlkIGFuZCBsZW5ndGgpXG4gIHR5cGVTZWN0aW9uWzFdID0gdHlwZVNlY3Rpb24ubGVuZ3RoIC0gMjtcblxuICAvLyBSZXN0IG9mIHRoZSBtb2R1bGUgaXMgc3RhdGljXG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAweDAwLCAweDYxLCAweDczLCAweDZkLCAvLyBtYWdpYyAoXCJcXDBhc21cIilcbiAgICAweDAxLCAweDAwLCAweDAwLCAweDAwLCAvLyB2ZXJzaW9uOiAxXG4gIF0uY29uY2F0KHR5cGVTZWN0aW9uLCBbXG4gICAgMHgwMiwgMHgwNywgLy8gaW1wb3J0IHNlY3Rpb25cbiAgICAgIC8vIChpbXBvcnQgXCJlXCIgXCJmXCIgKGZ1bmMgMCAodHlwZSAwKSkpXG4gICAgICAweDAxLCAweDAxLCAweDY1LCAweDAxLCAweDY2LCAweDAwLCAweDAwLFxuICAgIDB4MDcsIDB4MDUsIC8vIGV4cG9ydCBzZWN0aW9uXG4gICAgICAvLyAoZXhwb3J0IFwiZlwiIChmdW5jIDAgKHR5cGUgMCkpKVxuICAgICAgMHgwMSwgMHgwMSwgMHg2NiwgMHgwMCwgMHgwMCxcbiAgXSkpO1xuXG4gICAvLyBXZSBjYW4gY29tcGlsZSB0aGlzIHdhc20gbW9kdWxlIHN5bmNocm9ub3VzbHkgYmVjYXVzZSBpdCBpcyB2ZXJ5IHNtYWxsLlxuICAvLyBUaGlzIGFjY2VwdHMgYW4gaW1wb3J0IChhdCBcImUuZlwiKSwgdGhhdCBpdCByZXJvdXRlcyB0byBhbiBleHBvcnQgKGF0IFwiZlwiKVxuICB2YXIgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShieXRlcyk7XG4gIHZhciBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIHtcbiAgICAnZSc6IHtcbiAgICAgICdmJzogZnVuY1xuICAgIH1cbiAgfSk7XG4gIHZhciB3cmFwcGVkRnVuYyA9IGluc3RhbmNlLmV4cG9ydHNbJ2YnXTtcbiAgcmV0dXJuIHdyYXBwZWRGdW5jO1xufVxuXG52YXIgZnJlZVRhYmxlSW5kZXhlcyA9IFtdO1xuXG4vLyBXZWFrIG1hcCBvZiBmdW5jdGlvbnMgaW4gdGhlIHRhYmxlIHRvIHRoZWlyIGluZGV4ZXMsIGNyZWF0ZWQgb24gZmlyc3QgdXNlLlxudmFyIGZ1bmN0aW9uc0luVGFibGVNYXA7XG5cbmZ1bmN0aW9uIGdldEVtcHR5VGFibGVTbG90KCkge1xuICAvLyBSZXVzZSBhIGZyZWUgaW5kZXggaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2UgZ3Jvdy5cbiAgaWYgKGZyZWVUYWJsZUluZGV4ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZyZWVUYWJsZUluZGV4ZXMucG9wKCk7XG4gIH1cbiAgLy8gR3JvdyB0aGUgdGFibGVcbiAgdHJ5IHtcbiAgICB3YXNtVGFibGUuZ3JvdygxKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhyb3cgJ1VuYWJsZSB0byBncm93IHdhc20gdGFibGUuIFNldCBBTExPV19UQUJMRV9HUk9XVEguJztcbiAgfVxuICByZXR1cm4gd2FzbVRhYmxlLmxlbmd0aCAtIDE7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRhYmxlTWFwKG9mZnNldCwgY291bnQpIHtcbiAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIGNvdW50OyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGdldFdhc21UYWJsZUVudHJ5KGkpO1xuICAgIC8vIElnbm9yZSBudWxsIHZhbHVlcy5cbiAgICBpZiAoaXRlbSkge1xuICAgICAgZnVuY3Rpb25zSW5UYWJsZU1hcC5zZXQoaXRlbSwgaSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgZnVuY3Rpb24gdG8gdGhlIHRhYmxlLlxuICogJ3NpZycgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGlmIHRoZSBmdW5jdGlvbiBiZWluZyBhZGRlZCBpcyBhIEpTIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmc9fSBzaWdcbiAqL1xuZnVuY3Rpb24gYWRkRnVuY3Rpb24oZnVuYywgc2lnKSB7XG4gIGFzc2VydCh0eXBlb2YgZnVuYyAhPSAndW5kZWZpbmVkJyk7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIGZ1bmN0aW9uIGlzIGFscmVhZHkgaW4gdGhlIHRhYmxlLCB0byBlbnN1cmUgZWFjaCBmdW5jdGlvblxuICAvLyBnZXRzIGEgdW5pcXVlIGluZGV4LiBGaXJzdCwgY3JlYXRlIHRoZSBtYXAgaWYgdGhpcyBpcyB0aGUgZmlyc3QgdXNlLlxuICBpZiAoIWZ1bmN0aW9uc0luVGFibGVNYXApIHtcbiAgICBmdW5jdGlvbnNJblRhYmxlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB1cGRhdGVUYWJsZU1hcCgwLCB3YXNtVGFibGUubGVuZ3RoKTtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSW5UYWJsZU1hcC5oYXMoZnVuYykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zSW5UYWJsZU1hcC5nZXQoZnVuYyk7XG4gIH1cblxuICAvLyBJdCdzIG5vdCBpbiB0aGUgdGFibGUsIGFkZCBpdCBub3cuXG5cbiAgdmFyIHJldCA9IGdldEVtcHR5VGFibGVTbG90KCk7XG5cbiAgLy8gU2V0IHRoZSBuZXcgdmFsdWUuXG4gIHRyeSB7XG4gICAgLy8gQXR0ZW1wdGluZyB0byBjYWxsIHRoaXMgd2l0aCBKUyBmdW5jdGlvbiB3aWxsIGNhdXNlIG9mIHRhYmxlLnNldCgpIHRvIGZhaWxcbiAgICBzZXRXYXNtVGFibGVFbnRyeShyZXQsIGZ1bmMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGFzc2VydCh0eXBlb2Ygc2lnICE9ICd1bmRlZmluZWQnLCAnTWlzc2luZyBzaWduYXR1cmUgYXJndW1lbnQgdG8gYWRkRnVuY3Rpb246ICcgKyBmdW5jKTtcbiAgICB2YXIgd3JhcHBlZCA9IGNvbnZlcnRKc0Z1bmN0aW9uVG9XYXNtKGZ1bmMsIHNpZyk7XG4gICAgc2V0V2FzbVRhYmxlRW50cnkocmV0LCB3cmFwcGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uc0luVGFibGVNYXAuc2V0KGZ1bmMsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaW5kZXgpIHtcbiAgZnVuY3Rpb25zSW5UYWJsZU1hcC5kZWxldGUoZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKTtcbiAgZnJlZVRhYmxlSW5kZXhlcy5wdXNoKGluZGV4KTtcbn1cblxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfZnVuY3Rpb25zLmpzXG4vLyBpbmNsdWRlOiBydW50aW1lX2RlYnVnLmpzXG5cblxuZnVuY3Rpb24gbGVnYWN5TW9kdWxlUHJvcChwcm9wLCBuZXdOYW1lKSB7XG4gIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgcHJvcCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgYWJvcnQoJ01vZHVsZS4nICsgcHJvcCArICcgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBwbGFpbiAnICsgbmV3TmFtZSArICcgKHRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBwcm92aWRlZCBvbiBNb2R1bGUsIGJ1dCBhZnRlciBzdGFydHVwIHRoZSB2YWx1ZSBpcyBvbmx5IGxvb2tlZCBmb3Igb24gYSBsb2NhbCB2YXJpYWJsZSBvZiB0aGF0IG5hbWUpJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlZE1vZHVsZVByb3AocHJvcCkge1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gICAgYWJvcnQoJ2BNb2R1bGUuJyArIHByb3AgKyAnYCB3YXMgc3VwcGxpZWQgYnV0IGAnICsgcHJvcCArICdgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5leHBvcnRlZE1lc3NhZ2Uoc3ltLCBpc0ZTU3lib2wpIHtcbiAgdmFyIG1zZyA9IFwiJ1wiICsgc3ltICsgXCInIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiO1xuICBpZiAoaXNGU1N5Ym9sKSB7XG4gICAgbXNnICs9ICcuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91JztcbiAgfVxuICByZXR1cm4gbXNnO1xufVxuXG5mdW5jdGlvbiB1bmV4cG9ydGVkUnVudGltZVN5bWJvbChzeW0sIGlzRlNTeWJvbCkge1xuICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBzeW0pKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgc3ltLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBhYm9ydCh1bmV4cG9ydGVkTWVzc2FnZShzeW0sIGlzRlNTeWJvbCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oc3ltLCBpc0ZTU3lib2wpIHtcbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgc3ltKSkge1xuICAgIE1vZHVsZVtzeW1dID0gKCkgPT4gYWJvcnQodW5leHBvcnRlZE1lc3NhZ2Uoc3ltLCBpc0ZTU3lib2wpKTtcbiAgfVxufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9kZWJ1Zy5qc1xudmFyIHRlbXBSZXQwID0gMDtcbnZhciBzZXRUZW1wUmV0MCA9ICh2YWx1ZSkgPT4geyB0ZW1wUmV0MCA9IHZhbHVlOyB9O1xudmFyIGdldFRlbXBSZXQwID0gKCkgPT4gdGVtcFJldDA7XG5cblxuXG4vLyA9PT0gUHJlYW1ibGUgbGlicmFyeSBzdHVmZiA9PT1cblxuLy8gRG9jdW1lbnRhdGlvbiBmb3IgdGhlIHB1YmxpYyBBUElzIGRlZmluZWQgaW4gdGhpcyBmaWxlIG11c3QgYmUgdXBkYXRlZCBpbjpcbi8vICAgIHNpdGUvc291cmNlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5yc3Rcbi8vIEEgcHJlYnVpbHQgbG9jYWwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgYXQ6XG4vLyAgICBzaXRlL2J1aWxkL3RleHQvZG9jcy9hcGlfcmVmZXJlbmNlL3ByZWFtYmxlLmpzLnR4dFxuLy8gWW91IGNhbiBhbHNvIGJ1aWxkIGRvY3MgbG9jYWxseSBhcyBIVE1MIG9yIG90aGVyIGZvcm1hdHMgaW4gc2l0ZS9cbi8vIEFuIG9ubGluZSBIVE1MIHZlcnNpb24gKHdoaWNoIG1heSBiZSBvZiBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIEVtc2NyaXB0ZW4pXG4vLyAgICBpcyB1cCBhdCBodHRwOi8va3JpcGtlbi5naXRodWIuaW8vZW1zY3JpcHRlbi1zaXRlL2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy5odG1sXG5cbnZhciBkeW5hbWljTGlicmFyaWVzID0gTW9kdWxlWydkeW5hbWljTGlicmFyaWVzJ10gfHwgW107XG5cbnZhciB3YXNtQmluYXJ5O1xuaWYgKE1vZHVsZVsnd2FzbUJpbmFyeSddKSB3YXNtQmluYXJ5ID0gTW9kdWxlWyd3YXNtQmluYXJ5J107bGVnYWN5TW9kdWxlUHJvcCgnd2FzbUJpbmFyeScsICd3YXNtQmluYXJ5Jyk7XG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVsnbm9FeGl0UnVudGltZSddIHx8IHRydWU7bGVnYWN5TW9kdWxlUHJvcCgnbm9FeGl0UnVudGltZScsICdub0V4aXRSdW50aW1lJyk7XG5cbmlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT0gJ29iamVjdCcpIHtcbiAgYWJvcnQoJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcbn1cblxuLy8gaW5jbHVkZTogcnVudGltZV9zYWZlX2hlYXAuanNcblxuXG4vLyBJbiBNSU5JTUFMX1JVTlRJTUUsIHNldFZhbHVlKCkgYW5kIGdldFZhbHVlKCkgYXJlIG9ubHkgYXZhaWxhYmxlIHdoZW4gYnVpbGRpbmcgd2l0aCBzYWZlIGhlYXAgZW5hYmxlZCwgZm9yIGhlYXAgc2FmZXR5IGNoZWNraW5nLlxuLy8gSW4gdHJhZGl0aW9uYWwgcnVudGltZSwgc2V0VmFsdWUoKSBhbmQgZ2V0VmFsdWUoKSBhcmUgYWx3YXlzIGF2YWlsYWJsZSAoYWx0aG91Z2ggdGhlaXIgdXNlIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBkdWUgdG8gcGVyZiBwZW5hbHRpZXMpXG5cbi8qKiBAcGFyYW0ge251bWJlcn0gcHRyXG4gICAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICBAcGFyYW0ge251bWJlcnxib29sZWFuPX0gbm9TYWZlICovXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gJ2k4Jywgbm9TYWZlKSB7XG4gIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpMSc6IEhFQVA4WygocHRyKT4+MCldID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAnaTgnOiBIRUFQOFsoKHB0cik+PjApXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2kxNic6IEhFQVAxNlsoKHB0cik+PjEpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2kzMic6IEhFQVAzMlsoKHB0cik+PjIpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgJ2k2NCc6ICh0ZW1wSTY0ID0gW3ZhbHVlPj4+MCwodGVtcERvdWJsZT12YWx1ZSwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKHB0cik+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKHB0cikrKDQpKT4+MildID0gdGVtcEk2NFsxXSk7IGJyZWFrO1xuICAgICAgY2FzZSAnZmxvYXQnOiBIRUFQRjMyWygocHRyKT4+MildID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAnZG91YmxlJzogSEVBUEY2NFsoKHB0cik+PjMpXSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGFib3J0KCdpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAnICsgdHlwZSk7XG4gICAgfVxufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHB0clxuICAgIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgQHBhcmFtIHtudW1iZXJ8Ym9vbGVhbj19IG5vU2FmZSAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlID0gJ2k4Jywgbm9TYWZlKSB7XG4gIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aC0xKSA9PT0gJyonKSB0eXBlID0gJ2kzMic7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpMSc6IHJldHVybiBIRUFQOFsoKHB0cik+PjApXTtcbiAgICAgIGNhc2UgJ2k4JzogcmV0dXJuIEhFQVA4WygocHRyKT4+MCldO1xuICAgICAgY2FzZSAnaTE2JzogcmV0dXJuIEhFQVAxNlsoKHB0cik+PjEpXTtcbiAgICAgIGNhc2UgJ2kzMic6IHJldHVybiBIRUFQMzJbKChwdHIpPj4yKV07XG4gICAgICBjYXNlICdpNjQnOiByZXR1cm4gSEVBUDMyWygocHRyKT4+MildO1xuICAgICAgY2FzZSAnZmxvYXQnOiByZXR1cm4gSEVBUEYzMlsoKHB0cik+PjIpXTtcbiAgICAgIGNhc2UgJ2RvdWJsZSc6IHJldHVybiBOdW1iZXIoSEVBUEY2NFsoKHB0cik+PjMpXSk7XG4gICAgICBkZWZhdWx0OiBhYm9ydCgnaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJyArIHR5cGUpO1xuICAgIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX3NhZmVfaGVhcC5qc1xuLy8gV2FzbSBnbG9iYWxzXG5cbnZhciB3YXNtTWVtb3J5O1xuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU0RMIGZ1bmN0aW9uc1xuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSdW50aW1lIGVzc2VudGlhbHNcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyB3aGV0aGVyIHdlIGFyZSBxdWl0dGluZyB0aGUgYXBwbGljYXRpb24uIG5vIGNvZGUgc2hvdWxkIHJ1biBhZnRlciB0aGlzLlxuLy8gc2V0IGluIGV4aXQoKSBhbmQgYWJvcnQoKVxudmFyIEFCT1JUID0gZmFsc2U7XG5cbi8vIHNldCBieSBleGl0KCkgYW5kIGFib3J0KCkuICBQYXNzZWQgdG8gJ29uRXhpdCcgaGFuZGxlci5cbi8vIE5PVEU6IFRoaXMgaXMgYWxzbyB1c2VkIGFzIHRoZSBwcm9jZXNzIHJldHVybiBjb2RlIGNvZGUgaW4gc2hlbGwgZW52aXJvbm1lbnRzXG4vLyBidXQgb25seSB3aGVuIG5vRXhpdFJ1bnRpbWUgaXMgZmFsc2UuXG52YXIgRVhJVFNUQVRVUztcblxuLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZCcgKyAodGV4dCA/ICc6ICcgKyB0ZXh0IDogJycpKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBDIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgaWRlbnRpZmllciAoZm9yIEMrKywgeW91IG5lZWQgdG8gZG8gbWFudWFsIG5hbWUgbWFuZ2xpbmcpXG5mdW5jdGlvbiBnZXRDRnVuYyhpZGVudCkge1xuICB2YXIgZnVuYyA9IE1vZHVsZVsnXycgKyBpZGVudF07IC8vIGNsb3N1cmUgZXhwb3J0ZWQgZnVuY3Rpb25cbiAgYXNzZXJ0KGZ1bmMsICdDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uICcgKyBpZGVudCArICcsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZCcpO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gQyBjYWxsaW5nIGludGVyZmFjZS5cbi8qKiBAcGFyYW0ge3N0cmluZ3xudWxsPX0gcmV0dXJuVHlwZVxuICAgIEBwYXJhbSB7QXJyYXk9fSBhcmdUeXBlc1xuICAgIEBwYXJhbSB7QXJndW1lbnRzfEFycmF5PX0gYXJnc1xuICAgIEBwYXJhbSB7T2JqZWN0PX0gb3B0cyAqL1xuZnVuY3Rpb24gY2NhbGwoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmdzLCBvcHRzKSB7XG4gIC8vIEZvciBmYXN0IGxvb2t1cCBvZiBjb252ZXJzaW9uIGZ1bmN0aW9uc1xuICB2YXIgdG9DID0ge1xuICAgICdzdHJpbmcnOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciByZXQgPSAwO1xuICAgICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHsgLy8gbnVsbCBzdHJpbmdcbiAgICAgICAgLy8gYXQgbW9zdCA0IGJ5dGVzIHBlciBVVEYtOCBjb2RlIHBvaW50LCArMSBmb3IgdGhlIHRyYWlsaW5nICdcXDAnXG4gICAgICAgIHZhciBsZW4gPSAoc3RyLmxlbmd0aCA8PCAyKSArIDE7XG4gICAgICAgIHJldCA9IHN0YWNrQWxsb2MobGVuKTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBsZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgICdhcnJheSc6IGZ1bmN0aW9uKGFycikge1xuICAgICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XG4gICAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCkge1xuICAgIGlmIChyZXR1cm5UeXBlID09PSAnc3RyaW5nJykgcmV0dXJuIFVURjhUb1N0cmluZyhyZXQpO1xuICAgIGlmIChyZXR1cm5UeXBlID09PSAnYm9vbGVhbicpIHJldHVybiBCb29sZWFuKHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHZhciBmdW5jID0gZ2V0Q0Z1bmMoaWRlbnQpO1xuICB2YXIgY0FyZ3MgPSBbXTtcbiAgdmFyIHN0YWNrID0gMDtcbiAgYXNzZXJ0KHJldHVyblR5cGUgIT09ICdhcnJheScsICdSZXR1cm4gdHlwZSBzaG91bGQgbm90IGJlIFwiYXJyYXlcIi4nKTtcbiAgaWYgKGFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSB0b0NbYXJnVHlwZXNbaV1dO1xuICAgICAgaWYgKGNvbnZlcnRlcikge1xuICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgICAgIGNBcmdzW2ldID0gY29udmVydGVyKGFyZ3NbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmV0ID0gZnVuYy5hcHBseShudWxsLCBjQXJncyk7XG4gIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcbiAgICBpZiAoc3RhY2sgIT09IDApIHN0YWNrUmVzdG9yZShzdGFjayk7XG4gICAgcmV0dXJuIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpO1xuICB9XG5cbiAgcmV0ID0gb25Eb25lKHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKiBAcGFyYW0ge3N0cmluZz19IHJldHVyblR5cGVcbiAgICBAcGFyYW0ge0FycmF5PX0gYXJnVHlwZXNcbiAgICBAcGFyYW0ge09iamVjdD19IG9wdHMgKi9cbmZ1bmN0aW9uIGN3cmFwKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgb3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJndW1lbnRzLCBvcHRzKTtcbiAgfVxufVxuXG4vLyBXZSB1c2VkIHRvIGluY2x1ZGUgbWFsbG9jL2ZyZWUgYnkgZGVmYXVsdCBpbiB0aGUgcGFzdC4gU2hvdyBhIGhlbHBmdWwgZXJyb3IgaW5cbi8vIGJ1aWxkcyB3aXRoIGFzc2VydGlvbnMuXG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfbGVnYWN5LmpzXG5cblxudmFyIEFMTE9DX05PUk1BTCA9IDA7IC8vIFRyaWVzIHRvIHVzZSBfbWFsbG9jKClcbnZhciBBTExPQ19TVEFDSyA9IDE7IC8vIExpdmVzIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24gY2FsbFxuXG4vKipcbiAqIGFsbG9jYXRlKCk6IFRoaXMgZnVuY3Rpb24gaXMgbm8gbG9uZ2VyIHVzZWQgYnkgZW1zY3JpcHRlbiBidXQgaXMga2VwdCBhcm91bmQgdG8gYXZvaWRcbiAqICAgICAgICAgICAgIGJyZWFraW5nIGV4dGVybmFsIHVzZXJzLlxuICogICAgICAgICAgICAgWW91IHNob3VsZCBub3JtYWxseSBub3QgdXNlIGFsbG9jYXRlKCksIGFuZCBpbnN0ZWFkIGFsbG9jYXRlXG4gKiAgICAgICAgICAgICBtZW1vcnkgdXNpbmcgX21hbGxvYygpL3N0YWNrQWxsb2MoKSwgaW5pdGlhbGl6ZSBpdCB3aXRoXG4gKiAgICAgICAgICAgICBzZXRWYWx1ZSgpLCBhbmQgc28gZm9ydGguXG4gKiBAcGFyYW0geyhVaW50OEFycmF5fEFycmF5PG51bWJlcj4pfSBzbGFiOiBBbiBhcnJheSBvZiBkYXRhLlxuICogQHBhcmFtIHtudW1iZXI9fSBhbGxvY2F0b3IgOiBIb3cgdG8gYWxsb2NhdGUgbWVtb3J5LCBzZWUgQUxMT0NfKlxuICovXG5mdW5jdGlvbiBhbGxvY2F0ZShzbGFiLCBhbGxvY2F0b3IpIHtcbiAgdmFyIHJldDtcbiAgYXNzZXJ0KHR5cGVvZiBhbGxvY2F0b3IgPT0gJ251bWJlcicsICdhbGxvY2F0ZSBubyBsb25nZXIgdGFrZXMgYSB0eXBlIGFyZ3VtZW50JylcbiAgYXNzZXJ0KHR5cGVvZiBzbGFiICE9ICdudW1iZXInLCAnYWxsb2NhdGUgbm8gbG9uZ2VyIHRha2VzIGEgbnVtYmVyIGFzIGFyZzAnKVxuXG4gIGlmIChhbGxvY2F0b3IgPT0gQUxMT0NfU1RBQ0spIHtcbiAgICByZXQgPSBzdGFja0FsbG9jKHNsYWIubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBfbWFsbG9jKHNsYWIubGVuZ3RoKTtcbiAgfVxuXG4gIGlmICghc2xhYi5zdWJhcnJheSAmJiAhc2xhYi5zbGljZSkge1xuICAgIHNsYWIgPSBuZXcgVWludDhBcnJheShzbGFiKTtcbiAgfVxuICBIRUFQVTguc2V0KHNsYWIsIHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2xlZ2FjeS5qc1xuLy8gaW5jbHVkZTogcnVudGltZV9zdHJpbmdzLmpzXG5cblxuLy8gcnVudGltZV9zdHJpbmdzLmpzOiBTdHJpbmdzIHJlbGF0ZWQgcnVudGltZSBmdW5jdGlvbnMgdGhhdCBhcmUgcGFydCBvZiBib3RoIE1JTklNQUxfUlVOVElNRSBhbmQgcmVndWxhciBydW50aW1lLlxuXG52YXIgVVRGOERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjgtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgY29udGFpbnMgdWludDggdmFsdWVzLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG4vKipcbiAqIGhlYXBPckFycmF5IGlzIGVpdGhlciBhIHJlZ3VsYXIgYXJyYXksIG9yIGEgSmF2YVNjcmlwdCB0eXBlZCBhcnJheSB2aWV3LlxuICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICogQHBhcmFtIHtudW1iZXI9fSBtYXhCeXRlc1RvUmVhZFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuICB2YXIgZW5kSWR4ID0gaWR4ICsgbWF4Qnl0ZXNUb1JlYWQ7XG4gIHZhciBlbmRQdHIgPSBpZHg7XG4gIC8vIFRleHREZWNvZGVyIG5lZWRzIHRvIGtub3cgdGhlIGJ5dGUgbGVuZ3RoIGluIGFkdmFuY2UsIGl0IGRvZXNuJ3Qgc3RvcCBvbiBudWxsIHRlcm1pbmF0b3IgYnkgaXRzZWxmLlxuICAvLyBBbHNvLCB1c2UgdGhlIGxlbmd0aCBpbmZvIHRvIGF2b2lkIHJ1bm5pbmcgdGlueSBzdHJpbmdzIHRocm91Z2ggVGV4dERlY29kZXIsIHNpbmNlIC5zdWJhcnJheSgpIGFsbG9jYXRlcyBnYXJiYWdlLlxuICAvLyAoQXMgYSB0aW55IGNvZGUgc2F2ZSB0cmljaywgY29tcGFyZSBlbmRQdHIgYWdhaW5zdCBlbmRJZHggdXNpbmcgYSBuZWdhdGlvbiwgc28gdGhhdCB1bmRlZmluZWQgbWVhbnMgSW5maW5pdHkpXG4gIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuXG4gIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIC8vIElmIGJ1aWxkaW5nIHdpdGggVGV4dERlY29kZXIsIHdlIGhhdmUgYWxyZWFkeSBjb21wdXRlZCB0aGUgc3RyaW5nIGxlbmd0aCBhYm92ZSwgc28gdGVzdCBsb29wIGVuZCBjb25kaXRpb24gYWdhaW5zdCB0aGF0XG4gICAgd2hpbGUgKGlkeCA8IGVuZFB0cikge1xuICAgICAgLy8gRm9yIFVURjggYnl0ZSBzdHJ1Y3R1cmUsIHNlZTpcbiAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cbiAgICAgIC8vIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dFxuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICAgIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMHg4MCkpIHsgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApOyBjb250aW51ZTsgfVxuICAgICAgdmFyIHUxID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhFMCkgPT0gMHhDMCkgeyBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOyBjb250aW51ZTsgfVxuICAgICAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICB1MCA9ICgodTAgJiAxNSkgPDwgMTIpIHwgKHUxIDw8IDYpIHwgdTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKHUwICYgMHhGOCkgIT0gMHhGMCkgd2Fybk9uY2UoJ0ludmFsaWQgVVRGLTggbGVhZGluZyBieXRlIDB4JyArIHUwLnRvU3RyaW5nKDE2KSArICcgZW5jb3VudGVyZWQgd2hlbiBkZXNlcmlhbGl6aW5nIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5IHRvIGEgSlMgc3RyaW5nIScpO1xuICAgICAgICB1MCA9ICgodTAgJiA3KSA8PCAxOCkgfCAodTEgPDwgMTIpIHwgKHUyIDw8IDYpIHwgKGhlYXBPckFycmF5W2lkeCsrXSAmIDYzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHUwIDwgMHgxMDAwMCkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2ggPSB1MCAtIDB4MTAwMDA7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IChjaCA+PiAxMCksIDB4REMwMCB8IChjaCAmIDB4M0ZGKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBVVEY4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBlbXNjcmlwdGVuIEhFQVAsIHJldHVybnMgYVxuLy8gY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cbi8vIG1heEJ5dGVzVG9SZWFkOiBhbiBvcHRpb25hbCBsZW5ndGggdGhhdCBzcGVjaWZpZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIFlvdSBjYW4gb21pdFxuLy8gICAgICAgICAgICAgICAgIHRoaXMgcGFyYW1ldGVyIHRvIHNjYW4gdGhlIHN0cmluZyB1bnRpbCB0aGUgZmlyc3QgXFwwIGJ5dGUuIElmIG1heEJ5dGVzVG9SZWFkIGlzXG4vLyAgICAgICAgICAgICAgICAgcGFzc2VkLCBhbmQgdGhlIHN0cmluZyBhdCBbcHRyLCBwdHIrbWF4Qnl0ZXNUb1JlYWRyWyBjb250YWlucyBhIG51bGwgYnl0ZSBpbiB0aGVcbi8vICAgICAgICAgICAgICAgICBtaWRkbGUsIHRoZW4gdGhlIHN0cmluZyB3aWxsIGN1dCBzaG9ydCBhdCB0aGF0IGJ5dGUgaW5kZXggKGkuZS4gbWF4Qnl0ZXNUb1JlYWQgd2lsbFxuLy8gICAgICAgICAgICAgICAgIG5vdCBwcm9kdWNlIGEgc3RyaW5nIG9mIGV4YWN0IGxlbmd0aCBbcHRyLCBwdHIrbWF4Qnl0ZXNUb1JlYWRbKVxuLy8gICAgICAgICAgICAgICAgIE4uQi4gbWl4aW5nIGZyZXF1ZW50IHVzZXMgb2YgVVRGOFRvU3RyaW5nKCkgd2l0aCBhbmQgd2l0aG91dCBtYXhCeXRlc1RvUmVhZCBtYXlcbi8vICAgICAgICAgICAgICAgICB0aHJvdyBKUyBKSVQgb3B0aW1pemF0aW9ucyBvZmYsIHNvIGl0IGlzIHdvcnRoIHRvIGNvbnNpZGVyIGNvbnNpc3RlbnRseSB1c2luZyBvbmVcbi8vICAgICAgICAgICAgICAgICBzdHlsZSBvciB0aGUgb3RoZXIuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBwdHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gbWF4Qnl0ZXNUb1JlYWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgO1xuICByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6ICcnO1xufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBhdCBhZGRyZXNzICdvdXRJZHgnLFxuLy8gZW5jb2RlZCBpbiBVVEY4IGZvcm0gYW5kIG51bGwtdGVybWluYXRlZC4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXG4vLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOCB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxuLy8gUGFyYW1ldGVyczpcbi8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cbi8vICAgaGVhcDogdGhlIGFycmF5IHRvIGNvcHkgdG8uIEVhY2ggaW5kZXggaW4gdGhpcyBhcnJheSBpcyBhc3N1bWVkIHRvIGJlIG9uZSA4LWJ5dGUgZWxlbWVudC5cbi8vICAgb3V0SWR4OiBUaGUgc3RhcnRpbmcgb2Zmc2V0IGluIHRoZSBhcnJheSB0byBiZWdpbiB0aGUgY29weWluZy5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LlxuLy8gICAgICAgICAgICAgICAgICAgIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGwgdGVybWluYXRvcixcbi8vICAgICAgICAgICAgICAgICAgICBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT0xLCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXG4vLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPTAgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgaWYgKCEobWF4Qnl0ZXNUb1dyaXRlID4gMCkpIC8vIFBhcmFtZXRlciBtYXhCeXRlc1RvV3JpdGUgaXMgbm90IG9wdGlvbmFsLiBOZWdhdGl2ZSB2YWx1ZXMsIDAsIG51bGwsIHVuZGVmaW5lZCBhbmQgZmFsc2UgZWFjaCBkb24ndCB3cml0ZSBvdXQgYW55IGJ5dGVzLlxuICAgIHJldHVybiAwO1xuXG4gIHZhciBzdGFydElkeCA9IG91dElkeDtcbiAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7IC8vIC0xIGZvciBzdHJpbmcgbnVsbCB0ZXJtaW5hdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb24gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dCBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB7XG4gICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgdSA9IDB4MTAwMDAgKyAoKHUgJiAweDNGRikgPDwgMTApIHwgKHUxICYgMHgzRkYpO1xuICAgIH1cbiAgICBpZiAodSA8PSAweDdGKSB7XG4gICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEMwIHwgKHUgPj4gNik7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XG4gICAgICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweEUwIHwgKHUgPj4gMTIpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAweDgwIHwgKHUgJiA2Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvdXRJZHggKyAzID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBpZiAodSA+IDB4MTBGRkZGKSB3YXJuT25jZSgnSW52YWxpZCBVbmljb2RlIGNvZGUgcG9pbnQgMHgnICsgdS50b1N0cmluZygxNikgKyAnIGVuY291bnRlcmVkIHdoZW4gc2VyaWFsaXppbmcgYSBKUyBzdHJpbmcgdG8gYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkhIChWYWxpZCB1bmljb2RlIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbiByYW5nZSAwLTB4MTBGRkZGKS4nKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHhGMCB8ICh1ID4+IDE4KTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMHg4MCB8ICgodSA+PiAxMikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDB4ODAgfCAodSAmIDYzKTtcbiAgICB9XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIGJ1ZmZlci5cbiAgaGVhcFtvdXRJZHhdID0gMDtcbiAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGOCBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4IHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xuICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEY4IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gIHZhciBsZW4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4M0ZGKTtcbiAgICBpZiAodSA8PSAweDdGKSArK2xlbjtcbiAgICBlbHNlIGlmICh1IDw9IDB4N0ZGKSBsZW4gKz0gMjtcbiAgICBlbHNlIGlmICh1IDw9IDB4RkZGRikgbGVuICs9IDM7XG4gICAgZWxzZSBsZW4gKz0gNDtcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zdHJpbmdzLmpzXG4vLyBpbmNsdWRlOiBydW50aW1lX3N0cmluZ3NfZXh0cmEuanNcblxuXG4vLyBydW50aW1lX3N0cmluZ3NfZXh0cmEuanM6IFN0cmluZ3MgcmVsYXRlZCBydW50aW1lIGZ1bmN0aW9ucyB0aGF0IGFyZSBhdmFpbGFibGUgb25seSBpbiByZWd1bGFyIHJ1bnRpbWUuXG5cbi8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBBU0NJSS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXG4vLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXG5cbmZ1bmN0aW9uIEFzY2lpVG9TdHJpbmcocHRyKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgY2ggPSBIRUFQVThbKChwdHIrKyk+PjApXTtcbiAgICBpZiAoIWNoKSByZXR1cm4gc3RyO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgfVxufVxuXG4vLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXG4vLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gQVNDSUkgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCsxIGJ5dGVzIG9mIHNwYWNlIGluIHRoZSBIRUFQLlxuXG5mdW5jdGlvbiBzdHJpbmdUb0FzY2lpKHN0ciwgb3V0UHRyKSB7XG4gIHJldHVybiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBvdXRQdHIsIGZhbHNlKTtcbn1cblxuLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjE2TEUtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xuLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxuXG52YXIgVVRGMTZEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtMTZsZScpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBVVEYxNlRvU3RyaW5nKHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgYXNzZXJ0KHB0ciAlIDIgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIFVURjE2VG9TdHJpbmcgbXVzdCBiZSBhbGlnbmVkIHRvIHR3byBieXRlcyEnKTtcbiAgdmFyIGVuZFB0ciA9IHB0cjtcbiAgLy8gVGV4dERlY29kZXIgbmVlZHMgdG8ga25vdyB0aGUgYnl0ZSBsZW5ndGggaW4gYWR2YW5jZSwgaXQgZG9lc24ndCBzdG9wIG9uIG51bGwgdGVybWluYXRvciBieSBpdHNlbGYuXG4gIC8vIEFsc28sIHVzZSB0aGUgbGVuZ3RoIGluZm8gdG8gYXZvaWQgcnVubmluZyB0aW55IHN0cmluZ3MgdGhyb3VnaCBUZXh0RGVjb2Rlciwgc2luY2UgLnN1YmFycmF5KCkgYWxsb2NhdGVzIGdhcmJhZ2UuXG4gIHZhciBpZHggPSBlbmRQdHIgPj4gMTtcbiAgdmFyIG1heElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkIC8gMjtcbiAgLy8gSWYgbWF4Qnl0ZXNUb1JlYWQgaXMgbm90IHBhc3NlZCBleHBsaWNpdGx5LCBpdCB3aWxsIGJlIHVuZGVmaW5lZCwgYW5kIHRoaXNcbiAgLy8gd2lsbCBhbHdheXMgZXZhbHVhdGUgdG8gdHJ1ZS4gVGhpcyBzYXZlcyBvbiBjb2RlIHNpemUuXG4gIHdoaWxlICghKGlkeCA+PSBtYXhJZHgpICYmIEhFQVBVMTZbaWR4XSkgKytpZHg7XG4gIGVuZFB0ciA9IGlkeCA8PCAxO1xuXG4gIGlmIChlbmRQdHIgLSBwdHIgPiAzMiAmJiBVVEYxNkRlY29kZXIpIHtcbiAgICByZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLCBlbmRQdHIpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAvLyBJZiBtYXhCeXRlc1RvUmVhZCBpcyBub3QgcGFzc2VkIGV4cGxpY2l0bHksIGl0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhlIGZvci1sb29wJ3MgY29uZGl0aW9uXG4gICAgLy8gd2lsbCBhbHdheXMgZXZhbHVhdGUgdG8gdHJ1ZS4gVGhlIGxvb3AgaXMgdGhlbiB0ZXJtaW5hdGVkIG9uIHRoZSBmaXJzdCBudWxsIGNoYXIuXG4gICAgZm9yICh2YXIgaSA9IDA7ICEoaSA+PSBtYXhCeXRlc1RvUmVhZCAvIDIpOyArK2kpIHtcbiAgICAgIHZhciBjb2RlVW5pdCA9IEhFQVAxNlsoKChwdHIpKyhpKjIpKT4+MSldO1xuICAgICAgaWYgKGNvZGVVbml0ID09IDApIGJyZWFrO1xuICAgICAgLy8gZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBjb2RlIHVuaXQsIHNvIHdlIGNhbiBwYXNzIHRoZSBVVEYxNiBzdHJpbmcgcmlnaHQgdGhyb3VnaC5cbiAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYxNiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMiBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9Miwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTwyIGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgYXNzZXJ0KG91dFB0ciAlIDIgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIHN0cmluZ1RvVVRGMTYgbXVzdCBiZSBhbGlnbmVkIHRvIHR3byBieXRlcyEnKTtcbiAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjE2KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpO1xuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XG4gIH1cbiAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDIpIHJldHVybiAwO1xuICBtYXhCeXRlc1RvV3JpdGUgLT0gMjsgLy8gTnVsbCB0ZXJtaW5hdG9yLlxuICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XG4gIHZhciBudW1DaGFyc1RvV3JpdGUgPSAobWF4Qnl0ZXNUb1dyaXRlIDwgc3RyLmxlbmd0aCoyKSA/IChtYXhCeXRlc1RvV3JpdGUgLyAyKSA6IHN0ci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhcnNUb1dyaXRlOyArK2kpIHtcbiAgICAvLyBjaGFyQ29kZUF0IHJldHVybnMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIHNvIGl0IGNhbiBiZSBkaXJlY3RseSB3cml0dGVuIHRvIHRoZSBIRUFQLlxuICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXG4gICAgSEVBUDE2Wygob3V0UHRyKT4+MSldID0gY29kZVVuaXQ7XG4gICAgb3V0UHRyICs9IDI7XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gIEhFQVAxNlsoKG91dFB0cik+PjEpXSA9IDA7XG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNihzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGgqMjtcbn1cblxuZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gIGFzc2VydChwdHIgJSA0ID09IDAsICdQb2ludGVyIHBhc3NlZCB0byBVVEYzMlRvU3RyaW5nIG11c3QgYmUgYWxpZ25lZCB0byBmb3VyIGJ5dGVzIScpO1xuICB2YXIgaSA9IDA7XG5cbiAgdmFyIHN0ciA9ICcnO1xuICAvLyBJZiBtYXhCeXRlc1RvUmVhZCBpcyBub3QgcGFzc2VkIGV4cGxpY2l0bHksIGl0IHdpbGwgYmUgdW5kZWZpbmVkLCBhbmQgdGhpc1xuICAvLyB3aWxsIGFsd2F5cyBldmFsdWF0ZSB0byB0cnVlLiBUaGlzIHNhdmVzIG9uIGNvZGUgc2l6ZS5cbiAgd2hpbGUgKCEoaSA+PSBtYXhCeXRlc1RvUmVhZCAvIDQpKSB7XG4gICAgdmFyIHV0ZjMyID0gSEVBUDMyWygoKHB0cikrKGkqNCkpPj4yKV07XG4gICAgaWYgKHV0ZjMyID09IDApIGJyZWFrO1xuICAgICsraTtcbiAgICAvLyBHb3RjaGE6IGZyb21DaGFyQ29kZSBjb25zdHJ1Y3RzIGEgY2hhcmFjdGVyIGZyb20gYSBVVEYtMTYgZW5jb2RlZCBjb2RlIChwYWlyKSwgbm90IGZyb20gYSBVbmljb2RlIGNvZGUgcG9pbnQhIFNvIGVuY29kZSB0aGUgY29kZSBwb2ludCB0byBVVEYtMTYgZm9yIGNvbnN0cnVjdGluZy5cbiAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xuICAgIGlmICh1dGYzMiA+PSAweDEwMDAwKSB7XG4gICAgICB2YXIgY2ggPSB1dGYzMiAtIDB4MTAwMDA7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgfCAoY2ggPj4gMTApLCAweERDMDAgfCAoY2ggJiAweDNGRikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBlbXNjcmlwdGVuIEhFQVAgYXQgYWRkcmVzcyAnb3V0UHRyJyxcbi8vIG51bGwtdGVybWluYXRlZCBhbmQgZW5jb2RlZCBpbiBVVEYzMiBmb3JtLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrNCBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cbi8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMigpIHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxuLy8gICBvdXRQdHI6IEJ5dGUgYWRkcmVzcyBpbiBFbXNjcmlwdGVuIEhFQVAgd2hlcmUgdG8gd3JpdGUgdGhlIHN0cmluZyB0by5cbi8vICAgbWF4Qnl0ZXNUb1dyaXRlOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdGhpcyBmdW5jdGlvbiBjYW4gd3JpdGUgdG8gdGhlIGFycmF5LiBUaGlzIGNvdW50IHNob3VsZCBpbmNsdWRlIHRoZSBudWxsXG4vLyAgICAgICAgICAgICAgICAgICAgdGVybWluYXRvciwgaS5lLiBpZiBtYXhCeXRlc1RvV3JpdGU9NCwgb25seSB0aGUgbnVsbCB0ZXJtaW5hdG9yIHdpbGwgYmUgd3JpdHRlbiBhbmQgbm90aGluZyBlbHNlLlxuLy8gICAgICAgICAgICAgICAgICAgIG1heEJ5dGVzVG9Xcml0ZTw0IGRvZXMgbm90IHdyaXRlIGFueSBieXRlcyB0byB0aGUgb3V0cHV0LCBub3QgZXZlbiB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcbiAgYXNzZXJ0KG91dFB0ciAlIDQgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIHN0cmluZ1RvVVRGMzIgbXVzdCBiZSBhbGlnbmVkIHRvIGZvdXIgYnl0ZXMhJyk7XG4gIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09ICdudW1iZXInLCAnc3RyaW5nVG9VVEYzMihzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSBpcyBtaXNzaW5nIHRoZSB0aGlyZCBwYXJhbWV0ZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGJ1ZmZlciEnKTtcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIG1heCBieXRlcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgdW5zYWZlIHVuYm91bmRlZCB3cml0ZSBpcyBhbGxvd2VkLlxuICBpZiAobWF4Qnl0ZXNUb1dyaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXhCeXRlc1RvV3JpdGUgPSAweDdGRkZGRkZGO1xuICB9XG4gIGlmIChtYXhCeXRlc1RvV3JpdGUgPCA0KSByZXR1cm4gMDtcbiAgdmFyIHN0YXJ0UHRyID0gb3V0UHRyO1xuICB2YXIgZW5kUHRyID0gc3RhcnRQdHIgKyBtYXhCeXRlc1RvV3JpdGUgLSA0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFdlIG11c3QgZGVjb2RlIHRoZSBzdHJpbmcgdG8gVVRGLTMyIHRvIHRoZSBoZWFwLlxuICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXG4gICAgdmFyIGNvZGVVbml0ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcbiAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikge1xuICAgICAgdmFyIHRyYWlsU3Vycm9nYXRlID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIGNvZGVVbml0ID0gMHgxMDAwMCArICgoY29kZVVuaXQgJiAweDNGRikgPDwgMTApIHwgKHRyYWlsU3Vycm9nYXRlICYgMHgzRkYpO1xuICAgIH1cbiAgICBIRUFQMzJbKChvdXRQdHIpPj4yKV0gPSBjb2RlVW5pdDtcbiAgICBvdXRQdHIgKz0gNDtcbiAgICBpZiAob3V0UHRyICsgNCA+IGVuZFB0cikgYnJlYWs7XG4gIH1cbiAgLy8gTnVsbC10ZXJtaW5hdGUgdGhlIHBvaW50ZXIgdG8gdGhlIEhFQVAuXG4gIEhFQVAzMlsoKG91dFB0cik+PjIpXSA9IDA7XG4gIHJldHVybiBvdXRQdHIgLSBzdGFydFB0cjtcbn1cblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IHN0cmluZyB0YWtlcyBpZiBlbmNvZGVkIGFzIGEgVVRGMTYgYnl0ZSBhcnJheSwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IgYnl0ZS5cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMihzdHIpIHtcbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXG4gICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcbiAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikgKytpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlLCBzbyBza2lwIG92ZXIgdGhlIHRhaWwgc3Vycm9nYXRlLlxuICAgIGxlbiArPSA0O1xuICB9XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuLy8gQWxsb2NhdGUgaGVhcCBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cbi8vIEl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyIHRvIGZyZWUoKSB0aGF0IG1lbW9yeS5cbmZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpIHtcbiAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuICBpZiAocmV0KSBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVA4LCByZXQsIHNpemUpO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBBbGxvY2F0ZSBzdGFjayBzcGFjZSBmb3IgYSBKUyBzdHJpbmcsIGFuZCB3cml0ZSBpdCB0aGVyZS5cbmZ1bmN0aW9uIGFsbG9jYXRlVVRGOE9uU3RhY2soc3RyKSB7XG4gIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcbiAgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRGVwcmVjYXRlZDogVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWNhdXNlIGl0IGlzIHVuc2FmZSBhbmQgZG9lcyBub3QgcHJvdmlkZVxuLy8gYSBtYXhpbXVtIGxlbmd0aCBsaW1pdCBvZiBob3cgbWFueSBieXRlcyBpdCBpcyBhbGxvd2VkIHRvIHdyaXRlLiBQcmVmZXIgY2FsbGluZyB0aGVcbi8vIGZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KCkgaW5zdGVhZCwgd2hpY2ggdGFrZXMgaW4gYSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSB1c2VkXG4vLyB0byBiZSBzZWN1cmUgZnJvbSBvdXQgb2YgYm91bmRzIHdyaXRlcy5cbi8qKiBAZGVwcmVjYXRlZFxuICAgIEBwYXJhbSB7Ym9vbGVhbj19IGRvbnRBZGROdWxsICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1RvTWVtb3J5KHN0cmluZywgYnVmZmVyLCBkb250QWRkTnVsbCkge1xuICB3YXJuT25jZSgnd3JpdGVTdHJpbmdUb01lbW9yeSBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCEgVXNlIHN0cmluZ1RvVVRGOCgpIGluc3RlYWQhJyk7XG5cbiAgdmFyIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyBsYXN0Q2hhciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIGVuZDtcbiAgaWYgKGRvbnRBZGROdWxsKSB7XG4gICAgLy8gc3RyaW5nVG9VVEY4QXJyYXkgYWx3YXlzIGFwcGVuZHMgbnVsbC4gSWYgd2UgZG9uJ3Qgd2FudCB0byBkbyB0aGF0LCByZW1lbWJlciB0aGVcbiAgICAvLyBjaGFyYWN0ZXIgdGhhdCBleGlzdGVkIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgbnVsbCB3aWxsIGJlIHBsYWNlZCwgYW5kIHJlc3RvcmVcbiAgICAvLyB0aGF0IGFmdGVyIHRoZSB3cml0ZSAoYmVsb3cpLlxuICAgIGVuZCA9IGJ1ZmZlciArIGxlbmd0aEJ5dGVzVVRGOChzdHJpbmcpO1xuICAgIGxhc3RDaGFyID0gSEVBUDhbZW5kXTtcbiAgfVxuICBzdHJpbmdUb1VURjgoc3RyaW5nLCBidWZmZXIsIEluZmluaXR5KTtcbiAgaWYgKGRvbnRBZGROdWxsKSBIRUFQOFtlbmRdID0gbGFzdENoYXI7IC8vIFJlc3RvcmUgdGhlIHZhbHVlIHVuZGVyIHRoZSBudWxsIGNoYXJhY3Rlci5cbn1cblxuZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LCBidWZmZXIpIHtcbiAgYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCAnd3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KScpXG4gIEhFQVA4LnNldChhcnJheSwgYnVmZmVyKTtcbn1cblxuLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGRvbnRBZGROdWxsICovXG5mdW5jdGlvbiB3cml0ZUFzY2lpVG9NZW1vcnkoc3RyLCBidWZmZXIsIGRvbnRBZGROdWxsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYXNzZXJ0KHN0ci5jaGFyQ29kZUF0KGkpID09PSAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSk7XG4gICAgSEVBUDhbKChidWZmZXIrKyk+PjApXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxuICBpZiAoIWRvbnRBZGROdWxsKSBIRUFQOFsoKGJ1ZmZlcik+PjApXSA9IDA7XG59XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX3N0cmluZ3NfZXh0cmEuanNcbi8vIE1lbW9yeSBtYW5hZ2VtZW50XG5cbnZhciBIRUFQLFxuLyoqIEB0eXBlIHshQXJyYXlCdWZmZXJ9ICovXG4gIGJ1ZmZlcixcbi8qKiBAdHlwZSB7IUludDhBcnJheX0gKi9cbiAgSEVBUDgsXG4vKiogQHR5cGUgeyFVaW50OEFycmF5fSAqL1xuICBIRUFQVTgsXG4vKiogQHR5cGUgeyFJbnQxNkFycmF5fSAqL1xuICBIRUFQMTYsXG4vKiogQHR5cGUgeyFVaW50MTZBcnJheX0gKi9cbiAgSEVBUFUxNixcbi8qKiBAdHlwZSB7IUludDMyQXJyYXl9ICovXG4gIEhFQVAzMixcbi8qKiBAdHlwZSB7IVVpbnQzMkFycmF5fSAqL1xuICBIRUFQVTMyLFxuLyoqIEB0eXBlIHshRmxvYXQzMkFycmF5fSAqL1xuICBIRUFQRjMyLFxuLyoqIEB0eXBlIHshRmxvYXQ2NEFycmF5fSAqL1xuICBIRUFQRjY0O1xuXG5mdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgYnVmZmVyID0gYnVmO1xuICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmKTtcbn1cblxudmFyIFRPVEFMX1NUQUNLID0gNTI0Mjg4MDtcbmlmIChNb2R1bGVbJ1RPVEFMX1NUQUNLJ10pIGFzc2VydChUT1RBTF9TVEFDSyA9PT0gTW9kdWxlWydUT1RBTF9TVEFDSyddLCAndGhlIHN0YWNrIHNpemUgY2FuIG5vIGxvbmdlciBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUnKVxuXG52YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTM0MjE3NzI4O2xlZ2FjeU1vZHVsZVByb3AoJ0lOSVRJQUxfTUVNT1JZJywgJ0lOSVRJQUxfTUVNT1JZJyk7XG5cbmFzc2VydChJTklUSUFMX01FTU9SWSA+PSBUT1RBTF9TVEFDSywgJ0lOSVRJQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICcgKyBJTklUSUFMX01FTU9SWSArICchIChUT1RBTF9TVEFDSz0nICsgVE9UQUxfU1RBQ0sgKyAnKScpO1xuXG4vLyBjaGVjayBmb3IgZnVsbCBlbmdpbmUgc3VwcG9ydCAodXNlIHN0cmluZyAnc3ViYXJyYXknIHRvIGF2b2lkIGNsb3N1cmUgY29tcGlsZXIgY29uZnVzaW9uKVxuYXNzZXJ0KHR5cGVvZiBJbnQzMkFycmF5ICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEludDMyQXJyYXkucHJvdG90eXBlLnN1YmFycmF5ICE9IHVuZGVmaW5lZCAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT0gdW5kZWZpbmVkLFxuICAgICAgICdKUyBlbmdpbmUgZG9lcyBub3QgcHJvdmlkZSBmdWxsIHR5cGVkIGFycmF5IHN1cHBvcnQnKTtcblxuLy8gSW4gbm9uLXN0YW5kYWxvbmUvbm9ybWFsIG1vZGUsIHdlIGNyZWF0ZSB0aGUgbWVtb3J5IGhlcmUuXG4vLyBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG5cblxuLy8gQ3JlYXRlIHRoZSB3YXNtIG1lbW9yeS4gKE5vdGU6IHRoaXMgb25seSBhcHBsaWVzIGlmIElNUE9SVEVEX01FTU9SWSBpcyBkZWZpbmVkKVxuXG4gIGlmIChNb2R1bGVbJ3dhc21NZW1vcnknXSkge1xuICAgIHdhc21NZW1vcnkgPSBNb2R1bGVbJ3dhc21NZW1vcnknXTtcbiAgfSBlbHNlXG4gIHtcbiAgICB3YXNtTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICAnaW5pdGlhbCc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzYsXG4gICAgICAnbWF4aW11bSc6IElOSVRJQUxfTUVNT1JZIC8gNjU1MzZcbiAgICB9KTtcbiAgfVxuXG5pZiAod2FzbU1lbW9yeSkge1xuICBidWZmZXIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbn1cblxuLy8gSWYgdGhlIHVzZXIgcHJvdmlkZXMgYW4gaW5jb3JyZWN0IGxlbmd0aCwganVzdCB1c2UgdGhhdCBsZW5ndGggaW5zdGVhZCByYXRoZXIgdGhhbiBwcm92aWRpbmcgdGhlIHVzZXIgdG9cbi8vIHNwZWNpZmljYWxseSBwcm92aWRlIHRoZSBtZW1vcnkgbGVuZ3RoIHdpdGggTW9kdWxlWydJTklUSUFMX01FTU9SWSddLlxuSU5JVElBTF9NRU1PUlkgPSBidWZmZXIuYnl0ZUxlbmd0aDtcbmFzc2VydChJTklUSUFMX01FTU9SWSAlIDY1NTM2ID09PSAwKTtcbnVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKGJ1ZmZlcik7XG5cbi8vIGVuZCBpbmNsdWRlOiBydW50aW1lX2luaXRfbWVtb3J5LmpzXG5cbi8vIGluY2x1ZGU6IHJ1bnRpbWVfaW5pdF90YWJsZS5qc1xuLy8gSW4gUkVMT0NBVEFCTEUgbW9kZSB3ZSBjcmVhdGUgdGhlIHRhYmxlIGluIEpTLlxudmFyIHdhc21UYWJsZSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7XG4gICdpbml0aWFsJzogNDM3NCxcbiAgJ2VsZW1lbnQnOiAnYW55ZnVuYydcbn0pO1xuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9pbml0X3RhYmxlLmpzXG4vLyBpbmNsdWRlOiBydW50aW1lX3N0YWNrX2NoZWNrLmpzXG5cblxuLy8gSW5pdGlhbGl6ZXMgdGhlIHN0YWNrIGNvb2tpZS4gQ2FsbGVkIGF0IHRoZSBzdGFydHVwIG9mIG1haW4gYW5kIGF0IHRoZSBzdGFydHVwIG9mIGVhY2ggdGhyZWFkIGluIHB0aHJlYWRzIG1vZGUuXG5mdW5jdGlvbiB3cml0ZVN0YWNrQ29va2llKCkge1xuICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuICBhc3NlcnQoKG1heCAmIDMpID09IDApO1xuICAvLyBUaGUgc3RhY2sgZ3JvdyBkb3dud2FyZHMgdG93YXJkcyBfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kLlxuICAvLyBXZSB3cml0ZSBjb29raWVzIHRvIHRoZSBmaW5hbCB0d28gd29yZHMgaW4gdGhlIHN0YWNrIGFuZCBkZXRlY3QgaWYgdGhleSBhcmVcbiAgLy8gZXZlciBvdmVyd3JpdHRlbi5cbiAgSEVBUDMyWygobWF4KT4+MildID0gMHgyMTM1NDY3O1xuICBIRUFQMzJbKCgobWF4KSsoNCkpPj4yKV0gPSAweDg5QkFDREZFO1xuICAvLyBBbHNvIHRlc3QgdGhlIGdsb2JhbCBhZGRyZXNzIDAgZm9yIGludGVncml0eS5cbiAgSEVBUDMyWzBdID0gMHg2MzczNmQ2NTsgLyogJ2Vtc2MnICovXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhY2tDb29raWUoKSB7XG4gIGlmIChBQk9SVCkgcmV0dXJuO1xuICB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuICB2YXIgY29va2llMSA9IEhFQVBVMzJbKChtYXgpPj4yKV07XG4gIHZhciBjb29raWUyID0gSEVBUFUzMlsoKChtYXgpKyg0KSk+PjIpXTtcbiAgLyppZiAoY29va2llMSAhPSAweDIxMzU0NjcgfHwgY29va2llMiAhPSAweDg5QkFDREZFKSB7XG4gICAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBTdGFjayBjb29raWUgaGFzIGJlZW4gb3ZlcndyaXR0ZW4sIGV4cGVjdGVkIGhleCBkd29yZHMgMHg4OUJBQ0RGRSBhbmQgMHgyMTM1NDY3LCBidXQgcmVjZWl2ZWQgMHgnICsgY29va2llMi50b1N0cmluZygxNikgKyAnIDB4JyArIGNvb2tpZTEudG9TdHJpbmcoMTYpKTtcbiAgfSovXG4gIC8vIEFsc28gdGVzdCB0aGUgZ2xvYmFsIGFkZHJlc3MgMCBmb3IgaW50ZWdyaXR5LlxuICBpZiAoSEVBUDMyWzBdICE9PSAweDYzNzM2ZDY1IC8qICdlbXNjJyAqLykgYWJvcnQoJ1J1bnRpbWUgZXJyb3I6IFRoZSBhcHBsaWNhdGlvbiBoYXMgY29ycnVwdGVkIGl0cyBoZWFwIG1lbW9yeSBhcmVhIChhZGRyZXNzIHplcm8pIScpO1xufVxuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9zdGFja19jaGVjay5qc1xuLy8gaW5jbHVkZTogcnVudGltZV9hc3NlcnRpb25zLmpzXG5cblxuLy8gRW5kaWFubmVzcyBjaGVja1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgaDE2ID0gbmV3IEludDE2QXJyYXkoMSk7XG4gIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gIGgxNlswXSA9IDB4NjM3MztcbiAgaWYgKGg4WzBdICE9PSAweDczIHx8IGg4WzFdICE9PSAweDYzKSB0aHJvdyAnUnVudGltZSBlcnJvcjogZXhwZWN0ZWQgdGhlIHN5c3RlbSB0byBiZSBsaXR0bGUtZW5kaWFuISAoUnVuIHdpdGggLXMgU1VQUE9SVF9CSUdfRU5ESUFOPTEgdG8gYnlwYXNzKSc7XG59KSgpO1xuXG4vLyBlbmQgaW5jbHVkZTogcnVudGltZV9hc3NlcnRpb25zLmpzXG52YXIgX19BVFBSRVJVTl9fICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGJlZm9yZSB0aGUgcnVudGltZSBpcyBpbml0aWFsaXplZFxudmFyIF9fQVRJTklUX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBkdXJpbmcgc3RhcnR1cFxudmFyIF9fQVRNQUlOX18gICAgPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCB3aGVuIG1haW4oKSBpcyB0byBiZSBydW5cbnZhciBfX0FURVhJVF9fICAgID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHNodXRkb3duXG52YXIgX19BVFBPU1RSVU5fXyA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGFmdGVyIHRoZSBtYWluKCkgaXMgY2FsbGVkXG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpIHtcbiAgcmV0dXJuIG5vRXhpdFJ1bnRpbWU7XG59XG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcblxuICBpZiAoTW9kdWxlWydwcmVSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwcmVSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZVJ1biddID0gW01vZHVsZVsncHJlUnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3ByZVJ1biddLmxlbmd0aCkge1xuICAgICAgYWRkT25QcmVSdW4oTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xufVxuXG5mdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuICBhc3NlcnQoIXJ1bnRpbWVJbml0aWFsaXplZCk7XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG5cbiAgXG5pZiAoIU1vZHVsZVtcIm5vRlNJbml0XCJdICYmICFGUy5pbml0LmluaXRpYWxpemVkKVxuICBGUy5pbml0KCk7XG5GUy5pZ25vcmVQZXJtaXNzaW9ucyA9IGZhbHNlO1xuXG5UVFkuaW5pdCgpO1xuU09DS0ZTLnJvb3QgPSBGUy5tb3VudChTT0NLRlMsIHt9LCBudWxsKTtcblBJUEVGUy5yb290ID0gRlMubW91bnQoUElQRUZTLCB7fSwgbnVsbCk7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG5mdW5jdGlvbiBwcmVNYWluKCkge1xuICBjaGVja1N0YWNrQ29va2llKCk7XG4gIFxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUTUFJTl9fKTtcbn1cblxuZnVuY3Rpb24gcG9zdFJ1bigpIHtcbiAgY2hlY2tTdGFja0Nvb2tpZSgpO1xuXG4gIGlmIChNb2R1bGVbJ3Bvc3RSdW4nXSkge1xuICAgIGlmICh0eXBlb2YgTW9kdWxlWydwb3N0UnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwb3N0UnVuJ10gPSBbTW9kdWxlWydwb3N0UnVuJ11dO1xuICAgIHdoaWxlIChNb2R1bGVbJ3Bvc3RSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUG9zdFJ1bihNb2R1bGVbJ3Bvc3RSdW4nXS5zaGlmdCgpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiAgX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiAgX19BVElOSVRfXy51bnNoaWZ0KGNiKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVNYWluKGNiKSB7XG4gIF9fQVRNQUlOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge1xufVxuXG5mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2IpIHtcbiAgX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuLy8gaW5jbHVkZTogcnVudGltZV9tYXRoLmpzXG5cblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9pbXVsXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvZnJvdW5kXG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuY1xuXG5hc3NlcnQoTWF0aC5pbXVsLCAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5pbXVsKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG5hc3NlcnQoTWF0aC5mcm91bmQsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmZyb3VuZCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbCcpO1xuYXNzZXJ0KE1hdGguY2x6MzIsICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmNsejMyKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsJyk7XG5hc3NlcnQoTWF0aC50cnVuYywgJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGgudHJ1bmMoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGwnKTtcblxuLy8gZW5kIGluY2x1ZGU6IHJ1bnRpbWVfbWF0aC5qc1xuLy8gQSBjb3VudGVyIG9mIGRlcGVuZGVuY2llcyBmb3IgY2FsbGluZyBydW4oKS4gSWYgd2UgbmVlZCB0b1xuLy8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYmVmb3JlIHJ1bm5pbmcsIGluY3JlbWVudCB0aGlzIGFuZFxuLy8gZGVjcmVtZW50IGl0LiBJbmNyZW1lbnRpbmcgbXVzdCBoYXBwZW4gaW4gYSBwbGFjZSBsaWtlXG4vLyBNb2R1bGUucHJlUnVuICh1c2VkIGJ5IGVtY2MgdG8gYWRkIGZpbGUgcHJlbG9hZGluZykuXG4vLyBOb3RlIHRoYXQgeW91IGNhbiBhZGQgZGVwZW5kZW5jaWVzIGluIHByZVJ1biwgZXZlbiB0aG91Z2hcbi8vIGl0IGhhcHBlbnMgcmlnaHQgYmVmb3JlIHJ1biAtIHJ1biB3aWxsIGJlIHBvc3Rwb25lZCB1bnRpbFxuLy8gdGhlIGRlcGVuZGVuY2llcyBhcmUgbWV0LlxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xudmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7IC8vIG92ZXJyaWRkZW4gdG8gdGFrZSBkaWZmZXJlbnQgYWN0aW9ucyB3aGVuIGFsbCBydW4gZGVwZW5kZW5jaWVzIGFyZSBmdWxmaWxsZWRcbnZhciBydW5EZXBlbmRlbmN5VHJhY2tpbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCkge1xuICB2YXIgb3JpZyA9IGlkO1xuICB3aGlsZSAoMSkge1xuICAgIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xuICAgIGlkID0gb3JpZyArIE1hdGgucmFuZG9tKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuICBydW5EZXBlbmRlbmNpZXMrKztcblxuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgaWYgKGlkKSB7XG4gICAgYXNzZXJ0KCFydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcbiAgICBydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gMTtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbWlzc2luZyBkZXBlbmRlbmNpZXMgZXZlcnkgZmV3IHNlY29uZHNcbiAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChBQk9SVCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgICAgICBpZiAoIXNob3duKSB7XG4gICAgICAgICAgICBzaG93biA9IHRydWU7XG4gICAgICAgICAgICBlcnIoJ3N0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczonKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyKCdkZXBlbmRlbmN5OiAnICsgZGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd24pIHtcbiAgICAgICAgICBlcnIoJyhlbmQgb2YgbGlzdCknKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnIoJ3dhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IGFkZGVkIHdpdGhvdXQgSUQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcy0tO1xuXG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cblxuICBpZiAoaWQpIHtcbiAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gIH0gZWxzZSB7XG4gICAgZXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSByZW1vdmVkIHdpdGhvdXQgSUQnKTtcbiAgfVxuICBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xuICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgICAgY2FsbGJhY2soKTsgLy8gY2FuIGFkZCBhbm90aGVyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZFxuICAgIH1cbiAgfVxufVxuXG5Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl0gPSB7fTsgLy8gbWFwcyB1cmwgdG8gaW1hZ2UgZGF0YVxuTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGF1ZGlvIGRhdGFcbk1vZHVsZVtcInByZWxvYWRlZFdhc21cIl0gPSB7fTsgLy8gbWFwcyB1cmwgdG8gd2FzbSBpbnN0YW5jZSBleHBvcnRzXG5cbi8qKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSB3aGF0ICovXG5mdW5jdGlvbiBhYm9ydCh3aGF0KSB7XG4gIHtcbiAgICBpZiAoTW9kdWxlWydvbkFib3J0J10pIHtcbiAgICAgIE1vZHVsZVsnb25BYm9ydCddKHdoYXQpO1xuICAgIH1cbiAgfVxuXG4gIHdoYXQgPSAnQWJvcnRlZCgnICsgd2hhdCArICcpJztcbiAgLy8gVE9ETyhzYmMpOiBTaG91bGQgd2UgcmVtb3ZlIHByaW50aW5nIGFuZCBsZWF2ZSBpdCB1cCB0byB3aG9ldmVyXG4gIC8vIGNhdGNoZXMgdGhlIGV4Y2VwdGlvbj9cbiAgZXJyKHdoYXQpO1xuXG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG5cbiAgLy8gVXNlIGEgd2FzbSBydW50aW1lIGVycm9yLCBiZWNhdXNlIGEgSlMgZXJyb3IgbWlnaHQgYmUgc2VlbiBhcyBhIGZvcmVpZ25cbiAgLy8gZXhjZXB0aW9uLCB3aGljaCBtZWFucyB3ZSdkIHJ1biBkZXN0cnVjdG9ycyBvbiBpdC4gV2UgbmVlZCB0aGUgZXJyb3IgdG9cbiAgLy8gc2ltcGx5IG1ha2UgdGhlIHByb2dyYW0gc3RvcC5cblxuICAvLyBTdXBwcmVzcyBjbG9zdXJlIGNvbXBpbGVyIHdhcm5pbmcgaGVyZS4gQ2xvc3VyZSBjb21waWxlcidzIGJ1aWx0aW4gZXh0ZXJuXG4gIC8vIGRlZmludGlvbiBmb3IgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yIGNsYWltcyBpdCB0YWtlcyBubyBhcmd1bWVudHMgZXZlblxuICAvLyB0aG91Z2ggaXQgY2FuLlxuICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9wdWxsLzM5MTMpOiBSZW1vdmUgaWYvd2hlbiB1cHN0cmVhbSBjbG9zdXJlIGdldHMgZml4ZWQuXG5cbiAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuXG4gIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiAgLy8gVGhyb3cgdGhlIGVycm9yIHdoZXRoZXIgb3Igbm90IE1PRFVMQVJJWkUgaXMgc2V0IGJlY2F1c2UgYWJvcnQgaXMgdXNlZFxuICAvLyBpbiBjb2RlIHBhdGhzIGFwYXJ0IGZyb20gaW5zdGFudGlhdGlvbiB3aGVyZSBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWRcbiAgLy8gdG8gYmUgdGhyb3duIHdoZW4gYWJvcnQgaXMgY2FsbGVkLlxuICB0aHJvdyBlO1xufVxuXG4vLyB7e01FTV9JTklUSUFMSVpFUn19XG5cbi8vIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG5cblxuLy8gZW5kIGluY2x1ZGU6IG1lbW9yeXByb2ZpbGVyLmpzXG4vLyBpbmNsdWRlOiBVUklVdGlscy5qc1xuXG5cbi8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxudmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7XG5cbi8vIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gIC8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxuICByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbn1cblxuLy8gSW5kaWNhdGVzIHdoZXRoZXIgZmlsZW5hbWUgaXMgZGVsaXZlcmVkIHZpYSBmaWxlIHByb3RvY29sIChhcyBvcHBvc2VkIHRvIGh0dHAvaHR0cHMpXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbn1cblxuLy8gZW5kIGluY2x1ZGU6IFVSSVV0aWxzLmpzXG4vKiogQHBhcmFtIHtib29sZWFuPX0gZml4ZWRhc20gKi9cbmZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgZml4ZWRhc20pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgdmFyIGFzbSA9IGZpeGVkYXNtO1xuICAgIGlmICghZml4ZWRhc20pIHtcbiAgICAgIGFzbSA9IE1vZHVsZVsnYXNtJ107XG4gICAgfVxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICduYXRpdmUgZnVuY3Rpb24gYCcgKyBkaXNwbGF5TmFtZSArICdgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvbicpO1xuICAgIGlmICghYXNtW25hbWVdKSB7XG4gICAgICBhc3NlcnQoYXNtW25hbWVdLCAnZXhwb3J0ZWQgbmF0aXZlIGZ1bmN0aW9uIGAnICsgZGlzcGxheU5hbWUgKyAnYCBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzbVtuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG53YXNtQmluYXJ5RmlsZSA9IGxvY2F0aW9uLnVzaW5nO1xuICBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuICB9XG5cbmZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gIHRyeSB7XG4gICAgaWYgKGZpbGUgPT0gd2FzbUJpbmFyeUZpbGUgJiYgd2FzbUJpbmFyeSkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICAgIH1cbiAgICBpZiAocmVhZEJpbmFyeSkge1xuICAgICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgYmluYXJ5IHlldCwgdHJ5IHRvIHRvIGxvYWQgaXQgYXN5bmNocm9ub3VzbHkuXG4gIC8vIEZldGNoIGhhcyBzb21lIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb25zIG92ZXIgWEhSLCBsaWtlIGl0IGNhbid0IGJlIHVzZWQgb24gYSBmaWxlOi8vIHVybC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvcHVsbC85MiNpc3N1ZWNvbW1lbnQtMTQwNjY1OTMyXG4gIC8vIENvcmRvdmEgb3IgRWxlY3Ryb24gYXBwcyBhcmUgdHlwaWNhbGx5IGxvYWRlZCBmcm9tIGEgZmlsZTovLyB1cmwuXG4gIC8vIFNvIHVzZSBmZXRjaCBpZiBpdCBpcyBhdmFpbGFibGUgYW5kIHRoZSB1cmwgaXMgbm90IGEgZmlsZSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBYSFIuXG4gIGlmICghd2FzbUJpbmFyeSAmJiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikpIHtcbiAgICBpZiAodHlwZW9mIGZldGNoID09ICdmdW5jdGlvbidcbiAgICAgICYmICFpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XG4gICAgICAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIHdhc21CaW5hcnlGaWxlICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAocmVhZEFzeW5jKSB7XG4gICAgICAgIC8vIGZldGNoIGlzIG5vdCBhdmFpbGFibGUgb3IgdXJsIGlzIGZpbGUgPT4gdHJ5IFhIUiAocmVhZEFzeW5jIHVzZXMgWEhSIGludGVybmFsbHkpXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWFkQXN5bmMod2FzbUJpbmFyeUZpbGUsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7IHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBleyFBcnJheUJ1ZmZlcn0gKi8ocmVzcG9uc2UpKSkgfSwgcmVqZWN0KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGdldEJpbmFyeSBzaG91bGQgYmUgYWJsZSB0byBnZXQgaXQgc3luY2hyb25vdXNseVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSk7IH0pO1xufVxuXG4vLyBDcmVhdGUgdGhlIHdhc20gaW5zdGFuY2UuXG4vLyBSZWNlaXZlcyB0aGUgd2FzbSBpbXBvcnRzLCByZXR1cm5zIHRoZSBleHBvcnRzLlxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgLy8gcHJlcGFyZSBpbXBvcnRzXG4gIHZhciBpbmZvID0ge1xuICAgICdlbnYnOiBhc21MaWJyYXJ5QXJnLFxuICAgICd3YXNpX3NuYXBzaG90X3ByZXZpZXcxJzogYXNtTGlicmFyeUFyZyxcbiAgICAnR09ULm1lbSc6IG5ldyBQcm94eShhc21MaWJyYXJ5QXJnLCBHT1RIYW5kbGVyKSxcbiAgICAnR09ULmZ1bmMnOiBuZXcgUHJveHkoYXNtTGlicmFyeUFyZywgR09USGFuZGxlciksXG4gIH07XG4gIC8vIExvYWQgdGhlIHdhc20gbW9kdWxlIGFuZCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdXNpbmcgbmF0aXZlIHN1cHBvcnQgaW4gdGhlIEpTIGVuZ2luZS5cbiAgLy8gaGFuZGxlIGEgZ2VuZXJhdGVkIHdhc20gaW5zdGFuY2UsIHJlY2VpdmluZyBpdHMgZXhwb3J0cyBhbmRcbiAgLy8gcGVyZm9ybWluZyBvdGhlciBuZWNlc3Nhcnkgc2V0dXBcbiAgLyoqIEBwYXJhbSB7V2ViQXNzZW1ibHkuTW9kdWxlPX0gbW9kdWxlKi9cbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG5cbiAgICBleHBvcnRzID0gcmVsb2NhdGVFeHBvcnRzKGV4cG9ydHMsIDEwMjQpO1xuXG4gICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG5cbiAgICB2YXIgbWV0YWRhdGEgPSBnZXREeWxpbmtNZXRhZGF0YShtb2R1bGUpO1xuICAgIGlmIChtZXRhZGF0YS5uZWVkZWREeW5saWJzKSB7XG4gICAgICBkeW5hbWljTGlicmFyaWVzID0gbWV0YWRhdGEubmVlZGVkRHlubGlicy5jb25jYXQoZHluYW1pY0xpYnJhcmllcyk7XG4gICAgfVxuICAgIG1lcmdlTGliU3ltYm9scyhleHBvcnRzLCAnbWFpbicpXG5cbiAgICBhZGRPbkluaXQoTW9kdWxlWydhc20nXVsnX193YXNtX2NhbGxfY3RvcnMnXSk7XG5cbiAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgfVxuICAvLyB3ZSBjYW4ndCBydW4geWV0IChleGNlcHQgaW4gYSBwdGhyZWFkLCB3aGVyZSB3ZSBoYXZlIGEgY3VzdG9tIHN5bmMgaW5zdGFudGlhdG9yKVxuICBhZGRSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7XG5cbiAgLy8gUHJlZmVyIHN0cmVhbWluZyBpbnN0YW50aWF0aW9uIGlmIGF2YWlsYWJsZS5cbiAgLy8gQXN5bmMgY29tcGlsYXRpb24gY2FuIGJlIGNvbmZ1c2luZyB3aGVuIGFuIGVycm9yIG9uIHRoZSBwYWdlIG92ZXJ3cml0ZXMgTW9kdWxlXG4gIC8vIChmb3IgZXhhbXBsZSwgaWYgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGlzIHdyb25nLCBhbmQgdGhlIG9uZSBkZWZpbmluZyBNb2R1bGUgaXNcbiAgLy8gbGF0ZXIpLCBzbyB3ZSBzYXZlIE1vZHVsZSBhbmQgY2hlY2sgaXQgbGF0ZXIuXG4gIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xuICBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyAncmVzdWx0JyBpcyBhIFJlc3VsdE9iamVjdCBvYmplY3Qgd2hpY2ggaGFzIGJvdGggdGhlIG1vZHVsZSBhbmQgaW5zdGFuY2UuXG4gICAgLy8gcmVjZWl2ZUluc3RhbmNlKCkgd2lsbCBzd2FwIGluIHRoZSBleHBvcnRzICh0byBNb2R1bGUuYXNtKSBzbyB0aGV5IGNhbiBiZSBjYWxsZWRcbiAgICBhc3NlcnQoTW9kdWxlID09PSB0cnVlTW9kdWxlLCAndGhlIE1vZHVsZSBvYmplY3Qgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCBkdXJpbmcgYXN5bmMgY29tcGlsYXRpb24gLSBwZXJoYXBzIHRoZSBvcmRlciBvZiBIVE1MIGVsZW1lbnRzIGlzIHdyb25nPycpO1xuICAgIHRydWVNb2R1bGUgPSBudWxsO1xuICAgIHJlY2VpdmVJbnN0YW5jZShyZXN1bHRbJ2luc3RhbmNlJ10sIHJlc3VsdFsnbW9kdWxlJ10pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcikge1xuICAgIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKCkudGhlbihmdW5jdGlvbihiaW5hcnkpIHtcbiAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSkudGhlbihyZWNlaXZlciwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuXG4gICAgICAvLyBXYXJuIG9uIHNvbWUgY29tbW9uIHByb2JsZW1zLlxuICAgICAgaWYgKGlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgICAgICAgZXJyKCd3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoJyArIHdhc21CaW5hcnlGaWxlICsgJykgaXMgbm90IHN1cHBvcnRlZCBpbiBtb3N0IGJyb3dzZXJzLiBTZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2dldHRpbmdfc3RhcnRlZC9GQVEuaHRtbCNob3ctZG8taS1ydW4tYS1sb2NhbC13ZWJzZXJ2ZXItZm9yLXRlc3Rpbmctd2h5LWRvZXMtbXktcHJvZ3JhbS1zdGFsbC1pbi1kb3dubG9hZGluZy1vci1wcmVwYXJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KHJlYXNvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCkge1xuICAgIGlmICghd2FzbUJpbmFyeSAmJlxuICAgICAgICB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICAvLyBEb24ndCB1c2Ugc3RyZWFtaW5nIGZvciBmaWxlOi8vIGRlbGl2ZXJlZCBvYmplY3RzIGluIGEgd2VidmlldywgZmV0Y2ggdGhlbSBzeW5jaHJvbm91c2x5LlxuICAgICAgICAhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSAmJlxuICAgICAgICB0eXBlb2YgZmV0Y2ggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gU3VwcHJlc3MgY2xvc3VyZSB3YXJuaW5nIGhlcmUgc2luY2UgdGhlIHVwc3RyZWFtIGRlZmluaXRpb24gZm9yXG4gICAgICAgIC8vIGluc3RhbnRpYXRlU3RyZWFtaW5nIG9ubHkgYWxsb3dzIFByb21pc2U8UmVwc3BvbnNlPiByYXRoZXIgdGhhblxuICAgICAgICAvLyBhbiBhY3R1YWwgUmVzcG9uc2UuXG4gICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL3B1bGwvMzkxMyk6IFJlbW92ZSBpZi93aGVuIHVwc3RyZWFtIGNsb3N1cmUgaXMgZml4ZWQuXG4gICAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW5mbyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKFxuICAgICAgICAgIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LFxuICAgICAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgICAgLy8gV2UgZXhwZWN0IHRoZSBtb3N0IGNvbW1vbiBmYWlsdXJlIGNhdXNlIHRvIGJlIGEgYmFkIE1JTUUgdHlwZSBmb3IgdGhlIGJpbmFyeSxcbiAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24gc2hvdWxkIHdvcmsuXG4gICAgICAgICAgICBlcnIoJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcbiAgICAgICAgICAgIGVycignZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlciBzaGVsbCBwYWdlcyBjYW4gd3JpdGUgdGhlaXIgb3duIE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gPSBmdW5jdGlvbihpbXBvcnRzLCBzdWNjZXNzQ2FsbGJhY2spIGNhbGxiYWNrXG4gIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0byBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWxcbiAgLy8gdG8gYW55IG90aGVyIGFzeW5jIHN0YXJ0dXAgYWN0aW9ucyB0aGV5IGFyZSBwZXJmb3JtaW5nLlxuICAvLyBBbHNvIHB0aHJlYWRzIGFuZCB3YXNtIHdvcmtlcnMgaW5pdGlhbGl6ZSB0aGUgd2FzbSBpbnN0YW5jZSB0aHJvdWdoIHRoaXMgcGF0aC5cbiAgaWYgKE1vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGV4cG9ydHMgPSBNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVycignTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIGluc3RhbnRpYXRpb24gZmFpbHMsIHJlamVjdCB0aGUgbW9kdWxlIHJlYWR5IHByb21pc2UuXG4gIGluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuICByZXR1cm4ge307IC8vIG5vIGV4cG9ydHMgeWV0OyB3ZSdsbCBmaWxsIHRoZW0gaW4gbGF0ZXJcbn1cblxuLy8gR2xvYmFscyB1c2VkIGJ5IEpTIGk2NCBjb252ZXJzaW9ucyAoc2VlIG1ha2VTZXRWYWx1ZSlcbnZhciB0ZW1wRG91YmxlO1xudmFyIHRlbXBJNjQ7XG5cbi8vID09PSBCb2R5ID09PVxuXG52YXIgQVNNX0NPTlNUUyA9IHtcbiAgXG59O1xuXG5cblxuXG5cblxuICB2YXIgR09UID0ge307XG4gIHZhciBHT1RIYW5kbGVyID0ge2dldDpmdW5jdGlvbihvYmosIHN5bU5hbWUpIHtcbiAgICAgICAgaWYgKCFHT1Rbc3ltTmFtZV0pIHtcbiAgICAgICAgICBHT1Rbc3ltTmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuR2xvYmFsKHsndmFsdWUnOiAnaTMyJywgJ211dGFibGUnOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdPVFtzeW1OYW1lXVxuICAgICAgfX07XG5cbiAgZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gICAgICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKE1vZHVsZSk7IC8vIFBhc3MgdGhlIG1vZHVsZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjay5mdW5jO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgd2FzbSBmdW5jdGlvbiBwdHIgd2l0aCBzaWduYXR1cmUgJ3YnLiBJZiBubyBmdW5jdGlvblxuICAgICAgICAgICAgLy8gd2l0aCBzdWNoIHNpZ25hdHVyZSB3YXMgZXhwb3J0ZWQsIHRoaXMgY2FsbCBkb2VzIG5vdCBuZWVkXG4gICAgICAgICAgICAvLyB0byBiZSBlbWl0dGVkIChhbmQgd291bGQgY29uZnVzZSBDbG9zdXJlKVxuICAgICAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnVuYykoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW55IGZ1bmN0aW9uIHdpdGggc2lnbmF0dXJlICd2aScgd2FzIGV4cG9ydGVkLCBydW5cbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFjayB3aXRoIHRoYXQgc2lnbmF0dXJlLlxuICAgICAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnVuYykoY2FsbGJhY2suYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnVuYyhjYWxsYmFjay5hcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjay5hcmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTdGFja1NhdmUoZikge1xuICAgICAgdmFyIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgICB2YXIgcmV0ID0gZigpO1xuICAgICAgc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICBmdW5jdGlvbiBkZW1hbmdsZShmdW5jKSB7XG4gICAgICB3YXJuT25jZSgnd2FybmluZzogYnVpbGQgd2l0aCAgLXMgREVNQU5HTEVfU1VQUE9SVD0xICB0byBsaW5rIGluIGxpYmN4eGFiaSBkZW1hbmdsaW5nJyk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gZGVtYW5nbGVBbGwodGV4dCkge1xuICAgICAgdmFyIHJlZ2V4ID1cbiAgICAgICAgL1xcYl9aW1xcd1xcZF9dKy9nO1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleCxcbiAgICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7XG4gICAgICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogKHkgKyAnIFsnICsgeCArICddJyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBnZXREeWxpbmtNZXRhZGF0YShiaW5hcnkpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGVuZCA9IDA7XG4gIFxuICAgICAgZnVuY3Rpb24gZ2V0VTgoKSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlbb2Zmc2V0KytdO1xuICAgICAgfVxuICBcbiAgICAgIGZ1bmN0aW9uIGdldExFQigpIHtcbiAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgIHZhciBtdWwgPSAxO1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHZhciBieXRlID0gYmluYXJ5W29mZnNldCsrXTtcbiAgICAgICAgICByZXQgKz0gKChieXRlICYgMHg3ZikgKiBtdWwpO1xuICAgICAgICAgIG11bCAqPSAweDgwO1xuICAgICAgICAgIGlmICghKGJ5dGUgJiAweDgwKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgXG4gICAgICBmdW5jdGlvbiBnZXRTdHJpbmcoKSB7XG4gICAgICAgIHZhciBsZW4gPSBnZXRMRUIoKTtcbiAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKGJpbmFyeSwgb2Zmc2V0IC0gbGVuLCBsZW4pO1xuICAgICAgfVxuICBcbiAgICAgIC8qKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgKi9cbiAgICAgIGZ1bmN0aW9uIGZhaWxJZihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBuYW1lID0gJ2R5bGluay4wJztcbiAgICAgIGlmIChiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpIHtcbiAgICAgICAgdmFyIGR5bGlua1NlY3Rpb24gPSBXZWJBc3NlbWJseS5Nb2R1bGUuY3VzdG9tU2VjdGlvbnMoYmluYXJ5LCBuYW1lKTtcbiAgICAgICAgaWYgKGR5bGlua1NlY3Rpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbmFtZSA9ICdkeWxpbmsnXG4gICAgICAgICAgZHlsaW5rU2VjdGlvbiA9IFdlYkFzc2VtYmx5Lk1vZHVsZS5jdXN0b21TZWN0aW9ucyhiaW5hcnksIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGZhaWxJZihkeWxpbmtTZWN0aW9uLmxlbmd0aCA9PT0gMCwgJ25lZWQgZHlsaW5rIHNlY3Rpb24nKTtcbiAgICAgICAgYmluYXJ5ID0gbmV3IFVpbnQ4QXJyYXkoZHlsaW5rU2VjdGlvblswXSk7XG4gICAgICAgIGVuZCA9IGJpbmFyeS5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkobmV3IFVpbnQ4QXJyYXkoYmluYXJ5LnN1YmFycmF5KDAsIDI0KSkuYnVmZmVyKTtcbiAgICAgICAgdmFyIG1hZ2ljTnVtYmVyRm91bmQgPSBpbnQzMlZpZXdbMF0gPT0gMHg2ZDczNjEwMDtcbiAgICAgICAgZmFpbElmKCFtYWdpY051bWJlckZvdW5kLCAnbmVlZCB0byBzZWUgd2FzbSBtYWdpYyBudW1iZXInKTsgLy8gXFwwYXNtXG4gICAgICAgIC8vIHdlIHNob3VsZCBzZWUgdGhlIGR5bGluayBjdXN0b20gc2VjdGlvbiByaWdodCBhZnRlciB0aGUgbWFnaWMgbnVtYmVyIGFuZCB3YXNtIHZlcnNpb25cbiAgICAgICAgZmFpbElmKGJpbmFyeVs4XSAhPT0gMCwgJ25lZWQgdGhlIGR5bGluayBzZWN0aW9uIHRvIGJlIGZpcnN0JylcbiAgICAgICAgb2Zmc2V0ID0gOTtcbiAgICAgICAgdmFyIHNlY3Rpb25fc2l6ZSA9IGdldExFQigpOyAvL3NlY3Rpb24gc2l6ZVxuICAgICAgICBlbmQgPSBvZmZzZXQgKyBzZWN0aW9uX3NpemU7XG4gICAgICAgIG5hbWUgPSBnZXRTdHJpbmcoKTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgY3VzdG9tU2VjdGlvbiA9IHsgbmVlZGVkRHlubGliczogW10sIHRsc0V4cG9ydHM6IHt9IH07XG4gICAgICBpZiAobmFtZSA9PSAnZHlsaW5rJykge1xuICAgICAgICBjdXN0b21TZWN0aW9uLm1lbW9yeVNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgY3VzdG9tU2VjdGlvbi5tZW1vcnlBbGlnbiA9IGdldExFQigpO1xuICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlU2l6ZSA9IGdldExFQigpO1xuICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgLy8gc2hhcmVkIGxpYnJhcmllcyB0aGlzIG1vZHVsZSBuZWVkcy4gV2UgbmVlZCB0byBsb2FkIHRoZW0gZmlyc3QsIHNvIHRoYXRcbiAgICAgICAgLy8gY3VycmVudCBtb2R1bGUgY291bGQgcmVzb2x2ZSBpdHMgaW1wb3J0cy4gKHNlZSB0b29scy9zaGFyZWQucHlcbiAgICAgICAgLy8gV2ViQXNzZW1ibHkubWFrZV9zaGFyZWRfbGlicmFyeSgpIGZvciBcImR5bGlua1wiIHNlY3Rpb24gZXh0ZW5zaW9uIGZvcm1hdClcbiAgICAgICAgdmFyIG5lZWRlZER5bmxpYnNDb3VudCA9IGdldExFQigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lZWRlZER5bmxpYnNDb3VudDsgKytpKSB7XG4gICAgICAgICAgdmFyIGxpYm5hbWUgPSBnZXRTdHJpbmcoKTtcbiAgICAgICAgICBjdXN0b21TZWN0aW9uLm5lZWRlZER5bmxpYnMucHVzaChsaWJuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbElmKG5hbWUgIT09ICdkeWxpbmsuMCcpO1xuICAgICAgICB2YXIgV0FTTV9EWUxJTktfTUVNX0lORk8gPSAweDE7XG4gICAgICAgIHZhciBXQVNNX0RZTElOS19ORUVERUQgPSAweDI7XG4gICAgICAgIHZhciBXQVNNX0RZTElOS19FWFBPUlRfSU5GTyA9IDB4MztcbiAgICAgICAgdmFyIFdBU01fU1lNQk9MX1RMUyA9IDB4MTAwO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIHN1YnNlY3Rpb25UeXBlID0gZ2V0VTgoKTtcbiAgICAgICAgICB2YXIgc3Vic2VjdGlvblNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgICBpZiAoc3Vic2VjdGlvblR5cGUgPT09IFdBU01fRFlMSU5LX01FTV9JTkZPKSB7XG4gICAgICAgICAgICBjdXN0b21TZWN0aW9uLm1lbW9yeVNpemUgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGN1c3RvbVNlY3Rpb24ubWVtb3J5QWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGN1c3RvbVNlY3Rpb24udGFibGVTaXplID0gZ2V0TEVCKCk7XG4gICAgICAgICAgICBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24gPSBnZXRMRUIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1YnNlY3Rpb25UeXBlID09PSBXQVNNX0RZTElOS19ORUVERUQpIHtcbiAgICAgICAgICAgIHZhciBuZWVkZWREeW5saWJzQ291bnQgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVlZGVkRHlubGlic0NvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgbGlibmFtZSA9IGdldFN0cmluZygpO1xuICAgICAgICAgICAgICBjdXN0b21TZWN0aW9uLm5lZWRlZER5bmxpYnMucHVzaChsaWJuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN1YnNlY3Rpb25UeXBlID09PSBXQVNNX0RZTElOS19FWFBPUlRfSU5GTykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gZ2V0TEVCKCk7XG4gICAgICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgICAgICB2YXIgc3ltbmFtZSA9IGdldFN0cmluZygpO1xuICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRMRUIoKTtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzICYgV0FTTV9TWU1CT0xfVExTKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tU2VjdGlvbi50bHNFeHBvcnRzW3N5bW5hbWVdID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIoJ3Vua25vd24gZHlsaW5rLjAgc3Vic2VjdGlvbjogJyArIHN1YnNlY3Rpb25UeXBlKVxuICAgICAgICAgICAgLy8gdW5rbm93biBzdWJzZWN0aW9uXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3Vic2VjdGlvblNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHRhYmxlQWxpZ24gPSBNYXRoLnBvdygyLCBjdXN0b21TZWN0aW9uLnRhYmxlQWxpZ24pO1xuICAgICAgYXNzZXJ0KHRhYmxlQWxpZ24gPT09IDEsICdpbnZhbGlkIHRhYmxlQWxpZ24gJyArIHRhYmxlQWxpZ24pO1xuICAgICAgYXNzZXJ0KG9mZnNldCA9PSBlbmQpO1xuICBcbiAgICAgIHJldHVybiBjdXN0b21TZWN0aW9uO1xuICAgIH1cblxuICB2YXIgd2FzbVRhYmxlTWlycm9yID0gW107XG4gIGZ1bmN0aW9uIGdldFdhc21UYWJsZUVudHJ5KGZ1bmNQdHIpIHtcbiAgICAgIHZhciBmdW5jID0gd2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdO1xuICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIGlmIChmdW5jUHRyID49IHdhc21UYWJsZU1pcnJvci5sZW5ndGgpIHdhc21UYWJsZU1pcnJvci5sZW5ndGggPSBmdW5jUHRyICsgMTtcbiAgICAgICAgd2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdID0gZnVuYyA9IHdhc21UYWJsZS5nZXQoZnVuY1B0cik7XG4gICAgICB9XG4gICAgICBhc3NlcnQod2FzbVRhYmxlLmdldChmdW5jUHRyKSA9PSBmdW5jLCBcIkphdmFTY3JpcHQtc2lkZSBXYXNtIGZ1bmN0aW9uIHRhYmxlIG1pcnJvciBpcyBvdXQgb2YgZGF0ZSFcIik7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUpIHtcbiAgICAgIC8vIENlcnRhaW4gZXhjZXB0aW9uIHR5cGVzIHdlIGRvIG5vdCB0cmVhdCBhcyBlcnJvcnMgc2luY2UgdGhleSBhcmUgdXNlZCBmb3JcbiAgICAgIC8vIGludGVybmFsIGNvbnRyb2wgZmxvdy5cbiAgICAgIC8vIDEuIEV4aXRTdGF0dXMsIHdoaWNoIGlzIHRocm93biBieSBleGl0KClcbiAgICAgIC8vIDIuIFwidW53aW5kXCIsIHdoaWNoIGlzIHRocm93biBieSBlbXNjcmlwdGVuX3Vud2luZF90b19qc19ldmVudF9sb29wKCkgYW5kIG90aGVyc1xuICAgICAgLy8gICAgdGhhdCB3aXNoIHRvIHJldHVybiB0byBKUyBldmVudCBsb29wLlxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzIHx8IGUgPT0gJ3Vud2luZCcpIHtcbiAgICAgICAgcmV0dXJuIEVYSVRTVEFUVVM7XG4gICAgICB9XG4gICAgICBxdWl0XygxLCBlKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24ganNTdGFja1RyYWNlKCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICBpZiAoIWVycm9yLnN0YWNrKSB7XG4gICAgICAgIC8vIElFMTArIHNwZWNpYWwgY2FzZXM6IEl0IGRvZXMgaGF2ZSBjYWxsc3RhY2sgaW5mbywgYnV0IGl0IGlzIG9ubHkgcG9wdWxhdGVkIGlmIGFuIEVycm9yIG9iamVjdCBpcyB0aHJvd24sXG4gICAgICAgIC8vIHNvIHRyeSB0aGF0IGFzIGEgc3BlY2lhbC1jYXNlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvci5zdGFjaykge1xuICAgICAgICAgIHJldHVybiAnKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3Iuc3RhY2sudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXNtanNNYW5nbGUoeCkge1xuICAgICAgdmFyIHVubWFuZ2xlZFN5bWJvbHMgPSBbJ3N0YWNrQWxsb2MnLCdzdGFja1NhdmUnLCdzdGFja1Jlc3RvcmUnXTtcbiAgICAgIHJldHVybiB4LmluZGV4T2YoJ2R5bkNhbGxfJykgPT0gMCB8fCB1bm1hbmdsZWRTeW1ib2xzLmluY2x1ZGVzKHgpID8geCA6ICdfJyArIHg7XG4gICAgfVxuICBmdW5jdGlvbiBtZXJnZUxpYlN5bWJvbHMoZXhwb3J0cywgbGliTmFtZSkge1xuICAgICAgLy8gYWRkIHN5bWJvbHMgaW50byBnbG9iYWwgbmFtZXNwYWNlIFRPRE86IHdlYWsgbGlua2luZyBldGMuXG4gICAgICBmb3IgKHZhciBzeW0gaW4gZXhwb3J0cykge1xuICAgICAgICBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoc3ltKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBXaGVuIFJUTERfR0xPQkFMIGlzIGVuYWJsZSwgdGhlIHN5bWJvbHMgZGVmaW5lZCBieSB0aGlzIHNoYXJlZCBvYmplY3Qgd2lsbCBiZSBtYWRlXG4gICAgICAgIC8vIGF2YWlsYWJsZSBmb3Igc3ltYm9sIHJlc29sdXRpb24gb2Ygc3Vic2VxdWVudGx5IGxvYWRlZCBzaGFyZWQgb2JqZWN0cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvcHkgdGhlIHN5bWJvbHMgKHdoaWNoIGluY2x1ZGUgbWV0aG9kcyBhbmQgdmFyaWFibGVzKSBmcm9tIFNJREVfTU9EVUxFIHRvIE1BSU5fTU9EVUxFLlxuICBcbiAgICAgICAgaWYgKCFhc21MaWJyYXJ5QXJnLmhhc093blByb3BlcnR5KHN5bSkpIHtcbiAgICAgICAgICBhc21MaWJyYXJ5QXJnW3N5bV0gPSBleHBvcnRzW3N5bV07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIEV4cG9ydCBuYXRpdmUgZXhwb3J0IG9uIHRoZSBNb2R1bGUgb2JqZWN0LlxuICAgICAgICAvLyBUT0RPKHNiYyk6IERvIGFsbCB1c2VycyB3YW50IHRoaXM/ICBTaG91bGQgd2Ugc2tpcCB0aGlzIGJ5IGRlZmF1bHQ/XG4gICAgICAgIHZhciBtb2R1bGVfc3ltID0gYXNtanNNYW5nbGUoc3ltKTtcbiAgICAgICAgaWYgKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobW9kdWxlX3N5bSkpIHtcbiAgICAgICAgICBNb2R1bGVbbW9kdWxlX3N5bV0gPSBleHBvcnRzW3N5bV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgdmFyIExEU08gPSB7bG9hZGVkTGlic0J5TmFtZTp7fSxsb2FkZWRMaWJzQnlIYW5kbGU6e319O1xuICBcbiAgZnVuY3Rpb24gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncykge1xuICAgICAgYXNzZXJ0KCgnZHluQ2FsbF8nICsgc2lnKSBpbiBNb2R1bGUsICdiYWQgZnVuY3Rpb24gcG9pbnRlciB0eXBlIC0gbm8gdGFibGUgZm9yIHNpZyBcXCcnICsgc2lnICsgJ1xcJycpO1xuICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gaiAoNjQtYml0IGludGVnZXIpIG11c3QgYmUgcGFzc2VkIGluIGFzIHR3byBudW1iZXJzIFtsb3cgMzIsIGhpZ2ggMzJdLlxuICAgICAgICBhc3NlcnQoYXJncy5sZW5ndGggPT09IHNpZy5zdWJzdHJpbmcoMSkucmVwbGFjZSgvai9nLCAnLS0nKS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHNpZy5sZW5ndGggPT0gMSk7XG4gICAgICB9XG4gICAgICB2YXIgZiA9IE1vZHVsZVtcImR5bkNhbGxfXCIgKyBzaWddO1xuICAgICAgcmV0dXJuIGFyZ3MgJiYgYXJncy5sZW5ndGggPyBmLmFwcGx5KG51bGwsIFtwdHJdLmNvbmNhdChhcmdzKSkgOiBmLmNhbGwobnVsbCwgcHRyKTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge09iamVjdD19IGFyZ3MgKi9cbiAgZnVuY3Rpb24gZHluQ2FsbChzaWcsIHB0ciwgYXJncykge1xuICAgICAgLy8gV2l0aG91dCBXQVNNX0JJR0lOVCBzdXBwb3J0IHdlIGNhbm5vdCBkaXJlY3RseSBjYWxsIGZ1bmN0aW9uIHdpdGggaTY0IGFzXG4gICAgICAvLyBwYXJ0IG9mIHRoaWVyIHNpZ25hdHVyZSwgc28gd2UgcmVseSB0aGUgZHluQ2FsbCBmdW5jdGlvbnMgZ2VuZXJhdGVkIGJ5XG4gICAgICAvLyB3YXNtLWVtc2NyaXB0ZW4tZmluYWxpemVcbiAgICAgIGlmIChzaWcuaW5jbHVkZXMoJ2onKSkge1xuICAgICAgICByZXR1cm4gZHluQ2FsbExlZ2FjeShzaWcsIHB0ciwgYXJncyk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoZ2V0V2FzbVRhYmxlRW50cnkocHRyKSwgJ21pc3NpbmcgdGFibGUgZW50cnkgaW4gZHluQ2FsbDogJyArIHB0cik7XG4gICAgICByZXR1cm4gZ2V0V2FzbVRhYmxlRW50cnkocHRyKS5hcHBseShudWxsLCBhcmdzKVxuICAgIH1cbiAgZnVuY3Rpb24gY3JlYXRlSW52b2tlRnVuY3Rpb24oc2lnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBkeW5DYWxsKHNpZywgYXJndW1lbnRzWzBdLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICAgICAgICAvLyBFeGNlcHRpb25zIHRocm93biBmcm9tIEMrKyBleGNlcHRpb24gd2lsbCBiZSBpbnRlZ2VyIG51bWJlcnMuXG4gICAgICAgICAgLy8gbG9uZ2ptcCB3aWxsIHRocm93IHRoZSBudW1iZXIgSW5maW5pdHkuIFJlLXRocm93IG90aGVyIHR5cGVzIG9mXG4gICAgICAgICAgLy8gZXhjZXB0aW9ucyB1c2luZyBhIGNvbXBhY3QgYW5kIGZhc3QgY2hlY2suXG4gICAgICAgICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICAgICAgICBfc2V0VGhyZXcoMSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICB2YXIgX19faGVhcF9iYXNlID0gNjI4NDc4NDtcbiAgZnVuY3Rpb24gZ2V0TWVtb3J5KHNpemUpIHtcbiAgICAgIC8vIEFmdGVyIHRoZSBydW50aW1lIGlzIGluaXRpYWxpemVkLCB3ZSBtdXN0IG9ubHkgdXNlIHNicmsoKSBub3JtYWxseS5cbiAgICAgIGlmIChydW50aW1lSW5pdGlhbGl6ZWQpXG4gICAgICAgIHJldHVybiBfbWFsbG9jKHNpemUpO1xuICAgICAgdmFyIHJldCA9IF9fX2hlYXBfYmFzZTtcbiAgICAgIHZhciBlbmQgPSAocmV0ICsgc2l6ZSArIDE1KSAmIC0xNjtcbiAgICAgIGFzc2VydChlbmQgPD0gSEVBUDgubGVuZ3RoLCAnZmFpbHVyZSB0byBnZXRNZW1vcnkgLSBtZW1vcnkgZ3Jvd3RoIGV0Yy4gaXMgbm90IHN1cHBvcnRlZCB0aGVyZSwgY2FsbCBtYWxsb2Mvc2JyayBkaXJlY3RseSBvciBpbmNyZWFzZSBJTklUSUFMX01FTU9SWScpO1xuICAgICAgX19faGVhcF9iYXNlID0gZW5kO1xuICAgICAgR09UWydfX2hlYXBfYmFzZSddLnZhbHVlID0gZW5kO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBpc0ludGVybmFsU3ltKHN5bU5hbWUpIHtcbiAgICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gbWFyayB0aGVzZSBpbiB0aGUgYmluYXJ5IG9yIGF2b2lkIGV4cG9ydGluZyB0aGVtLlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ19fY3BwX2V4Y2VwdGlvbicsXG4gICAgICAgICdfX2NfbG9uZ2ptcCcsXG4gICAgICAgICdfX3dhc21fYXBwbHlfZGF0YV9yZWxvY3MnLFxuICAgICAgICAnX19kc29faGFuZGxlJyxcbiAgICAgICAgJ19fdGxzX3NpemUnLFxuICAgICAgICAnX190bHNfYWxpZ24nLFxuICAgICAgICAnX19zZXRfc3RhY2tfbGltaXRzJyxcbiAgICAgICAgJ2Vtc2NyaXB0ZW5fdGxzX2luaXQnLFxuICAgICAgICAnX193YXNtX2luaXRfdGxzJyxcbiAgICAgICAgJ19fd2FzbV9jYWxsX2N0b3JzJyxcbiAgICAgIF0uaW5jbHVkZXMoc3ltTmFtZSlcbiAgICAgIDtcbiAgICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUdPVChleHBvcnRzLCByZXBsYWNlKSB7XG4gICAgICBmb3IgKHZhciBzeW1OYW1lIGluIGV4cG9ydHMpIHtcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxTeW0oc3ltTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0c1tzeW1OYW1lXTtcbiAgICAgICAgaWYgKHN5bU5hbWUuc3RhcnRzV2l0aCgnb3JpZyQnKSkge1xuICAgICAgICAgIHN5bU5hbWUgPSBzeW1OYW1lLnNwbGl0KCckJylbMV07XG4gICAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICghR09UW3N5bU5hbWVdKSB7XG4gICAgICAgICAgR09UW3N5bU5hbWVdID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBsYWNlIHx8IEdPVFtzeW1OYW1lXS52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBhZGRGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIEdPVFtzeW1OYW1lXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnIoXCJ1bmhhbmRsZWQgZXhwb3J0IHR5cGUgZm9yIGBcIiArIHN5bU5hbWUgKyBcImA6IFwiICsgKHR5cGVvZiB2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IHJlcGxhY2UgKi9cbiAgZnVuY3Rpb24gcmVsb2NhdGVFeHBvcnRzKGV4cG9ydHMsIG1lbW9yeUJhc2UsIHJlcGxhY2UpIHtcbiAgICAgIHZhciByZWxvY2F0ZWQgPSB7fTtcbiAgXG4gICAgICBmb3IgKHZhciBlIGluIGV4cG9ydHMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0c1tlXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGEgYnJlYWtpbmcgY2hhbmdlIGluIHRoZSB3YXNtIHNwZWMsIGdsb2JhbHMgYXJlIG5vdyBvYmplY3RzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L211dGFibGUtZ2xvYmFsL2lzc3Vlcy8xXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgKz0gbWVtb3J5QmFzZTtcbiAgICAgICAgfVxuICAgICAgICByZWxvY2F0ZWRbZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUdPVChyZWxvY2F0ZWQsIHJlcGxhY2UpO1xuICAgICAgcmV0dXJuIHJlbG9jYXRlZDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiByZXNvbHZlR2xvYmFsU3ltYm9sKHN5bU5hbWUsIGRpcmVjdCkge1xuICAgICAgdmFyIHN5bTtcbiAgICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgLy8gRmlyc3QgbG9vayBmb3IgdGhlIG9yaWckIHN5bWJvbCB3aGljaCBpcyB0aGUgc3ltYm9scyB3aXRob3V0XG4gICAgICAgIC8vIGFueSBsZWdhbGl6YXRpb24gcGVyZm9ybWVkLlxuICAgICAgICBzeW0gPSBhc21MaWJyYXJ5QXJnWydvcmlnJCcgKyBzeW1OYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICghc3ltKSB7XG4gICAgICAgIHN5bSA9IGFzbUxpYnJhcnlBcmdbc3ltTmFtZV07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzeW1ib2wgb24gdGhlIE1vZHVsZSBvYmplY3QuICBUaGlzIGlzIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdG8gZHluYW1pY2FsbHkgYWNjZXNzIEpTIGxpYnJhcnkgc3ltYm9scyB0aGF0IHdlcmUgbm90XG4gICAgICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBtYWluIG1vZHVsZSAoYW5kIHRoZXJlZm9yZSBub3QgcGFydCBvZiB0aGVcbiAgICAgIC8vIGluaXRpYWwgc2V0IG9mIHN5bWJvbHMgaW5jbHVkZWQgaW4gYXNtTGlicmFyeUFyZyB3aGVuIGl0XG4gICAgICAvLyB3YXMgZGVjbGFyZWQuXG4gICAgICBpZiAoIXN5bSkge1xuICAgICAgICBzeW0gPSBNb2R1bGVbYXNtanNNYW5nbGUoc3ltTmFtZSldO1xuICAgICAgfVxuICBcbiAgICAgIGlmICghc3ltICYmIHN5bU5hbWUuc3RhcnRzV2l0aCgnaW52b2tlXycpKSB7XG4gICAgICAgIHN5bSA9IGNyZWF0ZUludm9rZUZ1bmN0aW9uKHN5bU5hbWUuc3BsaXQoJ18nKVsxXSk7XG4gICAgICB9XG4gIFxuICAgICAgcmV0dXJuIHN5bTtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBhbGlnbm1lbnQpIHtcbiAgICAgIGFzc2VydChhbGlnbm1lbnQsIFwiYWxpZ25tZW50IGFyZ3VtZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gYWxpZ25tZW50KSAqIGFsaWdubWVudDtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiAgICAgIEhFQVBVOC5maWxsKDAsIGFkZHJlc3MsIGFkZHJlc3MgKyBzaXplKTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge251bWJlcj19IGhhbmRsZSAqL1xuICBmdW5jdGlvbiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUoYmluYXJ5LCBmbGFncywgaGFuZGxlKSB7XG4gICAgICB2YXIgbWV0YWRhdGEgPSBnZXREeWxpbmtNZXRhZGF0YShiaW5hcnkpO1xuICAgICAgdmFyIG9yaWdpbmFsVGFibGUgPSB3YXNtVGFibGU7XG4gIFxuICAgICAgLy8gbG9hZE1vZHVsZSBsb2FkcyB0aGUgd2FzbSBtb2R1bGUgYWZ0ZXIgYWxsIGl0cyBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIGxvYWRlZC5cbiAgICAgIC8vIGNhbiBiZSBjYWxsZWQgYm90aCBzeW5jL2FzeW5jLlxuICAgICAgZnVuY3Rpb24gbG9hZE1vZHVsZSgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRocmVhZCB0byBsb2FkIGEgZ2l2ZW4gbW9kdWxlIG5lZWRzIHRvIGFsbG9jYXRlIHRoZSBzdGF0aWNcbiAgICAgICAgLy8gdGFibGUgYW5kIG1lbW9yeSByZWdpb25zLiAgTGF0ZXIgdGhyZWFkcyByZS11c2UgdGhlIHNhbWUgdGFibGUgcmVnaW9uXG4gICAgICAgIC8vIGFuZCBjYW4gaWdub3JlIHRoZSBtZW1vcnkgcmVnaW9uIChzaW5jZSBtZW1vcnkgaXMgc2hhcmVkIGJldHdlZW5cbiAgICAgICAgLy8gdGhyZWFkcyBhbHJlYWR5KS5cbiAgICAgICAgdmFyIG5lZWRzQWxsb2NhdGlvbiA9ICFoYW5kbGUgfHwgIUhFQVA4WygoKGhhbmRsZSkrKDI0KSk+PjApXTtcbiAgICAgICAgaWYgKG5lZWRzQWxsb2NhdGlvbikge1xuICAgICAgICAgIC8vIGFsaWdubWVudHMgYXJlIHBvd2VycyBvZiAyXG4gICAgICAgICAgdmFyIG1lbUFsaWduID0gTWF0aC5wb3coMiwgbWV0YWRhdGEubWVtb3J5QWxpZ24pO1xuICAgICAgICAgIC8vIGZpbmFsaXplIGFsaWdubWVudHMgYW5kIHZlcmlmeSB0aGVtXG4gICAgICAgICAgbWVtQWxpZ24gPSBNYXRoLm1heChtZW1BbGlnbiwgU1RBQ0tfQUxJR04pOyAvLyB3ZSBhdCBsZWFzdCBuZWVkIHN0YWNrIGFsaWdubWVudFxuICAgICAgICAgIC8vIHByZXBhcmUgbWVtb3J5XG4gICAgICAgICAgdmFyIG1lbW9yeUJhc2UgPSBtZXRhZGF0YS5tZW1vcnlTaXplID8gYWxpZ25NZW1vcnkoZ2V0TWVtb3J5KG1ldGFkYXRhLm1lbW9yeVNpemUgKyBtZW1BbGlnbiksIG1lbUFsaWduKSA6IDA7IC8vIFRPRE86IGFkZCB0byBjbGVhbnVwc1xuICAgICAgICAgIHZhciB0YWJsZUJhc2UgPSBtZXRhZGF0YS50YWJsZVNpemUgPyB3YXNtVGFibGUubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICBIRUFQOFsoKChoYW5kbGUpKygyNCkpPj4wKV0gPSAxO1xuICAgICAgICAgICAgSEVBUDMyWygoKGhhbmRsZSkrKDI4KSk+PjIpXSA9IG1lbW9yeUJhc2U7XG4gICAgICAgICAgICBIRUFQMzJbKCgoaGFuZGxlKSsoMzIpKT4+MildID0gbWV0YWRhdGEubWVtb3J5U2l6ZTtcbiAgICAgICAgICAgIEhFQVAzMlsoKChoYW5kbGUpKygzNikpPj4yKV0gPSB0YWJsZUJhc2U7XG4gICAgICAgICAgICBIRUFQMzJbKCgoaGFuZGxlKSsoNDApKT4+MildID0gbWV0YWRhdGEudGFibGVTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZW1vcnlCYXNlID0gSEVBUDMyWygoKGhhbmRsZSkrKDI4KSk+PjIpXTtcbiAgICAgICAgICB0YWJsZUJhc2UgPSBIRUFQMzJbKCgoaGFuZGxlKSsoMzYpKT4+MildO1xuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgdGFibGVHcm93dGhOZWVkZWQgPSB0YWJsZUJhc2UgKyBtZXRhZGF0YS50YWJsZVNpemUgLSB3YXNtVGFibGUubGVuZ3RoO1xuICAgICAgICBpZiAodGFibGVHcm93dGhOZWVkZWQgPiAwKSB7XG4gICAgICAgICAgd2FzbVRhYmxlLmdyb3codGFibGVHcm93dGhOZWVkZWQpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBleHBvcnQgbWFwIHRoYXQgd2UgdWx0aW1hdGVseSByZXR1cm4uICBXZSBkZWNsYXJlIGl0IGhlcmVcbiAgICAgICAgLy8gc28gaXQgY2FuIGJlIHVzZWQgd2l0aGluIHJlc29sdmVTeW1ib2wuICBXZSByZXNvbHZlIHN5bWJvbHMgYWdhaW5zdFxuICAgICAgICAvLyB0aGlzIGxvY2FsIHN5bWJvbCBtYXAgaW4gdGhlIGNhc2UgdGhlcmUgdGhleSBhcmUgbm90IHByZXNlbnQgb24gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBNb2R1bGUgb2JqZWN0LiAgV2UgbmVlZCB0aGlzIGZhbGxiYWNrIGJlY2F1c2U6XG4gICAgICAgIC8vIGEpIE1vZHVsZXMgc29tZXRpbWUgbmVlZCB0byBpbXBvcnQgdGhlaXIgb3duIHN5bWJvbHNcbiAgICAgICAgLy8gYikgU3ltYm9scyBmcm9tIHNpZGUgbW9kdWxlcyBhcmUgbm90IGFsd2F5cyBhZGRlZCB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgdmFyIG1vZHVsZUV4cG9ydHM7XG4gIFxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlU3ltYm9sKHN5bSkge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVHbG9iYWxTeW1ib2woc3ltLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBtb2R1bGVFeHBvcnRzW3N5bV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydChyZXNvbHZlZCwgJ3VuZGVmaW5lZCBzeW1ib2wgYCcgKyBzeW0gKyAnYC4gcGVyaGFwcyBhIHNpZGUgbW9kdWxlIHdhcyBub3QgbGlua2VkIGluPyBpZiB0aGlzIGdsb2JhbCB3YXMgZXhwZWN0ZWQgdG8gYXJyaXZlIGZyb20gYSBzeXN0ZW0gbGlicmFyeSwgdHJ5IHRvIGJ1aWxkIHRoZSBNQUlOX01PRFVMRSB3aXRoIEVNQ0NfRk9SQ0VfU1RETElCUz0xIGluIHRoZSBlbnZpcm9ubWVudCcpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gVE9ETyBraWxsIOKGk+KGk+KGkyAoZXhjZXB0IFwic3ltYm9scyBsb2NhbCB0byB0aGlzIG1vZHVsZVwiLCBpdCB3aWxsIGxpa2VseSBiZVxuICAgICAgICAvLyBub3QgbmVlZGVkIGlmIHdlIHJlcXVpcmUgdGhhdCBpZiBBIHdhbnRzIHN5bWJvbHMgZnJvbSBCIGl0IGhhcyB0byBsaW5rXG4gICAgICAgIC8vIHRvIEIgZXhwbGljaXRseTogc2ltaWxhcmx5IHRvIC1XbCwtLW5vLXVuZGVmaW5lZClcbiAgICAgICAgLy9cbiAgICAgICAgLy8gd2FzbSBkeW5hbWljIGxpYnJhcmllcyBhcmUgcHVyZSB3YXNtLCBzbyB0aGV5IGNhbm5vdCBhc3Npc3QgaW5cbiAgICAgICAgLy8gdGhlaXIgb3duIGxvYWRpbmcuIFdoZW4gc2lkZSBtb2R1bGUgQSB3YW50cyB0byBpbXBvcnQgc29tZXRoaW5nXG4gICAgICAgIC8vIHByb3ZpZGVkIGJ5IGEgc2lkZSBtb2R1bGUgQiB0aGF0IGlzIGxvYWRlZCBsYXRlciwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYSBsYXllciBvZiBpbmRpcmVjdGlvbiwgYnV0IHdvcnNlLCB3ZSBjYW4ndCBldmVuIHRlbGwgd2hhdFxuICAgICAgICAvLyB0byBhZGQgdGhlIGluZGlyZWN0aW9uIGZvciwgd2l0aG91dCBpbnNwZWN0aW5nIHdoYXQgQSdzIGltcG9ydHNcbiAgICAgICAgLy8gYXJlLiBUbyBkbyB0aGF0IGhlcmUsIHdlIHVzZSBhIEpTIHByb3h5IChhbm90aGVyIG9wdGlvbiB3b3VsZFxuICAgICAgICAvLyBiZSB0byBpbnNwZWN0IHRoZSBiaW5hcnkgZGlyZWN0bHkpLlxuICAgICAgICB2YXIgcHJveHlIYW5kbGVyID0ge1xuICAgICAgICAgICdnZXQnOiBmdW5jdGlvbihzdHVicywgcHJvcCkge1xuICAgICAgICAgICAgLy8gc3ltYm9scyB0aGF0IHNob3VsZCBiZSBsb2NhbCB0byB0aGlzIG1vZHVsZVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ19fbWVtb3J5X2Jhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vcnlCYXNlO1xuICAgICAgICAgICAgICBjYXNlICdfX3RhYmxlX2Jhc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZUJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBhc21MaWJyYXJ5QXJnKSB7XG4gICAgICAgICAgICAgIC8vIE5vIHN0dWIgbmVlZGVkLCBzeW1ib2wgYWxyZWFkeSBleGlzdHMgaW4gc3ltYm9sIHRhYmxlXG4gICAgICAgICAgICAgIHJldHVybiBhc21MaWJyYXJ5QXJnW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgc3R1YiBmdW5jdGlvbiB0aGF0IHdpbGwgcmVzb2x2ZSB0aGUgc3ltYm9sXG4gICAgICAgICAgICAvLyB3aGVuIGZpcnN0IGNhbGxlZC5cbiAgICAgICAgICAgIGlmICghKHByb3AgaW4gc3R1YnMpKSB7XG4gICAgICAgICAgICAgIHZhciByZXNvbHZlZDtcbiAgICAgICAgICAgICAgc3R1YnNbcHJvcF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKSByZXNvbHZlZCA9IHJlc29sdmVTeW1ib2wocHJvcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R1YnNbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcHJveHkgPSBuZXcgUHJveHkoe30sIHByb3h5SGFuZGxlcik7XG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgICdHT1QubWVtJzogbmV3IFByb3h5KHt9LCBHT1RIYW5kbGVyKSxcbiAgICAgICAgICAnR09ULmZ1bmMnOiBuZXcgUHJveHkoe30sIEdPVEhhbmRsZXIpLFxuICAgICAgICAgICdlbnYnOiBwcm94eSxcbiAgICAgICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiBwcm94eSxcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIGZ1bmN0aW9uIHBvc3RJbnN0YW50aWF0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgICAgLy9GSVhNRSA6IFNldCB0aGlzIGluZm9ybWF0aW9uIGluIGN1c3RvbSBzZWN0aW9uXG4gICAgICAgICAgY29uc3QgZmlsdGVyX2VudHJ5ID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykuZmlsdGVyKGZuID0+IGZuLmVuZHNXaXRoKFwiX3JlZ2lzdGVyXCIpKTtcbiAgICAgICAgICBmaWx0ZXJfZW50cmllcyA9IGZpbHRlcl9lbnRyaWVzLmNvbmNhdChmaWx0ZXJfZW50cnkpO1xuICAgICAgICAgIGNvbnN0IG1vZHVsZV9lbnRyeSA9IE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpLmZpbHRlcihmbiA9PiBmbi5zdGFydHNXaXRoKFwiZ2ZfcmVnaXN0ZXJfbW9kdWxlX1wiKSk7XG4gICAgICAgICAgbW9kdWxlX2VudHJpZXMgPSBtb2R1bGVfZW50cmllcy5jb25jYXQobW9kdWxlX2VudHJ5KTtcbiAgICAgICAgICAvLyB0aGUgdGFibGUgc2hvdWxkIGJlIHVuY2hhbmdlZFxuICAgICAgICAgIGFzc2VydCh3YXNtVGFibGUgPT09IG9yaWdpbmFsVGFibGUpO1xuICAgICAgICAgIC8vIGFkZCBuZXcgZW50cmllcyB0byBmdW5jdGlvbnNJblRhYmxlTWFwXG4gICAgICAgICAgdXBkYXRlVGFibGVNYXAodGFibGVCYXNlLCBtZXRhZGF0YS50YWJsZVNpemUpO1xuICAgICAgICAgIG1vZHVsZUV4cG9ydHMgPSByZWxvY2F0ZUV4cG9ydHMoaW5zdGFuY2UuZXhwb3J0cywgbWVtb3J5QmFzZSk7XG4gICAgICAgICAgaWYgKCFmbGFncy5hbGxvd1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVwb3J0VW5kZWZpbmVkU3ltYm9scygpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgbW9kdWxlXG4gICAgICAgICAgICB2YXIgaW5pdCA9IG1vZHVsZUV4cG9ydHNbJ19fd2FzbV9jYWxsX2N0b3JzJ107XG4gICAgICAgICAgICBpZiAoaW5pdCkge1xuICAgICAgICAgICAgICBpZiAocnVudGltZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFyZW4ndCByZWFkeSB0byBydW4gY29tcGlsZWQgY29kZSB5ZXRcbiAgICAgICAgICAgICAgICBfX0FUSU5JVF9fLnB1c2goaW5pdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGZsYWdzLmxvYWRBc3luYykge1xuICAgICAgICAgIGlmIChiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShiaW5hcnksIGluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwb3N0SW5zdGFudGlhdGlvbihpbnN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbmZvKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RJbnN0YW50aWF0aW9uKHJlc3VsdC5pbnN0YW5jZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb2R1bGUgPSBiaW5hcnkgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5Nb2R1bGUgPyBiaW5hcnkgOiBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGJpbmFyeSk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShtb2R1bGUsIGluZm8pO1xuICAgICAgICByZXR1cm4gcG9zdEluc3RhbnRpYXRpb24oaW5zdGFuY2UpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIG5vdyBsb2FkIG5lZWRlZCBsaWJyYXJpZXMgYW5kIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAgICAgaWYgKGZsYWdzLmxvYWRBc3luYykge1xuICAgICAgICByZXR1cm4gbWV0YWRhdGEubmVlZGVkRHlubGlicy5yZWR1Y2UoZnVuY3Rpb24oY2hhaW4sIGR5bk5lZWRlZCkge1xuICAgICAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShkeW5OZWVkZWQsIGZsYWdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRNb2R1bGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gIFxuICAgICAgbWV0YWRhdGEubmVlZGVkRHlubGlicy5mb3JFYWNoKGZ1bmN0aW9uKGR5bk5lZWRlZCkge1xuICAgICAgICBsb2FkRHluYW1pY0xpYnJhcnkoZHluTmVlZGVkLCBmbGFncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsb2FkTW9kdWxlKCk7XG4gICAgfVxuICAvKiogQHBhcmFtIHtudW1iZXI9fSBoYW5kbGUgKi9cbiAgZnVuY3Rpb24gbG9hZER5bmFtaWNMaWJyYXJ5KGxpYiwgZmxhZ3MsIGhhbmRsZSkge1xuICAgICAgaWYgKGxpYiA9PSAnX19tYWluX18nICYmICFMRFNPLmxvYWRlZExpYnNCeU5hbWVbbGliXSkge1xuICAgICAgICBMRFNPLmxvYWRlZExpYnNCeU5hbWVbbGliXSA9IHtcbiAgICAgICAgICByZWZjb3VudDogSW5maW5pdHksICAgLy8gPSBub2RlbGV0ZVxuICAgICAgICAgIG5hbWU6ICAgICAnX19tYWluX18nLFxuICAgICAgICAgIG1vZHVsZTogICBNb2R1bGVbJ2FzbSddLFxuICAgICAgICAgIGdsb2JhbDogICB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gd2hlbiBsb2FkRHluYW1pY0xpYnJhcnkgZGlkIG5vdCBoYXZlIGZsYWdzLCBsaWJyYXJpZXMgd2VyZSBsb2FkZWRcbiAgICAgIC8vIGdsb2JhbGx5ICYgcGVybWFuZW50bHlcbiAgICAgIGZsYWdzID0gZmxhZ3MgfHwge2dsb2JhbDogdHJ1ZSwgbm9kZWxldGU6IHRydWV9XG4gIFxuICAgICAgdmFyIGRzbyA9IExEU08ubG9hZGVkTGlic0J5TmFtZVtsaWJdO1xuICAgICAgaWYgKGRzbykge1xuICAgICAgICAvLyB0aGUgbGlicmFyeSBpcyBiZWluZyBsb2FkZWQgb3IgaGFzIGJlZW4gbG9hZGVkIGFscmVhZHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGhvd2V2ZXIgaXQgY291bGQgYmUgcHJldmlvdXNseSBsb2FkZWQgb25seSBsb2NhbGx5IGFuZCBpZiB3ZSBnZXRcbiAgICAgICAgLy8gbG9hZCByZXF1ZXN0IHdpdGggZ2xvYmFsPXRydWUgd2UgaGF2ZSB0byBtYWtlIGl0IGdsb2JhbGx5IHZpc2libGUgbm93LlxuICAgICAgICBpZiAoZmxhZ3MuZ2xvYmFsICYmICFkc28uZ2xvYmFsKSB7XG4gICAgICAgICAgZHNvLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgaWYgKGRzby5tb2R1bGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgLy8gXl5eIGlmIG1vZHVsZSBpcyAnbG9hZGluZycgLSBzeW1ib2xzIG1lcmdpbmcgd2lsbCBiZSBldmVudHVhbGx5IGRvbmUgYnkgdGhlIGxvYWRlci5cbiAgICAgICAgICAgIG1lcmdlTGliU3ltYm9scyhkc28ubW9kdWxlLCBsaWIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNhbWUgZm9yIFwibm9kZWxldGVcIlxuICAgICAgICBpZiAoZmxhZ3Mubm9kZWxldGUgJiYgZHNvLnJlZmNvdW50ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgIGRzby5yZWZjb3VudCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGRzby5yZWZjb3VudCsrXG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdID0gZHNvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUodHJ1ZSkgOiB0cnVlO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGFsbG9jYXRlIG5ldyBEU09cbiAgICAgIGRzbyA9IHtcbiAgICAgICAgcmVmY291bnQ6IGZsYWdzLm5vZGVsZXRlID8gSW5maW5pdHkgOiAxLFxuICAgICAgICBuYW1lOiAgICAgbGliLFxuICAgICAgICBtb2R1bGU6ICAgJ2xvYWRpbmcnLFxuICAgICAgICBnbG9iYWw6ICAgZmxhZ3MuZ2xvYmFsLFxuICAgICAgfTtcbiAgICAgIExEU08ubG9hZGVkTGlic0J5TmFtZVtsaWJdID0gZHNvO1xuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdID0gZHNvO1xuICAgICAgfVxuICBcbiAgICAgIC8vIGxpYkRhdGEgPC0gbGliRmlsZVxuICAgICAgZnVuY3Rpb24gbG9hZExpYkRhdGEobGliRmlsZSkge1xuICAgICAgICAvLyBmb3Igd2FzbSwgd2UgY2FuIHVzZSBmZXRjaCBmb3IgYXN5bmMsIGJ1dCBmb3IgZnMgbW9kZSB3ZSBjYW4gb25seSBpbWl0YXRlIGl0XG4gICAgICAgIGlmIChmbGFncy5mcyAmJiBmbGFncy5mcy5maW5kT2JqZWN0KGxpYkZpbGUpKSB7XG4gICAgICAgICAgdmFyIGxpYkRhdGEgPSBmbGFncy5mcy5yZWFkRmlsZShsaWJGaWxlLCB7ZW5jb2Rpbmc6ICdiaW5hcnknfSk7XG4gICAgICAgICAgaWYgKCEobGliRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBsaWJEYXRhID0gbmV3IFVpbnQ4QXJyYXkobGliRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUobGliRGF0YSkgOiBsaWJEYXRhO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoZmxhZ3MubG9hZEFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVhZEFzeW5jKGxpYkZpbGUsIGZ1bmN0aW9uKGRhdGEpIHsgcmVzb2x2ZShuZXcgVWludDhBcnJheShkYXRhKSk7IH0sIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGxvYWQgdGhlIGJpbmFyeSBzeW5jaHJvbm91c2x5XG4gICAgICAgIGlmICghcmVhZEJpbmFyeSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsaWJGaWxlICsgJzogZmlsZSBub3QgZm91bmQsIGFuZCBzeW5jaHJvbm91cyBsb2FkaW5nIG9mIGV4dGVybmFsIGZpbGVzIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZEJpbmFyeShsaWJGaWxlKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBsaWJNb2R1bGUgPC0gbGliXG4gICAgICBmdW5jdGlvbiBnZXRMaWJNb2R1bGUoKSB7XG4gICAgICAgIC8vIGxvb2t1cCBwcmVsb2FkZWQgY2FjaGUgZmlyc3RcbiAgICAgICAgaWYgKE1vZHVsZVsncHJlbG9hZGVkV2FzbSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIE1vZHVsZVsncHJlbG9hZGVkV2FzbSddW2xpYl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBsaWJNb2R1bGUgPSBNb2R1bGVbJ3ByZWxvYWRlZFdhc20nXVtsaWJdO1xuICAgICAgICAgIHJldHVybiBmbGFncy5sb2FkQXN5bmMgPyBQcm9taXNlLnJlc29sdmUobGliTW9kdWxlKSA6IGxpYk1vZHVsZTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gbW9kdWxlIG5vdCBwcmVsb2FkZWQgLSBsb2FkIGxpYiBkYXRhIGFuZCBjcmVhdGUgbmV3IG1vZHVsZSBmcm9tIGl0XG4gICAgICAgIGlmIChmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZExpYkRhdGEobGliKS50aGVuKGZ1bmN0aW9uKGxpYkRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUobGliRGF0YSwgZmxhZ3MsIGhhbmRsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUobG9hZExpYkRhdGEobGliKSwgZmxhZ3MsIGhhbmRsZSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gbW9kdWxlIGZvciBsaWIgaXMgbG9hZGVkIC0gdXBkYXRlIHRoZSBkc28gJiBnbG9iYWwgbmFtZXNwYWNlXG4gICAgICBmdW5jdGlvbiBtb2R1bGVMb2FkZWQobGliTW9kdWxlKSB7XG4gICAgICAgIGlmIChkc28uZ2xvYmFsKSB7XG4gICAgICAgICAgbWVyZ2VMaWJTeW1ib2xzKGxpYk1vZHVsZSwgbGliKTtcbiAgICAgICAgfVxuICAgICAgICBkc28ubW9kdWxlID0gbGliTW9kdWxlO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIGdldExpYk1vZHVsZSgpLnRoZW4oZnVuY3Rpb24obGliTW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlTG9hZGVkKGxpYk1vZHVsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICBcbiAgICAgIG1vZHVsZUxvYWRlZChnZXRMaWJNb2R1bGUoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIFxuICBmdW5jdGlvbiByZXBvcnRVbmRlZmluZWRTeW1ib2xzKCkge1xuICAgICAgZm9yICh2YXIgc3ltTmFtZSBpbiBHT1QpIHtcbiAgICAgICAgaWYgKEdPVFtzeW1OYW1lXS52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZUdsb2JhbFN5bWJvbChzeW1OYW1lLCB0cnVlKVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSwgJ3VuZGVmaW5lZCBzeW1ib2wgYCcgKyBzeW1OYW1lICsgJ2AuIHBlcmhhcHMgYSBzaWRlIG1vZHVsZSB3YXMgbm90IGxpbmtlZCBpbj8gaWYgdGhpcyBnbG9iYWwgd2FzIGV4cGVjdGVkIHRvIGFycml2ZSBmcm9tIGEgc3lzdGVtIGxpYnJhcnksIHRyeSB0byBidWlsZCB0aGUgTUFJTl9NT0RVTEUgd2l0aCBFTUNDX0ZPUkNFX1NURExJQlM9MSBpbiB0aGUgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICAgICAgICBHT1Rbc3ltTmFtZV0udmFsdWUgPSBhZGRGdW5jdGlvbih2YWx1ZSwgdmFsdWUuc2lnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgR09UW3N5bU5hbWVdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGV4cG9ydCB0eXBlIGZvciBgJyArIHN5bU5hbWUgKyAnYDogJyArICh0eXBlb2YgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRfZmlsZV9pbygpe1xuICAgICAgbWVtaW8uZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgeC52YWx1ZSA9IGFkZEZ1bmN0aW9uKHgsIHguc2lnKTtcbiAgICAgIH0pXG4gICAgfVxuXG4gIGZ1bmN0aW9uIHByZWxvYWREeWxpYnMoKSB7XG4gICAgICBpZiAoIWR5bmFtaWNMaWJyYXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlcG9ydFVuZGVmaW5lZFN5bWJvbHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICBcbiAgICAgIC8vIExvYWQgYmluYXJpZXMgYXN5bmNocm9ub3VzbHlcbiAgICAgIGFkZFJ1bkRlcGVuZGVuY3koJ3ByZWxvYWREeWxpYnMnKTtcbiAgICAgIGR5bmFtaWNMaWJyYXJpZXMucmVkdWNlKGZ1bmN0aW9uKGNoYWluLCBsaWIpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShzY3JpcHREaXJlY3RvcnkgKyBsaWIsIHtsb2FkQXN5bmM6IHRydWUsIGdsb2JhbDogdHJ1ZSwgbm9kZWxldGU6IHRydWUsIGFsbG93VW5kZWZpbmVkOiB0cnVlfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHdlIGdvdCB0aGVtIGFsbCwgd29uZGVyZnVsXG4gICAgICAgIHJlcG9ydFVuZGVmaW5lZFN5bWJvbHMoKTtcbiAgICAgICAgYWRkX2ZpbGVfaW8oKTtcbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgncHJlbG9hZER5bGlicycpO1xuICAgICAgfSk7XG4gICAgfVxuXG5cblxuICBmdW5jdGlvbiBzZXRXYXNtVGFibGVFbnRyeShpZHgsIGZ1bmMpIHtcbiAgICAgIHdhc21UYWJsZS5zZXQoaWR4LCBmdW5jKTtcbiAgICAgIHdhc21UYWJsZU1pcnJvcltpZHhdID0gZnVuYztcbiAgICB9XG5cbiAgZnVuY3Rpb24gc3RhY2tUcmFjZSgpIHtcbiAgICAgIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpO1xuICAgICAgaWYgKE1vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10pIGpzICs9ICdcXG4nICsgTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSgpO1xuICAgICAgcmV0dXJuIGRlbWFuZ2xlQWxsKGpzKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX19fYXNzZXJ0X2ZhaWwoY29uZGl0aW9uLCBmaWxlbmFtZSwgbGluZSwgZnVuYykge1xuICAgICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBVVEY4VG9TdHJpbmcoY29uZGl0aW9uKSArICcsIGF0OiAnICsgW2ZpbGVuYW1lID8gVVRGOFRvU3RyaW5nKGZpbGVuYW1lKSA6ICd1bmtub3duIGZpbGVuYW1lJywgbGluZSwgZnVuYyA/IFVURjhUb1N0cmluZyhmdW5jKSA6ICd1bmtub3duIGZ1bmN0aW9uJ10pO1xuICAgIH1cbiAgX19fYXNzZXJ0X2ZhaWwuc2lnID0gJ3ZpaWlpJztcblxuICBmdW5jdGlvbiBfX19jYWxsX3NpZ2hhbmRsZXIoZnAsIHNpZykge1xuICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnApKHNpZyk7XG4gICAgfVxuXG5cbiAgdmFyIF9fX21lbW9yeV9iYXNlID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogZmFsc2V9LCAxMDI0KTtcblxuICB2YXIgX19fc3RhY2tfcG9pbnRlciA9IG5ldyBXZWJBc3NlbWJseS5HbG9iYWwoeyd2YWx1ZSc6ICdpMzInLCAnbXV0YWJsZSc6IHRydWV9LCA2Mjg0Nzg0KTtcblxuICB2YXIgUEFUSCA9IHtzcGxpdFBhdGg6ZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG4gICAgICAgIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbiAgICAgIH0sbm9ybWFsaXplQXJyYXk6ZnVuY3Rpb24ocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gICAgICAgIHZhciB1cCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxub3JtYWxpemU6ZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLycsXG4gICAgICAgICAgICB0cmFpbGluZ1NsYXNoID0gcGF0aC5zdWJzdHIoLTEpID09PSAnLyc7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShwYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gISFwO1xuICAgICAgICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgcGF0aCA9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgICAgIH0sZGlybmFtZTpmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSxcbiAgICAgICAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICAgICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgICAgICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdCArIGRpcjtcbiAgICAgIH0sYmFzZW5hbWU6ZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAvLyBFTVNDUklQVEVOIHJldHVybiAnLycnIGZvciAnLycsIG5vdCBhbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKGxhc3RTbGFzaCsxKTtcbiAgICAgIH0sZXh0bmFtZTpmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBQQVRILnNwbGl0UGF0aChwYXRoKVszXTtcbiAgICAgIH0sam9pbjpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oJy8nKSk7XG4gICAgICB9LGpvaW4yOmZ1bmN0aW9uKGwsIHIpIHtcbiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgICAgIH19O1xuICBcbiAgZnVuY3Rpb24gZ2V0UmFuZG9tRGV2aWNlKCkge1xuICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT0gJ29iamVjdCcgJiYgdHlwZW9mIGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBmb3IgbW9kZXJuIHdlYiBicm93c2Vyc1xuICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CdWZmZXIpOyByZXR1cm4gcmFuZG9tQnVmZmVyWzBdOyB9O1xuICAgICAgfSBlbHNlXG4gICAgICAvLyBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgLy8gICAvLyBmb3Igbm9kZWpzIHdpdGggb3Igd2l0aG91dCBjcnlwdG8gc3VwcG9ydCBpbmNsdWRlZFxuICAgICAgLy8gICB0cnkge1xuICAgICAgLy8gICAgIHZhciBjcnlwdG9fbW9kdWxlID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgICAvLyAgICAgLy8gbm9kZWpzIGhhcyBjcnlwdG8gc3VwcG9ydFxuICAgICAgLy8gICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGNyeXB0b19tb2R1bGVbJ3JhbmRvbUJ5dGVzJ10oMSlbMF07IH07XG4gICAgICAvLyAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vICAgICAvLyBub2RlanMgZG9lc24ndCBoYXZlIGNyeXB0byBzdXBwb3J0XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cbiAgICAgIC8vIHdlIGNvdWxkbid0IGZpbmQgYSBwcm9wZXIgaW1wbGVtZW50YXRpb24sIGFzIE1hdGgucmFuZG9tKCkgaXMgbm90IHN1aXRhYmxlIGZvciAvZGV2L3JhbmRvbSwgc2VlIGVtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3B1bGwvNzA5NlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydChcIm5vIGNyeXB0b2dyYXBoaWMgc3VwcG9ydCBmb3VuZCBmb3IgcmFuZG9tRGV2aWNlLiBjb25zaWRlciBwb2x5ZmlsbGluZyBpdCBpZiB5b3Ugd2FudCB0byB1c2Ugc29tZXRoaW5nIGluc2VjdXJlIGxpa2UgTWF0aC5yYW5kb20oKSwgZS5nLiBwdXQgdGhpcyBpbiBhIC0tcHJlLWpzOiB2YXIgY3J5cHRvID0geyBnZXRSYW5kb21WYWx1ZXM6IGZ1bmN0aW9uKGFycmF5KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqMjU2KXwwIH0gfTtcIik7IH07XG4gICAgfVxuICBcbiAgdmFyIFBBVEhfRlMgPSB7cmVzb2x2ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogRlMuY3dkKCk7XG4gICAgICAgICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJzsgLy8gYW4gaW52YWxpZCBwb3J0aW9uIGludmFsaWRhdGVzIHRoZSB3aG9sZSB0aGluZ1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAgICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IFBBVEgubm9ybWFsaXplQXJyYXkocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gISFwO1xuICAgICAgICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcbiAgICAgICAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xuICAgICAgfSxyZWxhdGl2ZTpmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICBmcm9tID0gUEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgICAgICAgdG8gPSBQQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtcbiAgICAgICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgICAgICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICAgICAgfX07XG4gIFxuICB2YXIgVFRZID0ge3R0eXM6W10saW5pdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9wdWxsLzE1NTVcbiAgICAgICAgLy8gaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiAgICAgICAgLy8gICAvLyBjdXJyZW50bHksIEZTLmluaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2ggaWYgcHJvY2Vzcy5zdGRpbiBpcyBhIGZpbGUgb3IgVFRZXG4gICAgICAgIC8vICAgLy8gZGV2aWNlLCBpdCBhbHdheXMgYXNzdW1lcyBpdCdzIGEgVFRZIGRldmljZS4gYmVjYXVzZSBvZiB0aGlzLCB3ZSdyZSBmb3JjaW5nXG4gICAgICAgIC8vICAgLy8gcHJvY2Vzcy5zdGRpbiB0byBVVEY4IGVuY29kaW5nIHRvIGF0IGxlYXN0IG1ha2Ugc3RkaW4gcmVhZGluZyBjb21wYXRpYmxlXG4gICAgICAgIC8vICAgLy8gd2l0aCB0ZXh0IGZpbGVzIHVudGlsIEZTLmluaXQgY2FuIGJlIHJlZmFjdG9yZWQuXG4gICAgICAgIC8vICAgcHJvY2Vzc1snc3RkaW4nXVsnc2V0RW5jb2RpbmcnXSgndXRmOCcpO1xuICAgICAgICAvLyB9XG4gICAgICB9LHNodXRkb3duOmZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vcHVsbC8xNTU1XG4gICAgICAgIC8vIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgIC8vICAgLy8gaW5vbGVuOiBhbnkgaWRlYSBhcyB0byB3aHkgbm9kZSAtZSAncHJvY2Vzcy5zdGRpbi5yZWFkKCknIHdvdWxkbid0IGV4aXQgaW1tZWRpYXRlbHkgKHdpdGggcHJvY2Vzcy5zdGRpbiBiZWluZyBhIHR0eSk/XG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBiZWNhdXNlIG5vdyBpdCdzIHJlYWRpbmcgZnJvbSB0aGUgc3RyZWFtLCB5b3UndmUgZXhwcmVzc2VkIGludGVyZXN0IGluIGl0LCBzbyB0aGF0IHJlYWQoKSBraWNrcyBvZmYgYSBfcmVhZCgpIHdoaWNoIGNyZWF0ZXMgYSBSZWFkUmVxIG9wZXJhdGlvblxuICAgICAgICAvLyAgIC8vIGlub2xlbjogSSB0aG91Z2h0IHJlYWQoKSBpbiB0aGF0IGNhc2Ugd2FzIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uIHRoYXQganVzdCBncmFiYmVkIHNvbWUgYW1vdW50IG9mIGJ1ZmZlcmVkIGRhdGEgaWYgaXQgZXhpc3RzP1xuICAgICAgICAvLyAgIC8vIGlzYWFjczogaXQgaXMuIGJ1dCBpdCBhbHNvIHRyaWdnZXJzIGEgX3JlYWQoKSBjYWxsLCB3aGljaCBjYWxscyByZWFkU3RhcnQoKSBvbiB0aGUgaGFuZGxlXG4gICAgICAgIC8vICAgLy8gaXNhYWNzOiBkbyBwcm9jZXNzLnN0ZGluLnBhdXNlKCkgYW5kIGknZCB0aGluayBpdCdkIHByb2JhYmx5IGNsb3NlIHRoZSBwZW5kaW5nIGNhbGxcbiAgICAgICAgLy8gICBwcm9jZXNzWydzdGRpbiddWydwYXVzZSddKCk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0scmVnaXN0ZXI6ZnVuY3Rpb24oZGV2LCBvcHMpIHtcbiAgICAgICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9O1xuICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIFRUWS5zdHJlYW1fb3BzKTtcbiAgICAgIH0sc3RyZWFtX29wczp7b3BlbjpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgdHR5ID0gVFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07XG4gICAgICAgICAgaWYgKCF0dHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyZWFtLnR0eSA9IHR0eTtcbiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICAvLyBmbHVzaCBhbnkgcGVuZGluZyBsaW5lIGRhdGFcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTtcbiAgICAgICAgfSxmbHVzaDpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTtcbiAgICAgICAgfSxyZWFkOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcihzdHJlYW0udHR5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgICB9LHdyaXRlOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9fSxkZWZhdWx0X3R0eV9vcHM6e2dldF9jaGFyOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICghdHR5LmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHJlYWQgZGF0YSBieSBjaHVua3Mgb2YgQlVGU0laRVxuICAgICAgICAgICAgICB2YXIgQlVGU0laRSA9IDI1NjtcbiAgICAgICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhCVUZTSVpFKTtcbiAgICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gIFxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKHByb2Nlc3Muc3RkaW4uZmQsIGJ1ZiwgMCwgQlVGU0laRSwgLTEpO1xuICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDcm9zcy1wbGF0Zm9ybSBkaWZmZXJlbmNlczogb24gV2luZG93cywgcmVhZGluZyBFT0YgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYnV0IG9uIG90aGVyIE9TZXMsXG4gICAgICAgICAgICAgICAgLy8gcmVhZGluZyBFT0YgcmV0dXJucyAwLiBVbmlmb3JtaXplIGJlaGF2aW9yIGJ5IHRyZWF0aW5nIHRoZSBFT0YgZXhjZXB0aW9uIHRvIHJldHVybiAwLlxuICAgICAgICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ0VPRicpKSBieXRlc1JlYWQgPSAwO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBidWYuc2xpY2UoMCwgYnl0ZXNSZWFkKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cucHJvbXB0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQnJvd3Nlci5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpOyAgLy8gcmV0dXJucyBudWxsIG9uIGNhbmNlbFxuICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWFkbGluZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIENvbW1hbmQgbGluZS5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVhZGxpbmUoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0dHkuaW5wdXQgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR0eS5pbnB1dC5zaGlmdCgpO1xuICAgICAgICB9LHB1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpOyAvLyB2YWwgPT0gMCB3b3VsZCBjdXQgdGV4dCBvdXRwdXQgb2ZmIGluIHRoZSBtaWRkbGUuXG4gICAgICAgICAgfVxuICAgICAgICB9LGZsdXNoOmZ1bmN0aW9uKHR0eSkge1xuICAgICAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsIDApKTtcbiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH19LGRlZmF1bHRfdHR5MV9vcHM6e3B1dF9jaGFyOmZ1bmN0aW9uKHR0eSwgdmFsKSB7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7XG4gICAgICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICAgICAgdHR5Lm91dHB1dCA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxmbHVzaDpmdW5jdGlvbih0dHkpIHtcbiAgICAgICAgICBpZiAodHR5Lm91dHB1dCAmJiB0dHkub3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7XG4gICAgICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9fX07XG4gIFxuICBmdW5jdGlvbiBtbWFwQWxsb2Moc2l6ZSkge1xuICAgICAgYWJvcnQoJ2ludGVybmFsIGVycm9yOiBtbWFwQWxsb2MgY2FsbGVkIGJ1dCBgZW1zY3JpcHRlbl9idWlsdGluX21lbWFsaWduYCBuYXRpdmUgc3ltYm9sIG5vdCBleHBvcnRlZCcpO1xuICAgIH1cbiAgdmFyIE1FTUZTID0ge29wc190YWJsZTpudWxsLG1vdW50OmZ1bmN0aW9uKG1vdW50KSB7XG4gICAgICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsICcvJywgMTYzODQgfCA1MTEgLyogMDc3NyAqLywgMCk7XG4gICAgICB9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkge1xuICAgICAgICAgIC8vIG5vIHN1cHBvcnRlZFxuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1FTUZTLm9wc190YWJsZSkge1xuICAgICAgICAgIE1FTUZTLm9wc190YWJsZSA9IHtcbiAgICAgICAgICAgIGRpcjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgICAgIGxvb2t1cDogTUVNRlMubm9kZV9vcHMubG9va3VwLFxuICAgICAgICAgICAgICAgIG1rbm9kOiBNRU1GUy5ub2RlX29wcy5ta25vZCxcbiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgICAgICB1bmxpbms6IE1FTUZTLm5vZGVfb3BzLnVubGluayxcbiAgICAgICAgICAgICAgICBybWRpcjogTUVNRlMubm9kZV9vcHMucm1kaXIsXG4gICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgICAgICBzeW1saW5rOiBNRU1GUy5ub2RlX29wcy5zeW1saW5rXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbToge1xuICAgICAgICAgICAgICAgIGxsc2VlazogTUVNRlMuc3RyZWFtX29wcy5sbHNlZWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0clxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdHJlYW06IHtcbiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgICAgIHJlYWQ6IE1FTUZTLnN0cmVhbV9vcHMucmVhZCxcbiAgICAgICAgICAgICAgICB3cml0ZTogTUVNRlMuc3RyZWFtX29wcy53cml0ZSxcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxcbiAgICAgICAgICAgICAgICBtbWFwOiBNRU1GUy5zdHJlYW1fb3BzLm1tYXAsXG4gICAgICAgICAgICAgICAgbXN5bmM6IE1FTUZTLnN0cmVhbV9vcHMubXN5bmNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgbm9kZToge1xuICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgICAgICByZWFkbGluazogTUVNRlMubm9kZV9vcHMucmVhZGxpbmtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3RyZWFtOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNocmRldjoge1xuICAgICAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICAgICAgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0cixcbiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5kaXIubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTtcbiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwOyAvLyBUaGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB1c2VkIGluIHRoZSB0eXBlZCBhcnJheSwgYXMgb3Bwb3NlZCB0byBjb250ZW50cy5sZW5ndGggd2hpY2ggZ2l2ZXMgdGhlIHdob2xlIGNhcGFjaXR5LlxuICAgICAgICAgIC8vIFdoZW4gdGhlIGJ5dGUgZGF0YSBvZiB0aGUgZmlsZSBpcyBwb3B1bGF0ZWQsIHRoaXMgd2lsbCBwb2ludCB0byBlaXRoZXIgYSB0eXBlZCBhcnJheSwgb3IgYSBub3JtYWwgSlMgYXJyYXkuIFR5cGVkIGFycmF5cyBhcmUgcHJlZmVycmVkXG4gICAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlLCBhbmQgdXNlZCBieSBkZWZhdWx0LiBIb3dldmVyLCB0eXBlZCBhcnJheXMgYXJlIG5vdCByZXNpemFibGUgbGlrZSBub3JtYWwgSlMgYXJyYXlzIGFyZSwgc28gdGhlcmUgaXMgYSBzbWFsbCBkaXNrIHNpemVcbiAgICAgICAgICAvLyBwZW5hbHR5IGludm9sdmVkIGZvciBhcHBlbmRpbmcgZmlsZSB3cml0ZXMgdGhhdCBjb250aW51b3VzbHkgZ3JvdyBhIGZpbGUgc2ltaWxhciB0byBzdGQ6OnZlY3RvciBjYXBhY2l0eSB2cyB1c2VkIC1zY2hlbWUuXG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IFxuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLm5vZGU7XG4gICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtO1xuICAgICAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO1xuICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgbm9kZSB0byB0aGUgcGFyZW50XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQuY29udGVudHNbbmFtZV0gPSBub2RlO1xuICAgICAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBub2RlLnRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6ZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkpIHJldHVybiBub2RlLmNvbnRlbnRzLnN1YmFycmF5KDAsIG5vZGUudXNlZEJ5dGVzKTsgLy8gTWFrZSBzdXJlIHRvIG5vdCByZXR1cm4gZXhjZXNzIHVudXNlZCBieXRlcy5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpO1xuICAgICAgfSxleHBhbmRGaWxlU3RvcmFnZTpmdW5jdGlvbihub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgICAgICB2YXIgcHJldkNhcGFjaXR5ID0gbm9kZS5jb250ZW50cyA/IG5vZGUuY29udGVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgaWYgKHByZXZDYXBhY2l0eSA+PSBuZXdDYXBhY2l0eSkgcmV0dXJuOyAvLyBObyBuZWVkIHRvIGV4cGFuZCwgdGhlIHN0b3JhZ2Ugd2FzIGFscmVhZHkgbGFyZ2UgZW5vdWdoLlxuICAgICAgICAvLyBEb24ndCBleHBhbmQgc3RyaWN0bHkgdG8gdGhlIGdpdmVuIHJlcXVlc3RlZCBsaW1pdCBpZiBpdCdzIG9ubHkgYSB2ZXJ5IHNtYWxsIGluY3JlYXNlLCBidXQgaW5zdGVhZCBnZW9tZXRyaWNhbGx5IGdyb3cgY2FwYWNpdHkuXG4gICAgICAgIC8vIEZvciBzbWFsbCBmaWxlc2l6ZXMgKDwxTUIpLCBwZXJmb3JtIHNpemUqMiBnZW9tZXRyaWMgaW5jcmVhc2UsIGJ1dCBmb3IgbGFyZ2Ugc2l6ZXMsIGRvIGEgbXVjaCBtb3JlIGNvbnNlcnZhdGl2ZSBzaXplKjEuMTI1IGluY3JlYXNlIHRvXG4gICAgICAgIC8vIGF2b2lkIG92ZXJzaG9vdGluZyB0aGUgYWxsb2NhdGlvbiBjYXAgYnkgYSB2ZXJ5IGxhcmdlIG1hcmdpbi5cbiAgICAgICAgdmFyIENBUEFDSVRZX0RPVUJMSU5HX01BWCA9IDEwMjQgKiAxMDI0O1xuICAgICAgICBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAocHJldkNhcGFjaXR5ICogKHByZXZDYXBhY2l0eSA8IENBUEFDSVRZX0RPVUJMSU5HX01BWCA/IDIuMCA6IDEuMTI1KSkgPj4+IDApO1xuICAgICAgICBpZiAocHJldkNhcGFjaXR5ICE9IDApIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIDI1Nik7IC8vIEF0IG1pbmltdW0gYWxsb2NhdGUgMjU2YiBmb3IgZWFjaCBmaWxlIHdoZW4gZXhwYW5kaW5nLlxuICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpOyAvLyBBbGxvY2F0ZSBuZXcgc3RvcmFnZS5cbiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMCkgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTsgLy8gQ29weSBvbGQgZGF0YSBvdmVyIHRvIHRoZSBuZXcgc3RvcmFnZS5cbiAgICAgIH0scmVzaXplRmlsZVN0b3JhZ2U6ZnVuY3Rpb24obm9kZSwgbmV3U2l6ZSkge1xuICAgICAgICBpZiAobm9kZS51c2VkQnl0ZXMgPT0gbmV3U2l6ZSkgcmV0dXJuO1xuICAgICAgICBpZiAobmV3U2l6ZSA9PSAwKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7IC8vIEZ1bGx5IGRlY29tbWl0IHdoZW4gcmVxdWVzdGluZyBhIHJlc2l6ZSB0byB6ZXJvLlxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBuZXcgVWludDhBcnJheShuZXdTaXplKTsgLy8gQWxsb2NhdGUgbmV3IHN0b3JhZ2UuXG4gICAgICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBNYXRoLm1pbihuZXdTaXplLCBub2RlLnVzZWRCeXRlcykpKTsgLy8gQ29weSBvbGQgZGF0YSBvdmVyIHRvIHRoZSBuZXcgc3RvcmFnZS5cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplO1xuICAgICAgICB9XG4gICAgICB9LG5vZGVfb3BzOntnZXRhdHRyOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IHt9O1xuICAgICAgICAgIC8vIGRldmljZSBudW1iZXJzIHJldXNlIGlub2RlIG51bWJlcnMuXG4gICAgICAgICAgYXR0ci5kZXYgPSBGUy5pc0NocmRldihub2RlLm1vZGUpID8gbm9kZS5pZCA6IDE7XG4gICAgICAgICAgYXR0ci5pbm8gPSBub2RlLmlkO1xuICAgICAgICAgIGF0dHIubW9kZSA9IG5vZGUubW9kZTtcbiAgICAgICAgICBhdHRyLm5saW5rID0gMTtcbiAgICAgICAgICBhdHRyLnVpZCA9IDA7XG4gICAgICAgICAgYXR0ci5naWQgPSAwO1xuICAgICAgICAgIGF0dHIucmRldiA9IG5vZGUucmRldjtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgYXR0ci5zaXplID0gNDA5NjtcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLnVzZWRCeXRlcztcbiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLmxpbmsubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyLnNpemUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyLmF0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgICAgIGF0dHIubXRpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICAgICAgYXR0ci5jdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgICAgICAvLyBOT1RFOiBJbiBvdXIgaW1wbGVtZW50YXRpb24sIHN0X2Jsb2NrcyA9IE1hdGguY2VpbChzdF9zaXplL3N0X2Jsa3NpemUpLFxuICAgICAgICAgIC8vICAgICAgIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCBieSB0aGUgc3RhbmRhcmQuXG4gICAgICAgICAgYXR0ci5ibGtzaXplID0gNDA5NjtcbiAgICAgICAgICBhdHRyLmJsb2NrcyA9IE1hdGguY2VpbChhdHRyLnNpemUgLyBhdHRyLmJsa3NpemUpO1xuICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9LHNldGF0dHI6ZnVuY3Rpb24obm9kZSwgYXR0cikge1xuICAgICAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLCBhdHRyLnNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxsb29rdXA6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1s0NF07XG4gICAgICAgIH0sbWtub2Q6ZnVuY3Rpb24ocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldik7XG4gICAgICAgIH0scmVuYW1lOmZ1bmN0aW9uKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSkge1xuICAgICAgICAgIC8vIGlmIHdlJ3JlIG92ZXJ3cml0aW5nIGEgZGlyZWN0b3J5IGF0IG5ld19uYW1lLCBtYWtlIHN1cmUgaXQncyBlbXB0eS5cbiAgICAgICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdfbm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3X25vZGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkbyB0aGUgaW50ZXJuYWwgcmV3aXJpbmdcbiAgICAgICAgICBkZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lO1xuICAgICAgICAgIG5ld19kaXIuY29udGVudHNbbmV3X25hbWVdID0gb2xkX25vZGU7XG4gICAgICAgICAgbmV3X2Rpci50aW1lc3RhbXAgPSBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wO1xuICAgICAgICAgIG9sZF9ub2RlLnBhcmVudCA9IG5ld19kaXI7XG4gICAgICAgIH0sdW5saW5rOmZ1bmN0aW9uKHBhcmVudCwgbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scm1kaXI6ZnVuY3Rpb24ocGFyZW50LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBub2RlLmNvbnRlbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07XG4gICAgICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIH0scmVhZGRpcjpmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbJy4nLCAnLi4nXTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgIH0sc3ltbGluazpmdW5jdGlvbihwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgLyogMDc3NyAqLyB8IDQwOTYwLCAwKTtcbiAgICAgICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LHJlYWRsaW5rOmZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmxpbms7XG4gICAgICAgIH19LHN0cmVhbV9vcHM6e3JlYWQ6ZnVuY3Rpb24oc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS51c2VkQnl0ZXMpIHJldHVybiAwO1xuICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7XG4gICAgICAgICAgYXNzZXJ0KHNpemUgPj0gMCk7XG4gICAgICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7IC8vIG5vbi10cml2aWFsLCBhbmQgdHlwZWQgYXJyYXlcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50c1twb3NpdGlvbiArIGldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgICAgICAvLyBUaGUgZGF0YSBidWZmZXIgc2hvdWxkIGJlIGEgdHlwZWQgYXJyYXkgdmlld1xuICAgICAgICAgIGFzc2VydCghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSk7XG4gIFxuICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbS5ub2RlO1xuICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgXG4gICAgICAgICAgaWYgKGJ1ZmZlci5zdWJhcnJheSAmJiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkpIHsgLy8gVGhpcyB3cml0ZSBpcyBmcm9tIGEgdHlwZWQgYXJyYXkgdG8gYSB0eXBlZCBhcnJheT9cbiAgICAgICAgICAgIGlmIChjYW5Pd24pIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KHBvc2l0aW9uID09PSAwLCAnY2FuT3duIG11c3QgaW1wbHkgbm8gd2VpcmQgcG9zaXRpb24gaW5zaWRlIHRoZSBmaWxlJyk7XG4gICAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS51c2VkQnl0ZXMgPT09IDAgJiYgcG9zaXRpb24gPT09IDApIHsgLy8gSWYgdGhpcyBpcyBhIHNpbXBsZSBmaXJzdCB3cml0ZSB0byBhbiBlbXB0eSBmaWxlLCBkbyBhIGZhc3Qgc2V0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gY2FyZSBhYm91dCBvbGQgZGF0YS5cbiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiArIGxlbmd0aCA8PSBub2RlLnVzZWRCeXRlcykgeyAvLyBXcml0aW5nIHRvIGFuIGFscmVhZHkgYWxsb2NhdGVkIGFuZCB1c2VkIHN1YnJhbmdlIG9mIHRoZSBmaWxlP1xuICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBBcHBlbmRpbmcgdG8gYW4gZXhpc3RpbmcgZmlsZSBhbmQgd2UgbmVlZCB0byByZWFsbG9jYXRlLCBvciBzb3VyY2UgZGF0YSBkaWQgbm90IGNvbWUgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLCBwb3NpdGlvbitsZW5ndGgpO1xuICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5ICYmIGJ1ZmZlci5zdWJhcnJheSkge1xuICAgICAgICAgICAgLy8gVXNlIHR5cGVkIGFycmF5IHdyaXRlIHdoaWNoIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsgLy8gT3IgZmFsbCBiYWNrIHRvIG1hbnVhbCB3cml0ZSBpZiBub3QuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9LGxsc2VlazpmdW5jdGlvbihzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikge1xuICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9LGFsbG9jYXRlOmZ1bmN0aW9uKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgICBzdHJlYW0ubm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChzdHJlYW0ubm9kZS51c2VkQnl0ZXMsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sbW1hcDpmdW5jdGlvbihzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICAgICAgaWYgKGFkZHJlc3MgIT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGxvY2F0aW9uIGhpbnRzIGZvciB0aGUgYWRkcmVzcyBvZiB0aGUgbWFwcGluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHRyO1xuICAgICAgICAgIHZhciBhbGxvY2F0ZWQ7XG4gICAgICAgICAgdmFyIGNvbnRlbnRzID0gc3RyZWFtLm5vZGUuY29udGVudHM7XG4gICAgICAgICAgLy8gT25seSBtYWtlIGEgbmV3IGNvcHkgd2hlbiBNQVBfUFJJVkFURSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cy5idWZmZXIgPT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZW11bGF0ZSBNQVBfU0hBUkVEIHdoZW4gdGhlIGZpbGUgaXMgbm90IGJhY2tlZCBieSB0aGUgYnVmZmVyXG4gICAgICAgICAgICAvLyB3ZSdyZSBtYXBwaW5nIHRvIChlLmcuIHRoZSBIRUFQIGJ1ZmZlcikuXG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHB0ciA9IGNvbnRlbnRzLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBzbGljZXMuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiAwIHx8IHBvc2l0aW9uICsgbGVuZ3RoIDwgY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChjb250ZW50cy5zdWJhcnJheSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxvY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoIXB0cikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0OCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQOC5zZXQoY29udGVudHMsIHB0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgICAgICB9LG1zeW5jOmZ1bmN0aW9uKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7XG4gICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1tYXBGbGFncyAmIDIpIHtcbiAgICAgICAgICAgIC8vIE1BUF9QUklWQVRFIGNhbGxzIG5lZWQgbm90IHRvIGJlIHN5bmNlZCBiYWNrIHRvIHVuZGVybHlpbmcgZnNcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIDAsIGxlbmd0aCwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgICAgLy8gc2hvdWxkIHdlIGNoZWNrIGlmIGJ5dGVzV3JpdHRlbiBhbmQgbGVuZ3RoIGFyZSB0aGUgc2FtZT9cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfX19O1xuICBcbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IG5vUnVuRGVwICovXG4gIGZ1bmN0aW9uIGFzeW5jTG9hZCh1cmwsIG9ubG9hZCwgb25lcnJvciwgbm9SdW5EZXApIHtcbiAgICAgIHZhciBkZXAgPSAhbm9SdW5EZXAgPyBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdhbCAnICsgdXJsKSA6ICcnO1xuICAgICAgcmVhZEFzeW5jKHVybCwgZnVuY3Rpb24oYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgYXNzZXJ0KGFycmF5QnVmZmVyLCAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicpO1xuICAgICAgICBvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgICAgaWYgKGRlcCkgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgfSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgICAgICBvbmVycm9yKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgJ0xvYWRpbmcgZGF0YSBmaWxlIFwiJyArIHVybCArICdcIiBmYWlsZWQuJztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGVwKSBhZGRSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgfVxuICBcbiAgdmFyIEVSUk5PX01FU1NBR0VTID0gezA6XCJTdWNjZXNzXCIsMTpcIkFyZyBsaXN0IHRvbyBsb25nXCIsMjpcIlBlcm1pc3Npb24gZGVuaWVkXCIsMzpcIkFkZHJlc3MgYWxyZWFkeSBpbiB1c2VcIiw0OlwiQWRkcmVzcyBub3QgYXZhaWxhYmxlXCIsNTpcIkFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wgZmFtaWx5XCIsNjpcIk5vIG1vcmUgcHJvY2Vzc2VzXCIsNzpcIlNvY2tldCBhbHJlYWR5IGNvbm5lY3RlZFwiLDg6XCJCYWQgZmlsZSBudW1iZXJcIiw5OlwiVHJ5aW5nIHRvIHJlYWQgdW5yZWFkYWJsZSBtZXNzYWdlXCIsMTA6XCJNb3VudCBkZXZpY2UgYnVzeVwiLDExOlwiT3BlcmF0aW9uIGNhbmNlbGVkXCIsMTI6XCJObyBjaGlsZHJlblwiLDEzOlwiQ29ubmVjdGlvbiBhYm9ydGVkXCIsMTQ6XCJDb25uZWN0aW9uIHJlZnVzZWRcIiwxNTpcIkNvbm5lY3Rpb24gcmVzZXQgYnkgcGVlclwiLDE2OlwiRmlsZSBsb2NraW5nIGRlYWRsb2NrIGVycm9yXCIsMTc6XCJEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkXCIsMTg6XCJNYXRoIGFyZyBvdXQgb2YgZG9tYWluIG9mIGZ1bmNcIiwxOTpcIlF1b3RhIGV4Y2VlZGVkXCIsMjA6XCJGaWxlIGV4aXN0c1wiLDIxOlwiQmFkIGFkZHJlc3NcIiwyMjpcIkZpbGUgdG9vIGxhcmdlXCIsMjM6XCJIb3N0IGlzIHVucmVhY2hhYmxlXCIsMjQ6XCJJZGVudGlmaWVyIHJlbW92ZWRcIiwyNTpcIklsbGVnYWwgYnl0ZSBzZXF1ZW5jZVwiLDI2OlwiQ29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIsMjc6XCJJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbFwiLDI4OlwiSW52YWxpZCBhcmd1bWVudFwiLDI5OlwiSS9PIGVycm9yXCIsMzA6XCJTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWRcIiwzMTpcIklzIGEgZGlyZWN0b3J5XCIsMzI6XCJUb28gbWFueSBzeW1ib2xpYyBsaW5rc1wiLDMzOlwiVG9vIG1hbnkgb3BlbiBmaWxlc1wiLDM0OlwiVG9vIG1hbnkgbGlua3NcIiwzNTpcIk1lc3NhZ2UgdG9vIGxvbmdcIiwzNjpcIk11bHRpaG9wIGF0dGVtcHRlZFwiLDM3OlwiRmlsZSBvciBwYXRoIG5hbWUgdG9vIGxvbmdcIiwzODpcIk5ldHdvcmsgaW50ZXJmYWNlIGlzIG5vdCBjb25maWd1cmVkXCIsMzk6XCJDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmtcIiw0MDpcIk5ldHdvcmsgaXMgdW5yZWFjaGFibGVcIiw0MTpcIlRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtXCIsNDI6XCJObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlXCIsNDM6XCJObyBzdWNoIGRldmljZVwiLDQ0OlwiTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeVwiLDQ1OlwiRXhlYyBmb3JtYXQgZXJyb3JcIiw0NjpcIk5vIHJlY29yZCBsb2NrcyBhdmFpbGFibGVcIiw0NzpcIlRoZSBsaW5rIGhhcyBiZWVuIHNldmVyZWRcIiw0ODpcIk5vdCBlbm91Z2ggY29yZVwiLDQ5OlwiTm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGVcIiw1MDpcIlByb3RvY29sIG5vdCBhdmFpbGFibGVcIiw1MTpcIk5vIHNwYWNlIGxlZnQgb24gZGV2aWNlXCIsNTI6XCJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWRcIiw1MzpcIlNvY2tldCBpcyBub3QgY29ubmVjdGVkXCIsNTQ6XCJOb3QgYSBkaXJlY3RvcnlcIiw1NTpcIkRpcmVjdG9yeSBub3QgZW1wdHlcIiw1NjpcIlN0YXRlIG5vdCByZWNvdmVyYWJsZVwiLDU3OlwiU29ja2V0IG9wZXJhdGlvbiBvbiBub24tc29ja2V0XCIsNTk6XCJOb3QgYSB0eXBld3JpdGVyXCIsNjA6XCJObyBzdWNoIGRldmljZSBvciBhZGRyZXNzXCIsNjE6XCJWYWx1ZSB0b28gbGFyZ2UgZm9yIGRlZmluZWQgZGF0YSB0eXBlXCIsNjI6XCJQcmV2aW91cyBvd25lciBkaWVkXCIsNjM6XCJOb3Qgc3VwZXItdXNlclwiLDY0OlwiQnJva2VuIHBpcGVcIiw2NTpcIlByb3RvY29sIGVycm9yXCIsNjY6XCJVbmtub3duIHByb3RvY29sXCIsNjc6XCJQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXRcIiw2ODpcIk1hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlXCIsNjk6XCJSZWFkIG9ubHkgZmlsZSBzeXN0ZW1cIiw3MDpcIklsbGVnYWwgc2Vla1wiLDcxOlwiTm8gc3VjaCBwcm9jZXNzXCIsNzI6XCJTdGFsZSBmaWxlIGhhbmRsZVwiLDczOlwiQ29ubmVjdGlvbiB0aW1lZCBvdXRcIiw3NDpcIlRleHQgZmlsZSBidXN5XCIsNzU6XCJDcm9zcy1kZXZpY2UgbGlua1wiLDEwMDpcIkRldmljZSBub3QgYSBzdHJlYW1cIiwxMDE6XCJCYWQgZm9udCBmaWxlIGZtdFwiLDEwMjpcIkludmFsaWQgc2xvdFwiLDEwMzpcIkludmFsaWQgcmVxdWVzdCBjb2RlXCIsMTA0OlwiTm8gYW5vZGVcIiwxMDU6XCJCbG9jayBkZXZpY2UgcmVxdWlyZWRcIiwxMDY6XCJDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2VcIiwxMDc6XCJMZXZlbCAzIGhhbHRlZFwiLDEwODpcIkxldmVsIDMgcmVzZXRcIiwxMDk6XCJMaW5rIG51bWJlciBvdXQgb2YgcmFuZ2VcIiwxMTA6XCJQcm90b2NvbCBkcml2ZXIgbm90IGF0dGFjaGVkXCIsMTExOlwiTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGVcIiwxMTI6XCJMZXZlbCAyIGhhbHRlZFwiLDExMzpcIkludmFsaWQgZXhjaGFuZ2VcIiwxMTQ6XCJJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvclwiLDExNTpcIkV4Y2hhbmdlIGZ1bGxcIiwxMTY6XCJObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pXCIsMTE3OlwiVGltZXIgZXhwaXJlZFwiLDExODpcIk91dCBvZiBzdHJlYW1zIHJlc291cmNlc1wiLDExOTpcIk1hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrXCIsMTIwOlwiUGFja2FnZSBub3QgaW5zdGFsbGVkXCIsMTIxOlwiVGhlIG9iamVjdCBpcyByZW1vdGVcIiwxMjI6XCJBZHZlcnRpc2UgZXJyb3JcIiwxMjM6XCJTcm1vdW50IGVycm9yXCIsMTI0OlwiQ29tbXVuaWNhdGlvbiBlcnJvciBvbiBzZW5kXCIsMTI1OlwiQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpXCIsMTI2OlwiR2l2ZW4gbG9nLiBuYW1lIG5vdCB1bmlxdWVcIiwxMjc6XCJmLmQuIGludmFsaWQgZm9yIHRoaXMgb3BlcmF0aW9uXCIsMTI4OlwiUmVtb3RlIGFkZHJlc3MgY2hhbmdlZFwiLDEyOTpcIkNhbiAgIGFjY2VzcyBhIG5lZWRlZCBzaGFyZWQgbGliXCIsMTMwOlwiQWNjZXNzaW5nIGEgY29ycnVwdGVkIHNoYXJlZCBsaWJcIiwxMzE6XCIubGliIHNlY3Rpb24gaW4gYS5vdXQgY29ycnVwdGVkXCIsMTMyOlwiQXR0ZW1wdGluZyB0byBsaW5rIGluIHRvbyBtYW55IGxpYnNcIiwxMzM6XCJBdHRlbXB0aW5nIHRvIGV4ZWMgYSBzaGFyZWQgbGlicmFyeVwiLDEzNTpcIlN0cmVhbXMgcGlwZSBlcnJvclwiLDEzNjpcIlRvbyBtYW55IHVzZXJzXCIsMTM3OlwiU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZFwiLDEzODpcIk5vdCBzdXBwb3J0ZWRcIiwxMzk6XCJQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZFwiLDE0MDpcIkNhbid0IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duXCIsMTQxOlwiVG9vIG1hbnkgcmVmZXJlbmNlc1wiLDE0MjpcIkhvc3QgaXMgZG93blwiLDE0ODpcIk5vIG1lZGl1bSAoaW4gdGFwZSBkcml2ZSlcIiwxNTY6XCJMZXZlbCAyIG5vdCBzeW5jaHJvbml6ZWRcIn07XG4gIFxuICB2YXIgRVJSTk9fQ09ERVMgPSB7fTtcbiAgdmFyIEZTID0ge3Jvb3Q6bnVsbCxtb3VudHM6W10sZGV2aWNlczp7fSxzdHJlYW1zOltdLG5leHRJbm9kZToxLG5hbWVUYWJsZTpudWxsLGN1cnJlbnRQYXRoOlwiL1wiLGluaXRpYWxpemVkOmZhbHNlLGlnbm9yZVBlcm1pc3Npb25zOnRydWUsRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGxvb2t1cFBhdGg6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBwYXRoID0gUEFUSF9GUy5yZXNvbHZlKEZTLmN3ZCgpLCBwYXRoKTtcbiAgXG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcbiAgXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBmb2xsb3dfbW91bnQ6IHRydWUsXG4gICAgICAgICAgcmVjdXJzZV9jb3VudDogMFxuICAgICAgICB9O1xuICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cylcbiAgXG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7ICAvLyBtYXggcmVjdXJzaXZlIGxvb2t1cCBvZiA4XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBzcGxpdCB0aGUgcGF0aFxuICAgICAgICB2YXIgcGFydHMgPSBQQVRILm5vcm1hbGl6ZUFycmF5KHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoKHApID0+ICEhcCksIGZhbHNlKTtcbiAgXG4gICAgICAgIC8vIHN0YXJ0IGF0IHRoZSByb290XG4gICAgICAgIHZhciBjdXJyZW50ID0gRlMucm9vdDtcbiAgICAgICAgdmFyIGN1cnJlbnRfcGF0aCA9ICcvJztcbiAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXNsYXN0ID0gKGkgPT09IHBhcnRzLmxlbmd0aC0xKTtcbiAgICAgICAgICBpZiAoaXNsYXN0ICYmIG9wdHMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBzdG9wIHJlc29sdmluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTtcbiAgXG4gICAgICAgICAgLy8ganVtcCB0byB0aGUgbW91bnQncyByb290IG5vZGUgaWYgdGhpcyBpcyBhIG1vdW50cG9pbnRcbiAgICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tb3VudGVkLnJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBieSBkZWZhdWx0LCBsb29rdXBQYXRoIHdpbGwgbm90IGZvbGxvdyBhIHN5bWxpbmsgaWYgaXQgaXMgdGhlIGZpbmFsIHBhdGggY29tcG9uZW50LlxuICAgICAgICAgIC8vIHNldHRpbmcgb3B0cy5mb2xsb3cgPSB0cnVlIHdpbGwgb3ZlcnJpZGUgdGhpcyBiZWhhdmlvci5cbiAgICAgICAgICBpZiAoIWlzbGFzdCB8fCBvcHRzLmZvbGxvdykge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkge1xuICAgICAgICAgICAgICB2YXIgbGluayA9IEZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG4gIFxuICAgICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChjdXJyZW50X3BhdGgsIHsgcmVjdXJzZV9jb3VudDogb3B0cy5yZWN1cnNlX2NvdW50ICsgMSB9KTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlO1xuICBcbiAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkgeyAgLy8gbGltaXQgbWF4IGNvbnNlY3V0aXZlIHN5bWxpbmtzIHRvIDQwIChTWU1MT09QX01BWCkuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gIFxuICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgICAgIH0sZ2V0UGF0aDoobm9kZSkgPT4ge1xuICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBtb3VudFttb3VudC5sZW5ndGgtMV0gIT09ICcvJyA/IG1vdW50ICsgJy8nICsgcGF0aCA6IG1vdW50ICsgcGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IHBhdGggPyBub2RlLm5hbWUgKyAnLycgKyBwYXRoIDogbm9kZS5uYW1lO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSxoYXNoTmFtZToocGFyZW50aWQsIG5hbWUpID0+IHtcbiAgICAgICAgdmFyIGhhc2ggPSAwO1xuICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gICAgICB9LGhhc2hBZGROb2RlOihub2RlKSA9PiB7XG4gICAgICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgICAgIG5vZGUubmFtZV9uZXh0ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlO1xuICAgICAgfSxoYXNoUmVtb3ZlTm9kZToobm9kZSkgPT4ge1xuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpO1xuICAgICAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XG4gICAgICAgICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZS5uYW1lX25leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5hbWVfbmV4dCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sbG9va3VwTm9kZToocGFyZW50LCBuYW1lKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubWF5TG9va3VwKHBhcmVudCk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7XG4gICAgICAgIGZvciAodmFyIG5vZGUgPSBGUy5uYW1lVGFibGVbaGFzaF07IG5vZGU7IG5vZGUgPSBub2RlLm5hbWVfbmV4dCkge1xuICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGZhaWxlZCB0byBmaW5kIGl0IGluIHRoZSBjYWNoZSwgY2FsbCBpbnRvIHRoZSBWRlNcbiAgICAgICAgcmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICAgICAgfSxjcmVhdGVOb2RlOihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpID0+IHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXJlbnQgPT0gJ29iamVjdCcpXG4gICAgICAgIHZhciBub2RlID0gbmV3IEZTLkZTTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpO1xuICBcbiAgICAgICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7XG4gIFxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sZGVzdHJveU5vZGU6KG5vZGUpID0+IHtcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7XG4gICAgICB9LGlzUm9vdDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gbm9kZSA9PT0gbm9kZS5wYXJlbnQ7XG4gICAgICB9LGlzTW91bnRwb2ludDoobm9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gISFub2RlLm1vdW50ZWQ7XG4gICAgICB9LGlzRmlsZToobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDMyNzY4O1xuICAgICAgfSxpc0RpcjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDE2Mzg0O1xuICAgICAgfSxpc0xpbms6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2MDtcbiAgICAgIH0saXNDaHJkZXY6KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA4MTkyO1xuICAgICAgfSxpc0Jsa2RldjoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDI0NTc2O1xuICAgICAgfSxpc0ZJRk86KG1vZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSA0MDk2O1xuICAgICAgfSxpc1NvY2tldDoobW9kZSkgPT4ge1xuICAgICAgICByZXR1cm4gKG1vZGUgJiA0OTE1MikgPT09IDQ5MTUyO1xuICAgICAgfSxmbGFnTW9kZXM6e1wiclwiOjAsXCJyK1wiOjIsXCJ3XCI6NTc3LFwidytcIjo1NzgsXCJhXCI6MTA4OSxcImErXCI6MTA5MH0sbW9kZVN0cmluZ1RvRmxhZ3M6KHN0cikgPT4ge1xuICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFncyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfSxmbGFnc1RvUGVybWlzc2lvblN0cmluZzooZmxhZykgPT4ge1xuICAgICAgICB2YXIgcGVybXMgPSBbJ3InLCAndycsICdydyddW2ZsYWcgJiAzXTtcbiAgICAgICAgaWYgKChmbGFnICYgNTEyKSkge1xuICAgICAgICAgIHBlcm1zICs9ICd3JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVybXM7XG4gICAgICB9LG5vZGVQZXJtaXNzaW9uczoobm9kZSwgcGVybXMpID0+IHtcbiAgICAgICAgaWYgKEZTLmlnbm9yZVBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIDAgaWYgYW55IHVzZXIsIGdyb3VwIG9yIG93bmVyIGJpdHMgYXJlIHNldC5cbiAgICAgICAgaWYgKHBlcm1zLmluY2x1ZGVzKCdyJykgJiYgIShub2RlLm1vZGUgJiAyOTIpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocGVybXMuaW5jbHVkZXMoJ3cnKSAmJiAhKG5vZGUubW9kZSAmIDE0NikpIHtcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LG1heUxvb2t1cDooZGlyKSA9PiB7XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHJldHVybiBlcnJDb2RlO1xuICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiAyO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5Q3JlYXRlOihkaXIsIG5hbWUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUoZGlyLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm4gMjA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgICB9LG1heURlbGV0ZTooZGlyLCBuYW1lLCBpc2RpcikgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gZXJyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNkaXIpIHtcbiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiA1NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSB8fCBGUy5nZXRQYXRoKG5vZGUpID09PSBGUy5jd2QoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sbWF5T3Blbjoobm9kZSwgZmxhZ3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIDQ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IC8vIG9wZW5pbmcgZm9yIHdyaXRlXG4gICAgICAgICAgICAgIChmbGFncyAmIDUxMikpIHsgLy8gVE9ETzogY2hlY2sgZm9yIE9fU0VBUkNIPyAoPT0gc2VhcmNoIGZvciBkaXIgb25seSlcbiAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICAgICAgfSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQ6KGZkX3N0YXJ0ID0gMCwgZmRfZW5kID0gRlMuTUFYX09QRU5fRkRTKSA9PiB7XG4gICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykge1xuICAgICAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpO1xuICAgICAgfSxnZXRTdHJlYW06KGZkKSA9PiBGUy5zdHJlYW1zW2ZkXSxjcmVhdGVTdHJlYW06KHN0cmVhbSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICAgICAgRlMuRlNTdHJlYW0gPSAvKiogQGNvbnN0cnVjdG9yICovIGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgICBGUy5GU1N0cmVhbS5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm9kZTsgfSxcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHsgdGhpcy5ub2RlID0gdmFsOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWFkOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxOyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNXcml0ZToge1xuICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMDsgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzQXBwZW5kOiB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDEwMjQpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbG9uZSBpdCwgc28gd2UgY2FuIHJldHVybiBhbiBpbnN0YW5jZSBvZiBGU1N0cmVhbVxuICAgICAgICBzdHJlYW0gPSBPYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSgpLCBzdHJlYW0pO1xuICAgICAgICB2YXIgZmQgPSBGUy5uZXh0ZmQoZmRfc3RhcnQsIGZkX2VuZCk7XG4gICAgICAgIHN0cmVhbS5mZCA9IGZkO1xuICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IHN0cmVhbTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sY2xvc2VTdHJlYW06KGZkKSA9PiB7XG4gICAgICAgIEZTLnN0cmVhbXNbZmRdID0gbnVsbDtcbiAgICAgIH0sY2hyZGV2X3N0cmVhbV9vcHM6e29wZW46KHN0cmVhbSkgPT4ge1xuICAgICAgICAgIHZhciBkZXZpY2UgPSBGUy5nZXREZXZpY2Uoc3RyZWFtLm5vZGUucmRldik7XG4gICAgICAgICAgLy8gb3ZlcnJpZGUgbm9kZSdzIHN0cmVhbSBvcHMgd2l0aCB0aGUgZGV2aWNlJ3NcbiAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcyA9IGRldmljZS5zdHJlYW1fb3BzO1xuICAgICAgICAgIC8vIGZvcndhcmQgdGhlIG9wZW4gY2FsbFxuICAgICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LGxsc2VlazooKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgICAgICB9fSxtYWpvcjooZGV2KSA9PiAoKGRldikgPj4gOCksbWlub3I6KGRldikgPT4gKChkZXYpICYgMHhmZiksbWFrZWRldjoobWEsIG1pKSA9PiAoKG1hKSA8PCA4IHwgKG1pKSkscmVnaXN0ZXJEZXZpY2U6KGRldiwgb3BzKSA9PiB7XG4gICAgICAgIEZTLmRldmljZXNbZGV2XSA9IHsgc3RyZWFtX29wczogb3BzIH07XG4gICAgICB9LGdldERldmljZTooZGV2KSA9PiBGUy5kZXZpY2VzW2Rldl0sZ2V0TW91bnRzOihtb3VudCkgPT4ge1xuICAgICAgICB2YXIgbW91bnRzID0gW107XG4gICAgICAgIHZhciBjaGVjayA9IFttb3VudF07XG4gIFxuICAgICAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIG0gPSBjaGVjay5wb3AoKTtcbiAgXG4gICAgICAgICAgbW91bnRzLnB1c2gobSk7XG4gIFxuICAgICAgICAgIGNoZWNrLnB1c2guYXBwbHkoY2hlY2ssIG0ubW91bnRzKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG1vdW50cztcbiAgICAgIH0sc3luY2ZzOihwb3B1bGF0ZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3B1bGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBwb3B1bGF0ZTtcbiAgICAgICAgICBwb3B1bGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gIFxuICAgICAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuICBcbiAgICAgICAgaWYgKEZTLnN5bmNGU1JlcXVlc3RzID4gMSkge1xuICAgICAgICAgIGVycignd2FybmluZzogJyArIEZTLnN5bmNGU1JlcXVlc3RzICsgJyBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrJyk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICBcbiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKSB7XG4gICAgICAgICAgYXNzZXJ0KEZTLnN5bmNGU1JlcXVlc3RzID4gMCk7XG4gICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyQ29kZSkge1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWRvbmUuZXJyb3JlZCkge1xuICAgICAgICAgICAgICBkb25lLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCsrY29tcGxldGVkID49IG1vdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICBcbiAgICAgICAgLy8gc3luYyBhbGwgbW91bnRzXG4gICAgICAgIG1vdW50cy5mb3JFYWNoKChtb3VudCkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sbW91bnQ6KHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpbGVzeXN0ZW0gd2FzIG5vdCBpbmNsdWRlZCwgYW5kIGluc3RlYWQgd2UgaGF2ZSBhbiBlcnJvclxuICAgICAgICAgIC8vIG1lc3NhZ2Ugc3RvcmVkIGluIHRoZSB2YXJpYWJsZS5cbiAgICAgICAgICB0aHJvdyB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbW91bnRwb2ludCA9PT0gJy8nO1xuICAgICAgICB2YXIgcHNldWRvID0gIW1vdW50cG9pbnQ7XG4gICAgICAgIHZhciBub2RlO1xuICBcbiAgICAgICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm9vdCAmJiAhcHNldWRvKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgICBtb3VudHBvaW50ID0gbG9va3VwLnBhdGg7ICAvLyB1c2UgdGhlIGFic29sdXRlIHBhdGhcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG1vdW50ID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICBtb3VudHBvaW50OiBtb3VudHBvaW50LFxuICAgICAgICAgIG1vdW50czogW11cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvb3Qgbm9kZSBmb3IgdGhlIGZzXG4gICAgICAgIHZhciBtb3VudFJvb3QgPSB0eXBlLm1vdW50KG1vdW50KTtcbiAgICAgICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XG4gICAgICAgIG1vdW50LnJvb3QgPSBtb3VudFJvb3Q7XG4gIFxuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIEZTLnJvb3QgPSBtb3VudFJvb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgICAgIC8vIHNldCBhcyBhIG1vdW50cG9pbnRcbiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDtcbiAgXG4gICAgICAgICAgLy8gYWRkIHRoZSBuZXcgbW91bnQgdG8gdGhlIGN1cnJlbnQgbW91bnQncyBjaGlsZHJlblxuICAgICAgICAgIGlmIChub2RlLm1vdW50KSB7XG4gICAgICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5wdXNoKG1vdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBtb3VudFJvb3Q7XG4gICAgICB9LHVubW91bnQ6KG1vdW50cG9pbnQpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICBcbiAgICAgICAgaWYgKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBkZXN0cm95IHRoZSBub2RlcyBmb3IgdGhpcyBtb3VudCwgYW5kIGFsbCBpdHMgY2hpbGQgbW91bnRzXG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnRlZDtcbiAgICAgICAgdmFyIG1vdW50cyA9IEZTLmdldE1vdW50cyhtb3VudCk7XG4gIFxuICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goKGhhc2gpID0+IHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTtcbiAgXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gY3VycmVudC5uYW1lX25leHQ7XG4gIFxuICAgICAgICAgICAgaWYgKG1vdW50cy5pbmNsdWRlcyhjdXJyZW50Lm1vdW50KSkge1xuICAgICAgICAgICAgICBGUy5kZXN0cm95Tm9kZShjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgLy8gbm8gbG9uZ2VyIGEgbW91bnRwb2ludFxuICAgICAgICBub2RlLm1vdW50ZWQgPSBudWxsO1xuICBcbiAgICAgICAgLy8gcmVtb3ZlIHRoaXMgbW91bnQgZnJvbSB0aGUgY2hpbGQgbW91bnRzXG4gICAgICAgIHZhciBpZHggPSBub2RlLm1vdW50Lm1vdW50cy5pbmRleE9mKG1vdW50KTtcbiAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpO1xuICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH0sbG9va3VwOihwYXJlbnQsIG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKTtcbiAgICAgIH0sbWtub2Q6KHBhdGgsIG1vZGUsIGRldikgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICghbmFtZSB8fCBuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUNyZWF0ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMubWtub2QocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgICAgfSxjcmVhdGU6KHBhdGgsIG1vZGUpID0+IHtcbiAgICAgICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA0MzggLyogMDY2NiAqLztcbiAgICAgICAgbW9kZSAmPSA0MDk1O1xuICAgICAgICBtb2RlIHw9IDMyNzY4O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyOihwYXRoLCBtb2RlKSA9PiB7XG4gICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNTExIC8qIDA3NzcgKi87XG4gICAgICAgIG1vZGUgJj0gNTExIHwgNTEyO1xuICAgICAgICBtb2RlIHw9IDE2Mzg0O1xuICAgICAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gICAgICB9LG1rZGlyVHJlZToocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgdmFyIGQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZTtcbiAgICAgICAgICBkICs9ICcvJyArIGRpcnNbaV07XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xuICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgaWYgKGUuZXJybm8gIT0gMjApIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LG1rZGV2OihwYXRoLCBtb2RlLCBkZXYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkZXYgPSBtb2RlO1xuICAgICAgICAgIG1vZGUgPSA0MzggLyogMDY2NiAqLztcbiAgICAgICAgfVxuICAgICAgICBtb2RlIHw9IDgxOTI7XG4gICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxzeW1saW5rOihvbGRwYXRoLCBuZXdwYXRoKSA9PiB7XG4gICAgICAgIGlmICghUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXduYW1lID0gUEFUSC5iYXNlbmFtZShuZXdwYXRoKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTtcbiAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQubm9kZV9vcHMuc3ltbGluayhwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpO1xuICAgICAgfSxyZW5hbWU6KG9sZF9wYXRoLCBuZXdfcGF0aCkgPT4ge1xuICAgICAgICB2YXIgb2xkX2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUob2xkX3BhdGgpO1xuICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpO1xuICAgICAgICB2YXIgb2xkX25hbWUgPSBQQVRILmJhc2VuYW1lKG9sZF9wYXRoKTtcbiAgICAgICAgdmFyIG5ld19uYW1lID0gUEFUSC5iYXNlbmFtZShuZXdfcGF0aCk7XG4gICAgICAgIC8vIHBhcmVudHMgbXVzdCBleGlzdFxuICAgICAgICB2YXIgbG9va3VwLCBvbGRfZGlyLCBuZXdfZGlyO1xuICBcbiAgICAgICAgLy8gbGV0IHRoZSBlcnJvcnMgZnJvbSBub24gZXhpc3RhbnQgZGlyZWN0b3JpZXMgcGVyY29sYXRlIHVwXG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBvbGRfZGlyID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3X3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7XG4gIFxuICAgICAgICBpZiAoIW9sZF9kaXIgfHwgIW5ld19kaXIpIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgLy8gbmVlZCB0byBiZSBwYXJ0IG9mIHRoZSBzYW1lIG1vdW50XG4gICAgICAgIGlmIChvbGRfZGlyLm1vdW50ICE9PSBuZXdfZGlyLm1vdW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNvdXJjZSBtdXN0IGV4aXN0XG4gICAgICAgIHZhciBvbGRfbm9kZSA9IEZTLmxvb2t1cE5vZGUob2xkX2Rpciwgb2xkX25hbWUpO1xuICAgICAgICAvLyBvbGQgcGF0aCBzaG91bGQgbm90IGJlIGFuIGFuY2VzdG9yIG9mIHRoZSBuZXcgcGF0aFxuICAgICAgICB2YXIgcmVsYXRpdmUgPSBQQVRIX0ZTLnJlbGF0aXZlKG9sZF9wYXRoLCBuZXdfZGlybmFtZSk7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZXcgcGF0aCBzaG91bGQgbm90IGJlIGFuIGFuY2VzdG9yIG9mIHRoZSBvbGQgcGF0aFxuICAgICAgICByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTtcbiAgICAgICAgaWYgKHJlbGF0aXZlLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZSBpZiB0aGUgbmV3IHBhdGggYWxyZWFkeSBleGlzdHNcbiAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub3QgZmF0YWxcbiAgICAgICAgfVxuICAgICAgICAvLyBlYXJseSBvdXQgaWYgbm90aGluZyBuZWVkcyB0byBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSdsbCBuZWVkIHRvIGRlbGV0ZSB0aGUgb2xkIGVudHJ5XG4gICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZWQgZGVsZXRlIHBlcm1pc3Npb25zIGlmIHdlJ2xsIGJlIG92ZXJ3cml0aW5nLlxuICAgICAgICAvLyBuZWVkIGNyZWF0ZSBwZXJtaXNzaW9ucyBpZiBuZXcgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgICAgICBlcnJDb2RlID0gbmV3X25vZGUgP1xuICAgICAgICAgIEZTLm1heURlbGV0ZShuZXdfZGlyLCBuZXdfbmFtZSwgaXNkaXIpIDpcbiAgICAgICAgICBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChvbGRfbm9kZSkgfHwgKG5ld19ub2RlICYmIEZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGFyZSBnb2luZyB0byBjaGFuZ2UgdGhlIHBhcmVudCwgY2hlY2sgd3JpdGUgcGVybWlzc2lvbnNcbiAgICAgICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHtcbiAgICAgICAgICBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKG9sZF9kaXIsICd3Jyk7XG4gICAgICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgbG9va3VwIGhhc2hcbiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO1xuICAgICAgICAvLyBkbyB0aGUgdW5kZXJseWluZyBmcyByZW5hbWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZShvbGRfbm9kZSwgbmV3X2RpciwgbmV3X25hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBhZGQgdGhlIG5vZGUgYmFjayB0byB0aGUgaGFzaCAoaW4gY2FzZSBub2RlX29wcy5yZW5hbWVcbiAgICAgICAgICAvLyBjaGFuZ2VkIGl0cyBuYW1lKVxuICAgICAgICAgIEZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSxybWRpcjoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnJtZGlyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkZGlyOihwYXRoKSA9PiB7XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMucmVhZGRpcikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5yZWFkZGlyKG5vZGUpO1xuICAgICAgfSx1bmxpbms6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgdmFyIGVyckNvZGUgPSBGUy5tYXlEZWxldGUocGFyZW50LCBuYW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIFBPU0lYLCB3ZSBzaG91bGQgbWFwIEVJU0RJUiB0byBFUEVSTSwgYnV0XG4gICAgICAgICAgLy8gd2UgaW5zdGVhZCBkbyB3aGF0IExpbnV4IGRvZXMgKGFuZCB3ZSBtdXN0LCBhcyB3ZSB1c2VcbiAgICAgICAgICAvLyB0aGUgbXVzbCBsaW51eCBsaWJjKS5cbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy51bmxpbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICAgICAgfSxyZWFkbGluazoocGF0aCkgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICAgICAgdmFyIGxpbmsgPSBsb29rdXAubm9kZTtcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluay5ub2RlX29wcy5yZWFkbGluaykge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUEFUSF9GUy5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLCBsaW5rLm5vZGVfb3BzLnJlYWRsaW5rKGxpbmspKTtcbiAgICAgIH0sc3RhdDoocGF0aCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpO1xuICAgICAgfSxsc3RhdDoocGF0aCkgPT4ge1xuICAgICAgICByZXR1cm4gRlMuc3RhdChwYXRoLCB0cnVlKTtcbiAgICAgIH0sY2htb2Q6KHBhdGgsIG1vZGUsIGRvbnRGb2xsb3cpID0+IHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHtcbiAgICAgICAgICBtb2RlOiAobW9kZSAmIDQwOTUpIHwgKG5vZGUubW9kZSAmIH40MDk1KSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG1vZDoocGF0aCwgbW9kZSkgPT4ge1xuICAgICAgICBGUy5jaG1vZChwYXRoLCBtb2RlLCB0cnVlKTtcbiAgICAgIH0sZmNobW9kOihmZCwgbW9kZSkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG1vZChzdHJlYW0ubm9kZSwgbW9kZSk7XG4gICAgICB9LGNob3duOihwYXRoLCB1aWQsIGdpZCwgZG9udEZvbGxvdykgPT4ge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIC8vIHdlIGlnbm9yZSB0aGUgdWlkIC8gZ2lkIGZvciBub3dcbiAgICAgICAgfSk7XG4gICAgICB9LGxjaG93bjoocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpO1xuICAgICAgfSxmY2hvd246KGZkLCB1aWQsIGdpZCkgPT4ge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jaG93bihzdHJlYW0ubm9kZSwgdWlkLCBnaWQpO1xuICAgICAgfSx0cnVuY2F0ZToocGF0aCwgbGVuKSA9PiB7XG4gICAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCAndycpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgc2l6ZTogbGVuLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICB9KTtcbiAgICAgIH0sZnRydW5jYXRlOihmZCwgbGVuKSA9PiB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7XG4gICAgICB9LHV0aW1lOihwYXRoLCBhdGltZSwgbXRpbWUpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7XG4gICAgICAgICAgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSxvcGVuOihwYXRoLCBmbGFncywgbW9kZSwgZmRfc3RhcnQsIGZkX2VuZCkgPT4ge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IHR5cGVvZiBmbGFncyA9PSAnc3RyaW5nJyA/IEZTLm1vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKSA6IGZsYWdzO1xuICAgICAgICBtb2RlID0gdHlwZW9mIG1vZGUgPT0gJ3VuZGVmaW5lZCcgPyA0MzggLyogMDY2NiAqLyA6IG1vZGU7XG4gICAgICAgIGlmICgoZmxhZ3MgJiA2NCkpIHtcbiAgICAgICAgICBtb2RlID0gKG1vZGUgJiA0MDk1KSB8IDMyNzY4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBub2RlID0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHtcbiAgICAgICAgICAgICAgZm9sbG93OiAhKGZsYWdzICYgMTMxMDcyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBlcmhhcHMgd2UgbmVlZCB0byBjcmVhdGUgdGhlIG5vZGVcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKChmbGFncyAmIDY0KSkge1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAvLyBpZiBPX0NSRUFUIGFuZCBPX0VYQ0wgYXJlIHNldCwgZXJyb3Igb3V0IGlmIHRoZSBub2RlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMTI4KSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vZGUgZG9lc24ndCBleGlzdCwgdHJ5IHRvIGNyZWF0ZSBpdFxuICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApO1xuICAgICAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW4ndCB0cnVuY2F0ZSBhIGRldmljZVxuICAgICAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgICAgIGZsYWdzICY9IH41MTI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYXNrZWQgb25seSBmb3IgYSBkaXJlY3RvcnksIHRoZW4gdGhpcyBtdXN0IGJlIG9uZVxuICAgICAgICBpZiAoKGZsYWdzICYgNjU1MzYpICYmICFGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHBlcm1pc3Npb25zLCBpZiB0aGlzIGlzIG5vdCBhIGZpbGUgd2UganVzdCBjcmVhdGVkIG5vdyAoaXQgaXMgb2sgdG9cbiAgICAgICAgLy8gY3JlYXRlIGFuZCB3cml0ZSB0byBhIGZpbGUgd2l0aCByZWFkLW9ubHkgcGVybWlzc2lvbnM7IGl0IGlzIHJlYWQtb25seVxuICAgICAgICAvLyBmb3IgbGF0ZXIgdXNlKVxuICAgICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gdHJ1bmNhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKChmbGFncyAmIDUxMikpIHtcbiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlc2UsIGRvbid0IHBhc3MgZG93biB0byB0aGUgdW5kZXJseWluZyB2ZnNcbiAgICAgICAgZmxhZ3MgJj0gfigxMjggfCA1MTIgfCAxMzEwNzIpO1xuICBcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIHN0cmVhbSB3aXRoIHRoZSBmaWxlc3lzdGVtXG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgcGF0aDogRlMuZ2V0UGF0aChub2RlKSwgIC8vIHdlIHdhbnQgdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIG5vZGVcbiAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgc2Vla2FibGU6IHRydWUsXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgc3RyZWFtX29wczogbm9kZS5zdHJlYW1fb3BzLFxuICAgICAgICAgIC8vIHVzZWQgYnkgdGhlIGZpbGUgZmFtaWx5IGxpYmMgY2FsbHMgKGZvcGVuLCBmd3JpdGUsIGZlcnJvciwgZXRjLilcbiAgICAgICAgICB1bmdvdHRlbjogW10sXG4gICAgICAgICAgZXJyb3I6IGZhbHNlXG4gICAgICAgIH0sIGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgICAgICAvLyBjYWxsIHRoZSBuZXcgc3RyZWFtJ3Mgb3BlbiBmdW5jdGlvblxuICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHtcbiAgICAgICAgICBpZiAoIUZTLnJlYWRGaWxlcykgRlMucmVhZEZpbGVzID0ge307XG4gICAgICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxjbG9zZTooc3RyZWFtKSA9PiB7XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsgLy8gZnJlZSByZWFkZGlyIHN0YXRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5jbG9zZShzdHJlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRlMuY2xvc2VTdHJlYW0oc3RyZWFtLmZkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uZmQgPSBudWxsO1xuICAgICAgfSxpc0Nsb3NlZDooc3RyZWFtKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZmQgPT09IG51bGw7XG4gICAgICB9LGxsc2Vlazooc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgPT4ge1xuICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoZW5jZSAhPSAwICYmIHdoZW5jZSAhPSAxICYmIHdoZW5jZSAhPSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb3NpdGlvbiA9IHN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107XG4gICAgICAgIHJldHVybiBzdHJlYW0ucG9zaXRpb247XG4gICAgICB9LHJlYWQ6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgcG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IHN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgIH0sd3JpdGU6KHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgPT4ge1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgLy8gc2VlayB0byB0aGUgZW5kIGJlZm9yZSB3cml0aW5nIGluIGFwcGVuZCBtb2RlXG4gICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmICghc2Vla2luZykge1xuICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJlYW0uc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzV3JpdHRlbiA9IHN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bik7XG4gICAgICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICAgIH0sYWxsb2NhdGU6KHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBsZW5ndGggPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkgJiYgIUZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMzgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmFsbG9jYXRlKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfSxtbWFwOihzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSA9PiB7XG4gICAgICAgIC8vIFVzZXIgcmVxdWVzdHMgd3JpdGluZyB0byBmaWxlIChwcm90ICYgUFJPVF9XUklURSAhPSAwKS5cbiAgICAgICAgLy8gQ2hlY2tpbmcgaWYgd2UgaGF2ZSBwZXJtaXNzaW9ucyB0byB3cml0ZSB0byB0aGUgZmlsZSB1bmxlc3NcbiAgICAgICAgLy8gTUFQX1BSSVZBVEUgZmxhZyBpcyBzZXQuIEFjY29yZGluZyB0byBQT1NJWCBzcGVjIGl0IGlzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRvIHdyaXRlIHRvIGZpbGUgb3BlbmVkIGluIHJlYWQtb25seSBtb2RlIHdpdGggTUFQX1BSSVZBVEUgZmxhZyxcbiAgICAgICAgLy8gYXMgYWxsIG1vZGlmaWNhdGlvbnMgd2lsbCBiZSB2aXNpYmxlIG9ubHkgaW4gdGhlIG1lbW9yeSBvZlxuICAgICAgICAvLyB0aGUgY3VycmVudCBwcm9jZXNzLlxuICAgICAgICBpZiAoKHByb3QgJiAyKSAhPT0gMFxuICAgICAgICAgICAgJiYgKGZsYWdzICYgMikgPT09IDBcbiAgICAgICAgICAgICYmIChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLm1tYXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1tYXAoc3RyZWFtLCBhZGRyZXNzLCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncyk7XG4gICAgICB9LG1zeW5jOihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCAhc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpO1xuICAgICAgfSxtdW5tYXA6KHN0cmVhbSkgPT4gMCxpb2N0bDooc3RyZWFtLCBjbWQsIGFyZykgPT4ge1xuICAgICAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKTtcbiAgICAgIH0scmVhZEZpbGU6KHBhdGgsIG9wdHMgPSB7fSkgPT4ge1xuICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAwO1xuICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICd1dGY4JyAmJiBvcHRzLmVuY29kaW5nICE9PSAnYmluYXJ5Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJyArIG9wdHMuZW5jb2RpbmcgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzKTtcbiAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICAgICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTtcbiAgICAgICAgaWYgKG9wdHMuZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgICAgIHJldCA9IFVURjhBcnJheVRvU3RyaW5nKGJ1ZiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICAgICAgICByZXQgPSBidWY7XG4gICAgICAgIH1cbiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sd3JpdGVGaWxlOihwYXRoLCBkYXRhLCBvcHRzID0ge30pID0+IHtcbiAgICAgICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgNTc3O1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMub3BlbihwYXRoLCBvcHRzLmZsYWdzLCBvcHRzLm1vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpKzEpO1xuICAgICAgICAgIHZhciBhY3R1YWxOdW1CeXRlcyA9IHN0cmluZ1RvVVRGOEFycmF5KGRhdGEsIGJ1ZiwgMCwgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCwgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgfSxjd2Q6KCkgPT4gRlMuY3VycmVudFBhdGgsY2hkaXI6KHBhdGgpID0+IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7XG4gICAgICAgIGlmIChsb29rdXAubm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLCAneCcpO1xuICAgICAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gICAgICB9LGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczooKSA9PiB7XG4gICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvaG9tZScpO1xuICAgICAgICBGUy5ta2RpcignL2hvbWUvd2ViX3VzZXInKTtcbiAgICAgIH0sY3JlYXRlRGVmYXVsdERldmljZXM6KCkgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgL2RldlxuICAgICAgICBGUy5ta2RpcignL2RldicpO1xuICAgICAgICAvLyBzZXR1cCAvZGV2L251bGxcbiAgICAgICAgRlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLCAzKSwge1xuICAgICAgICAgIHJlYWQ6ICgpID0+IDAsXG4gICAgICAgICAgd3JpdGU6IChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgPT4gbGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAgICAgRlMubWtkZXYoJy9kZXYvbnVsbCcsIEZTLm1ha2VkZXYoMSwgMykpO1xuICAgICAgICAvLyBzZXR1cCAvZGV2L3R0eSBhbmQgL2Rldi90dHkxXG4gICAgICAgIC8vIHN0ZGVyciBuZWVkcyB0byBwcmludCBvdXRwdXQgdXNpbmcgZXJyKCkgcmF0aGVyIHRoYW4gb3V0KClcbiAgICAgICAgLy8gc28gd2UgcmVnaXN0ZXIgYSBzZWNvbmQgdHR5IGp1c3QgZm9yIGl0LlxuICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7XG4gICAgICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDYsIDApLCBUVFkuZGVmYXVsdF90dHkxX29wcyk7XG4gICAgICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7XG4gICAgICAgIC8vIHNldHVwIC9kZXYvW3VdcmFuZG9tXG4gICAgICAgIHZhciByYW5kb21fZGV2aWNlID0gZ2V0UmFuZG9tRGV2aWNlKCk7XG4gICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3VyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICAgICAgLy8gd2UncmUgbm90IGdvaW5nIHRvIGVtdWxhdGUgdGhlIGFjdHVhbCBzaG0gZGV2aWNlLFxuICAgICAgICAvLyBqdXN0IGNyZWF0ZSB0aGUgdG1wIGRpcnMgdGhhdCByZXNpZGUgaW4gaXQgY29tbW9ubHlcbiAgICAgICAgRlMubWtkaXIoJy9kZXYvc2htJyk7XG4gICAgICAgIEZTLm1rZGlyKCcvZGV2L3NobS90bXAnKTtcbiAgICAgIH0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOigpID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIC9wcm9jL3NlbGYvZmQgd2hpY2ggYWxsb3dzIC9wcm9jL3NlbGYvZmQvNiA9PiByZWFkbGluayBnaXZlcyB0aGVcbiAgICAgICAgLy8gbmFtZSBvZiB0aGUgc3RyZWFtIGZvciBmZCA2IChzZWUgdGVzdF91bmlzdGRfdHR5bmFtZSlcbiAgICAgICAgRlMubWtkaXIoJy9wcm9jJyk7XG4gICAgICAgIHZhciBwcm9jX3NlbGYgPSBGUy5ta2RpcignL3Byb2Mvc2VsZicpO1xuICAgICAgICBGUy5ta2RpcignL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgICBGUy5tb3VudCh7XG4gICAgICAgICAgbW91bnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhciBub2RlID0gRlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsICdmZCcsIDE2Mzg0IHwgNTExIC8qIDA3NzcgKi8sIDczKTtcbiAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICAgIGxvb2t1cDogKHBhcmVudCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBmZCA9ICtuYW1lO1xuICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgbW91bnQ6IHsgbW91bnRwb2ludDogJ2Zha2UnIH0sXG4gICAgICAgICAgICAgICAgICBub2RlX29wczogeyByZWFkbGluazogKCkgPT4gc3RyZWFtLnBhdGggfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7IC8vIG1ha2UgaXQgbG9vayBsaWtlIGEgc2ltcGxlIHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHt9LCAnL3Byb2Mvc2VsZi9mZCcpO1xuICAgICAgfSxjcmVhdGVTdGFuZGFyZFN0cmVhbXM6KCkgPT4ge1xuICAgICAgICAvLyBUT0RPIGRlcHJlY2F0ZSB0aGUgb2xkIGZ1bmN0aW9uYWxpdHkgb2YgYSBzaW5nbGVcbiAgICAgICAgLy8gaW5wdXQgLyBvdXRwdXQgY2FsbGJhY2sgYW5kIHRoYXQgdXRpbGl6ZXMgRlMuY3JlYXRlRGV2aWNlXG4gICAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlcXVpcmUgYSB1bmlxdWUgc2V0IG9mIHN0cmVhbSBvcHNcbiAgXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIHdlIHN5bWxpbmsgdGhlIHN0YW5kYXJkIHN0cmVhbXMgdG8gdGhlXG4gICAgICAgIC8vIGRlZmF1bHQgdHR5IGRldmljZXMuIGhvd2V2ZXIsIGlmIHRoZSBzdGFuZGFyZCBzdHJlYW1zXG4gICAgICAgIC8vIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiB3ZSBjcmVhdGUgYSB1bmlxdWUgZGV2aWNlIGZvclxuICAgICAgICAvLyB0aGVtIGluc3RlYWQuXG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGluJ10pIHtcbiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3RkaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTW9kdWxlWydzdGRvdXQnXSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdzdGRvdXQnLCBudWxsLCBNb2R1bGVbJ3N0ZG91dCddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZG91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3N0ZGVycicsIG51bGwsIE1vZHVsZVsnc3RkZXJyJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBvcGVuIGRlZmF1bHQgc3RyZWFtcyBmb3IgdGhlIHN0ZGluLCBzdGRvdXQgYW5kIHN0ZGVyciBkZXZpY2VzXG4gICAgICAgIHZhciBzdGRpbiA9IEZTLm9wZW4oJy9kZXYvc3RkaW4nLCAwKTtcbiAgICAgICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgMSk7XG4gICAgICAgIHZhciBzdGRlcnIgPSBGUy5vcGVuKCcvZGV2L3N0ZGVycicsIDEpO1xuICAgICAgICBhc3NlcnQoc3RkaW4uZmQgPT09IDAsICdpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW4gKCcgKyBzdGRpbi5mZCArICcpJyk7XG4gICAgICAgIGFzc2VydChzdGRvdXQuZmQgPT09IDEsICdpbnZhbGlkIGhhbmRsZSBmb3Igc3Rkb3V0ICgnICsgc3Rkb3V0LmZkICsgJyknKTtcbiAgICAgICAgYXNzZXJ0KHN0ZGVyci5mZCA9PT0gMiwgJ2ludmFsaWQgaGFuZGxlIGZvciBzdGRlcnIgKCcgKyBzdGRlcnIuZmQgKyAnKScpO1xuICAgICAgfSxlbnN1cmVFcnJub0Vycm9yOigpID0+IHtcbiAgICAgICAgaWYgKEZTLkVycm5vRXJyb3IpIHJldHVybjtcbiAgICAgICAgRlMuRXJybm9FcnJvciA9IC8qKiBAdGhpc3tPYmplY3R9ICovIGZ1bmN0aW9uIEVycm5vRXJyb3IoZXJybm8sIG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICAgIHRoaXMuc2V0RXJybm8gPSAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbihlcnJubykge1xuICAgICAgICAgICAgdGhpcy5lcnJubyA9IGVycm5vO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIEVSUk5PX0NPREVTKSB7XG4gICAgICAgICAgICAgIGlmIChFUlJOT19DT0RFU1trZXldID09PSBlcnJubykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29kZSA9IGtleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gRVJSTk9fTUVTU0FHRVNbZXJybm9dO1xuICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGEgbWF4aW1hbGx5IGhlbHBmdWwgc3RhY2sgdHJhY2UuIE9uIE5vZGUuanMsIGdldHRpbmcgRXJyb3Iuc3RhY2tcbiAgICAgICAgICAvLyBub3cgZW5zdXJlcyBpdCBzaG93cyB3aGF0IHdlIHdhbnQuXG4gICAgICAgICAgaWYgKHRoaXMuc3RhY2spIHtcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgc3RhY2sgcHJvcGVydHkgZm9yIE5vZGUuanMgNCwgd2hpY2ggb3RoZXJ3aXNlIGVycm9ycyBvbiB0aGUgbmV4dCBsaW5lLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogKG5ldyBFcnJvcikuc3RhY2ssIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGRlbWFuZ2xlQWxsKHRoaXMuc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGUy5FcnJub0Vycm9yO1xuICAgICAgICAvLyBTb21lIGVycm9ycyBtYXkgaGFwcGVuIHF1aXRlIGEgYml0LCB0byBhdm9pZCBvdmVyaGVhZCB3ZSByZXVzZSB0aGVtIChhbmQgc3VmZmVyIGEgbGFjayBvZiBzdGFjayBpbmZvKVxuICAgICAgICBbNDRdLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdID0gbmV3IEZTLkVycm5vRXJyb3IoY29kZSk7XG4gICAgICAgICAgRlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjayA9ICc8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+JztcbiAgICAgICAgfSk7XG4gICAgICB9LHN0YXRpY0luaXQ6KCkgPT4ge1xuICAgICAgICBGUy5lbnN1cmVFcnJub0Vycm9yKCk7XG4gIFxuICAgICAgICBGUy5uYW1lVGFibGUgPSBuZXcgQXJyYXkoNDA5Nik7XG4gIFxuICAgICAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7XG4gIFxuICAgICAgICBGUy5jcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTtcbiAgICAgICAgRlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7XG4gIFxuICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHtcbiAgICAgICAgICAnTUVNRlMnOiBNRU1GUyxcbiAgICAgICAgfTtcbiAgICAgIH0saW5pdDooaW5wdXQsIG91dHB1dCwgZXJyb3IpID0+IHtcbiAgICAgICAgYXNzZXJ0KCFGUy5pbml0LmluaXRpYWxpemVkLCAnRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKScpO1xuICAgICAgICBGUy5pbml0LmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgXG4gICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcbiAgXG4gICAgICAgIC8vIEFsbG93IE1vZHVsZS5zdGRpbiBldGMuIHRvIHByb3ZpZGUgZGVmYXVsdHMsIGlmIG5vbmUgZXhwbGljaXRseSBwYXNzZWQgdG8gdXMgaGVyZVxuICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgICAgIE1vZHVsZVsnc3Rkb3V0J10gPSBvdXRwdXQgfHwgTW9kdWxlWydzdGRvdXQnXTtcbiAgICAgICAgTW9kdWxlWydzdGRlcnInXSA9IGVycm9yIHx8IE1vZHVsZVsnc3RkZXJyJ107XG4gIFxuICAgICAgICBGUy5jcmVhdGVTdGFuZGFyZFN0cmVhbXMoKTtcbiAgICAgIH0scXVpdDooKSA9PiB7XG4gICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FsbCBtdXNsLWludGVybmFsIGZ1bmN0aW9uIHRvIGNsb3NlIGFsbCBzdGRpbyBzdHJlYW1zLCBzbyBub3RoaW5nIGlzXG4gICAgICAgIC8vIGxlZnQgaW4gaW50ZXJuYWwgYnVmZmVycy5cbiAgICAgICAgX19fc3RkaW9fZXhpdCgpO1xuICAgICAgICAvLyBjbG9zZSBhbGwgb2Ygb3VyIHN0cmVhbXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLnN0cmVhbXNbaV07XG4gICAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9LGdldE1vZGU6KGNhblJlYWQsIGNhbldyaXRlKSA9PiB7XG4gICAgICAgIHZhciBtb2RlID0gMDtcbiAgICAgICAgaWYgKGNhblJlYWQpIG1vZGUgfD0gMjkyIHwgNzM7XG4gICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7XG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgICAgfSxmaW5kT2JqZWN0OihwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSA9PiB7XG4gICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICAgICAgaWYgKHJldC5leGlzdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmV0Lm9iamVjdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxhbmFseXplUGF0aDoocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykgPT4ge1xuICAgICAgICAvLyBvcGVyYXRlIGZyb20gd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBzeW1saW5rJ3MgdGFyZ2V0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgaXNSb290OiBmYWxzZSwgZXhpc3RzOiBmYWxzZSwgZXJyb3I6IDAsIG5hbWU6IG51bGwsIHBhdGg6IG51bGwsIG9iamVjdDogbnVsbCxcbiAgICAgICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLCBwYXJlbnRQYXRoOiBudWxsLCBwYXJlbnRPYmplY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICByZXQucGFyZW50RXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICByZXQucGFyZW50UGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgICAgICByZXQubmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7XG4gICAgICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgcmV0LnBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgICAgICByZXQub2JqZWN0ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xuICAgICAgICAgIHJldC5pc1Jvb3QgPSBsb29rdXAucGF0aCA9PT0gJy8nO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0LmVycm9yID0gZS5lcnJubztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sY3JlYXRlUGF0aDoocGFyZW50LCBwYXRoLCBjYW5SZWFkLCBjYW5Xcml0ZSkgPT4ge1xuICAgICAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpO1xuICAgICAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gUEFUSC5qb2luMihwYXJlbnQsIHBhcnQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgRUVYSVNUXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9LGNyZWF0ZUZpbGU6KHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgICAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICByZXR1cm4gRlMuY3JlYXRlKHBhdGgsIG1vZGUpO1xuICAgICAgfSxjcmVhdGVEYXRhRmlsZToocGFyZW50LCBuYW1lLCBkYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gbmFtZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7XG4gICAgICAgICAgcGF0aCA9IG5hbWUgPyBQQVRILmpvaW4yKHBhcmVudCwgbmFtZSkgOiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTtcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBkYXRhID0gYXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY2FuIHdyaXRlIHRvIHRoZSBmaWxlXG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSB8IDE0Nik7XG4gICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgNTc3KTtcbiAgICAgICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZURldmljZToocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTtcbiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKCEhaW5wdXQsICEhb3V0cHV0KTtcbiAgICAgICAgaWYgKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpIEZTLmNyZWF0ZURldmljZS5tYWpvciA9IDY0O1xuICAgICAgICB2YXIgZGV2ID0gRlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywgMCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIGZha2UgZGV2aWNlIHRoYXQgYSBzZXQgb2Ygc3RyZWFtIG9wcyB0byBlbXVsYXRlXG4gICAgICAgIC8vIHRoZSBvbGQgYmVoYXZpb3IuXG4gICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwge1xuICAgICAgICAgIG9wZW46IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2U6IChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgIC8vIGZsdXNoIGFueSBwZW5kaW5nIGxpbmUgZGF0YVxuICAgICAgICAgICAgaWYgKG91dHB1dCAmJiBvdXRwdXQuYnVmZmVyICYmIG91dHB1dC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG91dHB1dCgxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWFkOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MgLyogaWdub3JlZCAqLykgPT4ge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgJiYgYnl0ZXNSZWFkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0K2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkge1xuICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlOiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBGUy5ta2RldihwYXRoLCBtb2RlLCBkZXYpO1xuICAgICAgfSxmb3JjZUxvYWRGaWxlOihvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5pc0RldmljZSB8fCBvYmouaXNGb2xkZXIgfHwgb2JqLmxpbmsgfHwgb2JqLmNvbnRlbnRzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkXykge1xuICAgICAgICAgIC8vIENvbW1hbmQtbGluZS5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV0FSTklORzogQ2FuJ3QgcmVhZCBiaW5hcnkgZmlsZXMgaW4gVjgncyBkOCBvciB0cmFjZW1vbmtleSdzIGpzLCBhc1xuICAgICAgICAgICAgLy8gICAgICAgICAgcmVhZCgpIHdpbGwgdHJ5IHRvIHBhcnNlIFVURjguXG4gICAgICAgICAgICBvYmouY29udGVudHMgPSBpbnRBcnJheUZyb21TdHJpbmcocmVhZF8ob2JqLnVybCksIHRydWUpO1xuICAgICAgICAgICAgb2JqLnVzZWRCeXRlcyA9IG9iai5jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LicpO1xuICAgICAgICB9XG4gICAgICB9LGNyZWF0ZUxhenlGaWxlOihwYXJlbnQsIG5hbWUsIHVybCwgY2FuUmVhZCwgY2FuV3JpdGUpID0+IHtcbiAgICAgICAgLy8gTGF6eSBjaHVua2VkIFVpbnQ4QXJyYXkgKGltcGxlbWVudHMgZ2V0IGFuZCBsZW5ndGggZnJvbSBVaW50OEFycmF5KS4gQWN0dWFsIGdldHRpbmcgaXMgYWJzdHJhY3RlZCBhd2F5IGZvciBldmVudHVhbCByZXVzZS5cbiAgICAgICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgICAgICBmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsgLy8gTG9hZGVkIGNodW5rcy4gSW5kZXggaXMgdGhlIGNodW5rIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICAgICAgaWYgKGlkeCA+IHRoaXMubGVuZ3RoLTEgfHwgaWR4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNodW5rT2Zmc2V0ID0gaWR4ICUgdGhpcy5jaHVua1NpemU7XG4gICAgICAgICAgdmFyIGNodW5rTnVtID0gKGlkeCAvIHRoaXMuY2h1bmtTaXplKXwwO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5VWludDhBcnJheS5wcm90b3R5cGUuc2V0RGF0YUdldHRlciA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgICAgdGhpcy5nZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aCA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoKCkge1xuICAgICAgICAgIC8vIEZpbmQgbGVuZ3RoXG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgdXJsLCBmYWxzZSk7XG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgaWYgKCEoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiICsgdXJsICsgXCIuIFN0YXR1czogXCIgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgICB2YXIgZGF0YWxlbmd0aCA9IE51bWJlcih4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LWxlbmd0aFwiKSk7XG4gICAgICAgICAgdmFyIGhlYWRlcjtcbiAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkgJiYgaGVhZGVyID09PSBcImJ5dGVzXCI7XG4gICAgICAgICAgdmFyIHVzZXNHemlwID0gKGhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikpICYmIGhlYWRlciA9PT0gXCJnemlwXCI7XG4gIFxuICAgICAgICAgIHZhciBjaHVua1NpemUgPSAxMDI0KjEwMjQ7IC8vIENodW5rIHNpemUgaW4gYnl0ZXNcbiAgXG4gICAgICAgICAgaWYgKCFoYXNCeXRlU2VydmluZykgY2h1bmtTaXplID0gZGF0YWxlbmd0aDtcbiAgXG4gICAgICAgICAgLy8gRnVuY3Rpb24gdG8gZ2V0IGEgcmFuZ2UgZnJvbSB0aGUgcmVtb3RlIFVSTC5cbiAgICAgICAgICB2YXIgZG9YSFIgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gdG8pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiICsgZnJvbSArIFwiLCBcIiArIHRvICsgXCIpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCFcIik7XG4gICAgICAgICAgICBpZiAodG8gPiBkYXRhbGVuZ3RoLTEpIHRocm93IG5ldyBFcnJvcihcIm9ubHkgXCIgKyBkYXRhbGVuZ3RoICsgXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiKTtcbiAgXG4gICAgICAgICAgICAvLyBUT0RPOiBVc2UgbW96UmVzcG9uc2VBcnJheUJ1ZmZlciwgcmVzcG9uc2VTdHJlYW0sIGV0Yy4gaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGRhdGFsZW5ndGggIT09IGNodW5rU2l6ZSkgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiICsgZnJvbSArIFwiLVwiICsgdG8pO1xuICBcbiAgICAgICAgICAgIC8vIFNvbWUgaGludHMgdG8gdGhlIGJyb3dzZXIgdGhhdCB3ZSB3YW50IGJpbmFyeSBkYXRhLlxuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICBpZiAoeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcbiAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgIGlmICghKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDAgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArIFwiLiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZXtBcnJheTxudW1iZXI+fSAqLyh4aHIucmVzcG9uc2UgfHwgW10pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dCB8fCAnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpcztcbiAgICAgICAgICBsYXp5QXJyYXkuc2V0RGF0YUdldHRlcigoY2h1bmtOdW0pID0+IHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNodW5rTnVtICogY2h1bmtTaXplO1xuICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSsxKSAqIGNodW5rU2l6ZSAtIDE7IC8vIGluY2x1ZGluZyB0aGlzIGJ5dGVcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgZGF0YWxlbmd0aC0xKTsgLy8gaWYgZGF0YWxlbmd0aC0xIGlzIHNlbGVjdGVkLCB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID0gZG9YSFIoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RvWEhSIGZhaWxlZCEnKTtcbiAgICAgICAgICAgIHJldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXTtcbiAgICAgICAgICB9KTtcbiAgXG4gICAgICAgICAgaWYgKHVzZXNHemlwIHx8ICFkYXRhbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgc2VydmVyIHVzZXMgZ3ppcCBvciBkb2Vzbid0IHN1cHBseSB0aGUgbGVuZ3RoLCB3ZSBoYXZlIHRvIGRvd25sb2FkIHRoZSB3aG9sZSBmaWxlIHRvIGdldCB0aGUgKHVuY29tcHJlc3NlZCkgbGVuZ3RoXG4gICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoID0gMTsgLy8gdGhpcyB3aWxsIGZvcmNlIGdldHRlcigwKS9kb1hIUiBkbyBkb3dubG9hZCB0aGUgd2hvbGUgZmlsZVxuICAgICAgICAgICAgZGF0YWxlbmd0aCA9IHRoaXMuZ2V0dGVyKDApLmxlbmd0aDtcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgICAgICBvdXQoXCJMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWRcIik7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICAgICAgICB0aGlzLmxlbmd0aEtub3duID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYyc7XG4gICAgICAgICAgdmFyIGxhenlBcnJheSA9IG5ldyBMYXp5VWludDhBcnJheSgpO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICAgIGdldDogLyoqIEB0aGlze09iamVjdH0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaHVua1NpemU6IHtcbiAgICAgICAgICAgICAgZ2V0OiAvKiogQHRoaXN7T2JqZWN0fSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCBjb250ZW50czogbGF6eUFycmF5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgdG90YWwgaGFjaywgYnV0IEkgd2FudCB0byBnZXQgdGhpcyBsYXp5IGZpbGUgY29kZSBvdXQgb2YgdGhlXG4gICAgICAgIC8vIGNvcmUgb2YgTUVNRlMuIElmIHdlIHdhbnQgdG8ga2VlcCB0aGlzIGxhenkgZmlsZSBjb25jZXB0IEkgZmVlbCBpdCBzaG91bGRcbiAgICAgICAgLy8gYmUgaXRzIG93biB0aGluIExBWllGUyBwcm94eWluZyBjYWxscyB0byBNRU1GUy5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuY29udGVudHMpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gcHJvcGVydGllcy5jb250ZW50cztcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLnVybCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgIG5vZGUudXJsID0gcHJvcGVydGllcy51cmw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgZnVuY3Rpb24gdGhhdCBkZWZlcnMgcXVlcnlpbmcgdGhlIGZpbGUgc2l6ZSB1bnRpbCBpdCBpcyBhc2tlZCB0aGUgZmlyc3QgdGltZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwge1xuICAgICAgICAgIHVzZWRCeXRlczoge1xuICAgICAgICAgICAgZ2V0OiAvKiogQHRoaXMge0ZTTm9kZX0gKi8gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG92ZXJyaWRlIGVhY2ggc3RyZWFtIG9wIHdpdGggb25lIHRoYXQgdHJpZXMgdG8gZm9yY2UgbG9hZCB0aGUgbGF6eSBmaWxlIGZpcnN0XG4gICAgICAgIHZhciBzdHJlYW1fb3BzID0ge307XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICB2YXIgZm4gPSBub2RlLnN0cmVhbV9vcHNba2V5XTtcbiAgICAgICAgICBzdHJlYW1fb3BzW2tleV0gPSBmdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpIHtcbiAgICAgICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXNlIGEgY3VzdG9tIHJlYWQgZnVuY3Rpb25cbiAgICAgICAgc3RyZWFtX29wcy5yZWFkID0gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICBGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO1xuICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBjb250ZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKGNvbnRlbnRzLmxlbmd0aCAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgICAgIGFzc2VydChzaXplID49IDApO1xuICAgICAgICAgIGlmIChjb250ZW50cy5zbGljZSkgeyAvLyBub3JtYWwgYXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7IC8vIExhenlVaW50OEFycmF5IGZyb20gc3luYyBiaW5hcnkgWEhSXG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzLmdldChwb3NpdGlvbiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gc3RyZWFtX29wcztcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9LGNyZWF0ZVByZWxvYWRlZEZpbGU6KHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSwgb25sb2FkLCBvbmVycm9yLCBkb250Q3JlYXRlRmlsZSwgY2FuT3duLCBwcmVGaW5pc2gpID0+IHtcbiAgICAgICAgLy8gVE9ETyB3ZSBzaG91bGQgYWxsb3cgcGVvcGxlIHRvIGp1c3QgcGFzcyBpbiBhIGNvbXBsZXRlIGZpbGVuYW1lIGluc3RlYWRcbiAgICAgICAgLy8gb2YgcGFyZW50IGFuZCBuYW1lIGJlaW5nIHRoYXQgd2UganVzdCBqb2luIHRoZW0gYW55d2F5c1xuICAgICAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSF9GUy5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7XG4gICAgICAgIHZhciBkZXAgPSBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KCdjcCAnICsgZnVsbG5hbWUpOyAvLyBtaWdodCBoYXZlIHNldmVyYWwgYWN0aXZlIHJlcXVlc3RzIGZvciB0aGUgc2FtZSBmdWxsbmFtZVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHtcbiAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAocHJlRmluaXNoKSBwcmVGaW5pc2goKTtcbiAgICAgICAgICAgIGlmICghZG9udENyZWF0ZUZpbGUpIHtcbiAgICAgICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUocGFyZW50LCBuYW1lLCBieXRlQXJyYXksIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ubG9hZCkgb25sb2FkKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChCcm93c2VyLmhhbmRsZWRCeVByZWxvYWRQbHVnaW4oYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob25lcnJvcikgb25lcnJvcigpO1xuICAgICAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmlzaChieXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJ1bkRlcGVuZGVuY3koZGVwKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhc3luY0xvYWQodXJsLCAoYnl0ZUFycmF5KSA9PiBwcm9jZXNzRGF0YShieXRlQXJyYXkpLCBvbmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzRGF0YSh1cmwpO1xuICAgICAgICB9XG4gICAgICB9LGluZGV4ZWREQjooKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93LndlYmtpdEluZGV4ZWREQiB8fCB3aW5kb3cubXNJbmRleGVkREI7XG4gICAgICB9LERCX05BTUU6KCkgPT4ge1xuICAgICAgICByZXR1cm4gJ0VNX0ZTXycgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB9LERCX1ZFUlNJT046MjAsREJfU1RPUkVfTkFNRTpcIkZJTEVfREFUQVwiLHNhdmVGaWxlc1RvREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgICAgIG91dCgnY3JlYXRpbmcgZGInKTtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7XG4gICAgICAgICAgdmFyIGZpbGVzID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgdmFyIG9rID0gMCwgZmFpbCA9IDAsIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpOyBlbHNlIG9uZXJyb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aHMuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBmaWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLCBwYXRoKTtcbiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4geyBvaysrOyBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKSB9O1xuICAgICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gKCkgPT4geyBmYWlsKys7IGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICAgICAgfSxsb2FkRmlsZXNGcm9tREI6KHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8ICgoKSA9PiB7fSk7XG4gICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIG9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjsgLy8gbm8gZGF0YWJhc2UgdG8gbG9hZCBmcm9tXG4gICAgICAgIG9wZW5SZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgICAgICB2YXIgb2sgPSAwLCBmYWlsID0gMCwgdG90YWwgPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7IGVsc2Ugb25lcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTtcbiAgICAgICAgICAgIGdldFJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgRlMudW5saW5rKHBhdGgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFBBVEguZGlybmFtZShwYXRoKSwgUEFUSC5iYXNlbmFtZShwYXRoKSwgZ2V0UmVxdWVzdC5yZXN1bHQsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICBvaysrO1xuICAgICAgICAgICAgICBpZiAob2sgKyBmYWlsID09IHRvdGFsKSBmaW5pc2goKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnZXRSZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7IGZhaWwrKzsgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCkgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7XG4gICAgICB9LGFic29sdXRlUGF0aDooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5hYnNvbHV0ZVBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEhfRlMucmVzb2x2ZSBpbnN0ZWFkJyk7XG4gICAgICB9LGNyZWF0ZUZvbGRlcjooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVGb2xkZXIgaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIEZTLm1rZGlyIGluc3RlYWQnKTtcbiAgICAgIH0sY3JlYXRlTGluazooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5jcmVhdGVMaW5rIGhhcyBiZWVuIHJlbW92ZWQ7IHVzZSBGUy5zeW1saW5rIGluc3RlYWQnKTtcbiAgICAgIH0sam9pblBhdGg6KCkgPT4ge1xuICAgICAgICBhYm9ydCgnRlMuam9pblBhdGggaGFzIGJlZW4gcmVtb3ZlZDsgdXNlIFBBVEguam9pbiBpbnN0ZWFkJyk7XG4gICAgICB9LG1tYXBBbGxvYzooKSA9PiB7XG4gICAgICAgIGFib3J0KCdGUy5tbWFwQWxsb2MgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiBtbWFwQWxsb2MnKTtcbiAgICAgIH0sc3RhbmRhcmRpemVQYXRoOigpID0+IHtcbiAgICAgICAgYWJvcnQoJ0ZTLnN0YW5kYXJkaXplUGF0aCBoYXMgYmVlbiByZW1vdmVkOyB1c2UgUEFUSC5ub3JtYWxpemUgaW5zdGVhZCcpO1xuICAgICAgfX07XG4gIHZhciBTWVNDQUxMUyA9IHtERUZBVUxUX1BPTExNQVNLOjUsY2FsY3VsYXRlQXQ6ZnVuY3Rpb24oZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpIHtcbiAgICAgICAgaWYgKHBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbGF0aXZlIHBhdGhcbiAgICAgICAgdmFyIGRpcjtcbiAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7XG4gICAgICAgICAgZGlyID0gRlMuY3dkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IEZTLmdldFN0cmVhbShkaXJmZCk7XG4gICAgICAgICAgaWYgKCFkaXJzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICAgIGRpciA9IGRpcnN0cmVhbS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQQVRILmpvaW4yKGRpciwgcGF0aCk7XG4gICAgICB9LGRvU3RhdDpmdW5jdGlvbihmdW5jLCBwYXRoLCBidWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RhdCA9IGZ1bmMocGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLm5vZGUgJiYgUEFUSC5ub3JtYWxpemUocGF0aCkgIT09IFBBVEgubm9ybWFsaXplKEZTLmdldFBhdGgoZS5ub2RlKSkpIHtcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHRyeWluZyB0byBsb29rIHVwIHRoZSBwYXRoOyB3ZSBzaG91bGQganVzdCByZXBvcnQgRU5PVERJUlxuICAgICAgICAgICAgcmV0dXJuIC01NDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKChidWYpPj4yKV0gPSBzdGF0LmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDQpKT4+MildID0gMDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDgpKT4+MildID0gc3RhdC5pbm87XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygxMikpPj4yKV0gPSBzdGF0Lm1vZGU7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygxNikpPj4yKV0gPSBzdGF0Lm5saW5rO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoMjApKT4+MildID0gc3RhdC51aWQ7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKygyNCkpPj4yKV0gPSBzdGF0LmdpZDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDI4KSk+PjIpXSA9IHN0YXQucmRldjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDMyKSk+PjIpXSA9IDA7XG4gICAgICAgICh0ZW1wSTY0ID0gW3N0YXQuc2l6ZT4+PjAsKHRlbXBEb3VibGU9c3RhdC5zaXplLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGJ1ZikrKDQwKSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGJ1ZikrKDQ0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNDgpKT4+MildID0gNDA5NjtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDUyKSk+PjIpXSA9IHN0YXQuYmxvY2tzO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNTYpKT4+MildID0gKHN0YXQuYXRpbWUuZ2V0VGltZSgpIC8gMTAwMCl8MDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDYwKSk+PjIpXSA9IDA7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg2NCkpPj4yKV0gPSAoc3RhdC5tdGltZS5nZXRUaW1lKCkgLyAxMDAwKXwwO1xuICAgICAgICBIRUFQMzJbKCgoYnVmKSsoNjgpKT4+MildID0gMDtcbiAgICAgICAgSEVBUDMyWygoKGJ1ZikrKDcyKSk+PjIpXSA9IChzdGF0LmN0aW1lLmdldFRpbWUoKSAvIDEwMDApfDA7XG4gICAgICAgIEhFQVAzMlsoKChidWYpKyg3NikpPj4yKV0gPSAwO1xuICAgICAgICAodGVtcEk2NCA9IFtzdGF0Lmlubz4+PjAsKHRlbXBEb3VibGU9c3RhdC5pbm8sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgoYnVmKSsoODApKT4+MildID0gdGVtcEk2NFswXSxIRUFQMzJbKCgoYnVmKSsoODQpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxkb01zeW5jOmZ1bmN0aW9uKGFkZHIsIHN0cmVhbSwgbGVuLCBmbGFncywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBIRUFQVTguc2xpY2UoYWRkciwgYWRkciArIGxlbik7XG4gICAgICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICAgICAgfSxkb01rZGlyOmZ1bmN0aW9uKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGEgdHJhaWxpbmcgc2xhc2gsIGlmIG9uZSAtIC9hL2IvIGhhcyBiYXNlbmFtZSBvZiAnJywgYnV0XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY3JlYXRlIGIgaW4gdGhlIGNvbnRleHQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoLTFdID09PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aC0xKTtcbiAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxkb01rbm9kOmZ1bmN0aW9uKHBhdGgsIG1vZGUsIGRldikge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoaXMgaW4gdGhlIEpTIEFQSSBhcyBpdCB1c2VzIG1rbm9kIHRvIGNyZWF0ZSBhbGwgbm9kZXMuXG4gICAgICAgIHN3aXRjaCAobW9kZSAmIDYxNDQwKSB7XG4gICAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgICAgY2FzZSAyNDU3NjpcbiAgICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgICAgY2FzZSA0OTE1MjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiAtMjg7XG4gICAgICAgIH1cbiAgICAgICAgRlMubWtub2QocGF0aCwgbW9kZSwgZGV2KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LGRvUmVhZGxpbms6ZnVuY3Rpb24ocGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgICAgIGlmIChidWZzaXplIDw9IDApIHJldHVybiAtMjg7XG4gICAgICAgIHZhciByZXQgPSBGUy5yZWFkbGluayhwYXRoKTtcbiAgXG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihidWZzaXplLCBsZW5ndGhCeXRlc1VURjgocmV0KSk7XG4gICAgICAgIHZhciBlbmRDaGFyID0gSEVBUDhbYnVmK2xlbl07XG4gICAgICAgIHN0cmluZ1RvVVRGOChyZXQsIGJ1ZiwgYnVmc2l6ZSsxKTtcbiAgICAgICAgLy8gcmVhZGxpbmsgaXMgb25lIG9mIHRoZSByYXJlIGZ1bmN0aW9ucyB0aGF0IHdyaXRlIG91dCBhIEMgc3RyaW5nLCBidXQgZG9lcyBuZXZlciBhcHBlbmQgYSBudWxsIHRvIHRoZSBvdXRwdXQgYnVmZmVyKCEpXG4gICAgICAgIC8vIHN0cmluZ1RvVVRGOCgpIGFsd2F5cyBhcHBlbmRzIGEgbnVsbCBieXRlLCBzbyByZXN0b3JlIHRoZSBjaGFyYWN0ZXIgdW5kZXIgdGhlIG51bGwgYnl0ZSBhZnRlciB0aGUgd3JpdGUuXG4gICAgICAgIEhFQVA4W2J1ZitsZW5dID0gZW5kQ2hhcjtcbiAgXG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICB9LGRvQWNjZXNzOmZ1bmN0aW9uKHBhdGgsIGFtb2RlKSB7XG4gICAgICAgIGlmIChhbW9kZSAmIH43KSB7XG4gICAgICAgICAgLy8gbmVlZCBhIHZhbGlkIG1vZGVcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gLTQ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwZXJtcyA9ICcnO1xuICAgICAgICBpZiAoYW1vZGUgJiA0KSBwZXJtcyArPSAncic7XG4gICAgICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnO1xuICAgICAgICBpZiAocGVybXMgLyogb3RoZXJ3aXNlLCB0aGV5J3ZlIGp1c3QgcGFzc2VkIEZfT0sgKi8gJiYgRlMubm9kZVBlcm1pc3Npb25zKG5vZGUsIHBlcm1zKSkge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sZG9SZWFkdjpmdW5jdGlvbihzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgICAgICB2YXIgcHRyID0gSEVBUDMyWygoKGlvdikrKGkqOCkpPj4yKV07XG4gICAgICAgICAgdmFyIGxlbiA9IEhFQVAzMlsoKChpb3YpKyhpKjggKyA0KSk+PjIpXTtcbiAgICAgICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCxwdHIsIGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgICAgICByZXQgKz0gY3VycjtcbiAgICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWs7IC8vIG5vdGhpbmcgbW9yZSB0byByZWFkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZG9Xcml0ZXY6ZnVuY3Rpb24oc3RyZWFtLCBpb3YsIGlvdmNudCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHB0ciA9IEhFQVAzMlsoKChpb3YpKyhpKjgpKT4+MildO1xuICAgICAgICAgIHZhciBsZW4gPSBIRUFQMzJbKCgoaW92KSsoaSo4ICsgNCkpPj4yKV07XG4gICAgICAgICAgdmFyIGN1cnIgPSBGUy53cml0ZShzdHJlYW0sIEhFQVA4LHB0ciwgbGVuLCBvZmZzZXQpO1xuICAgICAgICAgIGlmIChjdXJyIDwgMCkgcmV0dXJuIC0xO1xuICAgICAgICAgIHJldCArPSBjdXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LHZhcmFyZ3M6dW5kZWZpbmVkLGdldDpmdW5jdGlvbigpIHtcbiAgICAgICAgYXNzZXJ0KFNZU0NBTExTLnZhcmFyZ3MgIT0gdW5kZWZpbmVkKTtcbiAgICAgICAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWygoKFNZU0NBTExTLnZhcmFyZ3MpLSg0KSk+PjIpXTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sZ2V0U3RyOmZ1bmN0aW9uKHB0cikge1xuICAgICAgICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LGdldFN0cmVhbUZyb21GRDpmdW5jdGlvbihmZCkge1xuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxnZXQ2NDpmdW5jdGlvbihsb3csIGhpZ2gpIHtcbiAgICAgICAgaWYgKGxvdyA+PSAwKSBhc3NlcnQoaGlnaCA9PT0gMCk7XG4gICAgICAgIGVsc2UgYXNzZXJ0KGhpZ2ggPT09IC0xKTtcbiAgICAgICAgcmV0dXJuIGxvdztcbiAgICAgIH19O1xuICBmdW5jdGlvbiBfX19zeXNjYWxsX19uZXdzZWxlY3QobmZkcywgcmVhZGZkcywgd3JpdGVmZHMsIGV4Y2VwdGZkcywgdGltZW91dCkge1xuICB0cnkge1xuICBcbiAgICAgIC8vIHJlYWRmZHMgYXJlIHN1cHBvcnRlZCxcbiAgICAgIC8vIHdyaXRlZmRzIGNoZWNrcyBzb2NrZXQgb3BlbiBzdGF0dXNcbiAgICAgIC8vIGV4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkXG4gICAgICAvLyB0aW1lb3V0IGlzIGFsd2F5cyAwIC0gZnVsbHkgYXN5bmNcbiAgICAgIGFzc2VydChuZmRzIDw9IDY0LCAnbmZkcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2NCcpOyAgLy8gZmQgc2V0cyBoYXZlIDY0IGJpdHMgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSAxMDI0IGJhc2VkIG9uIGN1cnJlbnQgbXVzbCBoZWFkZXJzXG4gICAgICBhc3NlcnQoIWV4Y2VwdGZkcywgJ2V4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkJyk7XG4gIFxuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIFxuICAgICAgdmFyIHNyY1JlYWRMb3cgPSAocmVhZGZkcyA/IEhFQVAzMlsoKHJlYWRmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNSZWFkSGlnaCA9IChyZWFkZmRzID8gSEVBUDMyWygoKHJlYWRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICAgICAgdmFyIHNyY1dyaXRlTG93ID0gKHdyaXRlZmRzID8gSEVBUDMyWygod3JpdGVmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNXcml0ZUhpZ2ggPSAod3JpdGVmZHMgPyBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA6IDApO1xuICAgICAgdmFyIHNyY0V4Y2VwdExvdyA9IChleGNlcHRmZHMgPyBIRUFQMzJbKChleGNlcHRmZHMpPj4yKV0gOiAwKSxcbiAgICAgICAgICBzcmNFeGNlcHRIaWdoID0gKGV4Y2VwdGZkcyA/IEhFQVAzMlsoKChleGNlcHRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICBcbiAgICAgIHZhciBkc3RSZWFkTG93ID0gMCxcbiAgICAgICAgICBkc3RSZWFkSGlnaCA9IDA7XG4gICAgICB2YXIgZHN0V3JpdGVMb3cgPSAwLFxuICAgICAgICAgIGRzdFdyaXRlSGlnaCA9IDA7XG4gICAgICB2YXIgZHN0RXhjZXB0TG93ID0gMCxcbiAgICAgICAgICBkc3RFeGNlcHRIaWdoID0gMDtcbiAgXG4gICAgICB2YXIgYWxsTG93ID0gKHJlYWRmZHMgPyBIRUFQMzJbKChyZWFkZmRzKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICh3cml0ZWZkcyA/IEhFQVAzMlsoKHdyaXRlZmRzKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgIChleGNlcHRmZHMgPyBIRUFQMzJbKChleGNlcHRmZHMpPj4yKV0gOiAwKTtcbiAgICAgIHZhciBhbGxIaWdoID0gKHJlYWRmZHMgPyBIRUFQMzJbKCgocmVhZGZkcykrKDQpKT4+MildIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAod3JpdGVmZHMgPyBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgKGV4Y2VwdGZkcyA/IEhFQVAzMlsoKChleGNlcHRmZHMpKyg0KSk+PjIpXSA6IDApO1xuICBcbiAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uKGZkLCBsb3csIGhpZ2gsIHZhbCkge1xuICAgICAgICByZXR1cm4gKGZkIDwgMzIgPyAobG93ICYgdmFsKSA6IChoaWdoICYgdmFsKSk7XG4gICAgICB9O1xuICBcbiAgICAgIGZvciAodmFyIGZkID0gMDsgZmQgPCBuZmRzOyBmZCsrKSB7XG4gICAgICAgIHZhciBtYXNrID0gMSA8PCAoZmQgJSAzMik7XG4gICAgICAgIGlmICghKGNoZWNrKGZkLCBhbGxMb3csIGFsbEhpZ2gsIG1hc2spKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAgLy8gaW5kZXggaXNuJ3QgaW4gdGhlIHNldFxuICAgICAgICB9XG4gIFxuICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICBcbiAgICAgICAgdmFyIGZsYWdzID0gU1lTQ0FMTFMuREVGQVVMVF9QT0xMTUFTSztcbiAgXG4gICAgICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5wb2xsKSB7XG4gICAgICAgICAgZmxhZ3MgPSBzdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGlmICgoZmxhZ3MgJiAxKSAmJiBjaGVjayhmZCwgc3JjUmVhZExvdywgc3JjUmVhZEhpZ2gsIG1hc2spKSB7XG4gICAgICAgICAgZmQgPCAzMiA/IChkc3RSZWFkTG93ID0gZHN0UmVhZExvdyB8IG1hc2spIDogKGRzdFJlYWRIaWdoID0gZHN0UmVhZEhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmxhZ3MgJiA0KSAmJiBjaGVjayhmZCwgc3JjV3JpdGVMb3csIHNyY1dyaXRlSGlnaCwgbWFzaykpIHtcbiAgICAgICAgICBmZCA8IDMyID8gKGRzdFdyaXRlTG93ID0gZHN0V3JpdGVMb3cgfCBtYXNrKSA6IChkc3RXcml0ZUhpZ2ggPSBkc3RXcml0ZUhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZmxhZ3MgJiAyKSAmJiBjaGVjayhmZCwgc3JjRXhjZXB0TG93LCBzcmNFeGNlcHRIaWdoLCBtYXNrKSkge1xuICAgICAgICAgIGZkIDwgMzIgPyAoZHN0RXhjZXB0TG93ID0gZHN0RXhjZXB0TG93IHwgbWFzaykgOiAoZHN0RXhjZXB0SGlnaCA9IGRzdEV4Y2VwdEhpZ2ggfCBtYXNrKTtcbiAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHJlYWRmZHMpIHtcbiAgICAgICAgSEVBUDMyWygocmVhZGZkcyk+PjIpXSA9IGRzdFJlYWRMb3c7XG4gICAgICAgIEhFQVAzMlsoKChyZWFkZmRzKSsoNCkpPj4yKV0gPSBkc3RSZWFkSGlnaDtcbiAgICAgIH1cbiAgICAgIGlmICh3cml0ZWZkcykge1xuICAgICAgICBIRUFQMzJbKCh3cml0ZWZkcyk+PjIpXSA9IGRzdFdyaXRlTG93O1xuICAgICAgICBIRUFQMzJbKCgod3JpdGVmZHMpKyg0KSk+PjIpXSA9IGRzdFdyaXRlSGlnaDtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRmZHMpIHtcbiAgICAgICAgSEVBUDMyWygoZXhjZXB0ZmRzKT4+MildID0gZHN0RXhjZXB0TG93O1xuICAgICAgICBIRUFQMzJbKCgoZXhjZXB0ZmRzKSsoNCkpPj4yKV0gPSBkc3RFeGNlcHRIaWdoO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBTT0NLRlMgPSB7bW91bnQ6ZnVuY3Rpb24obW91bnQpIHtcbiAgICAgICAgLy8gSWYgTW9kdWxlWyd3ZWJzb2NrZXQnXSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgKGUuZy4gZm9yIGNvbmZpZ3VyaW5nXG4gICAgICAgIC8vIHRoZSBzdWJwcm90b2NvbC91cmwpIHVzZSB0aGF0LCBpZiBub3QgaW5pdGlhbGlzZSBpdCB0byBhIG5ldyBvYmplY3QuXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10gPSAoTW9kdWxlWyd3ZWJzb2NrZXQnXSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJ29iamVjdCcgPT09IHR5cGVvZiBNb2R1bGVbJ3dlYnNvY2tldCddKSkgPyBNb2R1bGVbJ3dlYnNvY2tldCddIDoge307XG4gIFxuICAgICAgICAvLyBBZGQgdGhlIEV2ZW50IHJlZ2lzdHJhdGlvbiBtZWNoYW5pc20gdG8gdGhlIGV4cG9ydGVkIHdlYnNvY2tldCBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIG9iamVjdCBzbyB3ZSBjYW4gcmVnaXN0ZXIgbmV0d29yayBjYWxsYmFja3MgZnJvbSBuYXRpdmUgSmF2YVNjcmlwdCB0b28uXG4gICAgICAgIC8vIEZvciBtb3JlIGRvY3VtZW50YXRpb24gc2VlIHN5c3RlbS9pbmNsdWRlL2Vtc2NyaXB0ZW4vZW1zY3JpcHRlbi5oXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddWydvbiddID0gLyoqIEB0aGlze09iamVjdH0gKi8gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCA9IC8qKiBAdGhpc3tPYmplY3R9ICovIGZ1bmN0aW9uKGV2ZW50LCBwYXJhbSkge1xuICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5jYWxsKHRoaXMsIHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gIFxuICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkIHJlZ2lzdGVyIHNpbXBsZSBkZWZhdWx0IGxvZ2dpbmcgY2FsbGJhY2tzIGZvciBlYWNoIEV2ZW50LlxuICBcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAvKiAwNzc3ICovLCAwKTtcbiAgICAgIH0sY3JlYXRlU29ja2V0OmZ1bmN0aW9uKGZhbWlseSwgdHlwZSwgcHJvdG9jb2wpIHtcbiAgICAgICAgdHlwZSAmPSB+NTI2MzM2OyAvLyBTb21lIGFwcGxpY2F0aW9ucyBtYXkgcGFzcyBpdDsgaXQgbWFrZXMgbm8gc2Vuc2UgZm9yIGEgc2luZ2xlIHByb2Nlc3MuXG4gICAgICAgIHZhciBzdHJlYW1pbmcgPSB0eXBlID09IDE7XG4gICAgICAgIGlmIChzdHJlYW1pbmcgJiYgcHJvdG9jb2wgJiYgcHJvdG9jb2wgIT0gNikge1xuICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDY2KTsgLy8gaWYgU09DS19TVFJFQU0sIG11c3QgYmUgdGNwIG9yIDAuXG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgaW50ZXJuYWwgc29ja2V0IHN0cnVjdHVyZVxuICAgICAgICB2YXIgc29jayA9IHtcbiAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICAgICAgICBzZXJ2ZXI6IG51bGwsXG4gICAgICAgICAgZXJyb3I6IG51bGwsIC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0XG4gICAgICAgICAgcGVlcnM6IHt9LFxuICAgICAgICAgIHBlbmRpbmc6IFtdLFxuICAgICAgICAgIHJlY3ZfcXVldWU6IFtdLFxuICAgICAgICAgIHNvY2tfb3BzOiBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzXG4gICAgICAgIH07XG4gIFxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZpbGVzeXN0ZW0gbm9kZSB0byBzdG9yZSB0aGUgc29ja2V0IHN0cnVjdHVyZVxuICAgICAgICB2YXIgbmFtZSA9IFNPQ0tGUy5uZXh0bmFtZSgpO1xuICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUoU09DS0ZTLnJvb3QsIG5hbWUsIDQ5MTUyLCAwKTtcbiAgICAgICAgbm9kZS5zb2NrID0gc29jaztcbiAgXG4gICAgICAgIC8vIGFuZCB0aGUgd3JhcHBpbmcgc3RyZWFtIHRoYXQgZW5hYmxlcyBsaWJyYXJ5IGZ1bmN0aW9ucyBzdWNoXG4gICAgICAgIC8vIGFzIHJlYWQgYW5kIHdyaXRlIHRvIGluZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgc29ja2V0XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oe1xuICAgICAgICAgIHBhdGg6IG5hbWUsXG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBmbGFnczogMixcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogU09DS0ZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICAvLyBtYXAgdGhlIG5ldyBzdHJlYW0gdG8gdGhlIHNvY2tldCBzdHJ1Y3R1cmUgKHNvY2tldHMgaGF2ZSBhIDE6MVxuICAgICAgICAvLyByZWxhdGlvbnNoaXAgd2l0aCBhIHN0cmVhbSlcbiAgICAgICAgc29jay5zdHJlYW0gPSBzdHJlYW07XG4gIFxuICAgICAgICByZXR1cm4gc29jaztcbiAgICAgIH0sZ2V0U29ja2V0OmZ1bmN0aW9uKGZkKSB7XG4gICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICBpZiAoIXN0cmVhbSB8fCAhRlMuaXNTb2NrZXQoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtLm5vZGUuc29jaztcbiAgICAgIH0sc3RyZWFtX29wczp7cG9sbDpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMucG9sbChzb2NrKTtcbiAgICAgICAgfSxpb2N0bDpmdW5jdGlvbihzdHJlYW0sIHJlcXVlc3QsIHZhcmFyZ3MpIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMuaW9jdGwoc29jaywgcmVxdWVzdCwgdmFyYXJncyk7XG4gICAgICAgIH0scmVhZDpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgdmFyIG1zZyA9IHNvY2suc29ja19vcHMucmVjdm1zZyhzb2NrLCBsZW5ndGgpO1xuICAgICAgICAgIGlmICghbXNnKSB7XG4gICAgICAgICAgICAvLyBzb2NrZXQgaXMgY2xvc2VkXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLnNldChtc2cuYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgIHJldHVybiBtc2cuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfSx3cml0ZTpmdW5jdGlvbihzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uIC8qIGlnbm9yZWQgKi8pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgcmV0dXJuIHNvY2suc29ja19vcHMuc2VuZG1zZyhzb2NrLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc29jayA9IHN0cmVhbS5ub2RlLnNvY2s7XG4gICAgICAgICAgc29jay5zb2NrX29wcy5jbG9zZShzb2NrKTtcbiAgICAgICAgfX0sbmV4dG5hbWU6ZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghU09DS0ZTLm5leHRuYW1lLmN1cnJlbnQpIHtcbiAgICAgICAgICBTT0NLRlMubmV4dG5hbWUuY3VycmVudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdzb2NrZXRbJyArIChTT0NLRlMubmV4dG5hbWUuY3VycmVudCsrKSArICddJztcbiAgICAgIH0sd2Vic29ja2V0X3NvY2tfb3BzOntjcmVhdGVQZWVyOmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICB2YXIgd3M7XG4gIFxuICAgICAgICAgIGlmICh0eXBlb2YgYWRkciA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgd3MgPSBhZGRyO1xuICAgICAgICAgICAgYWRkciA9IG51bGw7XG4gICAgICAgICAgICBwb3J0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgLy8gZm9yIHNvY2tldHMgdGhhdCd2ZSBhbHJlYWR5IGNvbm5lY3RlZCAoZS5nLiB3ZSdyZSB0aGUgc2VydmVyKVxuICAgICAgICAgICAgLy8gd2UgY2FuIGluc3BlY3QgdGhlIF9zb2NrZXQgcHJvcGVydHkgZm9yIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBpZiAod3MuX3NvY2tldCkge1xuICAgICAgICAgICAgICBhZGRyID0gd3MuX3NvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgICBwb3J0ID0gd3MuX3NvY2tldC5yZW1vdGVQb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UncmUganVzdCBub3cgaW5pdGlhbGl6aW5nIGEgY29ubmVjdGlvbiB0byB0aGUgcmVtb3RlLFxuICAgICAgICAgICAgLy8gaW5zcGVjdCB0aGUgdXJsIHByb3BlcnR5XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IC93c1tzXT86XFwvXFwvKFteOl0rKTooXFxkKykvLmV4ZWMod3MudXJsKTtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBVUkwgbXVzdCBiZSBpbiB0aGUgZm9ybWF0IHdzKHMpOi8vYWRkcmVzczpwb3J0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkciA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHJlc3VsdFsyXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGFjdHVhbCB3ZWJzb2NrZXQgb2JqZWN0IGFuZCBjb25uZWN0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBydW50aW1lQ29uZmlnIGdldHMgc2V0IHRvIHRydWUgaWYgV2ViU29ja2V0IHJ1bnRpbWUgY29uZmlndXJhdGlvbiBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgIHZhciBydW50aW1lQ29uZmlnID0gKE1vZHVsZVsnd2Vic29ja2V0J10gJiYgKCdvYmplY3QnID09PSB0eXBlb2YgTW9kdWxlWyd3ZWJzb2NrZXQnXSkpO1xuICBcbiAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ3dzOi8vJyB0aGUgcmVwbGFjZSBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgY29tcGlsZXIgcmVwbGFjZXMgJy8vJyBjb21tZW50cyB3aXRoICcjJ1xuICAgICAgICAgICAgICAvLyBjb21tZW50cyB3aXRob3V0IGNoZWNraW5nIGNvbnRleHQsIHNvIHdlJ2QgZW5kIHVwIHdpdGggd3M6IywgdGhlIHJlcGxhY2Ugc3dhcHMgdGhlICcjJyBmb3IgJy8vJyBhZ2Fpbi5cbiAgICAgICAgICAgICAgdmFyIHVybCA9ICd3czojJy5yZXBsYWNlKCcjJywgJy8vJyk7XG4gIFxuICAgICAgICAgICAgICBpZiAocnVudGltZUNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIE1vZHVsZVsnd2Vic29ja2V0J11bJ3VybCddKSB7XG4gICAgICAgICAgICAgICAgICB1cmwgPSBNb2R1bGVbJ3dlYnNvY2tldCddWyd1cmwnXTsgLy8gRmV0Y2ggcnVudGltZSBXZWJTb2NrZXQgVVJMIGNvbmZpZy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAgIGlmICh1cmwgPT09ICd3czovLycgfHwgdXJsID09PSAnd3NzOi8vJykgeyAvLyBJcyB0aGUgc3VwcGxpZWQgVVJMIGNvbmZpZyBqdXN0IGEgcHJlZml4LCBpZiBzbyBjb21wbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBhZGRyLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgcGFydHNbMF0gKyBcIjpcIiArIHBvcnQgKyBcIi9cIiArIHBhcnRzLnNsaWNlKDEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgV2ViU29ja2V0IHN1YnByb3RvY29sIChTZWMtV2ViU29ja2V0LVByb3RvY29sKSBkZWZhdWx0IHRvIGJpbmFyeSBpZiBubyBjb25maWd1cmF0aW9uIGlzIHNldC5cbiAgICAgICAgICAgICAgdmFyIHN1YlByb3RvY29scyA9ICdiaW5hcnknOyAvLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYmluYXJ5J1xuICBcbiAgICAgICAgICAgICAgaWYgKHJ1bnRpbWVDb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBNb2R1bGVbJ3dlYnNvY2tldCddWydzdWJwcm90b2NvbCddKSB7XG4gICAgICAgICAgICAgICAgICBzdWJQcm90b2NvbHMgPSBNb2R1bGVbJ3dlYnNvY2tldCddWydzdWJwcm90b2NvbCddOyAvLyBGZXRjaCBydW50aW1lIFdlYlNvY2tldCBzdWJwcm90b2NvbCBjb25maWcuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBXZWJTb2NrZXQgb3B0aW9uc1xuICAgICAgICAgICAgICB2YXIgb3B0cyA9IHVuZGVmaW5lZDtcbiAgXG4gICAgICAgICAgICAgIGlmIChzdWJQcm90b2NvbHMgIT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZWdleCB0cmltcyB0aGUgc3RyaW5nIChyZW1vdmVzIHNwYWNlcyBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQsIHRoZW4gc3BsaXRzIHRoZSBzdHJpbmcgYnlcbiAgICAgICAgICAgICAgICAvLyA8YW55IHNwYWNlPiw8YW55IHNwYWNlPiBpbnRvIGFuIEFycmF5LiBXaGl0ZXNwYWNlIHJlbW92YWwgaXMgaW1wb3J0YW50IGZvciBXZWJzb2NraWZ5IGFuZCB3cy5cbiAgICAgICAgICAgICAgICBzdWJQcm90b2NvbHMgPSBzdWJQcm90b2NvbHMucmVwbGFjZSgvXiArfCArJC9nLFwiXCIpLnNwbGl0KC8gKiwgKi8pO1xuICBcbiAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZSB3cyBsaWJyYXJ5IEFQSSBmb3Igc3BlY2lmeWluZyBvcHRpb25hbCBzdWJwcm90b2NvbCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiB0aGUgYnJvd3NlcidzLlxuICAgICAgICAgICAgICAgIG9wdHMgPSBFTlZJUk9OTUVOVF9JU19OT0RFID8geydwcm90b2NvbCc6IHN1YlByb3RvY29scy50b1N0cmluZygpfSA6IHN1YlByb3RvY29scztcbiAgICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgICAgLy8gc29tZSB3ZWJzZXJ2ZXJzIChhenVyZSkgZG9lcyBub3Qgc3VwcG9ydCBzdWJwcm90b2NvbCBoZWFkZXJcbiAgICAgICAgICAgICAgaWYgKHJ1bnRpbWVDb25maWcgJiYgbnVsbCA9PT0gTW9kdWxlWyd3ZWJzb2NrZXQnXVsnc3VicHJvdG9jb2wnXSkge1xuICAgICAgICAgICAgICAgIHN1YlByb3RvY29scyA9ICdudWxsJztcbiAgICAgICAgICAgICAgICBvcHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAvLyBJZiBub2RlIHdlIHVzZSB0aGUgd3MgbGlicmFyeS5cbiAgICAgICAgICAgICAgdmFyIFdlYlNvY2tldENvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgICAgICAgICAgICAgIFdlYlNvY2tldENvbnN0cnVjdG9yID0gLyoqIEB0eXBleyh0eXBlb2YgV2ViU29ja2V0KX0gKi8ocmVxdWlyZSgnd3MnKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgV2ViU29ja2V0Q29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3MgPSBuZXcgV2ViU29ja2V0Q29uc3RydWN0b3IodXJsLCBvcHRzKTtcbiAgICAgICAgICAgICAgd3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHZhciBwZWVyID0ge1xuICAgICAgICAgICAgYWRkcjogYWRkcixcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICAgICAgICBzb2NrZXQ6IHdzLFxuICAgICAgICAgICAgZGdyYW1fc2VuZF9xdWV1ZTogW11cbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmFkZFBlZXIoc29jaywgcGVlcik7XG4gICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5oYW5kbGVQZWVyRXZlbnRzKHNvY2ssIHBlZXIpO1xuICBcbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYm91bmQgZGdyYW0gc29ja2V0LCBzZW5kIHRoZSBwb3J0IG51bWJlciBmaXJzdCB0byBhbGxvd1xuICAgICAgICAgIC8vIHVzIHRvIG92ZXJyaWRlIHRoZSBlcGhlbWVyYWwgcG9ydCByZXBvcnRlZCB0byB1cyBieSByZW1vdGVQb3J0IG9uIHRoZVxuICAgICAgICAgIC8vIHJlbW90ZSBlbmQuXG4gICAgICAgICAgaWYgKHNvY2sudHlwZSA9PT0gMiAmJiB0eXBlb2Ygc29jay5zcG9ydCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGVlci5kZ3JhbV9zZW5kX3F1ZXVlLnB1c2gobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgICAgIDI1NSwgMjU1LCAyNTUsIDI1NSxcbiAgICAgICAgICAgICAgICAncCcuY2hhckNvZGVBdCgwKSwgJ28nLmNoYXJDb2RlQXQoMCksICdyJy5jaGFyQ29kZUF0KDApLCAndCcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgICAgICAoKHNvY2suc3BvcnQgJiAweGZmMDApID4+IDgpICwgKHNvY2suc3BvcnQgJiAweGZmKVxuICAgICAgICAgICAgXSkpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcmV0dXJuIHBlZXI7XG4gICAgICAgIH0sZ2V0UGVlcjpmdW5jdGlvbihzb2NrLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgICAgcmV0dXJuIHNvY2sucGVlcnNbYWRkciArICc6JyArIHBvcnRdO1xuICAgICAgICB9LGFkZFBlZXI6ZnVuY3Rpb24oc29jaywgcGVlcikge1xuICAgICAgICAgIHNvY2sucGVlcnNbcGVlci5hZGRyICsgJzonICsgcGVlci5wb3J0XSA9IHBlZXI7XG4gICAgICAgIH0scmVtb3ZlUGVlcjpmdW5jdGlvbihzb2NrLCBwZWVyKSB7XG4gICAgICAgICAgZGVsZXRlIHNvY2sucGVlcnNbcGVlci5hZGRyICsgJzonICsgcGVlci5wb3J0XTtcbiAgICAgICAgfSxoYW5kbGVQZWVyRXZlbnRzOmZ1bmN0aW9uKHNvY2ssIHBlZXIpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICBcbiAgICAgICAgICB2YXIgaGFuZGxlT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgXG4gICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ29wZW4nLCBzb2NrLnN0cmVhbS5mZCk7XG4gIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXVlZCA9IHBlZXIuZGdyYW1fc2VuZF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB3aGlsZSAocXVldWVkKSB7XG4gICAgICAgICAgICAgICAgcGVlci5zb2NrZXQuc2VuZChxdWV1ZWQpO1xuICAgICAgICAgICAgICAgIHF1ZXVlZCA9IHBlZXIuZGdyYW1fc2VuZF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBtdWNoIHdlIGNhbiBkbyBoZXJlIGluIHRoZSB3YXkgb2YgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGFzIHdlJ3ZlIGFscmVhZHlcbiAgICAgICAgICAgICAgLy8gbGllZCBhbmQgc2FpZCB0aGlzIGRhdGEgd2FzIHNlbnQuIHNodXQgaXQgZG93bi5cbiAgICAgICAgICAgICAgcGVlci5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YXIgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpOyAvLyBzaG91bGQgYmUgdXRmLThcbiAgICAgICAgICAgICAgZGF0YSA9IGVuY29kZXIuZW5jb2RlKGRhdGEpOyAvLyBtYWtlIGEgdHlwZWQgYXJyYXkgZnJvbSB0aGUgc3RyaW5nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhc3NlcnQoZGF0YS5ieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQpOyAvLyBtdXN0IHJlY2VpdmUgYW4gQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgaWYgKGRhdGEuYnl0ZUxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgQXJyYXlCdWZmZXIgd2lsbCBlbWl0IGEgcHNldWRvIGRpc2Nvbm5lY3QgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBhcyByZWN2L3JlY3Ztc2cgd2lsbCByZXR1cm4gemVybyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBhIHNvY2tldFxuICAgICAgICAgICAgICAgIC8vIGhhcyBwZXJmb3JtZWQgYSBzaHV0ZG93biBhbHRob3VnaCB0aGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZGlzY29ubmVjdGVkIHlldC5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBtYWtlIGEgdHlwZWQgYXJyYXkgdmlldyBvbiB0aGUgYXJyYXkgYnVmZmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBwb3J0IG1lc3NhZ2UsIG92ZXJyaWRlIHRoZSBwZWVyJ3MgcG9ydCB3aXRoIGl0XG4gICAgICAgICAgICB2YXIgd2FzZmlyc3QgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod2FzZmlyc3QgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmxlbmd0aCA9PT0gMTAgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzBdID09PSAyNTUgJiYgZGF0YVsxXSA9PT0gMjU1ICYmIGRhdGFbMl0gPT09IDI1NSAmJiBkYXRhWzNdID09PSAyNTUgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzRdID09PSAncCcuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzVdID09PSAnbycuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzZdID09PSAncicuY2hhckNvZGVBdCgwKSAmJiBkYXRhWzddID09PSAndCcuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBlZXIncyBwb3J0IGFuZCBpdCdzIGtleSBpbiB0aGUgcGVlciBtYXBcbiAgICAgICAgICAgICAgdmFyIG5ld3BvcnQgPSAoKGRhdGFbOF0gPDwgOCkgfCBkYXRhWzldKTtcbiAgICAgICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5yZW1vdmVQZWVyKHNvY2ssIHBlZXIpO1xuICAgICAgICAgICAgICBwZWVyLnBvcnQgPSBuZXdwb3J0O1xuICAgICAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmFkZFBlZXIoc29jaywgcGVlcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBzb2NrLnJlY3ZfcXVldWUucHVzaCh7IGFkZHI6IHBlZXIuYWRkciwgcG9ydDogcGVlci5wb3J0LCBkYXRhOiBkYXRhIH0pO1xuICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdtZXNzYWdlJywgc29jay5zdHJlYW0uZmQpO1xuICAgICAgICAgIH07XG4gIFxuICAgICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihkYXRhLCBmbGFncykge1xuICAgICAgICAgICAgICBpZiAoIWZsYWdzLmJpbmFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYW5kbGVNZXNzYWdlKChuZXcgVWludDhBcnJheShkYXRhKSkuYnVmZmVyKTsgIC8vIGNvcHkgZnJvbSBub2RlIEJ1ZmZlciAtPiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdjbG9zZScsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggdGhlIHdzIGxpYnJhcnkgbWF5IHBhc3MgZXJyb3JzIHRoYXQgbWF5IGJlIG1vcmUgZGVzY3JpcHRpdmUgdGhhblxuICAgICAgICAgICAgICAvLyBFQ09OTlJFRlVTRUQgdGhleSBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIGUuZy4gXG4gICAgICAgICAgICAgIC8vIEVOT1RGT1VORCBvbiBnZXRhZGRyaW5mbyBzZWVtcyB0byBiZSBub2RlLmpzIHNwZWNpZmljLCBzbyB1c2luZyBFQ09OTlJFRlVTRURcbiAgICAgICAgICAgICAgLy8gaXMgc3RpbGwgcHJvYmFibHkgdGhlIG1vc3QgdXNlZnVsIHRoaW5nIHRvIGRvLlxuICAgICAgICAgICAgICBzb2NrLmVycm9yID0gMTQ7IC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0LlxuICAgICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Vycm9yJywgW3NvY2suc3RyZWFtLmZkLCBzb2NrLmVycm9yLCAnRUNPTk5SRUZVU0VEOiBDb25uZWN0aW9uIHJlZnVzZWQnXSk7XG4gICAgICAgICAgICAgIC8vIGRvbid0IHRocm93XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVlci5zb2NrZXQub25vcGVuID0gaGFuZGxlT3BlbjtcbiAgICAgICAgICAgIHBlZXIuc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgTW9kdWxlWyd3ZWJzb2NrZXQnXS5lbWl0KCdjbG9zZScsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiBwZWVyX3NvY2tldF9vbm1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwZWVyLnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIFdlYlNvY2tldCBzcGVjIG9ubHkgYWxsb3dzIGEgJ3NpbXBsZSBldmVudCcgdG8gYmUgdGhyb3duIG9uIGVycm9yLFxuICAgICAgICAgICAgICAvLyBzbyB3ZSBvbmx5IHJlYWxseSBrbm93IGFzIG11Y2ggYXMgRUNPTk5SRUZVU0VELlxuICAgICAgICAgICAgICBzb2NrLmVycm9yID0gMTQ7IC8vIFVzZWQgaW4gZ2V0c29ja29wdCBmb3IgU09MX1NPQ0tFVC9TT19FUlJPUiB0ZXN0LlxuICAgICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Vycm9yJywgW3NvY2suc3RyZWFtLmZkLCBzb2NrLmVycm9yLCAnRUNPTk5SRUZVU0VEOiBDb25uZWN0aW9uIHJlZnVzZWQnXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxwb2xsOmZ1bmN0aW9uKHNvY2spIHtcbiAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxICYmIHNvY2suc2VydmVyKSB7XG4gICAgICAgICAgICAvLyBsaXN0ZW4gc29ja2V0cyBzaG91bGQgb25seSBzYXkgdGhleSdyZSBhdmFpbGFibGUgZm9yIHJlYWRpbmdcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwZW5kaW5nIGNsaWVudHMuXG4gICAgICAgICAgICByZXR1cm4gc29jay5wZW5kaW5nLmxlbmd0aCA/ICg2NCB8IDEpIDogMDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHZhciBtYXNrID0gMDtcbiAgICAgICAgICB2YXIgZGVzdCA9IHNvY2sudHlwZSA9PT0gMSA/ICAvLyB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhlIHNvY2tldCBzdGF0ZSBmb3IgY29ubmVjdGlvbi1iYXNlZCBzb2NrZXRzXG4gICAgICAgICAgICBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgc29jay5kYWRkciwgc29jay5kcG9ydCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgXG4gICAgICAgICAgaWYgKHNvY2sucmVjdl9xdWV1ZS5sZW5ndGggfHxcbiAgICAgICAgICAgICAgIWRlc3QgfHwgIC8vIGNvbm5lY3Rpb24tbGVzcyBzb2NrZXRzIGFyZSBhbHdheXMgcmVhZHkgdG8gcmVhZFxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TSU5HKSB8fFxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpKSB7ICAvLyBsZXQgcmVjdiByZXR1cm4gMCBvbmNlIGNsb3NlZFxuICAgICAgICAgICAgbWFzayB8PSAoNjQgfCAxKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGlmICghZGVzdCB8fCAgLy8gY29ubmVjdGlvbi1sZXNzIHNvY2tldHMgYXJlIGFsd2F5cyByZWFkeSB0byB3cml0ZVxuICAgICAgICAgICAgICAoZGVzdCAmJiBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5PUEVOKSkge1xuICAgICAgICAgICAgbWFzayB8PSA0O1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKChkZXN0ICYmIGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NJTkcpIHx8XG4gICAgICAgICAgICAgIChkZXN0ICYmIGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NFRCkpIHtcbiAgICAgICAgICAgIG1hc2sgfD0gMTY7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICByZXR1cm4gbWFzaztcbiAgICAgICAgfSxpb2N0bDpmdW5jdGlvbihzb2NrLCByZXF1ZXN0LCBhcmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNhc2UgMjE1MzE6XG4gICAgICAgICAgICAgIHZhciBieXRlcyA9IDA7XG4gICAgICAgICAgICAgIGlmIChzb2NrLnJlY3ZfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBzb2NrLnJlY3ZfcXVldWVbMF0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgSEVBUDMyWygoYXJnKT4+MildID0gYnl0ZXM7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbihzb2NrKSB7XG4gICAgICAgICAgLy8gaWYgd2UndmUgc3Bhd25lZCBhIGxpc3RlbiBzZXJ2ZXIsIGNsb3NlIGl0XG4gICAgICAgICAgaWYgKHNvY2suc2VydmVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzb2NrLnNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjbG9zZSBhbnkgcGVlciBjb25uZWN0aW9uc1xuICAgICAgICAgIHZhciBwZWVycyA9IE9iamVjdC5rZXlzKHNvY2sucGVlcnMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwZWVyID0gc29jay5wZWVyc1twZWVyc1tpXV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwZWVyLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5yZW1vdmVQZWVyKHNvY2ssIHBlZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxiaW5kOmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNvY2suc2FkZHIgIT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNvY2suc3BvcnQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTsgIC8vIGFscmVhZHkgYm91bmRcbiAgICAgICAgICB9XG4gICAgICAgICAgc29jay5zYWRkciA9IGFkZHI7XG4gICAgICAgICAgc29jay5zcG9ydCA9IHBvcnQ7XG4gICAgICAgICAgLy8gaW4gb3JkZXIgdG8gZW11bGF0ZSBkZ3JhbSBzb2NrZXRzLCB3ZSBuZWVkIHRvIGxhdW5jaCBhIGxpc3RlbiBzZXJ2ZXIgd2hlblxuICAgICAgICAgIC8vIGJpbmRpbmcgb24gYSBjb25uZWN0aW9uLWxlc3Mgc29ja2V0XG4gICAgICAgICAgLy8gbm90ZTogdGhpcyBpcyBvbmx5IHJlcXVpcmVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBleGlzdGluZyBzZXJ2ZXIgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgc29jay5zZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3dhbGxvdyBlcnJvciBvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBlcnJvciB0aGF0IG9jY3VycyB3aGVuIGJpbmRpbmcgaW4gdGhlXG4gICAgICAgICAgICAvLyBicm93c2VyIHdoZXJlIHRoaXMgaXNuJ3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzb2NrLnNvY2tfb3BzLmxpc3Rlbihzb2NrLCAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgICAgICAgICAgICBpZiAoZS5lcnJubyAhPT0gMTM4KSB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxjb25uZWN0OmZ1bmN0aW9uKHNvY2ssIGFkZHIsIHBvcnQpIHtcbiAgICAgICAgICBpZiAoc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBUT0RPIGF1dG9iaW5kXG4gICAgICAgICAgLy8gaWYgKCFzb2NrLmFkZHIgJiYgc29jay50eXBlID09IDIpIHtcbiAgICAgICAgICAvLyB9XG4gIFxuICAgICAgICAgIC8vIGVhcmx5IG91dCBpZiB3ZSdyZSBhbHJlYWR5IGNvbm5lY3RlZCAvIGluIHRoZSBtaWRkbGUgb2YgY29ubmVjdGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc29jay5kYWRkciAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc29jay5kcG9ydCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIGRlc3QgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgc29jay5kYWRkciwgc29jay5kcG9ydCk7XG4gICAgICAgICAgICBpZiAoZGVzdCkge1xuICAgICAgICAgICAgICBpZiAoZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgLy8gYWRkIHRoZSBzb2NrZXQgdG8gb3VyIHBlZXIgbGlzdCBhbmQgc2V0IG91clxuICAgICAgICAgIC8vIGRlc3RpbmF0aW9uIGFkZHJlc3MgLyBwb3J0IHRvIG1hdGNoXG4gICAgICAgICAgdmFyIHBlZXIgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmNyZWF0ZVBlZXIoc29jaywgYWRkciwgcG9ydCk7XG4gICAgICAgICAgc29jay5kYWRkciA9IHBlZXIuYWRkcjtcbiAgICAgICAgICBzb2NrLmRwb3J0ID0gcGVlci5wb3J0O1xuICBcbiAgICAgICAgICAvLyBhbHdheXMgXCJmYWlsXCIgaW4gbm9uLWJsb2NraW5nIG1vZGVcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyNik7XG4gICAgICAgIH0sbGlzdGVuOmZ1bmN0aW9uKHNvY2ssIGJhY2tsb2cpIHtcbiAgICAgICAgICBpZiAoIUVOVklST05NRU5UX0lTX05PREUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb2NrLnNlcnZlcikge1xuICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTsgIC8vIGFscmVhZHkgbGlzdGVuaW5nXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBXZWJTb2NrZXRTZXJ2ZXIgPSByZXF1aXJlKCd3cycpLlNlcnZlcjtcbiAgICAgICAgICB2YXIgaG9zdCA9IHNvY2suc2FkZHI7XG4gICAgICAgICAgc29jay5zZXJ2ZXIgPSBuZXcgV2ViU29ja2V0U2VydmVyKHtcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICBwb3J0OiBzb2NrLnNwb3J0XG4gICAgICAgICAgICAvLyBUT0RPIHN1cHBvcnQgYmFja2xvZ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnbGlzdGVuJywgc29jay5zdHJlYW0uZmQpOyAvLyBTZW5kIEV2ZW50IHdpdGggbGlzdGVuIGZkLlxuICBcbiAgICAgICAgICBzb2NrLnNlcnZlci5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uKHdzKSB7XG4gICAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdzb2NrID0gU09DS0ZTLmNyZWF0ZVNvY2tldChzb2NrLmZhbWlseSwgc29jay50eXBlLCBzb2NrLnByb3RvY29sKTtcbiAgXG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBlZXIgb24gdGhlIG5ldyBzb2NrZXRcbiAgICAgICAgICAgICAgdmFyIHBlZXIgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmNyZWF0ZVBlZXIobmV3c29jaywgd3MpO1xuICAgICAgICAgICAgICBuZXdzb2NrLmRhZGRyID0gcGVlci5hZGRyO1xuICAgICAgICAgICAgICBuZXdzb2NrLmRwb3J0ID0gcGVlci5wb3J0O1xuICBcbiAgICAgICAgICAgICAgLy8gcHVzaCB0byBxdWV1ZSBmb3IgYWNjZXB0IHRvIHBpY2sgdXBcbiAgICAgICAgICAgICAgc29jay5wZW5kaW5nLnB1c2gobmV3c29jayk7XG4gICAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnY29ubmVjdGlvbicsIG5ld3NvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBlZXIgb24gdGhlIGxpc3RlbiBzb2NrZXQgc28gY2FsbGluZyBzZW5kdG9cbiAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgbGlzdGVuIHNvY2tldCBhbmQgYW4gYWRkcmVzcyB3aWxsIHJlc29sdmVcbiAgICAgICAgICAgICAgLy8gdG8gdGhlIGNvcnJlY3QgY2xpZW50XG4gICAgICAgICAgICAgIFNPQ0tGUy53ZWJzb2NrZXRfc29ja19vcHMuY3JlYXRlUGVlcihzb2NrLCB3cyk7XG4gICAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnY29ubmVjdGlvbicsIHNvY2suc3RyZWFtLmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb2NrLnNlcnZlci5vbignY2xvc2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBNb2R1bGVbJ3dlYnNvY2tldCddLmVtaXQoJ2Nsb3NlJywgc29jay5zdHJlYW0uZmQpO1xuICAgICAgICAgICAgc29jay5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNvY2suc2VydmVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBBbHRob3VnaCB0aGUgd3MgbGlicmFyeSBtYXkgcGFzcyBlcnJvcnMgdGhhdCBtYXkgYmUgbW9yZSBkZXNjcmlwdGl2ZSB0aGFuXG4gICAgICAgICAgICAvLyBFQ09OTlJFRlVTRUQgdGhleSBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIGUuZy4gXG4gICAgICAgICAgICAvLyBFTk9URk9VTkQgb24gZ2V0YWRkcmluZm8gc2VlbXMgdG8gYmUgbm9kZS5qcyBzcGVjaWZpYywgc28gdXNpbmcgRUhPU1RVTlJFQUNIXG4gICAgICAgICAgICAvLyBpcyBzdGlsbCBwcm9iYWJseSB0aGUgbW9zdCB1c2VmdWwgdGhpbmcgdG8gZG8uIFRoaXMgZXJyb3Igc2hvdWxkbid0XG4gICAgICAgICAgICAvLyBvY2N1ciBpbiBhIHdlbGwgd3JpdHRlbiBhcHAgYXMgZXJyb3JzIHNob3VsZCBnZXQgdHJhcHBlZCBpbiB0aGUgY29tcGlsZWRcbiAgICAgICAgICAgIC8vIGFwcCdzIG93biBnZXRhZGRyaW5mbyBjYWxsLlxuICAgICAgICAgICAgc29jay5lcnJvciA9IDIzOyAvLyBVc2VkIGluIGdldHNvY2tvcHQgZm9yIFNPTF9TT0NLRVQvU09fRVJST1IgdGVzdC5cbiAgICAgICAgICAgIE1vZHVsZVsnd2Vic29ja2V0J10uZW1pdCgnZXJyb3InLCBbc29jay5zdHJlYW0uZmQsIHNvY2suZXJyb3IsICdFSE9TVFVOUkVBQ0g6IEhvc3QgaXMgdW5yZWFjaGFibGUnXSk7XG4gICAgICAgICAgICAvLyBkb24ndCB0aHJvd1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LGFjY2VwdDpmdW5jdGlvbihsaXN0ZW5zb2NrKSB7XG4gICAgICAgICAgaWYgKCFsaXN0ZW5zb2NrLnNlcnZlciB8fCAhbGlzdGVuc29jay5wZW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV3c29jayA9IGxpc3RlbnNvY2sucGVuZGluZy5zaGlmdCgpO1xuICAgICAgICAgIG5ld3NvY2suc3RyZWFtLmZsYWdzID0gbGlzdGVuc29jay5zdHJlYW0uZmxhZ3M7XG4gICAgICAgICAgcmV0dXJuIG5ld3NvY2s7XG4gICAgICAgIH0sZ2V0bmFtZTpmdW5jdGlvbihzb2NrLCBwZWVyKSB7XG4gICAgICAgICAgdmFyIGFkZHIsIHBvcnQ7XG4gICAgICAgICAgaWYgKHBlZXIpIHtcbiAgICAgICAgICAgIGlmIChzb2NrLmRhZGRyID09PSB1bmRlZmluZWQgfHwgc29jay5kcG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDUzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHIgPSBzb2NrLmRhZGRyO1xuICAgICAgICAgICAgcG9ydCA9IHNvY2suZHBvcnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2FkZHIgYW5kIHNwb3J0IHdpbGwgYmUgc2V0IGZvciBiaW5kKCknZCBVRFAgc29ja2V0cywgYnV0IHdoYXRcbiAgICAgICAgICAgIC8vIHNob3VsZCB3ZSBiZSByZXR1cm5pbmcgZm9yIFRDUCBzb2NrZXRzIHRoYXQndmUgYmVlbiBjb25uZWN0KCknZD9cbiAgICAgICAgICAgIGFkZHIgPSBzb2NrLnNhZGRyIHx8IDA7XG4gICAgICAgICAgICBwb3J0ID0gc29jay5zcG9ydCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBhZGRyOiBhZGRyLCBwb3J0OiBwb3J0IH07XG4gICAgICAgIH0sc2VuZG1zZzpmdW5jdGlvbihzb2NrLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgICAgaWYgKHNvY2sudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgLy8gY29ubmVjdGlvbi1sZXNzIHNvY2tldHMgd2lsbCBob25vciB0aGUgbWVzc2FnZSBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gYW5kIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gdGhlIGJvdW5kIGRlc3RpbmF0aW9uIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChhZGRyID09PSB1bmRlZmluZWQgfHwgcG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGFkZHIgPSBzb2NrLmRhZGRyO1xuICAgICAgICAgICAgICBwb3J0ID0gc29jay5kcG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBhZGRyZXNzIHRvIGZhbGwgYmFjayB0bywgZXJyb3Igb3V0XG4gICAgICAgICAgICBpZiAoYWRkciA9PT0gdW5kZWZpbmVkIHx8IHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24tYmFzZWQgc29ja2V0cyB3aWxsIG9ubHkgdXNlIHRoZSBib3VuZFxuICAgICAgICAgICAgYWRkciA9IHNvY2suZGFkZHI7XG4gICAgICAgICAgICBwb3J0ID0gc29jay5kcG9ydDtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8vIGZpbmQgdGhlIHBlZXIgZm9yIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gICAgICAgICAgdmFyIGRlc3QgPSBTT0NLRlMud2Vic29ja2V0X3NvY2tfb3BzLmdldFBlZXIoc29jaywgYWRkciwgcG9ydCk7XG4gIFxuICAgICAgICAgIC8vIGVhcmx5IG91dCBpZiBub3QgY29ubmVjdGVkIHdpdGggYSBjb25uZWN0aW9uLWJhc2VkIHNvY2tldFxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghZGVzdCB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TSU5HIHx8IGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1Myk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlc3Quc29ja2V0LnJlYWR5U3RhdGUgPT09IGRlc3Quc29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICAvLyBjcmVhdGUgYSBjb3B5IG9mIHRoZSBpbmNvbWluZyBkYXRhIHRvIHNlbmQsIGFzIHRoZSBXZWJTb2NrZXQgQVBJXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGVudGlyZWx5IHdpdGggYW4gQXJyYXlCdWZmZXJWaWV3LCBpdCdsbCBqdXN0IHNlbmRcbiAgICAgICAgICAvLyB0aGUgZW50aXJlIHVuZGVybHlpbmcgYnVmZmVyXG4gICAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuYnVmZmVyO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgXG4gICAgICAgICAgLy8gaWYgd2UncmUgZW11bGF0aW5nIGEgY29ubmVjdGlvbi1sZXNzIGRncmFtIHNvY2tldCBhbmQgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGEgY2FjaGVkIGNvbm5lY3Rpb24sIHF1ZXVlIHRoZSBidWZmZXIgdG8gc2VuZCB1cG9uIGNvbm5lY3QgYW5kXG4gICAgICAgICAgLy8gbGllLCBzYXlpbmcgdGhlIGRhdGEgd2FzIHNlbnQgbm93LlxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgIGlmICghZGVzdCB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlICE9PSBkZXN0LnNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIG9wZW4gYSBuZXcgY29ubmVjdGlvblxuICAgICAgICAgICAgICBpZiAoIWRlc3QgfHwgZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ0xPU0lORyB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICBkZXN0ID0gU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5jcmVhdGVQZWVyKHNvY2ssIGFkZHIsIHBvcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlc3QuZGdyYW1fc2VuZF9xdWV1ZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHNlbmQgdGhlIGFjdHVhbCBkYXRhXG4gICAgICAgICAgICBkZXN0LnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LHJlY3Ztc2c6ZnVuY3Rpb24oc29jaywgbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzc5MDg3OTkveG5zL3JlY3Ztc2cuaHRtbFxuICAgICAgICAgIGlmIChzb2NrLnR5cGUgPT09IDEgJiYgc29jay5zZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vIHRjcCBzZXJ2ZXJzIHNob3VsZCBub3QgYmUgcmVjdigpJ2luZyBvbiB0aGUgbGlzdGVuIHNvY2tldFxuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTMpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIHF1ZXVlZCA9IHNvY2sucmVjdl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIGlmICghcXVldWVkKSB7XG4gICAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBkZXN0ID0gU09DS0ZTLndlYnNvY2tldF9zb2NrX29wcy5nZXRQZWVyKHNvY2ssIHNvY2suZGFkZHIsIHNvY2suZHBvcnQpO1xuICBcbiAgICAgICAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIGRlc3RpbmF0aW9uIGFkZHJlc3MgYnV0IGFyZSBub3QgY29ubmVjdGVkLCBlcnJvciBvdXRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1Myk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGVzdC5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gZGVzdC5zb2NrZXQuQ0xPU0lORyB8fCBkZXN0LnNvY2tldC5yZWFkeVN0YXRlID09PSBkZXN0LnNvY2tldC5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gbnVsbCBpZiB0aGUgc29ja2V0IGhhcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlLCBvdXIgc29ja2V0IGlzIGluIGEgdmFsaWQgc3RhdGUgYnV0IHRydWx5IGhhcyBub3RoaW5nIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIC8vIHF1ZXVlZC5kYXRhIHdpbGwgYmUgYW4gQXJyYXlCdWZmZXIgaWYgaXQncyB1bmFkdWx0ZXJhdGVkLCBidXQgaWYgaXQnc1xuICAgICAgICAgIC8vIHJlcXVldWVkIFRDUCBkYXRhIGl0J2xsIGJlIGFuIEFycmF5QnVmZmVyVmlld1xuICAgICAgICAgIHZhciBxdWV1ZWRMZW5ndGggPSBxdWV1ZWQuZGF0YS5ieXRlTGVuZ3RoIHx8IHF1ZXVlZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgICB2YXIgcXVldWVkT2Zmc2V0ID0gcXVldWVkLmRhdGEuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICAgIHZhciBxdWV1ZWRCdWZmZXIgPSBxdWV1ZWQuZGF0YS5idWZmZXIgfHwgcXVldWVkLmRhdGE7XG4gICAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IE1hdGgubWluKGxlbmd0aCwgcXVldWVkTGVuZ3RoKTtcbiAgICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShxdWV1ZWRCdWZmZXIsIHF1ZXVlZE9mZnNldCwgYnl0ZXNSZWFkKSxcbiAgICAgICAgICAgIGFkZHI6IHF1ZXVlZC5hZGRyLFxuICAgICAgICAgICAgcG9ydDogcXVldWVkLnBvcnRcbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgICAvLyBwdXNoIGJhY2sgYW55IHVucmVhZCBkYXRhIGZvciBUQ1AgY29ubmVjdGlvbnNcbiAgICAgICAgICBpZiAoc29jay50eXBlID09PSAxICYmIGJ5dGVzUmVhZCA8IHF1ZXVlZExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzUmVtYWluaW5nID0gcXVldWVkTGVuZ3RoIC0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgcXVldWVkLmRhdGEgPSBuZXcgVWludDhBcnJheShxdWV1ZWRCdWZmZXIsIHF1ZXVlZE9mZnNldCArIGJ5dGVzUmVhZCwgYnl0ZXNSZW1haW5pbmcpO1xuICAgICAgICAgICAgc29jay5yZWN2X3F1ZXVlLnVuc2hpZnQocXVldWVkKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH19fTtcbiAgZnVuY3Rpb24gZ2V0U29ja2V0RnJvbUZEKGZkKSB7XG4gICAgICB2YXIgc29ja2V0ID0gU09DS0ZTLmdldFNvY2tldChmZCk7XG4gICAgICBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICByZXR1cm4gc29ja2V0O1xuICAgIH1cbiAgXG4gIGZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKSB7XG4gICAgICBIRUFQMzJbKChfX19lcnJub19sb2NhdGlvbigpKT4+MildID0gdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB2YXIgU29ja2V0cyA9IHtCVUZGRVJfU0laRToxMDI0MCxNQVhfQlVGRkVSX1NJWkU6MTA0ODU3NjAsbmV4dEZkOjEsZmRzOnt9LG5leHRwb3J0OjEsbWF4cG9ydDo2NTUzNSxwZWVyOm51bGwsY29ubmVjdGlvbnM6e30scG9ydG1hcDp7fSxsb2NhbEFkZHI6NDI2MTQxMjg3NCxhZGRyUG9vbDpbMzM1NTQ0NDIsNTAzMzE2NTgsNjcxMDg4NzQsODM4ODYwOTAsMTAwNjYzMzA2LDExNzQ0MDUyMiwxMzQyMTc3MzgsMTUwOTk0OTU0LDE2Nzc3MjE3MCwxODQ1NDkzODYsMjAxMzI2NjAyLDIxODEwMzgxOCwyMzQ4ODEwMzRdfTtcbiAgXG4gIGZ1bmN0aW9uIGluZXRQdG9uNChzdHIpIHtcbiAgICAgIHZhciBiID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB2YXIgdG1wID0gTnVtYmVyKGJbaV0pO1xuICAgICAgICBpZiAoaXNOYU4odG1wKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGJbaV0gPSB0bXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGJbMF0gfCAoYlsxXSA8PCA4KSB8IChiWzJdIDw8IDE2KSB8IChiWzNdIDw8IDI0KSkgPj4+IDA7XG4gICAgfVxuICBcbiAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgZnVuY3Rpb24ganN0b2lfcShzdHIpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzdHIpO1xuICAgIH1cbiAgZnVuY3Rpb24gaW5ldFB0b242KHN0cikge1xuICAgICAgdmFyIHdvcmRzO1xuICAgICAgdmFyIHcsIG9mZnNldCwgeiwgaTtcbiAgICAgIC8qIGh0dHA6Ly9ob21lLmRlZHMubmwvfmFlcm9uL3JlZ2V4LyAqL1xuICAgICAgdmFyIHZhbGlkNnJlZ3ggPSAvXigoPz0uKjo6KSg/IS4qOjouKzo6KSg6Oik/KFtcXGRBLUZdezEsNH06KDp8XFxiKXwpezV9fChbXFxkQS1GXXsxLDR9Oil7Nn0pKCgoW1xcZEEtRl17MSw0fSgoPyFcXDMpOjp8OlxcYnwkKSl8KD8hXFwyXFwzKSl7Mn18KCgoMlswLTRdfDFcXGR8WzEtOV0pP1xcZHwyNVswLTVdKVxcLj9cXGIpezR9KSQvaVxuICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICBpZiAoIXZhbGlkNnJlZ3gudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciA9PT0gXCI6OlwiKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICAvLyBaIHBsYWNlaG9sZGVyIHRvIGtlZXAgdHJhY2sgb2YgemVyb3Mgd2hlbiBzcGxpdHRpbmcgdGhlIHN0cmluZyBvbiBcIjpcIlxuICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIlo6XCIpOyAvLyBsZWFkaW5nIHplcm9zIGNhc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiOjpcIiwgXCI6WjpcIik7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHN0ci5pbmRleE9mKFwiLlwiKSA+IDApIHtcbiAgICAgICAgLy8gcGFyc2UgSVB2NCBlbWJlZGRlZCBzdHJlc3NcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnWy5dJywgJ2cnKSwgXCI6XCIpO1xuICAgICAgICB3b3JkcyA9IHN0ci5zcGxpdChcIjpcIik7XG4gICAgICAgIHdvcmRzW3dvcmRzLmxlbmd0aC00XSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTRdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTNdKSoyNTY7XG4gICAgICAgIHdvcmRzW3dvcmRzLmxlbmd0aC0zXSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTJdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTFdKSoyNTY7XG4gICAgICAgIHdvcmRzID0gd29yZHMuc2xpY2UoMCwgd29yZHMubGVuZ3RoLTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuICAgICAgfVxuICBcbiAgICAgIG9mZnNldCA9IDA7IHogPSAwO1xuICAgICAgZm9yICh3PTA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICAgICAgICBpZiAodHlwZW9mIHdvcmRzW3ddID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHdvcmRzW3ddID09PSAnWicpIHtcbiAgICAgICAgICAgIC8vIGNvbXByZXNzZWQgemVyb3MgLSB3cml0ZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgemVybyB3b3Jkc1xuICAgICAgICAgICAgZm9yICh6ID0gMDsgeiA8ICg4IC0gd29yZHMubGVuZ3RoKzEpOyB6KyspIHtcbiAgICAgICAgICAgICAgcGFydHNbdyt6XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB6LTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGhleCB0byBmaWVsZCB0byAxNi1iaXQgdmFsdWUgYW5kIHdyaXRlIGl0IGluIG5ldHdvcmsgYnl0ZS1vcmRlclxuICAgICAgICAgICAgcGFydHNbdytvZmZzZXRdID0gX2h0b25zKHBhcnNlSW50KHdvcmRzW3ddLDE2KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBhcnNlZCBJUHY0IHdvcmRzXG4gICAgICAgICAgcGFydHNbdytvZmZzZXRdID0gd29yZHNbd107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIChwYXJ0c1sxXSA8PCAxNikgfCBwYXJ0c1swXSxcbiAgICAgICAgKHBhcnRzWzNdIDw8IDE2KSB8IHBhcnRzWzJdLFxuICAgICAgICAocGFydHNbNV0gPDwgMTYpIHwgcGFydHNbNF0sXG4gICAgICAgIChwYXJ0c1s3XSA8PCAxNikgfCBwYXJ0c1s2XVxuICAgICAgXTtcbiAgICB9XG4gIC8qKiBAcGFyYW0ge251bWJlcj19IGFkZHJsZW4gKi9cbiAgZnVuY3Rpb24gd3JpdGVTb2NrYWRkcihzYSwgZmFtaWx5LCBhZGRyLCBwb3J0LCBhZGRybGVuKSB7XG4gICAgICBzd2l0Y2ggKGZhbWlseSkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYWRkciA9IGluZXRQdG9uNChhZGRyKTtcbiAgICAgICAgICB6ZXJvTWVtb3J5KHNhLCAxNik7XG4gICAgICAgICAgaWYgKGFkZHJsZW4pIHtcbiAgICAgICAgICAgIEhFQVAzMlsoKGFkZHJsZW4pPj4yKV0gPSAxNjtcbiAgICAgICAgICB9XG4gICAgICAgICAgSEVBUDE2Wygoc2EpPj4xKV0gPSBmYW1pbHk7XG4gICAgICAgICAgSEVBUDMyWygoKHNhKSsoNCkpPj4yKV0gPSBhZGRyO1xuICAgICAgICAgIEhFQVAxNlsoKChzYSkrKDIpKT4+MSldID0gX2h0b25zKHBvcnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGFkZHIgPSBpbmV0UHRvbjYoYWRkcik7XG4gICAgICAgICAgemVyb01lbW9yeShzYSwgMjgpO1xuICAgICAgICAgIGlmIChhZGRybGVuKSB7XG4gICAgICAgICAgICBIRUFQMzJbKChhZGRybGVuKT4+MildID0gMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIEhFQVAzMlsoKHNhKT4+MildID0gZmFtaWx5O1xuICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDgpKT4+MildID0gYWRkclswXTtcbiAgICAgICAgICBIRUFQMzJbKCgoc2EpKygxMikpPj4yKV0gPSBhZGRyWzFdO1xuICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDE2KSk+PjIpXSA9IGFkZHJbMl07XG4gICAgICAgICAgSEVBUDMyWygoKHNhKSsoMjApKT4+MildID0gYWRkclszXTtcbiAgICAgICAgICBIRUFQMTZbKCgoc2EpKygyKSk+PjEpXSA9IF9odG9ucyhwb3J0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgXG4gIHZhciBETlMgPSB7YWRkcmVzc19tYXA6e2lkOjEsYWRkcnM6e30sbmFtZXM6e319LGxvb2t1cF9uYW1lOmZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSBuYW1lIGlzIGFscmVhZHkgYSB2YWxpZCBpcHY0IC8gaXB2NiBhZGRyZXNzLCBkb24ndCBnZW5lcmF0ZSBhIGZha2Ugb25lLlxuICAgICAgICB2YXIgcmVzID0gaW5ldFB0b240KG5hbWUpO1xuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gaW5ldFB0b242KG5hbWUpO1xuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIFNlZSBpZiB0aGlzIG5hbWUgaXMgYWxyZWFkeSBtYXBwZWQuXG4gICAgICAgIHZhciBhZGRyO1xuICBcbiAgICAgICAgaWYgKEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSkge1xuICAgICAgICAgIGFkZHIgPSBETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlkID0gRE5TLmFkZHJlc3NfbWFwLmlkKys7XG4gICAgICAgICAgYXNzZXJ0KGlkIDwgNjU1MzUsICdleGNlZWRlZCBtYXggYWRkcmVzcyBtYXBwaW5ncyBvZiA2NTUzNScpO1xuICBcbiAgICAgICAgICBhZGRyID0gJzE3Mi4yOS4nICsgKGlkICYgMHhmZikgKyAnLicgKyAoaWQgJiAweGZmMDApO1xuICBcbiAgICAgICAgICBETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl0gPSBuYW1lO1xuICAgICAgICAgIEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSA9IGFkZHI7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgfSxsb29rdXBfYWRkcjpmdW5jdGlvbiAoYWRkcikge1xuICAgICAgICBpZiAoRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdKSB7XG4gICAgICAgICAgcmV0dXJuIEROUy5hZGRyZXNzX21hcC5uYW1lc1thZGRyXTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9fTtcbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9hY2NlcHQ0KGZkLCBhZGRyLCBhZGRybGVuLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBuZXdzb2NrID0gc29jay5zb2NrX29wcy5hY2NlcHQoc29jayk7XG4gICAgICBpZiAoYWRkcikge1xuICAgICAgICB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIG5ld3NvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUobmV3c29jay5kYWRkciksIG5ld3NvY2suZHBvcnQsIGFkZHJsZW4pO1xuICAgICAgICBhc3NlcnQoIWVycm5vKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdzb2NrLnN0cmVhbS5mZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZXROdG9wNChhZGRyKSB7XG4gICAgICByZXR1cm4gKGFkZHIgJiAweGZmKSArICcuJyArICgoYWRkciA+PiA4KSAmIDB4ZmYpICsgJy4nICsgKChhZGRyID4+IDE2KSAmIDB4ZmYpICsgJy4nICsgKChhZGRyID4+IDI0KSAmIDB4ZmYpXG4gICAgfVxuICBcbiAgZnVuY3Rpb24gaW5ldE50b3A2KGludHMpIHtcbiAgICAgIC8vICByZWY6ICBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzczLnR4dCAtIHNlY3Rpb24gMi41LjRcbiAgICAgIC8vICBGb3JtYXQgZm9yIElQdjQgY29tcGF0aWJsZSBhbmQgbWFwcGVkICAxMjgtYml0IElQdjYgQWRkcmVzc2VzXG4gICAgICAvLyAgMTI4LWJpdHMgYXJlIHNwbGl0IGludG8gZWlnaHQgMTYtYml0IHdvcmRzXG4gICAgICAvLyAgc3RvcmVkIGluIG5ldHdvcmsgYnl0ZSBvcmRlciAoYmlnLWVuZGlhbilcbiAgICAgIC8vICB8ICAgICAgICAgICAgICAgIDgwIGJpdHMgICAgICAgICAgICAgICB8IDE2IHwgICAgICAzMiBiaXRzICAgICAgICB8XG4gICAgICAvLyAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgLy8gIHwgICAgICAgICAgICAgICAxMCBieXRlcyAgICAgICAgICAgICAgIHwgIDIgfCAgICAgIDQgYnl0ZXMgICAgICAgIHxcbiAgICAgIC8vICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAvLyAgKyAgICAgICAgICAgICAgIDUgd29yZHMgICAgICAgICAgICAgICAgfCAgMSB8ICAgICAgMiB3b3JkcyAgICAgICAgfFxuICAgICAgLy8gICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgIC8vICB8MDAwMC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLjAwMDB8MDAwMHwgICAgSVB2NCBBRERSRVNTICAgICB8IChjb21wYXRpYmxlKVxuICAgICAgLy8gICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgIC8vICB8MDAwMC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLjAwMDB8RkZGRnwgICAgSVB2NCBBRERSRVNTICAgICB8IChtYXBwZWQpXG4gICAgICAvLyAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgd29yZCA9IDA7XG4gICAgICB2YXIgbG9uZ2VzdCA9IDA7XG4gICAgICB2YXIgbGFzdHplcm8gPSAwO1xuICAgICAgdmFyIHpzdGFydCA9IDA7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBwYXJ0cyA9IFtcbiAgICAgICAgaW50c1swXSAmIDB4ZmZmZixcbiAgICAgICAgKGludHNbMF0gPj4gMTYpLFxuICAgICAgICBpbnRzWzFdICYgMHhmZmZmLFxuICAgICAgICAoaW50c1sxXSA+PiAxNiksXG4gICAgICAgIGludHNbMl0gJiAweGZmZmYsXG4gICAgICAgIChpbnRzWzJdID4+IDE2KSxcbiAgICAgICAgaW50c1szXSAmIDB4ZmZmZixcbiAgICAgICAgKGludHNbM10gPj4gMTYpXG4gICAgICBdO1xuICBcbiAgICAgIC8vIEhhbmRsZSBJUHY0LWNvbXBhdGlibGUsIElQdjQtbWFwcGVkLCBsb29wYmFjayBhbmQgYW55L3Vuc3BlY2lmaWVkIGFkZHJlc3Nlc1xuICBcbiAgICAgIHZhciBoYXNpcHY0ID0gdHJ1ZTtcbiAgICAgIHZhciB2NHBhcnQgPSBcIlwiO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIDEwIGhpZ2gtb3JkZXIgYnl0ZXMgYXJlIGFsbCB6ZXJvcyAoZmlyc3QgNSB3b3JkcylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldICE9PSAwKSB7IGhhc2lwdjQgPSBmYWxzZTsgYnJlYWs7IH1cbiAgICAgIH1cbiAgXG4gICAgICBpZiAoaGFzaXB2NCkge1xuICAgICAgICAvLyBsb3ctb3JkZXIgMzItYml0cyBzdG9yZSBhbiBJUHY0IGFkZHJlc3MgKGJ5dGVzIDEzIHRvIDE2KSAobGFzdCAyIHdvcmRzKVxuICAgICAgICB2NHBhcnQgPSBpbmV0TnRvcDQocGFydHNbNl0gfCAocGFydHNbN10gPDwgMTYpKTtcbiAgICAgICAgLy8gSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzIGlmIDE2LWJpdCB2YWx1ZSAoYnl0ZXMgMTEgYW5kIDEyKSA9PSAweEZGRkYgKDZ0aCB3b3JkKVxuICAgICAgICBpZiAocGFydHNbNV0gPT09IC0xKSB7XG4gICAgICAgICAgc3RyID0gXCI6OmZmZmY6XCI7XG4gICAgICAgICAgc3RyICs9IHY0cGFydDtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIElQdjQtY29tcGF0aWJsZSBJUHY2IGFkZHJlc3MgaWYgMTYtYml0IHZhbHVlIChieXRlcyAxMSBhbmQgMTIpID09IDB4MDAwMCAoNnRoIHdvcmQpXG4gICAgICAgIGlmIChwYXJ0c1s1XSA9PT0gMCkge1xuICAgICAgICAgIHN0ciA9IFwiOjpcIjtcbiAgICAgICAgICAvL3NwZWNpYWwgY2FzZSBJUHY2IGFkZHJlc3Nlc1xuICAgICAgICAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMFwiKSB2NHBhcnQgPSBcIlwiOyAvLyBhbnkvdW5zcGVjaWZpZWQgYWRkcmVzc1xuICAgICAgICAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMVwiKSB2NHBhcnQgPSBcIjFcIjsvLyBsb29wYmFjayBhZGRyZXNzXG4gICAgICAgICAgc3RyICs9IHY0cGFydDtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgLy8gSGFuZGxlIGFsbCBvdGhlciBJUHY2IGFkZHJlc3Nlc1xuICBcbiAgICAgIC8vIGZpcnN0IHJ1biB0byBmaW5kIHRoZSBsb25nZXN0IGNvbnRpZ3VvdXMgemVybyB3b3Jkc1xuICAgICAgZm9yICh3b3JkID0gMDsgd29yZCA8IDg7IHdvcmQrKykge1xuICAgICAgICBpZiAocGFydHNbd29yZF0gPT09IDApIHtcbiAgICAgICAgICBpZiAod29yZCAtIGxhc3R6ZXJvID4gMSkge1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdHplcm8gPSB3b3JkO1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiBsb25nZXN0KSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IGxlbjtcbiAgICAgICAgICB6c3RhcnQgPSB3b3JkIC0gbG9uZ2VzdCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBmb3IgKHdvcmQgPSAwOyB3b3JkIDwgODsgd29yZCsrKSB7XG4gICAgICAgIGlmIChsb25nZXN0ID4gMSkge1xuICAgICAgICAgIC8vIGNvbXByZXNzIGNvbnRpZ3VvdXMgemVyb3MgLSB0byBwcm9kdWNlIFwiOjpcIlxuICAgICAgICAgIGlmIChwYXJ0c1t3b3JkXSA9PT0gMCAmJiB3b3JkID49IHpzdGFydCAmJiB3b3JkIDwgKHpzdGFydCArIGxvbmdlc3QpICkge1xuICAgICAgICAgICAgaWYgKHdvcmQgPT09IHpzdGFydCkge1xuICAgICAgICAgICAgICBzdHIgKz0gXCI6XCI7XG4gICAgICAgICAgICAgIGlmICh6c3RhcnQgPT09IDApIHN0ciArPSBcIjpcIjsgLy9sZWFkaW5nIHplcm9zIGNhc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0cyAxNi1iaXQgd29yZHMgZnJvbSBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYmVmb3JlIGNvbnZlcnRpbmcgdG8gaGV4IHN0cmluZ1xuICAgICAgICBzdHIgKz0gTnVtYmVyKF9udG9ocyhwYXJ0c1t3b3JkXSAmIDB4ZmZmZikpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgc3RyICs9IHdvcmQgPCA3ID8gXCI6XCIgOiBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGZ1bmN0aW9uIHJlYWRTb2NrYWRkcihzYSwgc2FsZW4pIHtcbiAgICAgIC8vIGZhbWlseSAvIHBvcnQgb2Zmc2V0cyBhcmUgY29tbW9uIHRvIGJvdGggc29ja2FkZHJfaW4gYW5kIHNvY2thZGRyX2luNlxuICAgICAgdmFyIGZhbWlseSA9IEhFQVAxNlsoKHNhKT4+MSldO1xuICAgICAgdmFyIHBvcnQgPSBfbnRvaHMoSEVBUFUxNlsoKChzYSkrKDIpKT4+MSldKTtcbiAgICAgIHZhciBhZGRyO1xuICBcbiAgICAgIHN3aXRjaCAoZmFtaWx5KSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoc2FsZW4gIT09IDE2KSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJubzogMjggfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkciA9IEhFQVAzMlsoKChzYSkrKDQpKT4+MildO1xuICAgICAgICAgIGFkZHIgPSBpbmV0TnRvcDQoYWRkcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgaWYgKHNhbGVuICE9PSAyOCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJybm86IDI4IH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZHIgPSBbXG4gICAgICAgICAgICBIRUFQMzJbKCgoc2EpKyg4KSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDE2KSk+PjIpXSxcbiAgICAgICAgICAgIEhFQVAzMlsoKChzYSkrKDIwKSk+PjIpXVxuICAgICAgICAgIF07XG4gICAgICAgICAgYWRkciA9IGluZXROdG9wNihhZGRyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4geyBlcnJubzogNSB9O1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiB7IGZhbWlseTogZmFtaWx5LCBhZGRyOiBhZGRyLCBwb3J0OiBwb3J0IH07XG4gICAgfVxuICAvKiogQHBhcmFtIHtib29sZWFuPX0gYWxsb3dOdWxsICovXG4gIGZ1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsIGFkZHJsZW4sIGFsbG93TnVsbCkge1xuICAgICAgaWYgKGFsbG93TnVsbCAmJiBhZGRycCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgaW5mbyA9IHJlYWRTb2NrYWRkcihhZGRycCwgYWRkcmxlbik7XG4gICAgICBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubyk7XG4gICAgICBpbmZvLmFkZHIgPSBETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKSB8fCBpbmZvLmFkZHI7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfYmluZChmZCwgYWRkciwgYWRkcmxlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0U29ja2V0QWRkcmVzcyhhZGRyLCBhZGRybGVuKTtcbiAgICAgIHNvY2suc29ja19vcHMuYmluZChzb2NrLCBpbmZvLmFkZHIsIGluZm8ucG9ydCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfY2hkaXIocGF0aCkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBGUy5jaGRpcihwYXRoKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9jb25uZWN0KGZkLCBhZGRyLCBhZGRybGVuKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuICAgICAgdmFyIGluZm8gPSBnZXRTb2NrZXRBZGRyZXNzKGFkZHIsIGFkZHJsZW4pO1xuICAgICAgc29jay5zb2NrX29wcy5jb25uZWN0KHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9kdXAoZmQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgb2xkID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIHJldHVybiBGUy5vcGVuKG9sZC5wYXRoLCBvbGQuZmxhZ3MsIDApLmZkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9kdXAzKGZkLCBzdWdnZXN0RkQsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIG9sZCA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICBhc3NlcnQoIWZsYWdzKTtcbiAgICAgIGlmIChvbGQuZmQgPT09IHN1Z2dlc3RGRCkgcmV0dXJuIC0yODtcbiAgICAgIHZhciBzdWdnZXN0ID0gRlMuZ2V0U3RyZWFtKHN1Z2dlc3RGRCk7XG4gICAgICBpZiAoc3VnZ2VzdCkgRlMuY2xvc2Uoc3VnZ2VzdCk7XG4gICAgICByZXR1cm4gRlMub3BlbihvbGQucGF0aCwgb2xkLmZsYWdzLCAwLCBzdWdnZXN0RkQsIHN1Z2dlc3RGRCkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCwgcGF0aCwgYW1vZGUsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIGFzc2VydChmbGFncyA9PT0gMCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvQWNjZXNzKHBhdGgsIGFtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgdmFyIGFyZyA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIGlmIChhcmcgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmV3U3RyZWFtO1xuICAgICAgICAgIG5ld1N0cmVhbSA9IEZTLm9wZW4oc3RyZWFtLnBhdGgsIHN0cmVhbS5mbGFncywgMCwgYXJnKTtcbiAgICAgICAgICByZXR1cm4gbmV3U3RyZWFtLmZkO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAwOyAgLy8gRkRfQ0xPRVhFQyBtYWtlcyBubyBzZW5zZSBmb3IgYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBzdHJlYW0uZmxhZ3M7XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICBzdHJlYW0uZmxhZ3MgfD0gYXJnO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgLyogY2FzZSA1OiBDdXJyZW50bHkgaW4gbXVzbCBGX0dFVExLNjQgaGFzIHNhbWUgdmFsdWUgYXMgRl9HRVRMSywgc28gb21pdHRlZCB0byBhdm9pZCBkdXBsaWNhdGUgY2FzZSBibG9ja3MuIElmIHRoYXQgY2hhbmdlcywgdW5jb21tZW50IHRoaXMgKi8ge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBhcmcgPSBTWVNDQUxMUy5nZXQoKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAvLyBXZSdyZSBhbHdheXMgdW5sb2NrZWQuXG4gICAgICAgICAgSEVBUDE2WygoKGFyZykrKG9mZnNldCkpPj4xKV0gPSAyO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAvKiBjYXNlIDY6IEN1cnJlbnRseSBpbiBtdXNsIEZfU0VUTEs2NCBoYXMgc2FtZSB2YWx1ZSBhcyBGX1NFVExLLCBzbyBvbWl0dGVkIHRvIGF2b2lkIGR1cGxpY2F0ZSBjYXNlIGJsb2Nrcy4gSWYgdGhhdCBjaGFuZ2VzLCB1bmNvbW1lbnQgdGhpcyAqL1xuICAgICAgICAvKiBjYXNlIDc6IEN1cnJlbnRseSBpbiBtdXNsIEZfU0VUTEtXNjQgaGFzIHNhbWUgdmFsdWUgYXMgRl9TRVRMS1csIHNvIG9taXR0ZWQgdG8gYXZvaWQgZHVwbGljYXRlIGNhc2UgYmxvY2tzLiBJZiB0aGF0IGNoYW5nZXMsIHVuY29tbWVudCB0aGlzICovXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIDA7IC8vIFByZXRlbmQgdGhhdCB0aGUgbG9ja2luZyBpcyBzdWNjZXNzZnVsLlxuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIC0yODsgLy8gVGhlc2UgYXJlIGZvciBzb2NrZXRzLiBXZSBkb24ndCBoYXZlIHRoZW0gZnVsbHkgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgLy8gbXVzbCB0cnVzdHMgZ2V0b3duIHJldHVybiB2YWx1ZXMsIGR1ZSB0byBhIGJ1ZyB3aGVyZSB0aGV5IG11c3QgYmUsIGFzIHRoZXkgb3ZlcmxhcCB3aXRoIGVycm9ycy4ganVzdCByZXR1cm4gLTEgaGVyZSwgc28gZm5jdGwoKSByZXR1cm5zIHRoYXQsIGFuZCB3ZSBzZXQgZXJybm8gb3Vyc2VsdmVzLlxuICAgICAgICAgIHNldEVyck5vKDI4KTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICByZXR1cm4gLTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5zdGF0LCBzdHJlYW0ucGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0Y3dkKGJ1Ziwgc2l6ZSkge1xuICB0cnkge1xuICBcbiAgICAgIGlmIChzaXplID09PSAwKSByZXR1cm4gLTI4O1xuICAgICAgdmFyIGN3ZCA9IEZTLmN3ZCgpO1xuICAgICAgdmFyIGN3ZExlbmd0aEluQnl0ZXMgPSBsZW5ndGhCeXRlc1VURjgoY3dkKTtcbiAgICAgIGlmIChzaXplIDwgY3dkTGVuZ3RoSW5CeXRlcyArIDEpIHJldHVybiAtNjg7XG4gICAgICBzdHJpbmdUb1VURjgoY3dkLCBidWYsIHNpemUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0ZGVudHM2NChmZCwgZGlycCwgY291bnQpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKVxuICAgICAgaWYgKCFzdHJlYW0uZ2V0ZGVudHMpIHtcbiAgICAgICAgc3RyZWFtLmdldGRlbnRzID0gRlMucmVhZGRpcihzdHJlYW0ucGF0aCk7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIHN0cnVjdF9zaXplID0gMjgwO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgb2ZmID0gRlMubGxzZWVrKHN0cmVhbSwgMCwgMSk7XG4gIFxuICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3Iob2ZmIC8gc3RydWN0X3NpemUpO1xuICBcbiAgICAgIHdoaWxlIChpZHggPCBzdHJlYW0uZ2V0ZGVudHMubGVuZ3RoICYmIHBvcyArIHN0cnVjdF9zaXplIDw9IGNvdW50KSB7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBuYW1lID0gc3RyZWFtLmdldGRlbnRzW2lkeF07XG4gICAgICAgIGlmIChuYW1lID09PSAnLicpIHtcbiAgICAgICAgICBpZCA9IHN0cmVhbS5ub2RlLmlkO1xuICAgICAgICAgIHR5cGUgPSA0OyAvLyBEVF9ESVJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnLi4nKSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoc3RyZWFtLnBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgICAgICAgIGlkID0gbG9va3VwLm5vZGUuaWQ7XG4gICAgICAgICAgdHlwZSA9IDQ7IC8vIERUX0RJUlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZCA9IEZTLmxvb2t1cE5vZGUoc3RyZWFtLm5vZGUsIG5hbWUpO1xuICAgICAgICAgIGlkID0gY2hpbGQuaWQ7XG4gICAgICAgICAgdHlwZSA9IEZTLmlzQ2hyZGV2KGNoaWxkLm1vZGUpID8gMiA6ICAvLyBEVF9DSFIsIGNoYXJhY3RlciBkZXZpY2UuXG4gICAgICAgICAgICAgICAgIEZTLmlzRGlyKGNoaWxkLm1vZGUpID8gNCA6ICAgICAvLyBEVF9ESVIsIGRpcmVjdG9yeS5cbiAgICAgICAgICAgICAgICAgRlMuaXNMaW5rKGNoaWxkLm1vZGUpID8gMTAgOiAgIC8vIERUX0xOSywgc3ltYm9saWMgbGluay5cbiAgICAgICAgICAgICAgICAgODsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERUX1JFRywgcmVndWxhciBmaWxlLlxuICAgICAgICB9XG4gICAgICAgIGFzc2VydChpZCk7XG4gICAgICAgICh0ZW1wSTY0ID0gW2lkPj4+MCwodGVtcERvdWJsZT1pZCwoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKGRpcnAgKyBwb3MpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChkaXJwICsgcG9zKSsoNCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgKHRlbXBJNjQgPSBbKGlkeCArIDEpICogc3RydWN0X3NpemU+Pj4wLCh0ZW1wRG91YmxlPShpZHggKyAxKSAqIHN0cnVjdF9zaXplLCgrKE1hdGguYWJzKHRlbXBEb3VibGUpKSkgPj0gMS4wID8gKHRlbXBEb3VibGUgPiAwLjAgPyAoKE1hdGgubWluKCgrKE1hdGguZmxvb3IoKHRlbXBEb3VibGUpLzQyOTQ5NjcyOTYuMCkpKSwgNDI5NDk2NzI5NS4wKSl8MCk+Pj4wIDogKH5+KCgrKE1hdGguY2VpbCgodGVtcERvdWJsZSAtICsoKCh+fih0ZW1wRG91YmxlKSkpPj4+MCkpLzQyOTQ5NjcyOTYuMCkpKSkpPj4+MCkgOiAwKV0sSEVBUDMyWygoKGRpcnAgKyBwb3MpKyg4KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKGRpcnAgKyBwb3MpKygxMikpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgICAgSEVBUDE2WygoKGRpcnAgKyBwb3MpKygxNikpPj4xKV0gPSAyODA7XG4gICAgICAgIEhFQVA4WygoKGRpcnAgKyBwb3MpKygxOCkpPj4wKV0gPSB0eXBlO1xuICAgICAgICBzdHJpbmdUb1VURjgobmFtZSwgZGlycCArIHBvcyArIDE5LCAyNTYpO1xuICAgICAgICBwb3MgKz0gc3RydWN0X3NpemU7XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgaWR4ICogc3RydWN0X3NpemUsIDApO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0c29ja25hbWUoZmQsIGFkZHIsIGFkZHJsZW4pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBlcnIoXCJfX3N5c2NhbGxfZ2V0c29ja25hbWUgXCIgKyBmZCk7XG4gICAgICB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gICAgICAvLyBUT0RPOiBzb2NrLnNhZGRyIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQsIHNlZSBUT0RPIGluIHdlYnNvY2tldF9zb2NrX29wcy5nZXRuYW1lXG4gICAgICB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUoc29jay5zYWRkciB8fCAnMC4wLjAuMCcpLCBzb2NrLnNwb3J0LCBhZGRybGVuKTtcbiAgICAgIGFzc2VydCghZXJybm8pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsIGxldmVsLCBvcHRuYW1lLCBvcHR2YWwsIG9wdGxlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIC8vIE1pbmltYWwgZ2V0c29ja29wdCBhaW1lZCBhdCByZXNvbHZpbmcgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2lzc3Vlcy8yMjExXG4gICAgICAvLyBzbyBvbmx5IHN1cHBvcnRzIFNPTF9TT0NLRVQgd2l0aCBTT19FUlJPUi5cbiAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICBpZiAob3B0bmFtZSA9PT0gNCkge1xuICAgICAgICAgIEhFQVAzMlsoKG9wdHZhbCk+PjIpXSA9IHNvY2suZXJyb3I7XG4gICAgICAgICAgSEVBUDMyWygob3B0bGVuKT4+MildID0gNDtcbiAgICAgICAgICBzb2NrLmVycm9yID0gbnVsbDsgLy8gQ2xlYXIgdGhlIGVycm9yIChUaGUgU09fRVJST1Igb3B0aW9uIG9idGFpbnMgYW5kIHRoZW4gY2xlYXJzIHRoaXMgZmllbGQpLlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTUwOyAvLyBUaGUgb3B0aW9uIGlzIHVua25vd24gYXQgdGhlIGxldmVsIGluZGljYXRlZC5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIDIxNTA5OlxuICAgICAgICBjYXNlIDIxNTA1OiB7XG4gICAgICAgICAgaWYgKCFzdHJlYW0udHR5KSByZXR1cm4gLTU5O1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MTA6XG4gICAgICAgIGNhc2UgMjE1MTE6XG4gICAgICAgIGNhc2UgMjE1MTI6XG4gICAgICAgIGNhc2UgMjE1MDY6XG4gICAgICAgIGNhc2UgMjE1MDc6XG4gICAgICAgIGNhc2UgMjE1MDg6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIG5vLW9wLCBub3QgYWN0dWFsbHkgYWRqdXN0aW5nIHRlcm1pbmFsIHNldHRpbmdzXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMTUxOToge1xuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIEhFQVAzMlsoKGFyZ3ApPj4yKV0gPSAwO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MjA6IHtcbiAgICAgICAgICBpZiAoIXN0cmVhbS50dHkpIHJldHVybiAtNTk7XG4gICAgICAgICAgcmV0dXJuIC0yODsgLy8gbm90IHN1cHBvcnRlZFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjE1MzE6IHtcbiAgICAgICAgICB2YXIgYXJncCA9IFNZU0NBTExTLmdldCgpO1xuICAgICAgICAgIHJldHVybiBGUy5pb2N0bChzdHJlYW0sIG9wLCBhcmdwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTIzOiB7XG4gICAgICAgICAgLy8gVE9ETzogaW4gdGhlb3J5IHdlIHNob3VsZCB3cml0ZSB0byB0aGUgd2luc2l6ZSBzdHJ1Y3QgdGhhdCBnZXRzXG4gICAgICAgICAgLy8gcGFzc2VkIGluLCBidXQgZm9yIG5vdyBtdXNsIGRvZXNuJ3QgcmVhZCBhbnl0aGluZyBvbiBpdFxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIxNTI0OiB7XG4gICAgICAgICAgLy8gVE9ETzogdGVjaG5pY2FsbHksIHRoaXMgaW9jdGwgY2FsbCBzaG91bGQgY2hhbmdlIHRoZSB3aW5kb3cgc2l6ZS5cbiAgICAgICAgICAvLyBidXQsIHNpbmNlIGVtc2NyaXB0ZW4gZG9lc24ndCBoYXZlIGFueSBjb25jZXB0IG9mIGEgdGVybWluYWwgd2luZG93XG4gICAgICAgICAgLy8geWV0LCB3ZSdsbCBqdXN0IHNpbGVudGx5IHRocm93IGl0IGF3YXkgYXMgd2UgZG8gVElPQ0dXSU5TWlxuICAgICAgICAgIGlmICghc3RyZWFtLnR0eSkgcmV0dXJuIC01OTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiBhYm9ydCgnYmFkIGlvY3RsIHN5c2NhbGwgJyArIG9wKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbGlzdGVuKGZkLCBiYWNrbG9nKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuICAgICAgc29jay5zb2NrX29wcy5saXN0ZW4oc29jaywgYmFja2xvZyk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcmV0dXJuIFNZU0NBTExTLmRvU3RhdChGUy5sc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXIocGF0aCwgbW9kZSkge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICByZXR1cm4gU1lTQ0FMTFMuZG9Na2RpcihwYXRoLCBtb2RlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtub2QocGF0aCwgbW9kZSwgZGV2KSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb01rbm9kKHBhdGgsIG1vZGUsIGRldik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX25ld2ZzdGF0YXQoZGlyZmQsIHBhdGgsIGJ1ZiwgZmxhZ3MpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgdmFyIG5vZm9sbG93ID0gZmxhZ3MgJiAyNTY7XG4gICAgICB2YXIgYWxsb3dFbXB0eSA9IGZsYWdzICYgNDA5NjtcbiAgICAgIGZsYWdzID0gZmxhZ3MgJiAofjQzNTIpO1xuICAgICAgYXNzZXJ0KCFmbGFncywgZmxhZ3MpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoLCBhbGxvd0VtcHR5KTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQobm9mb2xsb3cgPyBGUy5sc3RhdCA6IEZTLnN0YXQsIHBhdGgsIGJ1Zik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChkaXJmZCwgcGF0aCk7XG4gICAgICB2YXIgbW9kZSA9IHZhcmFyZ3MgPyBTWVNDQUxMUy5nZXQoKSA6IDA7XG4gICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgbW9kZSkuZmQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICB2YXIgUElQRUZTID0ge0JVQ0tFVF9CVUZGRVJfU0laRTo4MTkyLG1vdW50OmZ1bmN0aW9uIChtb3VudCkge1xuICAgICAgICAvLyBEbyBub3QgcG9sbHV0ZSB0aGUgcmVhbCByb290IGRpcmVjdG9yeSBvciBpdHMgY2hpbGQgbm9kZXMgd2l0aCBwaXBlc1xuICAgICAgICAvLyBMb29rcyBsaWtlIGl0IGlzIE9LIHRvIGNyZWF0ZSBhbm90aGVyIHBzZXVkby1yb290IG5vZGUgbm90IGxpbmtlZCB0byB0aGUgRlMucm9vdCBoaWVyYXJjaHkgdGhpcyB3YXlcbiAgICAgICAgcmV0dXJuIEZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSAvKiAwNzc3ICovLCAwKTtcbiAgICAgIH0sY3JlYXRlUGlwZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaXBlID0ge1xuICAgICAgICAgIGJ1Y2tldHM6IFtdLFxuICAgICAgICAgIC8vIHJlZmNudCAyIGJlY2F1c2UgcGlwZSBoYXMgYSByZWFkIGVuZCBhbmQgYSB3cml0ZSBlbmQuIFdlIG5lZWQgdG8gYmVcbiAgICAgICAgICAvLyBhYmxlIHRvIHJlYWQgZnJvbSB0aGUgcmVhZCBlbmQgYWZ0ZXIgd3JpdGUgZW5kIGlzIGNsb3NlZC5cbiAgICAgICAgICByZWZjbnQgOiAyLFxuICAgICAgICB9O1xuICBcbiAgICAgICAgcGlwZS5idWNrZXRzLnB1c2goe1xuICAgICAgICAgIGJ1ZmZlcjogbmV3IFVpbnQ4QXJyYXkoUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSksXG4gICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICB2YXIgck5hbWUgPSBQSVBFRlMubmV4dG5hbWUoKTtcbiAgICAgICAgdmFyIHdOYW1lID0gUElQRUZTLm5leHRuYW1lKCk7XG4gICAgICAgIHZhciByTm9kZSA9IEZTLmNyZWF0ZU5vZGUoUElQRUZTLnJvb3QsIHJOYW1lLCA0MDk2LCAwKTtcbiAgICAgICAgdmFyIHdOb2RlID0gRlMuY3JlYXRlTm9kZShQSVBFRlMucm9vdCwgd05hbWUsIDQwOTYsIDApO1xuICBcbiAgICAgICAgck5vZGUucGlwZSA9IHBpcGU7XG4gICAgICAgIHdOb2RlLnBpcGUgPSBwaXBlO1xuICBcbiAgICAgICAgdmFyIHJlYWRhYmxlU3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBwYXRoOiByTmFtZSxcbiAgICAgICAgICBub2RlOiByTm9kZSxcbiAgICAgICAgICBmbGFnczogMCxcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogUElQRUZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gICAgICAgIHJOb2RlLnN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICBcbiAgICAgICAgdmFyIHdyaXRhYmxlU3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKHtcbiAgICAgICAgICBwYXRoOiB3TmFtZSxcbiAgICAgICAgICBub2RlOiB3Tm9kZSxcbiAgICAgICAgICBmbGFnczogMSxcbiAgICAgICAgICBzZWVrYWJsZTogZmFsc2UsXG4gICAgICAgICAgc3RyZWFtX29wczogUElQRUZTLnN0cmVhbV9vcHNcbiAgICAgICAgfSk7XG4gICAgICAgIHdOb2RlLnN0cmVhbSA9IHdyaXRhYmxlU3RyZWFtO1xuICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZWFkYWJsZV9mZDogcmVhZGFibGVTdHJlYW0uZmQsXG4gICAgICAgICAgd3JpdGFibGVfZmQ6IHdyaXRhYmxlU3RyZWFtLmZkXG4gICAgICAgIH07XG4gICAgICB9LHN0cmVhbV9vcHM6e3BvbGw6ZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgXG4gICAgICAgICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICgyNTYgfCA0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBpcGUuYnVja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGlwZS5idWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IHBpcGUuYnVja2V0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0Lm9mZnNldCAtIGJ1Y2tldC5yb2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICg2NCB8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0saW9jdGw6ZnVuY3Rpb24gKHN0cmVhbSwgcmVxdWVzdCwgdmFyYXJncykge1xuICAgICAgICAgIHJldHVybiAyODtcbiAgICAgICAgfSxmc3luYzpmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIDI4O1xuICAgICAgICB9LHJlYWQ6ZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24gLyogaWdub3JlZCAqLykge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgICAgICAgICB2YXIgY3VycmVudExlbmd0aCA9IDA7XG4gIFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGlwZS5idWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnVja2V0ID0gcGlwZS5idWNrZXRzW2ldO1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBidWNrZXQub2Zmc2V0IC0gYnVja2V0LnJvZmZzZXQ7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBhc3NlcnQoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZmZlcikpO1xuICAgICAgICAgIHZhciBkYXRhID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgXG4gICAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgLy8gQmVoYXZlIGFzIGlmIHRoZSByZWFkIGVuZCBpcyBhbHdheXMgbm9uLWJsb2NraW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvUmVhZCA9IE1hdGgubWluKGN1cnJlbnRMZW5ndGgsIGxlbmd0aCk7XG4gIFxuICAgICAgICAgIHZhciB0b3RhbFJlYWQgPSB0b1JlYWQ7XG4gICAgICAgICAgdmFyIHRvUmVtb3ZlID0gMDtcbiAgXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaXBlLmJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyQnVja2V0ID0gcGlwZS5idWNrZXRzW2ldO1xuICAgICAgICAgICAgdmFyIGJ1Y2tldFNpemUgPSBjdXJyQnVja2V0Lm9mZnNldCAtIGN1cnJCdWNrZXQucm9mZnNldDtcbiAgXG4gICAgICAgICAgICBpZiAodG9SZWFkIDw9IGJ1Y2tldFNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIHRtcFNsaWNlID0gY3VyckJ1Y2tldC5idWZmZXIuc3ViYXJyYXkoY3VyckJ1Y2tldC5yb2Zmc2V0LCBjdXJyQnVja2V0Lm9mZnNldCk7XG4gICAgICAgICAgICAgIGlmICh0b1JlYWQgPCBidWNrZXRTaXplKSB7XG4gICAgICAgICAgICAgICAgdG1wU2xpY2UgPSB0bXBTbGljZS5zdWJhcnJheSgwLCB0b1JlYWQpO1xuICAgICAgICAgICAgICAgIGN1cnJCdWNrZXQucm9mZnNldCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhLnNldCh0bXBTbGljZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHRtcFNsaWNlID0gY3VyckJ1Y2tldC5idWZmZXIuc3ViYXJyYXkoY3VyckJ1Y2tldC5yb2Zmc2V0LCBjdXJyQnVja2V0Lm9mZnNldCk7XG4gICAgICAgICAgICAgIGRhdGEuc2V0KHRtcFNsaWNlKTtcbiAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkodG1wU2xpY2UuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIHRvUmVhZCAtPSB0bXBTbGljZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICB0b1JlbW92ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlID09IHBpcGUuYnVja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBnZW5lcmF0ZSBleGNlc3NpdmUgZ2FyYmFnZSBpbiB1c2UgY2FzZXMgc3VjaCBhc1xuICAgICAgICAgICAgLy8gd3JpdGUgc2V2ZXJhbCBieXRlcywgcmVhZCBldmVyeXRoaW5nLCB3cml0ZSBzZXZlcmFsIGJ5dGVzLCByZWFkIGV2ZXJ5dGhpbmcuLi5cbiAgICAgICAgICAgIHRvUmVtb3ZlLS07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHNbdG9SZW1vdmVdLm9mZnNldCA9IDA7XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHNbdG9SZW1vdmVdLnJvZmZzZXQgPSAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgcGlwZS5idWNrZXRzLnNwbGljZSgwLCB0b1JlbW92ZSk7XG4gIFxuICAgICAgICAgIHJldHVybiB0b3RhbFJlYWQ7XG4gICAgICAgIH0sd3JpdGU6ZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24gLyogaWdub3JlZCAqLykge1xuICAgICAgICAgIHZhciBwaXBlID0gc3RyZWFtLm5vZGUucGlwZTtcbiAgXG4gICAgICAgICAgYXNzZXJ0KGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpKTtcbiAgICAgICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gIFxuICAgICAgICAgIHZhciBkYXRhTGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmIChkYXRhTGVuIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIGN1cnJCdWNrZXQgPSBudWxsO1xuICBcbiAgICAgICAgICBpZiAocGlwZS5idWNrZXRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBjdXJyQnVja2V0ID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChjdXJyQnVja2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckJ1Y2tldCA9IHBpcGUuYnVja2V0c1twaXBlLmJ1Y2tldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBhc3NlcnQoY3VyckJ1Y2tldC5vZmZzZXQgPD0gUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSk7XG4gIFxuICAgICAgICAgIHZhciBmcmVlQnl0ZXNJbkN1cnJCdWZmZXIgPSBQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFIC0gY3VyckJ1Y2tldC5vZmZzZXQ7XG4gICAgICAgICAgaWYgKGZyZWVCeXRlc0luQ3VyckJ1ZmZlciA+PSBkYXRhTGVuKSB7XG4gICAgICAgICAgICBjdXJyQnVja2V0LmJ1ZmZlci5zZXQoZGF0YSwgY3VyckJ1Y2tldC5vZmZzZXQpO1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5vZmZzZXQgKz0gZGF0YUxlbjtcbiAgICAgICAgICAgIHJldHVybiBkYXRhTGVuO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJlZUJ5dGVzSW5DdXJyQnVmZmVyID4gMCkge1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5idWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkoMCwgZnJlZUJ5dGVzSW5DdXJyQnVmZmVyKSwgY3VyckJ1Y2tldC5vZmZzZXQpO1xuICAgICAgICAgICAgY3VyckJ1Y2tldC5vZmZzZXQgKz0gZnJlZUJ5dGVzSW5DdXJyQnVmZmVyO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3ViYXJyYXkoZnJlZUJ5dGVzSW5DdXJyQnVmZmVyLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgdmFyIG51bUJ1Y2tldHMgPSAoZGF0YS5ieXRlTGVuZ3RoIC8gUElQRUZTLkJVQ0tFVF9CVUZGRVJfU0laRSkgfCAwO1xuICAgICAgICAgIHZhciByZW1FbGVtZW50cyA9IGRhdGEuYnl0ZUxlbmd0aCAlIFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkU7XG4gIFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQnVja2V0czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmV3QnVja2V0ID0ge1xuICAgICAgICAgICAgICBidWZmZXI6IG5ldyBVaW50OEFycmF5KFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IFBJUEVGUy5CVUNLRVRfQlVGRkVSX1NJWkUsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChuZXdCdWNrZXQpO1xuICAgICAgICAgICAgbmV3QnVja2V0LmJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheSgwLCBQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFKSk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zdWJhcnJheShQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFLCBkYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgaWYgKHJlbUVsZW1lbnRzID4gMCkge1xuICAgICAgICAgICAgdmFyIG5ld0J1Y2tldCA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiBuZXcgVWludDhBcnJheShQSVBFRlMuQlVDS0VUX0JVRkZFUl9TSVpFKSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIHJvZmZzZXQ6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMucHVzaChuZXdCdWNrZXQpO1xuICAgICAgICAgICAgbmV3QnVja2V0LmJ1ZmZlci5zZXQoZGF0YSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICByZXR1cm4gZGF0YUxlbjtcbiAgICAgICAgfSxjbG9zZTpmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHBpcGUgPSBzdHJlYW0ubm9kZS5waXBlO1xuICAgICAgICAgIHBpcGUucmVmY250LS07XG4gICAgICAgICAgaWYgKHBpcGUucmVmY250ID09PSAwKSB7XG4gICAgICAgICAgICBwaXBlLmJ1Y2tldHMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfX0sbmV4dG5hbWU6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIVBJUEVGUy5uZXh0bmFtZS5jdXJyZW50KSB7XG4gICAgICAgICAgUElQRUZTLm5leHRuYW1lLmN1cnJlbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAncGlwZVsnICsgKFBJUEVGUy5uZXh0bmFtZS5jdXJyZW50KyspICsgJ10nO1xuICAgICAgfX07XG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfcGlwZShmZFB0cikge1xuICB0cnkge1xuICBcbiAgICAgIGlmIChmZFB0ciA9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDIxKTtcbiAgICAgIH1cbiAgXG4gICAgICB2YXIgcmVzID0gUElQRUZTLmNyZWF0ZVBpcGUoKTtcbiAgXG4gICAgICBIRUFQMzJbKChmZFB0cik+PjIpXSA9IHJlcy5yZWFkYWJsZV9mZDtcbiAgICAgIEhFQVAzMlsoKChmZFB0cikrKDQpKT4+MildID0gcmVzLndyaXRhYmxlX2ZkO1xuICBcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9yZWFkbGlua2F0KGRpcmZkLCBwYXRoLCBidWYsIGJ1ZnNpemUpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgcGF0aCA9IFNZU0NBTExTLmNhbGN1bGF0ZUF0KGRpcmZkLCBwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1JlYWRsaW5rKHBhdGgsIGJ1ZiwgYnVmc2l6ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JlY3Zmcm9tKGZkLCBidWYsIGxlbiwgZmxhZ3MsIGFkZHIsIGFkZHJsZW4pIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gICAgICB2YXIgbXNnID0gc29jay5zb2NrX29wcy5yZWN2bXNnKHNvY2ssIGxlbik7XG4gICAgICBpZiAoIW1zZykgcmV0dXJuIDA7IC8vIHNvY2tldCBpcyBjbG9zZWRcbiAgICAgIGlmIChhZGRyKSB7XG4gICAgICAgIHZhciBlcnJubyA9IHdyaXRlU29ja2FkZHIoYWRkciwgc29jay5mYW1pbHksIEROUy5sb29rdXBfbmFtZShtc2cuYWRkciksIG1zZy5wb3J0LCBhZGRybGVuKTtcbiAgICAgICAgYXNzZXJ0KCFlcnJubyk7XG4gICAgICB9XG4gICAgICBIRUFQVTguc2V0KG1zZy5idWZmZXIsIGJ1Zik7XG4gICAgICByZXR1cm4gbXNnLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9yZW5hbWVhdChvbGRkaXJmZCwgb2xkcGF0aCwgbmV3ZGlyZmQsIG5ld3BhdGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBvbGRwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKG9sZHBhdGgpO1xuICAgICAgbmV3cGF0aCA9IFNZU0NBTExTLmdldFN0cihuZXdwYXRoKTtcbiAgICAgIG9sZHBhdGggPSBTWVNDQUxMUy5jYWxjdWxhdGVBdChvbGRkaXJmZCwgb2xkcGF0aCk7XG4gICAgICBuZXdwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQobmV3ZGlyZmQsIG5ld3BhdGgpO1xuICAgICAgRlMucmVuYW1lKG9sZHBhdGgsIG5ld3BhdGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3JtZGlyKHBhdGgpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICBwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO1xuICAgICAgRlMucm1kaXIocGF0aCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc2VuZHRvKGZkLCBtZXNzYWdlLCBsZW5ndGgsIGZsYWdzLCBhZGRyLCBhZGRyX2xlbikge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiAgICAgIHZhciBkZXN0ID0gZ2V0U29ja2V0QWRkcmVzcyhhZGRyLCBhZGRyX2xlbiwgdHJ1ZSk7XG4gICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgLy8gc2VuZCwgbm8gYWRkcmVzcyBwcm92aWRlZFxuICAgICAgICByZXR1cm4gRlMud3JpdGUoc29jay5zdHJlYW0sIEhFQVA4LG1lc3NhZ2UsIGxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZW5kdG8gYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gc29jay5zb2NrX29wcy5zZW5kbXNnKHNvY2ssIEhFQVA4LG1lc3NhZ2UsIGxlbmd0aCwgZGVzdC5hZGRyLCBkZXN0LnBvcnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLCB0eXBlLCBwcm90b2NvbCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzb2NrID0gU09DS0ZTLmNyZWF0ZVNvY2tldChkb21haW4sIHR5cGUsIHByb3RvY29sKTtcbiAgICAgIGFzc2VydChzb2NrLnN0cmVhbS5mZCA8IDY0KTsgLy8gWFhYID8gc2VsZWN0KCkgYXNzdW1lcyBzb2NrZXQgZmQgdmFsdWVzIGFyZSBpbiAwLi42M1xuICAgICAgcmV0dXJuIHNvY2suc3RyZWFtLmZkO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiAtZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX19fc3lzY2FsbF9zdGF0NjQocGF0aCwgYnVmKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIHJldHVybiBTWVNDQUxMUy5kb1N0YXQoRlMuc3RhdCwgcGF0aCwgYnVmKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGxfc3ltbGluayh0YXJnZXQsIGxpbmtwYXRoKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdGFyZ2V0ID0gU1lTQ0FMTFMuZ2V0U3RyKHRhcmdldCk7XG4gICAgICBsaW5rcGF0aCA9IFNZU0NBTExTLmdldFN0cihsaW5rcGF0aCk7XG4gICAgICBGUy5zeW1saW5rKHRhcmdldCwgbGlua3BhdGgpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuICB0cnkge1xuICBcbiAgICAgIHBhdGggPSBTWVNDQUxMUy5nZXRTdHIocGF0aCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgpO1xuICAgICAgaWYgKGZsYWdzID09PSAwKSB7XG4gICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgPT09IDUxMikge1xuICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFib3J0KCdJbnZhbGlkIGZsYWdzIHBhc3NlZCB0byB1bmxpbmthdCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIC1lLmVycm5vO1xuICB9XG4gIH1cblxuICBmdW5jdGlvbiBfX19zeXNjYWxsX3V0aW1lbnNhdChkaXJmZCwgcGF0aCwgdGltZXMsIGZsYWdzKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgcGF0aCA9IFNZU0NBTExTLmdldFN0cihwYXRoKTtcbiAgICAgIGFzc2VydChmbGFncyA9PT0gMCk7XG4gICAgICBwYXRoID0gU1lTQ0FMTFMuY2FsY3VsYXRlQXQoZGlyZmQsIHBhdGgsIHRydWUpO1xuICAgICAgaWYgKCF0aW1lcykge1xuICAgICAgICB2YXIgYXRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgbXRpbWUgPSBhdGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWNvbmRzID0gSEVBUDMyWygodGltZXMpPj4yKV07XG4gICAgICAgIHZhciBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDQpKT4+MildO1xuICAgICAgICBhdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgICAgdGltZXMgKz0gODtcbiAgICAgICAgc2Vjb25kcyA9IEhFQVAzMlsoKHRpbWVzKT4+MildO1xuICAgICAgICBuYW5vc2Vjb25kcyA9IEhFQVAzMlsoKCh0aW1lcykrKDQpKT4+MildO1xuICAgICAgICBtdGltZSA9IChzZWNvbmRzKjEwMDApICsgKG5hbm9zZWNvbmRzLygxMDAwKjEwMDApKTtcbiAgICAgIH1cbiAgICAgIEZTLnV0aW1lKHBhdGgsIGF0aW1lLCBtdGltZSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gLWUuZXJybm87XG4gIH1cbiAgfVxuXG4gIHZhciBfX190YWJsZV9iYXNlID0gbmV3IFdlYkFzc2VtYmx5Lkdsb2JhbCh7J3ZhbHVlJzogJ2kzMicsICdtdXRhYmxlJzogZmFsc2V9LCAxKTtcblxuICB2YXIgRU5WID0ge307XG4gIFxuICBmdW5jdGlvbiBkbFNldEVycm9yKG1zZykge1xuICAgICAgd2l0aFN0YWNrU2F2ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNtc2cgPSBhbGxvY2F0ZVVURjhPblN0YWNrKG1zZyk7XG4gICAgICAgIF9fX2RsX3NldGVycihjbXNnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZnVuY3Rpb24gZGxvcGVuSW50ZXJuYWwoaGFuZGxlLCBqc2ZsYWdzKSB7XG4gICAgICAvLyB2b2lkICpkbG9wZW4oY29uc3QgY2hhciAqZmlsZSwgaW50IG1vZGUpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvZGxvcGVuLmh0bWxcbiAgICAgIHZhciBmaWxlbmFtZSA9IFVURjhUb1N0cmluZyhoYW5kbGUgKyA0NCk7XG4gICAgICB2YXIgZmxhZ3MgPSBIRUFQMzJbKCgoaGFuZGxlKSsoMjApKT4+MildO1xuICAgICAgZmlsZW5hbWUgPSBQQVRILm5vcm1hbGl6ZShmaWxlbmFtZSk7XG4gICAgICB2YXIgc2VhcmNocGF0aHMgPSBbXTtcbiAgXG4gICAgICB2YXIgaXNWYWxpZEZpbGUgPSAoZmlsZW5hbWUpID0+IHtcbiAgICAgICAgdmFyIHRhcmdldCA9IEZTLmZpbmRPYmplY3QoZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0ICYmICF0YXJnZXQuaXNGb2xkZXIgJiYgIXRhcmdldC5pc0RldmljZTtcbiAgICAgIH07XG4gIFxuICAgICAgaWYgKCFpc1ZhbGlkRmlsZShmaWxlbmFtZSkpIHtcbiAgICAgICAgaWYgKEVOVlsnTERfTElCUkFSWV9QQVRIJ10pIHtcbiAgICAgICAgICBzZWFyY2hwYXRocyA9IEVOVlsnTERfTElCUkFSWV9QQVRIJ10uc3BsaXQoJzonKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZm9yICh2YXIgaWRlbnQgaW4gc2VhcmNocGF0aHMpIHtcbiAgICAgICAgICB2YXIgc2VhcmNoZmlsZSA9IFBBVEguam9pbjIoc2VhcmNocGF0aHNbaWRlbnRdLCBmaWxlbmFtZSk7XG4gICAgICAgICAgaWYgKGlzVmFsaWRGaWxlKHNlYXJjaGZpbGUpKSB7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHNlYXJjaGZpbGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IFJUTERfTk9XIGFuZCBSVExEX0xBWlkuXG4gICAgICB2YXIgY29tYmluZWRGbGFncyA9IHtcbiAgICAgICAgZ2xvYmFsOiAgICBCb29sZWFuKGZsYWdzICYgMjU2KSxcbiAgICAgICAgbm9kZWxldGU6ICBCb29sZWFuKGZsYWdzICYgNDA5NiksXG4gICAgICAgIGxvYWRBc3luYzoganNmbGFncy5sb2FkQXN5bmMsXG4gICAgICAgIGZzOiAgICAgICAganNmbGFncy5mcyxcbiAgICAgIH1cbiAgXG4gICAgICBpZiAoanNmbGFncy5sb2FkQXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIGxvYWREeW5hbWljTGlicmFyeShmaWxlbmFtZSwgY29tYmluZWRGbGFncywgaGFuZGxlKTtcbiAgICAgIH1cbiAgXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9hZER5bmFtaWNMaWJyYXJ5KGZpbGVuYW1lLCBjb21iaW5lZEZsYWdzLCBoYW5kbGUpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycignRXJyb3IgaW4gbG9hZGluZyBkeW5hbWljIGxpYnJhcnkgJyArIGZpbGVuYW1lICsgXCI6IFwiICsgZSk7XG4gICAgICAgIGRsU2V0RXJyb3IoJ0NvdWxkIG5vdCBsb2FkIGR5bmFtaWMgbGliOiAnICsgZmlsZW5hbWUgKyAnXFxuJyArIGUpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGZ1bmN0aW9uIF9fZGxvcGVuX2pzKGhhbmRsZSkge1xuICAgICAgdmFyIGpzZmxhZ3MgPSB7XG4gICAgICAgIGxvYWRBc3luYzogZmFsc2UsXG4gICAgICAgIGZzOiBGUywgLy8gbG9hZCBsaWJyYXJpZXMgZnJvbSBwcm92aWRlZCBmaWxlc3lzdGVtXG4gICAgICB9XG4gICAgICByZXR1cm4gZGxvcGVuSW50ZXJuYWwoaGFuZGxlLCBqc2ZsYWdzKTtcbiAgICB9XG4gIF9fZGxvcGVuX2pzLnNpZyA9ICdpaWlpJztcblxuICBmdW5jdGlvbiBfX2Rsc3ltX2pzKGhhbmRsZSwgc3ltYm9sKSB7XG4gICAgICAvLyB2b2lkICpkbHN5bSh2b2lkICpyZXN0cmljdCBoYW5kbGUsIGNvbnN0IGNoYXIgKnJlc3RyaWN0IG5hbWUpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvZGxzeW0uaHRtbFxuICAgICAgc3ltYm9sID0gVVRGOFRvU3RyaW5nKHN5bWJvbCk7XG4gICAgICB2YXIgcmVzdWx0O1xuICBcbiAgICAgIGlmIChoYW5kbGUgPT0gMCkge1xuICAgICAgICByZXN1bHQgPSByZXNvbHZlR2xvYmFsU3ltYm9sKHN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgZGxTZXRFcnJvcignVHJpZWQgdG8gbG9va3VwIHVua25vd24gc3ltYm9sIFwiJyArIHN5bWJvbCArICdcIiBpbiBkeW5hbWljIGxpYjogUlRMRF9ERUZBVUxUJyk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaWIgPSBMRFNPLmxvYWRlZExpYnNCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICBhc3NlcnQobGliLCAnVHJpZWQgdG8gZGxzeW0oKSBmcm9tIGFuIHVub3BlbmVkIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICAgIGlmICghbGliLm1vZHVsZS5oYXNPd25Qcm9wZXJ0eShzeW1ib2wpKSB7XG4gICAgICAgICAgZGxTZXRFcnJvcignVHJpZWQgdG8gbG9va3VwIHVua25vd24gc3ltYm9sIFwiJyArIHN5bWJvbCArICdcIiBpbiBkeW5hbWljIGxpYjogJyArIGxpYi5uYW1lKVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpYi5tb2R1bGVbJ29yaWckJyArIHN5bWJvbF07XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICByZXN1bHQgPSBsaWIubW9kdWxlW3N5bWJvbF07XG4gICAgICB9XG4gIFxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGZ1bmN0aW9uIGludG8gdGhlIHdhc20gdGFibGUuICBJZiBpdHMgYSBkaXJlY3Qgd2FzbSBmdW5jdGlvblxuICAgICAgICAvLyB0aGUgc2Vjb25kIGFyZ3VtZW50IHdpbGwgbm90IGJlIG5lZWRlZC4gIElmIGl0cyBhIEpTIGZ1bmN0aW9uIHdlIHJlbHlcbiAgICAgICAgLy8gb24gdGhlIGBzaWdgIGF0dHJpYnV0ZSBiZWluZyBzZXQgYmFzZWQgb24gdGhlIGA8ZnVuYz5fX3NpZ2Agc3BlY2lmaWVkXG4gICAgICAgIC8vIGluIGxpYnJhcnkgSlMgZmlsZS5cbiAgICAgICAgcmVzdWx0ID0gYWRkRnVuY3Rpb24ocmVzdWx0LCByZXN1bHQuc2lnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBfX2Rsc3ltX2pzLnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9kYXRlX25vdygpIHtcbiAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cbiAgX19lbXNjcmlwdGVuX2RhdGVfbm93LnNpZyA9ICdqJztcblxuICB2YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlOztcbiAgZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuICAgICAgcmV0dXJuIG5vd0lzTW9ub3RvbmljO1xuICAgIH1cblxuICBmdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fdGhyb3dfbG9uZ2ptcCgpIHsgdGhyb3cgSW5maW5pdHk7IH1cbiAgX19lbXNjcmlwdGVuX3Rocm93X2xvbmdqbXAuc2lnID0gJ3YnO1xuXG4gIGZ1bmN0aW9uIF9fZ210aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKEhFQVAzMlsoKHRpbWUpPj4yKV0qMTAwMCk7XG4gICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoNCkpPj4yKV0gPSBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDgpKT4+MildID0gZGF0ZS5nZXRVVENIb3VycygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTIpKT4+MildID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCktMTkwMDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApO1xuICAgICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICB9XG4gIF9fZ210aW1lX2pzLnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKEhFQVAzMlsoKHRpbWUpPj4yKV0qMTAwMCk7XG4gICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoNCkpPj4yKV0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDgpKT4+MildID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTIpKT4+MildID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0gPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gPSBkYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0RGF5KCk7XG4gIFxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgIHZhciB5ZGF5ID0gKChkYXRlLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygyOCkpPj4yKV0gPSB5ZGF5O1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMzYpKT4+MildID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG4gIFxuICAgICAgLy8gQXR0ZW50aW9uOiBEU1QgaXMgaW4gRGVjZW1iZXIgaW4gU291dGgsIGFuZCBzb21lIHJlZ2lvbnMgZG9uJ3QgaGF2ZSBEU1QgYXQgYWxsLlxuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdCA9IChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpfDA7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKygzMikpPj4yKV0gPSBkc3Q7XG4gICAgfVxuICBfX2xvY2FsdGltZV9qcy5zaWcgPSAnaWlpJztcblxuICBmdW5jdGlvbiBfX21rdGltZV9qcyh0bVB0cikge1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gKyAxOTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gIFxuICAgICAgLy8gVGhlcmUncyBhbiBhbWJpZ3VvdXMgaG91ciB3aGVuIHRoZSB0aW1lIGdvZXMgYmFjazsgdGhlIHRtX2lzZHN0IGZpZWxkIGlzXG4gICAgICAvLyB1c2VkIHRvIGRpc2FtYmlndWF0ZSBpdC4gIERhdGUoKSBiYXNpY2FsbHkgZ3Vlc3Nlcywgc28gd2UgZml4IGl0IHVwIGlmIGl0XG4gICAgICAvLyBndWVzc2VkIHdyb25nLCBvciBmaWxsIGluIHRtX2lzZHN0IHdpdGggdGhlIGd1ZXNzIGlmIGl0J3MgLTEuXG4gICAgICB2YXIgZHN0ID0gSEVBUDMyWygoKHRtUHRyKSsoMzIpKT4+MildO1xuICAgICAgdmFyIGd1ZXNzZWRPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIGRzdE9mZnNldCA9IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTsgLy8gRFNUIGlzIGluIERlY2VtYmVyIGluIFNvdXRoXG4gICAgICBpZiAoZHN0IDwgMCkge1xuICAgICAgICAvLyBBdHRlbnRpb246IHNvbWUgcmVnaW9ucyBkb24ndCBoYXZlIERTVCBhdCBhbGwuXG4gICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDMyKSk+PjIpXSA9IE51bWJlcihzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRzdE9mZnNldCA9PSBndWVzc2VkT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoKGRzdCA+IDApICE9IChkc3RPZmZzZXQgPT0gZ3Vlc3NlZE9mZnNldCkpIHtcbiAgICAgICAgdmFyIG5vbkRzdE9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiAgICAgICAgdmFyIHRydWVPZmZzZXQgPSBkc3QgPiAwID8gZHN0T2Zmc2V0IDogbm9uRHN0T2Zmc2V0O1xuICAgICAgICAvLyBEb24ndCB0cnkgc2V0TWludXRlcyhkYXRlLmdldE1pbnV0ZXMoKSArIC4uLikgLS0gaXQncyBtZXNzZWQgdXAuXG4gICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICh0cnVlT2Zmc2V0IC0gZ3Vlc3NlZE9mZnNldCkqNjAwMDApO1xuICAgICAgfVxuICBcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICB2YXIgeWRheSA9ICgoZGF0ZS5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgICAgIC8vIFRvIG1hdGNoIGV4cGVjdGVkIGJlaGF2aW9yLCB1cGRhdGUgZmllbGRzIGZyb20gZGF0ZVxuICAgICAgSEVBUDMyWygodG1QdHIpPj4yKV0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICBIRUFQMzJbKCgodG1QdHIpKyg4KSk+PjIpXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMTYpKT4+MildID0gZGF0ZS5nZXRNb250aCgpO1xuICBcbiAgICAgIHJldHVybiAoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKXwwO1xuICAgIH1cbiAgX19ta3RpbWVfanMuc2lnID0gJ2lpJztcblxuICBmdW5jdGlvbiBfX3RpbWVnbV9qcyh0bVB0cikge1xuICAgICAgdmFyIHRpbWUgPSBEYXRlLlVUQyhIRUFQMzJbKCgodG1QdHIpKygyMCkpPj4yKV0gKyAxOTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCgodG1QdHIpKygxNikpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDEyKSk+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgSEVBUDMyWygoKHRtUHRyKSsoOCkpPj4yKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDQpKT4+MildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBIRUFQMzJbKCh0bVB0cik+PjIpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICBcbiAgICAgIEhFQVAzMlsoKCh0bVB0cikrKDI0KSk+PjIpXSA9IGRhdGUuZ2V0VVRDRGF5KCk7XG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEsIDAsIDAsIDAsIDApO1xuICAgICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKXwwO1xuICAgICAgSEVBUDMyWygoKHRtUHRyKSsoMjgpKT4+MildID0geWRheTtcbiAgXG4gICAgICByZXR1cm4gKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCl8MDtcbiAgICB9XG4gIF9fdGltZWdtX2pzLnNpZyA9ICdpaSc7XG5cbiAgZnVuY3Rpb24gX3R6c2V0X2ltcGwodGltZXpvbmUsIGRheWxpZ2h0LCB0em5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gICAgICB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuICAgICAgdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBcbiAgICAgIC8vIExvY2FsIHN0YW5kYXJkIHRpbWV6b25lIG9mZnNldC4gTG9jYWwgc3RhbmRhcmQgdGltZSBpcyBub3QgYWRqdXN0ZWQgZm9yIGRheWxpZ2h0IHNhdmluZ3MuXG4gICAgICAvLyBUaGlzIGNvZGUgdXNlcyB0aGUgZmFjdCB0aGF0IGdldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBncmVhdGVyIHZhbHVlIGR1cmluZyBTdGFuZGFyZCBUaW1lIHZlcnN1cyBEYXlsaWdodCBTYXZpbmcgVGltZSAoRFNUKS5cbiAgICAgIC8vIFRodXMgaXQgZGV0ZXJtaW5lcyB0aGUgZXhwZWN0ZWQgb3V0cHV0IGR1cmluZyBTdGFuZGFyZCBUaW1lLCBhbmQgaXQgY29tcGFyZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoZSBnaXZlbiBkYXRlIHRoZSBzYW1lIChTdGFuZGFyZCkgb3IgbGVzcyAoRFNUKS5cbiAgICAgIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiAgXG4gICAgICAvLyB0aW1lem9uZSBpcyBzcGVjaWZpZWQgYXMgc2Vjb25kcyB3ZXN0IG9mIFVUQyAoXCJUaGUgZXh0ZXJuYWwgdmFyaWFibGVcbiAgICAgIC8vIGB0aW1lem9uZWAgc2hhbGwgYmUgc2V0IHRvIHRoZSBkaWZmZXJlbmNlLCBpbiBzZWNvbmRzLCBiZXR3ZWVuXG4gICAgICAvLyBDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZSAoVVRDKSBhbmQgbG9jYWwgc3RhbmRhcmQgdGltZS5cIiksIHRoZSBzYW1lXG4gICAgICAvLyBhcyByZXR1cm5lZCBieSBzdGRUaW1lem9uZU9mZnNldC5cbiAgICAgIC8vIFNlZSBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDA5Njk1Mzk5L2Z1bmN0aW9ucy90enNldC5odG1sXG4gICAgICBIRUFQMzJbKCh0aW1lem9uZSk+PjIpXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG4gIFxuICAgICAgSEVBUDMyWygoZGF5bGlnaHQpPj4yKV0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG4gIFxuICAgICAgZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7XG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogXCJHTVRcIjtcbiAgICAgIH07XG4gICAgICB2YXIgd2ludGVyTmFtZSA9IGV4dHJhY3Rab25lKHdpbnRlcik7XG4gICAgICB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lcik7XG4gICAgICB2YXIgd2ludGVyTmFtZVB0ciA9IGFsbG9jYXRlVVRGOCh3aW50ZXJOYW1lKTtcbiAgICAgIHZhciBzdW1tZXJOYW1lUHRyID0gYWxsb2NhdGVVVEY4KHN1bW1lck5hbWUpO1xuICAgICAgaWYgKHN1bW1lck9mZnNldCA8IHdpbnRlck9mZnNldCkge1xuICAgICAgICAvLyBOb3J0aGVybiBoZW1pc3BoZXJlXG4gICAgICAgIEhFQVAzMlsoKHR6bmFtZSk+PjIpXSA9IHdpbnRlck5hbWVQdHI7XG4gICAgICAgIEhFQVAzMlsoKCh0em5hbWUpKyg0KSk+PjIpXSA9IHN1bW1lck5hbWVQdHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIRUFQMzJbKCh0em5hbWUpPj4yKV0gPSBzdW1tZXJOYW1lUHRyO1xuICAgICAgICBIRUFQMzJbKCgodHpuYW1lKSsoNCkpPj4yKV0gPSB3aW50ZXJOYW1lUHRyO1xuICAgICAgfVxuICAgIH1cbiAgX3R6c2V0X2ltcGwuc2lnID0gJ3ZpaWknO1xuICBmdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gICAgICAvLyBUT0RPOiBVc2UgKG1hbGxlYWJsZSkgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluc3RlYWQgb2Ygc3lzdGVtIHNldHRpbmdzLlxuICAgICAgaWYgKF9fdHpzZXRfanMuY2FsbGVkKSByZXR1cm47XG4gICAgICBfX3R6c2V0X2pzLmNhbGxlZCA9IHRydWU7XG4gICAgICBfdHpzZXRfaW1wbCh0aW1lem9uZSwgZGF5bGlnaHQsIHR6bmFtZSk7XG4gICAgfVxuICBfX3R6c2V0X2pzLnNpZyA9ICd2aWlpJztcblxuICBmdW5jdGlvbiBfYWJvcnQoKSB7XG4gICAgICBhYm9ydCgnbmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KCknKTtcbiAgICB9XG4gIF9hYm9ydC5zaWcgPSAndic7XG5cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcihzdHIpIHtcbiAgICAgIGFzc2VydCh0eXBlb2Ygc3RyID09ICdudW1iZXInKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoVVRGOFRvU3RyaW5nKHN0cikpO1xuICAgIH1cbiAgX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvci5zaWcgPSAndmknO1xuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpIHtcbiAgICAgIHJldHVybiBIRUFQVTgubGVuZ3RoO1xuICAgIH1cblxuICB2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAgIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiB7XG4gICAgICB2YXIgdCA9IHByb2Nlc3NbJ2hydGltZSddKCk7XG4gICAgICByZXR1cm4gdFswXSAqIDFlMyArIHRbMV0gLyAxZTY7XG4gICAgfTtcbiAgfSBlbHNlIF9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgO1xuXG4gIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiAgICAgIEhFQVBVOC5jb3B5V2l0aGluKGRlc3QsIHNyYywgc3JjICsgbnVtKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgYWJvcnQoJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMgdG8gc2l6ZSAnICsgcmVxdWVzdGVkU2l6ZSArICcgYnl0ZXMgKE9PTSkuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBJTklUSUFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgJyArIEhFQVA4Lmxlbmd0aCArICcsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICcpO1xuICAgIH1cbiAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuICAgICAgcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7XG4gICAgICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeShyZXF1ZXN0ZWRTaXplKTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpc1Byb2dyYW0gfHwgJy4vdGhpcy5wcm9ncmFtJztcbiAgICB9XG4gIGZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gICAgICBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgLy8gQnJvd3NlciBsYW5ndWFnZSBkZXRlY3Rpb24gIzg3NTFcbiAgICAgICAgdmFyIGxhbmcgPSAoKHR5cGVvZiBuYXZpZ2F0b3IgPT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdKSB8fCAnQycpLnJlcGxhY2UoJy0nLCAnXycpICsgJy5VVEYtOCc7XG4gICAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgICAgJ1VTRVInOiAnd2ViX3VzZXInLFxuICAgICAgICAgICdMT0dOQU1FJzogJ3dlYl91c2VyJyxcbiAgICAgICAgICAnUEFUSCc6ICcvJyxcbiAgICAgICAgICAnUFdEJzogJy8nLFxuICAgICAgICAgICdIT01FJzogJy9ob21lL3dlYl91c2VyJyxcbiAgICAgICAgICAnTEFORyc6IGxhbmcsXG4gICAgICAgICAgJ18nOiBnZXRFeGVjdXRhYmxlTmFtZSgpXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFwcGx5IHRoZSB1c2VyLXByb3ZpZGVkIHZhbHVlcywgaWYgYW55LlxuICAgICAgICBmb3IgKHZhciB4IGluIEVOVikge1xuICAgICAgICAgIC8vIHggaXMgYSBrZXkgaW4gRU5WOyBpZiBFTlZbeF0gaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIGl0IHdhc1xuICAgICAgICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRvIGJlIHNvLiBXZSBhbGxvdyB1c2VyIGNvZGUgdG8gZG8gdGhhdCB0b1xuICAgICAgICAgIC8vIGZvcmNlIHZhcmlhYmxlcyB3aXRoIGRlZmF1bHQgdmFsdWVzIHRvIHJlbWFpbiB1bnNldC5cbiAgICAgICAgICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07XG4gICAgICAgICAgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goeCArICc9JyArIGVudlt4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG4gICAgfVxuICBmdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuICAgICAgdmFyIGJ1ZlNpemUgPSAwO1xuICAgICAgZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLCBpKSB7XG4gICAgICAgIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gICAgICAgIEhFQVAzMlsoKChfX2Vudmlyb24pKyhpICogNCkpPj4yKV0gPSBwdHI7XG4gICAgICAgIHdyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcsIHB0cik7XG4gICAgICAgIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgX2Vudmlyb25fZ2V0LnNpZyA9ICdpaWknO1xuXG4gIGZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiAgICAgIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuICAgICAgSEVBUDMyWygocGVudmlyb25fY291bnQpPj4yKV0gPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIHZhciBidWZTaXplID0gMDtcbiAgICAgIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiAgICAgIH0pO1xuICAgICAgSEVBUDMyWygocGVudmlyb25fYnVmX3NpemUpPj4yKV0gPSBidWZTaXplO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBfZW52aXJvbl9zaXplc19nZXQuc2lnID0gJ2lpaSc7XG5cbiAgZnVuY3Rpb24gX2V4aXQoc3RhdHVzKSB7XG4gICAgICAvLyB2b2lkIF9leGl0KGludCBzdGF0dXMpO1xuICAgICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwMDA5NTM5OS9mdW5jdGlvbnMvZXhpdC5odG1sXG4gICAgICBleGl0KHN0YXR1cyk7XG4gICAgfVxuICBfZXhpdC5zaWcgPSAndmknO1xuXG4gIGZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICB0cnkge1xuICBcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX2Nsb3NlLnNpZyA9ICdpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiAgdHJ5IHtcbiAgXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICAgIC8vIEFsbCBjaGFyYWN0ZXIgZGV2aWNlcyBhcmUgdGVybWluYWxzIChvdGhlciB0aGluZ3MgYSBMaW51eCBzeXN0ZW0gd291bGRcbiAgICAgIC8vIGFzc3VtZSBpcyBhIGNoYXJhY3RlciBkZXZpY2UsIGxpa2UgdGhlIG1vdXNlLCB3ZSBoYXZlIHNwZWNpYWwgQVBJcyBmb3IpLlxuICAgICAgdmFyIHR5cGUgPSBzdHJlYW0udHR5ID8gMiA6XG4gICAgICAgICAgICAgICAgIEZTLmlzRGlyKHN0cmVhbS5tb2RlKSA/IDMgOlxuICAgICAgICAgICAgICAgICBGUy5pc0xpbmsoc3RyZWFtLm1vZGUpID8gNyA6XG4gICAgICAgICAgICAgICAgIDQ7XG4gICAgICBIRUFQOFsoKHBidWYpPj4wKV0gPSB0eXBlO1xuICAgICAgLy8gVE9ETyBIRUFQMTZbKCgocGJ1ZikrKDIpKT4+MSldID0gPztcbiAgICAgIC8vIFRPRE8gKHRlbXBJNjQgPSBbPz4+PjAsKHRlbXBEb3VibGU9PywoKyhNYXRoLmFicyh0ZW1wRG91YmxlKSkpID49IDEuMCA/ICh0ZW1wRG91YmxlID4gMC4wID8gKChNYXRoLm1pbigoKyhNYXRoLmZsb29yKCh0ZW1wRG91YmxlKS80Mjk0OTY3Mjk2LjApKSksIDQyOTQ5NjcyOTUuMCkpfDApPj4+MCA6ICh+figoKyhNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKCgofn4odGVtcERvdWJsZSkpKT4+PjApKS80Mjk0OTY3Mjk2LjApKSkpKT4+PjApIDogMCldLEhFQVAzMlsoKChwYnVmKSsoOCkpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChwYnVmKSsoMTIpKT4+MildID0gdGVtcEk2NFsxXSk7XG4gICAgICAvLyBUT0RPICh0ZW1wSTY0ID0gWz8+Pj4wLCh0ZW1wRG91YmxlPT8sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKCgocGJ1ZikrKDE2KSk+PjIpXSA9IHRlbXBJNjRbMF0sSEVBUDMyWygoKHBidWYpKygyMCkpPj4yKV0gPSB0ZW1wSTY0WzFdKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX2Zkc3RhdF9nZXQuc2lnID0gJ2lpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX3JlYWQoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgbnVtID0gU1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICAgIEhFQVAzMlsoKHBudW0pPj4yKV0gPSBudW07XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG4gIF9mZF9yZWFkLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2ZkX3NlZWsoZmQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCB3aGVuY2UsIG5ld09mZnNldCkge1xuICB0cnkge1xuICBcbiAgICAgIFxuICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgICB2YXIgSElHSF9PRkZTRVQgPSAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgICAgLy8gdXNlIGFuIHVuc2lnbmVkIG9wZXJhdG9yIG9uIGxvdyBhbmQgc2hpZnQgaGlnaCBieSAzMi1iaXRzXG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0X2hpZ2ggKiBISUdIX09GRlNFVCArIChvZmZzZXRfbG93ID4+PiAwKTtcbiAgXG4gICAgICB2YXIgRE9VQkxFX0xJTUlUID0gMHgyMDAwMDAwMDAwMDAwMDsgLy8gMl41M1xuICAgICAgLy8gd2UgYWxzbyBjaGVjayBmb3IgZXF1YWxpdHkgc2luY2UgRE9VQkxFX0xJTUlUICsgMSA9PSBET1VCTEVfTElNSVRcbiAgICAgIGlmIChvZmZzZXQgPD0gLURPVUJMRV9MSU1JVCB8fCBvZmZzZXQgPj0gRE9VQkxFX0xJTUlUKSB7XG4gICAgICAgIHJldHVybiAtNjE7XG4gICAgICB9XG4gIFxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xuICAgICAgKHRlbXBJNjQgPSBbc3RyZWFtLnBvc2l0aW9uPj4+MCwodGVtcERvdWJsZT1zdHJlYW0ucG9zaXRpb24sKCsoTWF0aC5hYnModGVtcERvdWJsZSkpKSA+PSAxLjAgPyAodGVtcERvdWJsZSA+IDAuMCA/ICgoTWF0aC5taW4oKCsoTWF0aC5mbG9vcigodGVtcERvdWJsZSkvNDI5NDk2NzI5Ni4wKSkpLCA0Mjk0OTY3Mjk1LjApKXwwKT4+PjAgOiAofn4oKCsoTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKygoKH5+KHRlbXBEb3VibGUpKSk+Pj4wKSkvNDI5NDk2NzI5Ni4wKSkpKSk+Pj4wKSA6IDApXSxIRUFQMzJbKChuZXdPZmZzZXQpPj4yKV0gPSB0ZW1wSTY0WzBdLEhFQVAzMlsoKChuZXdPZmZzZXQpKyg0KSk+PjIpXSA9IHRlbXBJNjRbMV0pO1xuICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyAvLyByZXNldCByZWFkZGlyIHN0YXRlXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuICB0cnkge1xuICBcbiAgICAgIDtcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgICAgdmFyIG51bSA9IFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgICAgSEVBUDMyWygocG51bSk+PjIpXSA9IG51bTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG4gIH1cbiAgX2ZkX3dyaXRlLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2dldFRlbXBSZXQwKCkge1xuICAgICAgcmV0dXJuIGdldFRlbXBSZXQwKCk7XG4gICAgfVxuICBfZ2V0VGVtcFJldDAuc2lnID0gJ2knO1xuXG4gIGZ1bmN0aW9uIF9nZXRhZGRyaW5mbyhub2RlLCBzZXJ2aWNlLCBoaW50LCBvdXQpIHtcbiAgICAgIC8vIE5vdGUgZ2V0YWRkcmluZm8gY3VycmVudGx5IG9ubHkgcmV0dXJucyBhIHNpbmdsZSBhZGRyaW5mbyB3aXRoIGFpX25leHQgZGVmYXVsdGluZyB0byBOVUxMLiBXaGVuIE5VTExcbiAgICAgIC8vIGhpbnRzIGFyZSBzcGVjaWZpZWQgb3IgYWlfZmFtaWx5IHNldCB0byBBRl9VTlNQRUMgb3IgYWlfc29ja3R5cGUgb3IgYWlfcHJvdG9jb2wgc2V0IHRvIDAgdGhlbiB3ZVxuICAgICAgLy8gcmVhbGx5IHNob3VsZCBwcm92aWRlIGEgbGlua2VkIGxpc3Qgb2Ygc3VpdGFibGUgYWRkcmluZm8gdmFsdWVzLlxuICAgICAgdmFyIGFkZHJzID0gW107XG4gICAgICB2YXIgY2Fub24gPSBudWxsO1xuICAgICAgdmFyIGFkZHIgPSAwO1xuICAgICAgdmFyIHBvcnQgPSAwO1xuICAgICAgdmFyIGZsYWdzID0gMDtcbiAgICAgIHZhciBmYW1pbHkgPSAwO1xuICAgICAgdmFyIHR5cGUgPSAwO1xuICAgICAgdmFyIHByb3RvID0gMDtcbiAgICAgIHZhciBhaSwgbGFzdDtcbiAgXG4gICAgICBmdW5jdGlvbiBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIGNhbm9uLCBhZGRyLCBwb3J0KSB7XG4gICAgICAgIHZhciBzYSwgc2FsZW4sIGFpO1xuICAgICAgICB2YXIgZXJybm87XG4gIFxuICAgICAgICBzYWxlbiA9IGZhbWlseSA9PT0gMTAgP1xuICAgICAgICAgIDI4IDpcbiAgICAgICAgICAxNjtcbiAgICAgICAgYWRkciA9IGZhbWlseSA9PT0gMTAgP1xuICAgICAgICAgIGluZXROdG9wNihhZGRyKSA6XG4gICAgICAgICAgaW5ldE50b3A0KGFkZHIpO1xuICAgICAgICBzYSA9IF9tYWxsb2Moc2FsZW4pO1xuICAgICAgICBlcnJubyA9IHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCk7XG4gICAgICAgIGFzc2VydCghZXJybm8pO1xuICBcbiAgICAgICAgYWkgPSBfbWFsbG9jKDMyKTtcbiAgICAgICAgSEVBUDMyWygoKGFpKSsoNCkpPj4yKV0gPSBmYW1pbHk7XG4gICAgICAgIEhFQVAzMlsoKChhaSkrKDgpKT4+MildID0gdHlwZTtcbiAgICAgICAgSEVBUDMyWygoKGFpKSsoMTIpKT4+MildID0gcHJvdG87XG4gICAgICAgIEhFQVAzMlsoKChhaSkrKDI0KSk+PjIpXSA9IGNhbm9uO1xuICAgICAgICBIRUFQMzJbKCgoYWkpKygyMCkpPj4yKV0gPSBzYTtcbiAgICAgICAgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgICAgICAgICBIRUFQMzJbKCgoYWkpKygxNikpPj4yKV0gPSAyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBIRUFQMzJbKCgoYWkpKygxNikpPj4yKV0gPSAxNjtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKCgoYWkpKygyOCkpPj4yKV0gPSAwO1xuICBcbiAgICAgICAgcmV0dXJuIGFpO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChoaW50KSB7XG4gICAgICAgIGZsYWdzID0gSEVBUDMyWygoaGludCk+PjIpXTtcbiAgICAgICAgZmFtaWx5ID0gSEVBUDMyWygoKGhpbnQpKyg0KSk+PjIpXTtcbiAgICAgICAgdHlwZSA9IEhFQVAzMlsoKChoaW50KSsoOCkpPj4yKV07XG4gICAgICAgIHByb3RvID0gSEVBUDMyWygoKGhpbnQpKygxMikpPj4yKV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZSAmJiAhcHJvdG8pIHtcbiAgICAgICAgcHJvdG8gPSB0eXBlID09PSAyID8gMTcgOiA2O1xuICAgICAgfVxuICAgICAgaWYgKCF0eXBlICYmIHByb3RvKSB7XG4gICAgICAgIHR5cGUgPSBwcm90byA9PT0gMTcgPyAyIDogMTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBJZiB0eXBlIG9yIHByb3RvIGFyZSBzZXQgdG8gemVybyBpbiBoaW50cyB3ZSBzaG91bGQgcmVhbGx5IGJlIHJldHVybmluZyBtdWx0aXBsZSBhZGRyaW5mbyB2YWx1ZXMsIGJ1dCBmb3JcbiAgICAgIC8vIG5vdyBkZWZhdWx0IHRvIGEgVENQIFNUUkVBTSBzb2NrZXQgc28gd2UgY2FuIGF0IGxlYXN0IHJldHVybiBhIHNlbnNpYmxlIGFkZHJpbmZvIGdpdmVuIE5VTEwgaGludHMuXG4gICAgICBpZiAocHJvdG8gPT09IDApIHtcbiAgICAgICAgcHJvdG8gPSA2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgdHlwZSA9IDE7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCFub2RlICYmICFzZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIH4oMXwyfDR8XG4gICAgICAgICAgMTAyNHw4fDE2fDMyKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoaGludCAhPT0gMCAmJiAoSEVBUDMyWygoaGludCk+PjIpXSAmIDIpICYmICFub2RlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIDMyKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSAmJiB0eXBlICE9PSAyKSB7XG4gICAgICAgIHJldHVybiAtNztcbiAgICAgIH1cbiAgICAgIGlmIChmYW1pbHkgIT09IDAgJiYgZmFtaWx5ICE9PSAyICYmIGZhbWlseSAhPT0gMTApIHtcbiAgICAgICAgcmV0dXJuIC02O1xuICAgICAgfVxuICBcbiAgICAgIGlmIChzZXJ2aWNlKSB7XG4gICAgICAgIHNlcnZpY2UgPSBVVEY4VG9TdHJpbmcoc2VydmljZSk7XG4gICAgICAgIHBvcnQgPSBwYXJzZUludChzZXJ2aWNlLCAxMCk7XG4gIFxuICAgICAgICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAxMDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCByZXNvbHZpbmcgd2VsbC1rbm93biBzZXJ2aWNlIG5hbWVzIGZyb206XG4gICAgICAgICAgLy8gaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zZXJ2aWNlLW5hbWVzLXBvcnQtbnVtYmVycy9zZXJ2aWNlLW5hbWVzLXBvcnQtbnVtYmVycy50eHRcbiAgICAgICAgICByZXR1cm4gLTg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgaWYgKGZhbWlseSA9PT0gMCkge1xuICAgICAgICAgIGZhbWlseSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChmbGFncyAmIDEpID09PSAwKSB7XG4gICAgICAgICAgaWYgKGZhbWlseSA9PT0gMikge1xuICAgICAgICAgICAgYWRkciA9IF9odG9ubCgyMTMwNzA2NDMzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkciA9IFswLCAwLCAwLCAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG51bGwsIGFkZHIsIHBvcnQpO1xuICAgICAgICBIRUFQMzJbKChvdXQpPj4yKV0gPSBhaTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gIFxuICAgICAgLy9cbiAgICAgIC8vIHRyeSBhcyBhIG51bWVyaWMgYWRkcmVzc1xuICAgICAgLy9cbiAgICAgIG5vZGUgPSBVVEY4VG9TdHJpbmcobm9kZSk7XG4gICAgICBhZGRyID0gaW5ldFB0b240KG5vZGUpO1xuICAgICAgaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5jb21pbmcgbm9kZSBpcyBhIHZhbGlkIGlwdjQgYWRkcmVzc1xuICAgICAgICBpZiAoZmFtaWx5ID09PSAwIHx8IGZhbWlseSA9PT0gMikge1xuICAgICAgICAgIGZhbWlseSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmFtaWx5ID09PSAxMCAmJiAoZmxhZ3MgJiA4KSkge1xuICAgICAgICAgIGFkZHIgPSBbMCwgMCwgX2h0b25sKDB4ZmZmZiksIGFkZHJdO1xuICAgICAgICAgIGZhbWlseSA9IDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkciA9IGluZXRQdG9uNihub2RlKTtcbiAgICAgICAgaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBpbmNvbWluZyBub2RlIGlzIGEgdmFsaWQgaXB2NiBhZGRyZXNzXG4gICAgICAgICAgaWYgKGZhbWlseSA9PT0gMCB8fCBmYW1pbHkgPT09IDEwKSB7XG4gICAgICAgICAgICBmYW1pbHkgPSAxMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbm9kZSwgYWRkciwgcG9ydCk7XG4gICAgICAgIEhFQVAzMlsoKG91dCk+PjIpXSA9IGFpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgfVxuICBcbiAgICAgIC8vXG4gICAgICAvLyB0cnkgYXMgYSBob3N0bmFtZVxuICAgICAgLy9cbiAgICAgIC8vIHJlc29sdmUgdGhlIGhvc3RuYW1lIHRvIGEgdGVtcG9yYXJ5IGZha2UgYWRkcmVzc1xuICAgICAgbm9kZSA9IEROUy5sb29rdXBfbmFtZShub2RlKTtcbiAgICAgIGFkZHIgPSBpbmV0UHRvbjQobm9kZSk7XG4gICAgICBpZiAoZmFtaWx5ID09PSAwKSB7XG4gICAgICAgIGZhbWlseSA9IDI7XG4gICAgICB9IGVsc2UgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgICAgICAgYWRkciA9IFswLCAwLCBfaHRvbmwoMHhmZmZmKSwgYWRkcl07XG4gICAgICB9XG4gICAgICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbnVsbCwgYWRkciwgcG9ydCk7XG4gICAgICBIRUFQMzJbKChvdXQpPj4yKV0gPSBhaTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgX2dldGFkZHJpbmZvLnNpZyA9ICdpaWlpaSc7XG5cbiAgZnVuY3Rpb24gX2dldG5hbWVpbmZvKHNhLCBzYWxlbiwgbm9kZSwgbm9kZWxlbiwgc2Vydiwgc2VydmxlbiwgZmxhZ3MpIHtcbiAgICAgIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKHNhLCBzYWxlbik7XG4gICAgICBpZiAoaW5mby5lcnJubykge1xuICAgICAgICByZXR1cm4gLTY7XG4gICAgICB9XG4gICAgICB2YXIgcG9ydCA9IGluZm8ucG9ydDtcbiAgICAgIHZhciBhZGRyID0gaW5mby5hZGRyO1xuICBcbiAgICAgIHZhciBvdmVyZmxvd2VkID0gZmFsc2U7XG4gIFxuICAgICAgaWYgKG5vZGUgJiYgbm9kZWxlbikge1xuICAgICAgICB2YXIgbG9va3VwO1xuICAgICAgICBpZiAoKGZsYWdzICYgMSkgfHwgIShsb29rdXAgPSBETlMubG9va3VwX2FkZHIoYWRkcikpKSB7XG4gICAgICAgICAgaWYgKGZsYWdzICYgOCkge1xuICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRyID0gbG9va3VwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IHN0cmluZ1RvVVRGOChhZGRyLCBub2RlLCBub2RlbGVuKTtcbiAgXG4gICAgICAgIGlmIChudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCsxID49IG5vZGVsZW4pIHtcbiAgICAgICAgICBvdmVyZmxvd2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIGlmIChzZXJ2ICYmIHNlcnZsZW4pIHtcbiAgICAgICAgcG9ydCA9ICcnICsgcG9ydDtcbiAgICAgICAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gc3RyaW5nVG9VVEY4KHBvcnQsIHNlcnYsIHNlcnZsZW4pO1xuICBcbiAgICAgICAgaWYgKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsKzEgPj0gc2Vydmxlbikge1xuICAgICAgICAgIG92ZXJmbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gIFxuICAgICAgaWYgKG92ZXJmbG93ZWQpIHtcbiAgICAgICAgLy8gTm90ZTogZXZlbiB3aGVuIHdlIG92ZXJmbG93LCBnZXRuYW1laW5mbygpIGlzIHNwZWNjZWQgdG8gd3JpdGUgb3V0IHRoZSB0cnVuY2F0ZWQgcmVzdWx0cy5cbiAgICAgICAgcmV0dXJuIC0xMjtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gICAgICBwcm9jRXhpdChjb2RlKTtcbiAgICB9XG4gIF9wcm9jX2V4aXQuc2lnID0gJ3ZpJztcblxuICBmdW5jdGlvbiBfcHRocmVhZF9zZXRzY2hlZHBhcmFtKFxuICApIHtcbiAgaWYgKCFNb2R1bGVbJ19wdGhyZWFkX3NldHNjaGVkcGFyYW0nXSkgYWJvcnQoXCJleHRlcm5hbCBzeW1ib2wgJ3B0aHJlYWRfc2V0c2NoZWRwYXJhbScgaXMgbWlzc2luZy4gcGVyaGFwcyBhIHNpZGUgbW9kdWxlIHdhcyBub3QgbGlua2VkIGluPyBpZiB0aGlzIGZ1bmN0aW9uIHdhcyBleHBlY3RlZCB0byBhcnJpdmUgZnJvbSBhIHN5c3RlbSBsaWJyYXJ5LCB0cnkgdG8gYnVpbGQgdGhlIE1BSU5fTU9EVUxFIHdpdGggRU1DQ19GT1JDRV9TVERMSUJTPTEgaW4gdGhlIGVudmlyb25tZW50XCIpO1xuICByZXR1cm4gTW9kdWxlWydfcHRocmVhZF9zZXRzY2hlZHBhcmFtJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZW1fdGltZWR3YWl0KFxuICApIHtcbiAgaWYgKCFNb2R1bGVbJ19zZW1fdGltZWR3YWl0J10pIGFib3J0KFwiZXh0ZXJuYWwgc3ltYm9sICdzZW1fdGltZWR3YWl0JyBpcyBtaXNzaW5nLiBwZXJoYXBzIGEgc2lkZSBtb2R1bGUgd2FzIG5vdCBsaW5rZWQgaW4/IGlmIHRoaXMgZnVuY3Rpb24gd2FzIGV4cGVjdGVkIHRvIGFycml2ZSBmcm9tIGEgc3lzdGVtIGxpYnJhcnksIHRyeSB0byBidWlsZCB0aGUgTUFJTl9NT0RVTEUgd2l0aCBFTUNDX0ZPUkNFX1NURExJQlM9MSBpbiB0aGUgZW52aXJvbm1lbnRcIik7XG4gIHJldHVybiBNb2R1bGVbJ19zZW1fdGltZWR3YWl0J10uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zZXRUZW1wUmV0MCh2YWwpIHtcbiAgICAgIHNldFRlbXBSZXQwKHZhbCk7XG4gICAgfVxuICBfc2V0VGVtcFJldDAuc2lnID0gJ3ZpJztcblxuICBmdW5jdGlvbiBfc3lzdGVtKGNvbW1hbmQpIHtcbiAgICAgIC8vIGludCBzeXN0ZW0oY29uc3QgY2hhciAqY29tbWFuZCk7XG4gICAgICAvLyBodHRwOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDAwMDk1Mzk5L2Z1bmN0aW9ucy9zeXN0ZW0uaHRtbFxuICAgICAgLy8gQ2FuJ3QgY2FsbCBleHRlcm5hbCBwcm9ncmFtcy5cbiAgICAgIGlmICghY29tbWFuZCkgcmV0dXJuIDA7IC8vIG5vIHNoZWxsIGF2YWlsYWJsZVxuICAgICAgc2V0RXJyTm8oNTIpO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICB2YXIgRlNOb2RlID0gLyoqIEBjb25zdHJ1Y3RvciAqLyBmdW5jdGlvbihwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcGFyZW50ID0gdGhpczsgIC8vIHJvb3Qgbm9kZSBzZXRzIHBhcmVudCB0byBpdHNlbGZcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5tb3VudCA9IHBhcmVudC5tb3VudDtcbiAgICB0aGlzLm1vdW50ZWQgPSBudWxsO1xuICAgIHRoaXMuaWQgPSBGUy5uZXh0SW5vZGUrKztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5ub2RlX29wcyA9IHt9O1xuICAgIHRoaXMuc3RyZWFtX29wcyA9IHt9O1xuICAgIHRoaXMucmRldiA9IHJkZXY7XG4gIH07XG4gIHZhciByZWFkTW9kZSA9IDI5Mi8qMjkyKi8gfCA3My8qNzMqLztcbiAgdmFyIHdyaXRlTW9kZSA9IDE0Ni8qMTQ2Ki87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTTm9kZS5wcm90b3R5cGUsIHtcbiAgIHJlYWQ6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgcmVhZE1vZGUpID09PSByZWFkTW9kZTtcbiAgICB9LFxuICAgIHNldDogLyoqIEB0aGlze0ZTTm9kZX0gKi9mdW5jdGlvbih2YWwpIHtcbiAgICAgdmFsID8gdGhpcy5tb2RlIHw9IHJlYWRNb2RlIDogdGhpcy5tb2RlICY9IH5yZWFkTW9kZTtcbiAgICB9XG4gICB9LFxuICAgd3JpdGU6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiAodGhpcy5tb2RlICYgd3JpdGVNb2RlKSA9PT0gd3JpdGVNb2RlO1xuICAgIH0sXG4gICAgc2V0OiAvKiogQHRoaXN7RlNOb2RlfSAqL2Z1bmN0aW9uKHZhbCkge1xuICAgICB2YWwgPyB0aGlzLm1vZGUgfD0gd3JpdGVNb2RlIDogdGhpcy5tb2RlICY9IH53cml0ZU1vZGU7XG4gICAgfVxuICAgfSxcbiAgIGlzRm9sZGVyOiB7XG4gICAgZ2V0OiAvKiogQHRoaXN7RlNOb2RlfSAqL2Z1bmN0aW9uKCkge1xuICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKTtcbiAgICB9XG4gICB9LFxuICAgaXNEZXZpY2U6IHtcbiAgICBnZXQ6IC8qKiBAdGhpc3tGU05vZGV9ICovZnVuY3Rpb24oKSB7XG4gICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpO1xuICAgIH1cbiAgIH1cbiAgfSk7XG4gIEZTLkZTTm9kZSA9IEZTTm9kZTtcbiAgRlMuc3RhdGljSW5pdCgpOztcbkVSUk5PX0NPREVTID0ge1xuICAgICAgJ0VQRVJNJzogNjMsXG4gICAgICAnRU5PRU5UJzogNDQsXG4gICAgICAnRVNSQ0gnOiA3MSxcbiAgICAgICdFSU5UUic6IDI3LFxuICAgICAgJ0VJTyc6IDI5LFxuICAgICAgJ0VOWElPJzogNjAsXG4gICAgICAnRTJCSUcnOiAxLFxuICAgICAgJ0VOT0VYRUMnOiA0NSxcbiAgICAgICdFQkFERic6IDgsXG4gICAgICAnRUNISUxEJzogMTIsXG4gICAgICAnRUFHQUlOJzogNixcbiAgICAgICdFV09VTERCTE9DSyc6IDYsXG4gICAgICAnRU5PTUVNJzogNDgsXG4gICAgICAnRUFDQ0VTJzogMixcbiAgICAgICdFRkFVTFQnOiAyMSxcbiAgICAgICdFTk9UQkxLJzogMTA1LFxuICAgICAgJ0VCVVNZJzogMTAsXG4gICAgICAnRUVYSVNUJzogMjAsXG4gICAgICAnRVhERVYnOiA3NSxcbiAgICAgICdFTk9ERVYnOiA0MyxcbiAgICAgICdFTk9URElSJzogNTQsXG4gICAgICAnRUlTRElSJzogMzEsXG4gICAgICAnRUlOVkFMJzogMjgsXG4gICAgICAnRU5GSUxFJzogNDEsXG4gICAgICAnRU1GSUxFJzogMzMsXG4gICAgICAnRU5PVFRZJzogNTksXG4gICAgICAnRVRYVEJTWSc6IDc0LFxuICAgICAgJ0VGQklHJzogMjIsXG4gICAgICAnRU5PU1BDJzogNTEsXG4gICAgICAnRVNQSVBFJzogNzAsXG4gICAgICAnRVJPRlMnOiA2OSxcbiAgICAgICdFTUxJTksnOiAzNCxcbiAgICAgICdFUElQRSc6IDY0LFxuICAgICAgJ0VET00nOiAxOCxcbiAgICAgICdFUkFOR0UnOiA2OCxcbiAgICAgICdFTk9NU0cnOiA0OSxcbiAgICAgICdFSURSTSc6IDI0LFxuICAgICAgJ0VDSFJORyc6IDEwNixcbiAgICAgICdFTDJOU1lOQyc6IDE1NixcbiAgICAgICdFTDNITFQnOiAxMDcsXG4gICAgICAnRUwzUlNUJzogMTA4LFxuICAgICAgJ0VMTlJORyc6IDEwOSxcbiAgICAgICdFVU5BVENIJzogMTEwLFxuICAgICAgJ0VOT0NTSSc6IDExMSxcbiAgICAgICdFTDJITFQnOiAxMTIsXG4gICAgICAnRURFQURMSyc6IDE2LFxuICAgICAgJ0VOT0xDSyc6IDQ2LFxuICAgICAgJ0VCQURFJzogMTEzLFxuICAgICAgJ0VCQURSJzogMTE0LFxuICAgICAgJ0VYRlVMTCc6IDExNSxcbiAgICAgICdFTk9BTk8nOiAxMDQsXG4gICAgICAnRUJBRFJRQyc6IDEwMyxcbiAgICAgICdFQkFEU0xUJzogMTAyLFxuICAgICAgJ0VERUFETE9DSyc6IDE2LFxuICAgICAgJ0VCRk9OVCc6IDEwMSxcbiAgICAgICdFTk9TVFInOiAxMDAsXG4gICAgICAnRU5PREFUQSc6IDExNixcbiAgICAgICdFVElNRSc6IDExNyxcbiAgICAgICdFTk9TUic6IDExOCxcbiAgICAgICdFTk9ORVQnOiAxMTksXG4gICAgICAnRU5PUEtHJzogMTIwLFxuICAgICAgJ0VSRU1PVEUnOiAxMjEsXG4gICAgICAnRU5PTElOSyc6IDQ3LFxuICAgICAgJ0VBRFYnOiAxMjIsXG4gICAgICAnRVNSTU5UJzogMTIzLFxuICAgICAgJ0VDT01NJzogMTI0LFxuICAgICAgJ0VQUk9UTyc6IDY1LFxuICAgICAgJ0VNVUxUSUhPUCc6IDM2LFxuICAgICAgJ0VET1RET1QnOiAxMjUsXG4gICAgICAnRUJBRE1TRyc6IDksXG4gICAgICAnRU5PVFVOSVEnOiAxMjYsXG4gICAgICAnRUJBREZEJzogMTI3LFxuICAgICAgJ0VSRU1DSEcnOiAxMjgsXG4gICAgICAnRUxJQkFDQyc6IDEyOSxcbiAgICAgICdFTElCQkFEJzogMTMwLFxuICAgICAgJ0VMSUJTQ04nOiAxMzEsXG4gICAgICAnRUxJQk1BWCc6IDEzMixcbiAgICAgICdFTElCRVhFQyc6IDEzMyxcbiAgICAgICdFTk9TWVMnOiA1MixcbiAgICAgICdFTk9URU1QVFknOiA1NSxcbiAgICAgICdFTkFNRVRPT0xPTkcnOiAzNyxcbiAgICAgICdFTE9PUCc6IDMyLFxuICAgICAgJ0VPUE5PVFNVUFAnOiAxMzgsXG4gICAgICAnRVBGTk9TVVBQT1JUJzogMTM5LFxuICAgICAgJ0VDT05OUkVTRVQnOiAxNSxcbiAgICAgICdFTk9CVUZTJzogNDIsXG4gICAgICAnRUFGTk9TVVBQT1JUJzogNSxcbiAgICAgICdFUFJPVE9UWVBFJzogNjcsXG4gICAgICAnRU5PVFNPQ0snOiA1NyxcbiAgICAgICdFTk9QUk9UT09QVCc6IDUwLFxuICAgICAgJ0VTSFVURE9XTic6IDE0MCxcbiAgICAgICdFQ09OTlJFRlVTRUQnOiAxNCxcbiAgICAgICdFQUREUklOVVNFJzogMyxcbiAgICAgICdFQ09OTkFCT1JURUQnOiAxMyxcbiAgICAgICdFTkVUVU5SRUFDSCc6IDQwLFxuICAgICAgJ0VORVRET1dOJzogMzgsXG4gICAgICAnRVRJTUVET1VUJzogNzMsXG4gICAgICAnRUhPU1RET1dOJzogMTQyLFxuICAgICAgJ0VIT1NUVU5SRUFDSCc6IDIzLFxuICAgICAgJ0VJTlBST0dSRVNTJzogMjYsXG4gICAgICAnRUFMUkVBRFknOiA3LFxuICAgICAgJ0VERVNUQUREUlJFUSc6IDE3LFxuICAgICAgJ0VNU0dTSVpFJzogMzUsXG4gICAgICAnRVBST1RPTk9TVVBQT1JUJzogNjYsXG4gICAgICAnRVNPQ0tUTk9TVVBQT1JUJzogMTM3LFxuICAgICAgJ0VBRERSTk9UQVZBSUwnOiA0LFxuICAgICAgJ0VORVRSRVNFVCc6IDM5LFxuICAgICAgJ0VJU0NPTk4nOiAzMCxcbiAgICAgICdFTk9UQ09OTic6IDUzLFxuICAgICAgJ0VUT09NQU5ZUkVGUyc6IDE0MSxcbiAgICAgICdFVVNFUlMnOiAxMzYsXG4gICAgICAnRURRVU9UJzogMTksXG4gICAgICAnRVNUQUxFJzogNzIsXG4gICAgICAnRU5PVFNVUCc6IDEzOCxcbiAgICAgICdFTk9NRURJVU0nOiAxNDgsXG4gICAgICAnRUlMU0VRJzogMjUsXG4gICAgICAnRU9WRVJGTE9XJzogNjEsXG4gICAgICAnRUNBTkNFTEVEJzogMTEsXG4gICAgICAnRU5PVFJFQ09WRVJBQkxFJzogNTYsXG4gICAgICAnRU9XTkVSREVBRCc6IDYyLFxuICAgICAgJ0VTVFJQSVBFJzogMTM1LFxuICAgIH07O1xudmFyIEFTU0VSVElPTlMgPSB0cnVlO1xuXG5cblxuLyoqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcsIGJvb2xlYW49LCBudW1iZXI9KX0gKi9cbmZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7XG4gIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XG4gIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gIHJldHVybiB1OGFycmF5O1xufVxuXG5mdW5jdGlvbiBpbnRBcnJheVRvU3RyaW5nKGFycmF5KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaHIgPSBhcnJheVtpXTtcbiAgICBpZiAoY2hyID4gMHhGRikge1xuICAgICAgaWYgKEFTU0VSVElPTlMpIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnQ2hhcmFjdGVyIGNvZGUgJyArIGNociArICcgKCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyAnKSAgYXQgb2Zmc2V0ICcgKyBpICsgJyBub3QgaW4gMHgwMC0weEZGLicpO1xuICAgICAgfVxuICAgICAgY2hyICY9IDB4RkY7XG4gICAgfVxuICAgIHJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn1cblxuXG5mdW5jdGlvbiBjaGVja0luY29taW5nTW9kdWxlQVBJKCkge1xuICBpZ25vcmVkTW9kdWxlUHJvcCgnZmV0Y2hTZXR0aW5ncycpO1xufVxudmFyIGNvcmVMaWJyYXJ5QXJnID0ge1xuICBcIl9fYXNzZXJ0X2ZhaWxcIjogX19fYXNzZXJ0X2ZhaWwsXG4gIFwiX19jYWxsX3NpZ2hhbmRsZXJcIjogX19fY2FsbF9zaWdoYW5kbGVyLFxuICBcIl9faGVhcF9iYXNlXCI6IF9fX2hlYXBfYmFzZSxcbiAgXCJfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlXCI6IHdhc21UYWJsZSxcbiAgXCJfX21lbW9yeV9iYXNlXCI6IF9fX21lbW9yeV9iYXNlLFxuICBcIl9fc3RhY2tfcG9pbnRlclwiOiBfX19zdGFja19wb2ludGVyLFxuICBcIl9fc3lzY2FsbF9fbmV3c2VsZWN0XCI6IF9fX3N5c2NhbGxfX25ld3NlbGVjdCxcbiAgXCJfX3N5c2NhbGxfYWNjZXB0NFwiOiBfX19zeXNjYWxsX2FjY2VwdDQsXG4gIFwiX19zeXNjYWxsX2JpbmRcIjogX19fc3lzY2FsbF9iaW5kLFxuICBcIl9fc3lzY2FsbF9jaGRpclwiOiBfX19zeXNjYWxsX2NoZGlyLFxuICBcIl9fc3lzY2FsbF9jb25uZWN0XCI6IF9fX3N5c2NhbGxfY29ubmVjdCxcbiAgXCJfX3N5c2NhbGxfZHVwXCI6IF9fX3N5c2NhbGxfZHVwLFxuICBcIl9fc3lzY2FsbF9kdXAzXCI6IF9fX3N5c2NhbGxfZHVwMyxcbiAgXCJfX3N5c2NhbGxfZmFjY2Vzc2F0XCI6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuICBcIl9fc3lzY2FsbF9mY250bDY0XCI6IF9fX3N5c2NhbGxfZmNudGw2NCxcbiAgXCJfX3N5c2NhbGxfZnN0YXQ2NFwiOiBfX19zeXNjYWxsX2ZzdGF0NjQsXG4gIFwiX19zeXNjYWxsX2dldGN3ZFwiOiBfX19zeXNjYWxsX2dldGN3ZCxcbiAgXCJfX3N5c2NhbGxfZ2V0ZGVudHM2NFwiOiBfX19zeXNjYWxsX2dldGRlbnRzNjQsXG4gIFwiX19zeXNjYWxsX2dldHNvY2tuYW1lXCI6IF9fX3N5c2NhbGxfZ2V0c29ja25hbWUsXG4gIFwiX19zeXNjYWxsX2dldHNvY2tvcHRcIjogX19fc3lzY2FsbF9nZXRzb2Nrb3B0LFxuICBcIl9fc3lzY2FsbF9pb2N0bFwiOiBfX19zeXNjYWxsX2lvY3RsLFxuICBcIl9fc3lzY2FsbF9saXN0ZW5cIjogX19fc3lzY2FsbF9saXN0ZW4sXG4gIFwiX19zeXNjYWxsX2xzdGF0NjRcIjogX19fc3lzY2FsbF9sc3RhdDY0LFxuICBcIl9fc3lzY2FsbF9ta2RpclwiOiBfX19zeXNjYWxsX21rZGlyLFxuICBcIl9fc3lzY2FsbF9ta25vZFwiOiBfX19zeXNjYWxsX21rbm9kLFxuICBcIl9fc3lzY2FsbF9uZXdmc3RhdGF0XCI6IF9fX3N5c2NhbGxfbmV3ZnN0YXRhdCxcbiAgXCJfX3N5c2NhbGxfb3BlbmF0XCI6IF9fX3N5c2NhbGxfb3BlbmF0LFxuICBcIl9fc3lzY2FsbF9waXBlXCI6IF9fX3N5c2NhbGxfcGlwZSxcbiAgXCJfX3N5c2NhbGxfcmVhZGxpbmthdFwiOiBfX19zeXNjYWxsX3JlYWRsaW5rYXQsXG4gIFwiX19zeXNjYWxsX3JlY3Zmcm9tXCI6IF9fX3N5c2NhbGxfcmVjdmZyb20sXG4gIFwiX19zeXNjYWxsX3JlbmFtZWF0XCI6IF9fX3N5c2NhbGxfcmVuYW1lYXQsXG4gIFwiX19zeXNjYWxsX3JtZGlyXCI6IF9fX3N5c2NhbGxfcm1kaXIsXG4gIFwiX19zeXNjYWxsX3NlbmR0b1wiOiBfX19zeXNjYWxsX3NlbmR0byxcbiAgXCJfX3N5c2NhbGxfc29ja2V0XCI6IF9fX3N5c2NhbGxfc29ja2V0LFxuICBcIl9fc3lzY2FsbF9zdGF0NjRcIjogX19fc3lzY2FsbF9zdGF0NjQsXG4gIFwiX19zeXNjYWxsX3N5bWxpbmtcIjogX19fc3lzY2FsbF9zeW1saW5rLFxuICBcIl9fc3lzY2FsbF91bmxpbmthdFwiOiBfX19zeXNjYWxsX3VubGlua2F0LFxuICBcIl9fc3lzY2FsbF91dGltZW5zYXRcIjogX19fc3lzY2FsbF91dGltZW5zYXQsXG4gIFwiX190YWJsZV9iYXNlXCI6IF9fX3RhYmxlX2Jhc2UsXG4gIFwiX2Rsb3Blbl9qc1wiOiBfX2Rsb3Blbl9qcyxcbiAgXCJfZGxzeW1fanNcIjogX19kbHN5bV9qcyxcbiAgXCJfZW1zY3JpcHRlbl9kYXRlX25vd1wiOiBfX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWNcIjogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuICBcIl9lbXNjcmlwdGVuX3Rocm93X2xvbmdqbXBcIjogX19lbXNjcmlwdGVuX3Rocm93X2xvbmdqbXAsXG4gIFwiX2dtdGltZV9qc1wiOiBfX2dtdGltZV9qcyxcbiAgXCJfbG9jYWx0aW1lX2pzXCI6IF9fbG9jYWx0aW1lX2pzLFxuICBcIl9ta3RpbWVfanNcIjogX19ta3RpbWVfanMsXG4gIFwiX3RpbWVnbV9qc1wiOiBfX3RpbWVnbV9qcyxcbiAgXCJfdHpzZXRfanNcIjogX190enNldF9qcyxcbiAgXCJhYm9ydFwiOiBfYWJvcnQsXG4gIFwiZW1zY3JpcHRlbl9jb25zb2xlX2Vycm9yXCI6IF9lbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3IsXG4gIFwiZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXhcIjogX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4LFxuICBcImVtc2NyaXB0ZW5fZ2V0X25vd1wiOiBfZW1zY3JpcHRlbl9nZXRfbm93LFxuICBcImVtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFxuICBcImVtc2NyaXB0ZW5fcmVzaXplX2hlYXBcIjogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXG4gIFwiZW52aXJvbl9nZXRcIjogX2Vudmlyb25fZ2V0LFxuICBcImVudmlyb25fc2l6ZXNfZ2V0XCI6IF9lbnZpcm9uX3NpemVzX2dldCxcbiAgXCJleGl0XCI6IF9leGl0LFxuICBcImZkX2Nsb3NlXCI6IF9mZF9jbG9zZSxcbiAgXCJmZF9mZHN0YXRfZ2V0XCI6IF9mZF9mZHN0YXRfZ2V0LFxuICBcImZkX3JlYWRcIjogX2ZkX3JlYWQsXG4gIFwiZmRfc2Vla1wiOiBfZmRfc2VlayxcbiAgXCJmZF93cml0ZVwiOiBfZmRfd3JpdGUsXG4gIFwiZ2V0VGVtcFJldDBcIjogX2dldFRlbXBSZXQwLFxuICBcImdldGFkZHJpbmZvXCI6IF9nZXRhZGRyaW5mbyxcbiAgXCJnZXRuYW1laW5mb1wiOiBfZ2V0bmFtZWluZm8sXG4gIFwiaW52b2tlX2lpXCI6IGludm9rZV9paSxcbiAgXCJpbnZva2VfaWlpXCI6IGludm9rZV9paWksXG4gIFwiaW52b2tlX2lpaWlcIjogaW52b2tlX2lpaWksXG4gIFwiaW52b2tlX2lpaWlpXCI6IGludm9rZV9paWlpaSxcbiAgXCJpbnZva2VfaWlpaWlpXCI6IGludm9rZV9paWlpaWksXG4gIFwiaW52b2tlX3ZpXCI6IGludm9rZV92aSxcbiAgXCJpbnZva2VfdmlpXCI6IGludm9rZV92aWksXG4gIFwiaW52b2tlX3ZpaWlcIjogaW52b2tlX3ZpaWksXG4gIFwiaW52b2tlX3ZpaWlpXCI6IGludm9rZV92aWlpaSxcbiAgXCJpbnZva2VfdmlpaWlpaWlpaVwiOiBpbnZva2VfdmlpaWlpaWlpaSxcbiAgXCJtZW1vcnlcIjogd2FzbU1lbW9yeSxcbiAgXCJwcm9jX2V4aXRcIjogX3Byb2NfZXhpdCxcbiAgXCJwdGhyZWFkX3NldHNjaGVkcGFyYW1cIjogX3B0aHJlYWRfc2V0c2NoZWRwYXJhbSxcbiAgXCJzZW1fdGltZWR3YWl0XCI6IF9zZW1fdGltZWR3YWl0LFxuICBcInNldFRlbXBSZXQwXCI6IF9zZXRUZW1wUmV0MCxcbiAgXCJzeXN0ZW1cIjogX3N5c3RlbVxufTtcblxudmFyIGFzbUxpYnJhcnlBcmcgPSBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVMaWJyYXJ5QXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNETF9NT0RVTEUod2FzbU1lbW9yeS5idWZmZXIsIE1vZHVsZSwgYWJvcnQsY3JlYXRlRXhwb3J0V3JhcHBlciwgc3RyaW5nVG9VVEY4LCBVVEY4VG9TdHJpbmcsYWxsb2NhdGVVVEY4LCBnZXRXYXNtVGFibGVFbnRyeSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRkVUQ0hfTU9EVUxFKHdhc21NZW1vcnkuYnVmZmVyLCBNb2R1bGUsIGFib3J0LGNyZWF0ZUV4cG9ydFdyYXBwZXIsIHN0cmluZ1RvVVRGOCwgVVRGOFRvU3RyaW5nLGFsbG9jYXRlVVRGOCwgZ2V0V2FzbVRhYmxlRW50cnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxudmFyIGFzbSA9IGNyZWF0ZVdhc20oKTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX193YXNtX2NhbGxfY3RvcnMgPSBNb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX193YXNtX2NhbGxfY3RvcnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29uc3RydWN0b3IgPSBNb2R1bGVbXCJfY29uc3RydWN0b3JcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiY29uc3RydWN0b3JcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2V0ID0gTW9kdWxlW1wiX3NldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2V0ID0gTW9kdWxlW1wiX2dldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZGVzdHJ1Y3RvciA9IE1vZHVsZVtcIl9kZXN0cnVjdG9yXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImRlc3RydWN0b3JcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnByaW50ZiA9IE1vZHVsZVtcIl9mcHJpbnRmXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY21wID0gTW9kdWxlW1wiX3N0cmNtcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzIgPSBNb2R1bGVbXCJfZ2ZfZmlsZWlvX3NldF9zdGF0c191MzJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsZWlvX3NldF9zdGF0c191MzJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZyZWVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcmVhbGxvYyA9IE1vZHVsZVtcIl9yZWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInJlYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtY3B5ID0gTW9kdWxlW1wiX21lbWNweVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1jcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybGVuID0gTW9kdWxlW1wiX3N0cmxlblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJsZW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtY21wID0gTW9kdWxlW1wiX21lbWNtcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1jbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtbW92ZSA9IE1vZHVsZVtcIl9tZW1tb3ZlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1lbW1vdmVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX25ldyA9IE1vZHVsZVtcIl9nZl9maWxlaW9fbmV3XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbGVpb19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX3VybCA9IE1vZHVsZVtcIl9nZl9maWxlaW9fdXJsXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbGVpb191cmxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsZWlvX2dldF91ZHRhID0gTW9kdWxlW1wiX2dmX2ZpbGVpb19nZXRfdWR0YVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWxlaW9fZ2V0X3VkdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19lcnJub19sb2NhdGlvbiA9IE1vZHVsZVtcIl9fX2Vycm5vX2xvY2F0aW9uXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fZXJybm9fbG9jYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY3B5ID0gTW9kdWxlW1wiX3N0cmNweVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY2F0ID0gTW9kdWxlW1wiX3N0cmNhdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjYXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyY2hyID0gTW9kdWxlW1wiX3N0cmNoclwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJjaHJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybmNtcCA9IE1vZHVsZVtcIl9zdHJuY21wXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0cm5jbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3ByaW50ZiA9IE1vZHVsZVtcIl9zcHJpbnRmXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2Zfc3RyZHVwID0gTW9kdWxlW1wiX2dmX3N0cmR1cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9zdHJkdXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdnNucHJpbnRmID0gTW9kdWxlW1wiX3ZzbnByaW50ZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJ2c25wcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZndyaXRlID0gTW9kdWxlW1wiX2Z3cml0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmd3JpdGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdmZwcmludGYgPSBNb2R1bGVbXCJfdmZwcmludGZcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwidmZwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZmZsdXNoID0gTW9kdWxlW1wiX2ZmbHVzaFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmZmx1c2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfbmV3ID0gTW9kdWxlW1wiX2dmX2JzX25ld1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfZGVsID0gTW9kdWxlW1wiX2dmX2JzX2RlbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19kZWxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfcmVhZF9pbnQgPSBNb2R1bGVbXCJfZ2ZfYnNfcmVhZF9pbnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfYnNfcmVhZF9pbnRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfYXZhaWxhYmxlID0gTW9kdWxlW1wiX2dmX2JzX2F2YWlsYWJsZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19hdmFpbGFibGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfYnNfZ2V0X3Bvc2l0aW9uID0gTW9kdWxlW1wiX2dmX2JzX2dldF9wb3NpdGlvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9ic19nZXRfcG9zaXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RybmNweSA9IE1vZHVsZVtcIl9zdHJuY3B5XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0cm5jcHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY2FsbG9jID0gTW9kdWxlW1wiX2NhbGxvY1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJjYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc3RyZHVwID0gTW9kdWxlW1wiX3N0cmR1cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdHJkdXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfdXJsX2NvbmNhdGVuYXRlID0gTW9kdWxlW1wiX2dmX3VybF9jb25jYXRlbmF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl91cmxfY29uY2F0ZW5hdGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9zZWxmID0gTW9kdWxlW1wiX3B0aHJlYWRfc2VsZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX3NlbGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9pbml0ID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfaW5pdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2luaXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9kZXN0cm95ID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfZGVzdHJveVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2Rlc3Ryb3lcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF91bmxvY2sgPSBNb2R1bGVbXCJfcHRocmVhZF9tdXRleF91bmxvY2tcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwicHRocmVhZF9tdXRleF91bmxvY2tcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcHRocmVhZF9tdXRleF9sb2NrID0gTW9kdWxlW1wiX3B0aHJlYWRfbXV0ZXhfbG9ja1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwdGhyZWFkX211dGV4X2xvY2tcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2V0ZW52ID0gTW9kdWxlW1wiX2dldGVudlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZXRlbnZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2MgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2NcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19uZXdfYWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19uZXdfcmVmID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfbmV3X3JlZlwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX25ld19yZWZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZW5kID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2VuZFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NlbmRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfZGF0YSA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX2dldF9kYXRhXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfZ2V0X2RhdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19nZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZnJhbWluZyA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX3NldF9mcmFtaW5nXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfc2V0X2ZyYW1pbmdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfY3RzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X2N0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfY3RzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X2N0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfdGltZXNjYWxlID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X3RpbWVzY2FsZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF90aW1lc2NhbGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfc2FwID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X3NhcFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9zYXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb24gPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19zZXRfZHVyYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb24gPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19nZXRfZHVyYXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfc2Vla19mbGFnID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfc2V0X3NlZWtfZmxhZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX3NldF9zZWVrX2ZsYWdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19nZXRfc2Vla19mbGFnID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9wY2tfZ2V0X3NlZWtfZmxhZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGNrX2dldF9zZWVrX2ZsYWdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfZGVwZW5kZW5jeV9mbGFncyA9IE1vZHVsZVtcIl9nZl9maWx0ZXJfcGNrX3NldF9kZXBlbmRlbmN5X2ZsYWdzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImdmX2ZpbHRlcl9wY2tfc2V0X2RlcGVuZGVuY3lfZmxhZ3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXQgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9nZXRfcGFja2V0ID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfZ2V0X3BhY2tldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX2dldF9wYWNrZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9jaGVja19jYXBzID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfY2hlY2tfY2Fwc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX2NoZWNrX2NhcHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9zZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHkgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9nZXRfcHJvcGVydHlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9zZXRfZnJhbWluZ19tb2RlID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9waWRfc2V0X2ZyYW1pbmdfbW9kZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfcGlkX3NldF9mcmFtaW5nX21vZGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9uZXcgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9uZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXMgPSBNb2R1bGVbXCJfZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZ2ZfZmlsdGVyX3BpZF9jb3B5X3Byb3BlcnRpZXNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29zID0gTW9kdWxlW1wiX2Nvc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJjb3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2luID0gTW9kdWxlW1wiX3NpblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzaW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdGFuID0gTW9kdWxlW1wiX3RhblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJ0YW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYXRhbiA9IE1vZHVsZVtcIl9hdGFuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImF0YW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcG93ID0gTW9kdWxlW1wiX3Bvd1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJwb3dcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYWNvcyA9IE1vZHVsZVtcIl9hY29zXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFjb3NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfaHRvbmwgPSBNb2R1bGVbXCJfaHRvbmxcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbmxcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfaHRvbnMgPSBNb2R1bGVbXCJfaHRvbnNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbnRvaHMgPSBNb2R1bGVbXCJfbnRvaHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibnRvaHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYXNpbiA9IE1vZHVsZVtcIl9hc2luXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImFzaW5cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbG9nID0gTW9kdWxlW1wiX2xvZ1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJsb2dcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2F2ZVNldGptcCA9IE1vZHVsZVtcIl9zYXZlU2V0am1wXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNhdmVTZXRqbXBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX2dldF91ZHRhID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9nZXRfdWR0YVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfZ2V0X3VkdGFcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZ2ZfZmlsdGVyX3NldF9uYW1lID0gTW9kdWxlW1wiX2dmX2ZpbHRlcl9zZXRfbmFtZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJnZl9maWx0ZXJfc2V0X25hbWVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZmFicyA9IE1vZHVsZVtcIl9mYWJzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZhYnNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZXhwID0gTW9kdWxlW1wiX2V4cFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfY29zaCA9IE1vZHVsZVtcIl9jb3NoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImNvc2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2luaCA9IE1vZHVsZVtcIl9zaW5oXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInNpbmhcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfdGFuaCA9IE1vZHVsZVtcIl90YW5oXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInRhbmhcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtc2V0ID0gTW9kdWxlW1wiX21lbXNldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtZW1zZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2lwcmludGYgPSBNb2R1bGVbXCJfc2lwcmludGZcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic2lwcmludGZcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZnJleHAgPSBNb2R1bGVbXCJfZnJleHBcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZnJleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19zdGRpb19leGl0ID0gTW9kdWxlW1wiX19fc3RkaW9fZXhpdFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX3N0ZGlvX2V4aXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfYnNlYXJjaCA9IE1vZHVsZVtcIl9ic2VhcmNoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImJzZWFyY2hcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfX19kbF9zZXRlcnIgPSBNb2R1bGVbXCJfX19kbF9zZXRlcnJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19kbF9zZXRlcnJcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbGRleHAgPSBNb2R1bGVbXCJfbGRleHBcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibGRleHBcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbGxyaW50ID0gTW9kdWxlW1wiX2xscmludFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJsbHJpbnRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfbWVtYWxpZ24gPSBNb2R1bGVbXCJfbWVtYWxpZ25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibWVtYWxpZ25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfcG9zaXhfbWVtYWxpZ24gPSBNb2R1bGVbXCJfcG9zaXhfbWVtYWxpZ25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwicG9zaXhfbWVtYWxpZ25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfc2V0VGhyZXcgPSBNb2R1bGVbXCJfc2V0VGhyZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic2V0VGhyZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0c1wiXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHMgPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWVcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlXCJdID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSBNb2R1bGVbXCJfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZVwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCA9IE1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfZW5kID0gTW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZFwiXSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBzdGFja1NhdmUgPSBNb2R1bGVbXCJzdGFja1NhdmVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic3RhY2tTYXZlXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgc3RhY2tSZXN0b3JlID0gTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrUmVzdG9yZVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIHN0YWNrQWxsb2MgPSBNb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrQWxsb2NcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppID0gTW9kdWxlW1wiZHluQ2FsbF9qaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9paWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF92aWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppamlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaWpcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpamlqamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppamppXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqamppaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWpqamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWpqamlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfaWlpamppID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX3ZpaWlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqamlpaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppamlpaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfamlpaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlpXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9paWppampqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlqaWpqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppampqaVwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpamlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBkeW5DYWxsX2lpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWlqXCIpO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopOj99ICovXG52YXIgZHluQ2FsbF9qaWogPSBNb2R1bGVbXCJkeW5DYWxsX2ppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppalwiKTtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKTo/fSAqL1xudmFyIGR5bkNhbGxfdmlqamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWpqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqaWlcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19uZXcgPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19uZXdcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19uZXdcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19hdmFpbGFibGUgPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19hdmFpbGFibGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19hdmFpbGFibGVcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9ic19nZXRfcG9zaXRpb24gPSBNb2R1bGVbXCJfb3JpZyRnZl9ic19nZXRfcG9zaXRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9ic19nZXRfcG9zaXRpb25cIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHMgPSBNb2R1bGVbXCJfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9maWx0ZXJfcGNrX3NldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHMgPSBNb2R1bGVbXCJfb3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRnZl9maWx0ZXJfcGNrX2dldF9jdHNcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRnZl9maWx0ZXJfcGNrX3NldF9ieXRlX29mZnNldCA9IE1vZHVsZVtcIl9vcmlnJGdmX2ZpbHRlcl9wY2tfc2V0X2J5dGVfb2Zmc2V0XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm9yaWckZ2ZfZmlsdGVyX3Bja19zZXRfYnl0ZV9vZmZzZXRcIik7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKik6P30gKi9cbnZhciBfb3JpZyRsbHJpbnQgPSBNb2R1bGVbXCJfb3JpZyRsbHJpbnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwib3JpZyRsbHJpbnRcIik7XG5cblxuZnVuY3Rpb24gaW52b2tlX2lpKGluZGV4LGExKSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWkoaW5kZXgsYTEsYTIpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX3ZpaWkoaW5kZXgsYTEsYTIsYTMpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfdmkoaW5kZXgsYTEpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfaWlpaShpbmRleCxhMSxhMixhMykge1xuICB2YXIgc3AgPSBzdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzKTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VfdmlpKGluZGV4LGExLGEyKSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMik7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX2lpaWlpKGluZGV4LGExLGEyLGEzLGE0KSB7XG4gIHZhciBzcCA9IHN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIHJldHVybiBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEsYTIsYTMsYTQpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV92aWlpaShpbmRleCxhMSxhMixhMyxhNCkge1xuICB2YXIgc3AgPSBzdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBnZXRXYXNtVGFibGVFbnRyeShpbmRleCkoYTEsYTIsYTMsYTQpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzdGFja1Jlc3RvcmUoc3ApO1xuICAgIGlmIChlICE9PSBlKzApIHRocm93IGU7XG4gICAgX3NldFRocmV3KDEsIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZV9paWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdldFdhc21UYWJsZUVudHJ5KGluZGV4KShhMSxhMixhMyxhNCxhNSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHN0YWNrUmVzdG9yZShzcCk7XG4gICAgaWYgKGUgIT09IGUrMCkgdGhyb3cgZTtcbiAgICBfc2V0VGhyZXcoMSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWkoaW5kZXgsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpIHtcbiAgdmFyIHNwID0gc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgZ2V0V2FzbVRhYmxlRW50cnkoaW5kZXgpKGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KTtcbiAgfSBjYXRjaChlKSB7XG4gICAgc3RhY2tSZXN0b3JlKHNwKTtcbiAgICBpZiAoZSAhPT0gZSswKSB0aHJvdyBlO1xuICAgIF9zZXRUaHJldygxLCAwKTtcbiAgfVxufVxuXG5cblxuXG4vLyA9PT0gQXV0by1nZW5lcmF0ZWQgcG9zdGFtYmxlIHNldHVwIGVudHJ5IHN0dWZmID09PVxuXG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdpbnRBcnJheUZyb21TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdpbnRBcnJheVRvU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignY2NhbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjd3JhcCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldFZhbHVlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0VmFsdWUnLCBmYWxzZSk7XG5Nb2R1bGVbXCJhbGxvY2F0ZVwiXSA9IGFsbG9jYXRlO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignVVRGOEFycmF5VG9TdHJpbmcnLCBmYWxzZSk7XG5Nb2R1bGVbXCJVVEY4VG9TdHJpbmdcIl0gPSBVVEY4VG9TdHJpbmc7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjhBcnJheScsIGZhbHNlKTtcbk1vZHVsZVtcInN0cmluZ1RvVVRGOFwiXSA9IHN0cmluZ1RvVVRGODtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2xlbmd0aEJ5dGVzVVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrVHJhY2UnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRPblByZVJ1bicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uSW5pdCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uUHJlTWFpbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uRXhpdCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FkZE9uUG9zdFJ1bicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlU3RyaW5nVG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3cml0ZUFycmF5VG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3cml0ZUFzY2lpVG9NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRSdW5EZXBlbmRlbmN5JywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZW1vdmVSdW5EZXBlbmRlbmN5JywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVGb2xkZXInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVQYXRoJywgdHJ1ZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVEYXRhRmlsZScsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlNfY3JlYXRlUHJlbG9hZGVkRmlsZScsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlNfY3JlYXRlTGF6eUZpbGUnLCB0cnVlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0ZTX2NyZWF0ZUxpbmsnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdGU19jcmVhdGVEZXZpY2UnLCB0cnVlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0ZTX3VubGluaycsIHRydWUpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0TEVCJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RnVuY3Rpb25UYWJsZXMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhbGlnbkZ1bmN0aW9uVGFibGVzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJGdW5jdGlvbnMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdhZGRGdW5jdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlbW92ZUZ1bmN0aW9uJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RnVuY1dyYXBwZXInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwcmV0dHlQcmludCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2R5bkNhbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRDb21waWxlclNldHRpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwcmludCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3ByaW50RXJyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0VGVtcFJldDAnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzZXRUZW1wUmV0MCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NhbGxNYWluJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYWJvcnQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdrZWVwUnVudGltZUFsaXZlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignemVyb01lbW9yeScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0cmluZ1RvTmV3VVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Fib3J0T25DYW5ub3RHcm93TWVtb3J5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0VOVicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0VSUk5PX0NPREVTJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRVJSTk9fTUVTU0FHRVMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzZXRFcnJObycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXRQdG9uNCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXROdG9wNCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXRQdG9uNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2luZXROdG9wNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlYWRTb2NrYWRkcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlU29ja2FkZHInLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdETlMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRIb3N0QnlOYW1lJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignUHJvdG9jb2xzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU29ja2V0cycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldFJhbmRvbURldmljZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3RyYXZlcnNlU3RhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdVTldJTkRfQ0FDSEUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb252ZXJ0UEN0b1NvdXJjZUxvY2F0aW9uJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEFzbUNvbnN0QXJnc0FycmF5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEFzbUNvbnN0QXJncycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ21haW5UaHJlYWRFTV9BU00nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdqc3RvaV9xJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignanN0b2lfcycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldEV4ZWN1dGFibGVOYW1lJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGlzdGVuT25jZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2F1dG9SZXN1bWVBdWRpb0NvbnRleHQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkeW5DYWxsTGVnYWN5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RHluQ2FsbGVyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZHluQ2FsbCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2hhbmRsZUV4Y2VwdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3J1bnRpbWVLZWVwYWxpdmVQdXNoJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncnVudGltZUtlZXBhbGl2ZVBvcCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NhbGxVc2VyQ2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtYXliZUV4aXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzYWZlU2V0VGltZW91dCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FzbWpzTWFuZ2xlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYXN5bmNMb2FkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignYWxpZ25NZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtbWFwQWxsb2MnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWFsbHlOZWdhdGl2ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3VuU2lnbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlU2lnbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Zvcm1hdFN0cmluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1BBVEgnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdQQVRIX0ZTJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU1lTQ0FMTFMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRTb2NrZXRGcm9tRkQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRTb2NrZXRBZGRyZXNzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignSlNFdmVudHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlcktleUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzcGVjaWFsSFRNTFRhcmdldHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtYXliZUNTdHJpbmdUb0pzU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmluZEV2ZW50VGFyZ2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmluZENhbnZhc0V2ZW50VGFyZ2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0Qm91bmRpbmdDbGllbnRSZWN0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbE1vdXNlRXZlbnREYXRhJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJNb3VzZUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlcldoZWVsRXZlbnRDYWxsYmFjaycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyVWlFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJGb2N1c0V2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsRGV2aWNlT3JpZW50YXRpb25FdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckRldmljZU9yaWVudGF0aW9uRXZlbnRDYWxsYmFjaycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2ZpbGxEZXZpY2VNb3Rpb25FdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckRldmljZU1vdGlvbkV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzY3JlZW5PcmllbnRhdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2ZpbGxPcmllbnRhdGlvbkNoYW5nZUV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyT3JpZW50YXRpb25DaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbEZ1bGxzY3JlZW5DaGFuZ2VFdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckZ1bGxzY3JlZW5DaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJSZXN0b3JlT2xkU3R5bGUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdoaWRlRXZlcnl0aGluZ0V4Y2VwdEdpdmVuRWxlbWVudCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3Jlc3RvcmVIaWRkZW5FbGVtZW50cycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldExldHRlcmJveCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2N1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3knLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZXN0b3JlT2xkV2luZG93ZWRTdHlsZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NvZnRGdWxsc2NyZWVuUmVzaXplV2ViR0xSZW5kZXJUYXJnZXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkb1JlcXVlc3RGdWxsc2NyZWVuJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbFBvaW50ZXJsb2NrQ2hhbmdlRXZlbnREYXRhJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJQb2ludGVybG9ja0NoYW5nZUV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlclBvaW50ZXJsb2NrRXJyb3JFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVxdWVzdFBvaW50ZXJMb2NrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZmlsbFZpc2liaWxpdHlDaGFuZ2VFdmVudERhdGEnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVnaXN0ZXJUb3VjaEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsR2FtZXBhZEV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlZ2lzdGVyR2FtZXBhZEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckJlZm9yZVVubG9hZEV2ZW50Q2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdmaWxsQmF0dGVyeUV2ZW50RGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2JhdHRlcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdyZWdpc3RlckJhdHRlcnlFdmVudENhbGxiYWNrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc2V0Q2FudmFzRWxlbWVudFNpemUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRDYW52YXNFbGVtZW50U2l6ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2RlbWFuZ2xlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZGVtYW5nbGVBbGwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdqc1N0YWNrVHJhY2UnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdGFja1RyYWNlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZ2V0RW52U3RyaW5ncycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2NoZWNrV2FzaUNsb2NrJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb0k2NCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlSTUzVG9JNjRDbGFtcGVkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb0k2NFNpZ25hbGluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dyaXRlSTUzVG9VNjRDbGFtcGVkJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVJNTNUb1U2NFNpZ25hbGluZycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3JlYWRJNTNGcm9tSTY0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbigncmVhZEk1M0Zyb21VNjQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb252ZXJ0STMyUGFpclRvSTUzJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignY29udmVydFUzMlBhaXJUb0k1MycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dPVCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0xEU08nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdnZXRNZW1vcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdtZXJnZUxpYlN5bWJvbHMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdsb2FkV2ViQXNzZW1ibHlNb2R1bGUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdsb2FkRHluYW1pY0xpYnJhcnknLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdkbG9wZW5JbnRlcm5hbCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3NldEltbWVkaWF0ZVdyYXBwZWQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjbGVhckltbWVkaWF0ZVdyYXBwZWQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdwb2x5ZmlsbFNldEltbWVkaWF0ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdleGNlcHRpb25MYXN0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZXhjZXB0aW9uQ2F1Z2h0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRXhjZXB0aW9uSW5mbycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0NhdGNoSW5mbycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2V4Y2VwdGlvbl9hZGRSZWYnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdleGNlcHRpb25fZGVjUmVmJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignQnJvd3NlcicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Z1bmNXcmFwcGVycycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2dldEZ1bmNXcmFwcGVyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc2V0TWFpbkxvb3AnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3Z2V0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignRlMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdNRU1GUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1RUWScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1BJUEVGUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1NPQ0tGUycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ19zZXROZXR3b3JrQ2FsbGJhY2snLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd0ZW1wRml4ZWRMZW5ndGhBcnJheScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ21pbmlUZW1wV2ViR0xGbG9hdEJ1ZmZlcnMnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdoZWFwT2JqZWN0Rm9yV2ViR0xUeXBlJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignR0wnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdlbXNjcmlwdGVuV2ViR0xHZXQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Vtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2Vtc2NyaXB0ZW5XZWJHTEdldFVuaWZvcm0nLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dlYmdsUHJlcGFyZVVuaWZvcm1Mb2NhdGlvbnNCZWZvcmVGaXJzdFVzZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3dlYmdsR2V0TGVmdEJyYWNlUG9zJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignZW1zY3JpcHRlbldlYkdMR2V0VmVydGV4QXR0cmliJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignd3JpdGVHTEFycmF5JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignQUwnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdTRExfdW5pY29kZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1NETF90dGZDb250ZXh0JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMX2F1ZGlvJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignU0RMX2dmeCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dMVVQnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdFR0wnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdHTEZXX1dpbmRvdycsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ0dMRlcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdHTEVXJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignSURCU3RvcmUnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdydW5BbmRBYm9ydElmRXJyb3InLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCd3YXJuT25jZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrU2F2ZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrUmVzdG9yZScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ3N0YWNrQWxsb2MnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdBc2NpaVRvU3RyaW5nJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignc3RyaW5nVG9Bc2NpaScsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1VURjE2VG9TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjE2JywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGVuZ3RoQnl0ZXNVVEYxNicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ1VURjMyVG9TdHJpbmcnLCBmYWxzZSk7XG51bmV4cG9ydGVkUnVudGltZUZ1bmN0aW9uKCdzdHJpbmdUb1VURjMyJywgZmFsc2UpO1xudW5leHBvcnRlZFJ1bnRpbWVGdW5jdGlvbignbGVuZ3RoQnl0ZXNVVEYzMicsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FsbG9jYXRlVVRGOCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lRnVuY3Rpb24oJ2FsbG9jYXRlVVRGOE9uU3RhY2snLCBmYWxzZSk7XG5Nb2R1bGVbXCJ3cml0ZVN0YWNrQ29va2llXCJdID0gd3JpdGVTdGFja0Nvb2tpZTtcbk1vZHVsZVtcImNoZWNrU3RhY2tDb29raWVcIl0gPSBjaGVja1N0YWNrQ29va2llO1xudW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woJ0FMTE9DX05PUk1BTCcsIGZhbHNlKTtcbnVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKCdBTExPQ19TVEFDSycsIGZhbHNlKTtcblxudmFyIGNhbGxlZFJ1bjtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtFeGl0U3RhdHVzfVxuICovXG5mdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykge1xuICB0aGlzLm5hbWUgPSBcIkV4aXRTdGF0dXNcIjtcbiAgdGhpcy5tZXNzYWdlID0gXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiICsgc3RhdHVzICsgXCIpXCI7XG4gIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xufVxuXG52YXIgY2FsbGVkTWFpbiA9IGZhbHNlO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gIC8vIElmIHJ1biBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIGFuZCB3ZSBzaG91bGQgY2FsbCBydW4gKElOVk9LRV9SVU4gaXMgdHJ1ZSwgYW5kIE1vZHVsZS5ub0luaXRpYWxSdW4gaXMgbm90IGZhbHNlKVxuICBpZiAoIWNhbGxlZFJ1bikgcnVuKCk7XG4gIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7IC8vIHRyeSB0aGlzIGFnYWluIGxhdGVyLCBhZnRlciBuZXcgZGVwcyBhcmUgZnVsZmlsbGVkXG59O1xuXG5mdW5jdGlvbiBjYWxsTWFpbihhcmdzKSB7XG4gIGFzc2VydChydW5EZXBlbmRlbmNpZXMgPT0gMCwgJ2Nhbm5vdCBjYWxsIG1haW4gd2hlbiBhc3luYyBkZXBlbmRlbmNpZXMgcmVtYWluISAobGlzdGVuIG9uIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKScpO1xuICBhc3NlcnQoX19BVFBSRVJVTl9fLmxlbmd0aCA9PSAwLCAnY2Fubm90IGNhbGwgbWFpbiB3aGVuIHByZVJ1biBmdW5jdGlvbnMgcmVtYWluIHRvIGJlIGNhbGxlZCcpO1xuXG4gIHZhciBlbnRyeUZ1bmN0aW9uID0gTW9kdWxlWydfbWFpbiddO1xuXG4gIC8vIE1haW4gbW9kdWxlcyBjYW4ndCB0ZWxsIGlmIHRoZXkgaGF2ZSBtYWluKCkgYXQgY29tcGlsZSB0aW1lLCBzaW5jZSBpdCBtYXlcbiAgLy8gYXJyaXZlIGZyb20gYSBkeW5hbWljIGxpYnJhcnkuXG4gIGlmICghZW50cnlGdW5jdGlvbikgcmV0dXJuO1xuXG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuXG4gIHZhciBhcmdjID0gYXJncy5sZW5ndGgrMTtcbiAgdmFyIGFyZ3YgPSBzdGFja0FsbG9jKChhcmdjICsgMSkgKiA0KTtcbiAgSEVBUDMyW2FyZ3YgPj4gMl0gPSBhbGxvY2F0ZVVURjhPblN0YWNrKHRoaXNQcm9ncmFtKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdjOyBpKyspIHtcbiAgICBIRUFQMzJbKGFyZ3YgPj4gMikgKyBpXSA9IGFsbG9jYXRlVVRGOE9uU3RhY2soYXJnc1tpIC0gMV0pO1xuICB9XG4gIEhFQVAzMlsoYXJndiA+PiAyKSArIGFyZ2NdID0gMDtcblxuICB0cnkge1xuXG4gICAgdmFyIHJldCA9IGVudHJ5RnVuY3Rpb24oYXJnYywgYXJndik7XG5cbiAgICAvLyBJbiBQUk9YWV9UT19QVEhSRUFEIGJ1aWxkcywgd2Ugc2hvdWxkIG5ldmVyIGV4aXQgdGhlIHJ1bnRpbWUgYmVsb3csIGFzXG4gICAgLy8gZXhlY3V0aW9uIGlzIGFzeW5jaHJvbm91c2x5IGhhbmRlZCBvZmYgdG8gYSBwdGhyZWFkLlxuICAgIC8vIGlmIHdlJ3JlIG5vdCBydW5uaW5nIGFuIGV2ZW50ZWQgbWFpbiBsb29wLCBpdCdzIHRpbWUgdG8gZXhpdFxuICAgIGV4aXQocmV0LCAvKiBpbXBsaWNpdCA9ICovIHRydWUpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpO1xuICB9IGZpbmFsbHkge1xuICAgIGNhbGxlZE1haW4gPSB0cnVlO1xuXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tDaGVja0luaXQoKSB7XG4gIC8vIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIF9fd2FzbV9jYWxsX2N0b3JzIGJ1dCBuZWVkIHRvXG4gIC8vIGdldCB0aGVzZSB2YWx1ZXMgYmVmb3JlIGV2ZW4gcnVubmluZyBhbnkgb2YgdGhlIGN0b3JzIHNvIHdlIGNhbGwgaXQgcmVkdW5kYW50bHlcbiAgLy8gaGVyZS5cbiAgLy8gVE9ETyhzYmMpOiBNb3ZlIHdyaXRlU3RhY2tDb29raWUgdG8gbmF0aXZlIHRvIHRvIGF2b2lkIHRoaXMuXG4gIF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHMoNjI4NDc4NCwgMTA0MTkwNCk7XG4gIHdyaXRlU3RhY2tDb29raWUoKTtcbn1cblxudmFyIGR5bGlic0xvYWRlZCA9IGZhbHNlO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKEFycmF5PSl9ICovXG5mdW5jdGlvbiBydW4oYXJncykge1xuICBhcmdzID0gYXJncyB8fCBhcmd1bWVudHNfO1xuXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhY2tDaGVja0luaXQoKTtcblxuICBpZiAoIWR5bGlic0xvYWRlZCkge1xuICAvLyBMb2FkaW5nIG9mIGR5bmFtaWMgbGlicmFyaWVzIG5lZWRzIHRvIGhhcHBlbiBvbiBlYWNoIHRocmVhZCwgc28gd2UgY2FuJ3RcbiAgLy8gdXNlIHRoZSBub3JtYWwgX19BVFBSRVJVTl9fIG1lY2hhbmlzbS5cbiAgICBwcmVsb2FkRHlsaWJzKCk7XG4gICAgZHlsaWJzTG9hZGVkID0gdHJ1ZTtcblxuICAgIC8vIExvYWRpbmcgZHlsaWJzIGNhbiBhZGQgcnVuIGRlcGVuZGVuY2llcy5cbiAgICBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByZVJ1bigpO1xuXG4gIC8vIGEgcHJlUnVuIGFkZGVkIGEgZGVwZW5kZW5jeSwgcnVuIHdpbGwgYmUgY2FsbGVkIGxhdGVyXG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgLy8gcnVuIG1heSBoYXZlIGp1c3QgYmVlbiBjYWxsZWQgdGhyb3VnaCBkZXBlbmRlbmNpZXMgYmVpbmcgZnVsZmlsbGVkIGp1c3QgaW4gdGhpcyB2ZXJ5IGZyYW1lLFxuICAgIC8vIG9yIHdoaWxlIHRoZSBhc3luYyBzZXRTdGF0dXMgdGltZSBiZWxvdyB3YXMgaGFwcGVuaW5nXG4gICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG5cbiAgICBpZiAoQUJPUlQpIHJldHVybjtcblxuICAgIGluaXRSdW50aW1lKCk7XG5cbiAgICBwcmVNYWluKCk7XG5cbiAgICByZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7XG4gICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XG5cbiAgICBpZiAoc2hvdWxkUnVuTm93KSBjYWxsTWFpbihhcmdzKTtcblxuICAgIHBvc3RSdW4oKTtcbiAgfVxuXG4gIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcbiAgICAgIH0sIDEpO1xuICAgICAgZG9SdW4oKTtcbiAgICB9LCAxKTtcbiAgfSBlbHNlXG4gIHtcbiAgICBkb1J1bigpO1xuICB9XG4gIGNoZWNrU3RhY2tDb29raWUoKTtcbn1cbk1vZHVsZVsncnVuJ10gPSBydW47XG5cbmZ1bmN0aW9uIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpIHtcbiAgLy8gQ29tcGlsZXIgc2V0dGluZ3MgZG8gbm90IGFsbG93IGV4aXRpbmcgdGhlIHJ1bnRpbWUsIHNvIGZsdXNoaW5nXG4gIC8vIHRoZSBzdHJlYW1zIGlzIG5vdCBwb3NzaWJsZS4gYnV0IGluIEFTU0VSVElPTlMgbW9kZSB3ZSBjaGVja1xuICAvLyBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIHRvIGZsdXNoLCBhbmQgaWYgc28gdGVsbCB0aGUgdXNlciB0aGV5XG4gIC8vIHNob3VsZCByZXF1ZXN0IHRoYXQgdGhlIHJ1bnRpbWUgYmUgZXhpdGFibGUuXG4gIC8vIE5vcm1hbGx5IHdlIHdvdWxkIG5vdCBldmVuIGluY2x1ZGUgZmx1c2goKSBhdCBhbGwsIGJ1dCBpbiBBU1NFUlRJT05TXG4gIC8vIGJ1aWxkcyB3ZSBkbyBzbyBqdXN0IGZvciB0aGlzIGNoZWNrLCBhbmQgaGVyZSB3ZSBzZWUgaWYgdGhlcmUgaXMgYW55XG4gIC8vIGNvbnRlbnQgdG8gZmx1c2gsIHRoYXQgaXMsIHdlIGNoZWNrIGlmIHRoZXJlIHdvdWxkIGhhdmUgYmVlblxuICAvLyBzb21ldGhpbmcgYSBub24tQVNTRVJUSU9OUyBidWlsZCB3b3VsZCBoYXZlIG5vdCBzZWVuLlxuICAvLyBIb3cgd2UgZmx1c2ggdGhlIHN0cmVhbXMgZGVwZW5kcyBvbiB3aGV0aGVyIHdlIGFyZSBpbiBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU09MFxuICAvLyBtb2RlICh3aGljaCBoYXMgaXRzIG93biBzcGVjaWFsIGZ1bmN0aW9uIGZvciB0aGlzOyBvdGhlcndpc2UsIGFsbFxuICAvLyB0aGUgY29kZSBpcyBpbnNpZGUgbGliYylcbiAgdmFyIG9sZE91dCA9IG91dDtcbiAgdmFyIG9sZEVyciA9IGVycjtcbiAgdmFyIGhhcyA9IGZhbHNlO1xuICBvdXQgPSBlcnIgPSAoeCkgPT4ge1xuICAgIGhhcyA9IHRydWU7XG4gIH1cbiAgdHJ5IHsgLy8gaXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgZmFpbHNcbiAgICBfX19zdGRpb19leGl0KCk7XG4gICAgLy8gYWxzbyBmbHVzaCBpbiB0aGUgSlMgRlMgbGF5ZXJcbiAgICBbJ3N0ZG91dCcsICdzdGRlcnInXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBpbmZvID0gRlMuYW5hbHl6ZVBhdGgoJy9kZXYvJyArIG5hbWUpO1xuICAgICAgaWYgKCFpbmZvKSByZXR1cm47XG4gICAgICB2YXIgc3RyZWFtID0gaW5mby5vYmplY3Q7XG4gICAgICB2YXIgcmRldiA9IHN0cmVhbS5yZGV2O1xuICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3JkZXZdO1xuICAgICAgaWYgKHR0eSAmJiB0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgIGhhcyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2goZSkge31cbiAgb3V0ID0gb2xkT3V0O1xuICBlcnIgPSBvbGRFcnI7XG4gIGlmIChoYXMpIHtcbiAgICB3YXJuT25jZSgnc3RkaW8gc3RyZWFtcyBoYWQgY29udGVudCBpbiB0aGVtIHRoYXQgd2FzIG5vdCBmbHVzaGVkLiB5b3Ugc2hvdWxkIHNldCBFWElUX1JVTlRJTUUgdG8gMSAoc2VlIHRoZSBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy4nKTtcbiAgfVxufVxuXG4vKiogQHBhcmFtIHtib29sZWFufG51bWJlcj19IGltcGxpY2l0ICovXG5mdW5jdGlvbiBleGl0KHN0YXR1cywgaW1wbGljaXQpIHtcbiAgRVhJVFNUQVRVUyA9IHN0YXR1cztcblxuICBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTtcblxuICAvLyBpZiBleGl0KCkgd2FzIGNhbGxlZCBleHBsaWNpdGx5LCB3YXJuIHRoZSB1c2VyIGlmIHRoZSBydW50aW1lIGlzbid0IGFjdHVhbGx5IGJlaW5nIHNodXQgZG93blxuICBpZiAoa2VlcFJ1bnRpbWVBbGl2ZSgpICYmICFpbXBsaWNpdCkge1xuICAgIHZhciBtc2cgPSAncHJvZ3JhbSBleGl0ZWQgKHdpdGggc3RhdHVzOiAnICsgc3RhdHVzICsgJyksIGJ1dCBFWElUX1JVTlRJTUUgaXMgbm90IHNldCwgc28gaGFsdGluZyBleGVjdXRpb24gYnV0IG5vdCBleGl0aW5nIHRoZSBydW50aW1lIG9yIHByZXZlbnRpbmcgZnVydGhlciBhc3luYyBleGVjdXRpb24gKGJ1aWxkIHdpdGggRVhJVF9SVU5USU1FPTEsIGlmIHlvdSB3YW50IGEgdHJ1ZSBzaHV0ZG93biknO1xuICAgIHJlYWR5UHJvbWlzZVJlamVjdChtc2cpO1xuICAgIGVycihtc2cpO1xuICB9XG5cbiAgcHJvY0V4aXQoc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gcHJvY0V4aXQoY29kZSkge1xuICBFWElUU1RBVFVTID0gY29kZTtcbiAgaWYgKCFrZWVwUnVudGltZUFsaXZlKCkpIHtcbiAgICBpZiAoTW9kdWxlWydvbkV4aXQnXSkgTW9kdWxlWydvbkV4aXQnXShjb2RlKTtcbiAgICBBQk9SVCA9IHRydWU7XG4gIH1cbiAgcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xufVxuXG5pZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgfVxufVxuXG4vLyBzaG91bGRSdW5Ob3cgcmVmZXJzIHRvIGNhbGxpbmcgbWFpbigpLCBub3QgcnVuKCkuXG52YXIgc2hvdWxkUnVuTm93ID0gdHJ1ZTtcblxuaWYgKE1vZHVsZVsnbm9Jbml0aWFsUnVuJ10pIHNob3VsZFJ1bk5vdyA9IGZhbHNlO1xuXG5ydW4oKTtcblxuXG5cblxuXG5cblxuICByZXR1cm4gTW9kdWxlLnJlYWR5XG59XG4pO1xufSkoKTtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gTW9kdWxlO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gTW9kdWxlOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcbiAgZXhwb3J0c1tcIk1vZHVsZVwiXSA9IE1vZHVsZTtcblxuICBjb25zdCBsb2NhdGlvbiA9IHt9O1xuICBjb25zdCBtZW1pbyA9IFtdO1xuICBleHBvcnQge01vZHVsZSwgbG9jYXRpb24sIG1lbWlvfTsiLCJmdW5jdGlvbiBTRExfTU9EVUxFKE1PRFVMRV9IRUFQLCBNT0RVTEUsIEFCT1JULCBFWFBPUlRfV1JBUFBFUiwgU1RSSU5HVE9VVEY4LFVURjhUT1NUUklORyxBTExPQ0FURVVURjgsV0FTTUVOVFJZVEFCTEUpIHtcbiAgICAvLyBHbG9iYWwgZnVuY3Rpb25cbiAgICB2YXIgSEVBUCxcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXlCdWZmZXJ9ICovXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgLyoqIEB0eXBlIHshSW50OEFycmF5fSAqL1xuICAgICAgICBIRUFQOCxcbiAgICAgICAgLyoqIEB0eXBlIHshVWludDhBcnJheX0gKi9cbiAgICAgICAgSEVBUFU4LFxuICAgICAgICAvKiogQHR5cGUgeyFJbnQxNkFycmF5fSAqL1xuICAgICAgICBIRUFQMTYsXG4gICAgICAgIC8qKiBAdHlwZSB7IVVpbnQxNkFycmF5fSAqL1xuICAgICAgICBIRUFQVTE2LFxuICAgICAgICAvKiogQHR5cGUgeyFJbnQzMkFycmF5fSAqL1xuICAgICAgICBIRUFQMzIsXG4gICAgICAgIC8qKiBAdHlwZSB7IVVpbnQzMkFycmF5fSAqL1xuICAgICAgICBIRUFQVTMyLFxuICAgICAgICAvKiogQHR5cGUgeyFGbG9hdDMyQXJyYXl9ICovXG4gICAgICAgIEhFQVBGMzIsXG4gICAgICAgIC8qKiBAdHlwZSB7IUZsb2F0NjRBcnJheX0gKi9cbiAgICAgICAgSEVBUEY2NDtcbiAgICB2YXIgTW9kdWxlID0gTU9EVUxFO1xuICAgIHZhciBhYm9ydCA9IEFCT1JUO1xuICAgIHZhciBnZXRXYXNtVGFibGVFbnRyeSA9IFdBU01FTlRSWVRBQkxFOyBcbiAgICBcbiAgICB2YXIgZXJyID0gY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5cbiAgICB2YXIgX19BVEVYSVRfXyAgICA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzaHV0ZG93blxuICAgIHZhciBzZXRXaW5kb3dUaXRsZSA9ICh0aXRsZSkgPT4gZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbiAgICB2YXIgR0xjdHg7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmO1xuICAgICAgICBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICAgICAgSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWYpO1xuICAgICAgICBIRUFQVTMyID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG4gICAgICAgIEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1Zik7XG4gICAgICAgIEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG4gICAgfVxuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKE1PRFVMRV9IRUFQKTtcblxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKiwgc3RyaW5nPSl9ICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQnICsgKHRleHQgPyAnOiAnICsgdGV4dCA6ICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNyZWF0ZUV4cG9ydFdyYXBwZXIgPSBFWFBPUlRfV1JBUFBFUjtcbiAgICB2YXIgX21hbGxvYyA9IE1vZHVsZVtcIl9tYWxsb2NcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibWFsbG9jXCIpO1xuXG4gICAgdmFyIHN0cmluZ1RvVVRGOCA9IFNUUklOR1RPVVRGODtcbiAgICB2YXIgVVRGOFRvU3RyaW5nID0gVVRGOFRPU1RSSU5HO1xuICAgIHZhciBhbGxvY2F0ZVVURjggPSBBTExPQ0FURVVURjg7XG5cbiAgICAvL1NwZWNpZmljIFNETCBmdW5jdGlvbnNcblxuICAgIGZ1bmN0aW9uIGxpc3Rlbk9uY2Uob2JqZWN0LCBldmVudCwgZnVuYykge1xuICAgICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgeyAnb25jZSc6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtPYmplY3Q9fSBlbGVtZW50cyAqL1xuICBmdW5jdGlvbiBhdXRvUmVzdW1lQXVkaW9Db250ZXh0KGN0eCwgZWxlbWVudHMpIHtcbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50cyA9IFtkb2N1bWVudCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpXTtcbiAgICB9XG4gICAgWydrZXlkb3duJywgJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgbGlzdGVuT25jZShlbGVtZW50LCBldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnN0YXRlID09PSAnc3VzcGVuZGVkJykgY3R4LnJlc3VtZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gICAgdmFyIEFTTV9DT05TVFMgPSB7XG4gICAgICAgIDI5MTc4MDogZnVuY3Rpb24oJDAsICQxLCAkMikge3ZhciB3ID0gJDA7IHZhciBoID0gJDE7IHZhciBwaXhlbHMgPSAkMjsgaWYgKCFNb2R1bGVbJ1NETDInXSkgTW9kdWxlWydTREwyJ10gPSB7fTsgdmFyIFNETDIgPSBNb2R1bGVbJ1NETDInXTsgaWYgKFNETDIuY3R4Q2FudmFzICE9PSBNb2R1bGVbJ2NhbnZhcyddKSB7IFNETDIuY3R4ID0gTW9kdWxlWydjcmVhdGVDb250ZXh0J10oTW9kdWxlWydjYW52YXMnXSwgZmFsc2UsIHRydWUpOyBTREwyLmN0eENhbnZhcyA9IE1vZHVsZVsnY2FudmFzJ107IH0gaWYgKFNETDIudyAhPT0gdyB8fCBTREwyLmggIT09IGggfHwgU0RMMi5pbWFnZUN0eCAhPT0gU0RMMi5jdHgpIHsgU0RMMi5pbWFnZSA9IFNETDIuY3R4LmNyZWF0ZUltYWdlRGF0YSh3LCBoKTsgU0RMMi53ID0gdzsgU0RMMi5oID0gaDsgU0RMMi5pbWFnZUN0eCA9IFNETDIuY3R4OyB9IHZhciBkYXRhID0gU0RMMi5pbWFnZS5kYXRhOyB2YXIgc3JjID0gcGl4ZWxzID4+IDI7IHZhciBkc3QgPSAwOyB2YXIgbnVtOyBpZiAodHlwZW9mIENhbnZhc1BpeGVsQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBDYW52YXNQaXhlbEFycmF5KSB7IG51bSA9IGRhdGEubGVuZ3RoOyB3aGlsZSAoZHN0IDwgbnVtKSB7IHZhciB2YWwgPSBIRUFQMzJbc3JjXTsgZGF0YVtkc3QgXSA9IHZhbCAmIDB4ZmY7IGRhdGFbZHN0KzFdID0gKHZhbCA+PiA4KSAmIDB4ZmY7IGRhdGFbZHN0KzJdID0gKHZhbCA+PiAxNikgJiAweGZmOyBkYXRhW2RzdCszXSA9IDB4ZmY7IHNyYysrOyBkc3QgKz0gNDsgfSB9IGVsc2UgeyBpZiAoU0RMMi5kYXRhMzJEYXRhICE9PSBkYXRhKSB7IFNETDIuZGF0YTMyID0gbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIpOyBTREwyLmRhdGE4ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIpOyBTREwyLmRhdGEzMkRhdGEgPSBkYXRhOyB9IHZhciBkYXRhMzIgPSBTREwyLmRhdGEzMjsgbnVtID0gZGF0YTMyLmxlbmd0aDsgZGF0YTMyLnNldChIRUFQMzIuc3ViYXJyYXkoc3JjLCBzcmMgKyBudW0pKTsgdmFyIGRhdGE4ID0gU0RMMi5kYXRhODsgdmFyIGkgPSAzOyB2YXIgaiA9IGkgKyA0Km51bTsgaWYgKG51bSAlIDggPT0gMCkgeyB3aGlsZSAoaSA8IGopIHsgZGF0YThbaV0gPSAweGZmOyBpID0gaSArIDQgfCAwOyBkYXRhOFtpXSA9IDB4ZmY7IGkgPSBpICsgNCB8IDA7IGRhdGE4W2ldID0gMHhmZjsgaSA9IGkgKyA0IHwgMDsgZGF0YThbaV0gPSAweGZmOyBpID0gaSArIDQgfCAwOyBkYXRhOFtpXSA9IDB4ZmY7IGkgPSBpICsgNCB8IDA7IGRhdGE4W2ldID0gMHhmZjsgaSA9IGkgKyA0IHwgMDsgZGF0YThbaV0gPSAweGZmOyBpID0gaSArIDQgfCAwOyBkYXRhOFtpXSA9IDB4ZmY7IGkgPSBpICsgNCB8IDA7IH0gfSBlbHNlIHsgd2hpbGUgKGkgPCBqKSB7IGRhdGE4W2ldID0gMHhmZjsgaSA9IGkgKyA0IHwgMDsgfSB9IH0gU0RMMi5jdHgucHV0SW1hZ2VEYXRhKFNETDIuaW1hZ2UsIDAsIDApOyByZXR1cm4gMDt9LCAgXG4gICAgICAgIDI5MzI1OTogZnVuY3Rpb24oKSB7aWYgKHR5cGVvZihBdWRpb0NvbnRleHQpICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gMTsgfSBlbHNlIGlmICh0eXBlb2Yod2Via2l0QXVkaW9Db250ZXh0KSAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIDE7IH0gcmV0dXJuIDA7fSwgIFxuICAgICAgICAyOTMzOTY6IGZ1bmN0aW9uKCkge2lmICgodHlwZW9mKG5hdmlnYXRvci5tZWRpYURldmljZXMpICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZihuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkgIT09ICd1bmRlZmluZWQnKSkgeyByZXR1cm4gMTsgfSBlbHNlIGlmICh0eXBlb2YobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSkgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiAxOyB9IHJldHVybiAwO30sICBcbiAgICAgICAgMjkzNjIwOiBmdW5jdGlvbigkMCkge2lmKHR5cGVvZihNb2R1bGVbJ1NETDInXSkgPT09ICd1bmRlZmluZWQnKSB7IE1vZHVsZVsnU0RMMiddID0ge307IH0gdmFyIFNETDIgPSBNb2R1bGVbJ1NETDInXTsgaWYgKCEkMCkgeyBTREwyLmF1ZGlvID0ge307IH0gZWxzZSB7IFNETDIuY2FwdHVyZSA9IHt9OyB9IGlmICghU0RMMi5hdWRpb0NvbnRleHQpIHsgaWYgKHR5cGVvZihBdWRpb0NvbnRleHQpICE9PSAndW5kZWZpbmVkJykgeyBTREwyLmF1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTsgfSBlbHNlIGlmICh0eXBlb2Yod2Via2l0QXVkaW9Db250ZXh0KSAhPT0gJ3VuZGVmaW5lZCcpIHsgU0RMMi5hdWRpb0NvbnRleHQgPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0KCk7IH0gaWYgKFNETDIuYXVkaW9Db250ZXh0KSB7IGF1dG9SZXN1bWVBdWRpb0NvbnRleHQoU0RMMi5hdWRpb0NvbnRleHQpOyB9IH0gcmV0dXJuIFNETDIuYXVkaW9Db250ZXh0ID09PSB1bmRlZmluZWQgPyAtMSA6IDA7fSwgIFxuICAgICAgICAyOTQxMTM6IGZ1bmN0aW9uKCkge3ZhciBTREwyID0gTW9kdWxlWydTREwyJ107IHJldHVybiBTREwyLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO30sICBcbiAgICAgICAgMjk0MTgxOiBmdW5jdGlvbigkMCwgJDEsICQyLCAkMykge3ZhciBTREwyID0gTW9kdWxlWydTREwyJ107IHZhciBoYXZlX21pY3JvcGhvbmUgPSBmdW5jdGlvbihzdHJlYW0pIHsgaWYgKFNETDIuY2FwdHVyZS5zaWxlbmNlVGltZXIgIT09IHVuZGVmaW5lZCkgeyBjbGVhclRpbWVvdXQoU0RMMi5jYXB0dXJlLnNpbGVuY2VUaW1lcik7IFNETDIuY2FwdHVyZS5zaWxlbmNlVGltZXIgPSB1bmRlZmluZWQ7IH0gU0RMMi5jYXB0dXJlLm1lZGlhU3RyZWFtTm9kZSA9IFNETDIuYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7IFNETDIuY2FwdHVyZS5zY3JpcHRQcm9jZXNzb3JOb2RlID0gU0RMMi5hdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKCQxLCAkMCwgMSk7IFNETDIuY2FwdHVyZS5zY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oYXVkaW9Qcm9jZXNzaW5nRXZlbnQpIHsgaWYgKChTREwyID09PSB1bmRlZmluZWQpIHx8IChTREwyLmNhcHR1cmUgPT09IHVuZGVmaW5lZCkpIHsgcmV0dXJuOyB9IGF1ZGlvUHJvY2Vzc2luZ0V2ZW50Lm91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKS5maWxsKDAuMCk7IFNETDIuY2FwdHVyZS5jdXJyZW50Q2FwdHVyZUJ1ZmZlciA9IGF1ZGlvUHJvY2Vzc2luZ0V2ZW50LmlucHV0QnVmZmVyOyBkeW5DYWxsKCd2aScsICQyLCBbJDNdKTsgfTsgU0RMMi5jYXB0dXJlLm1lZGlhU3RyZWFtTm9kZS5jb25uZWN0KFNETDIuY2FwdHVyZS5zY3JpcHRQcm9jZXNzb3JOb2RlKTsgU0RMMi5jYXB0dXJlLnNjcmlwdFByb2Nlc3Nvck5vZGUuY29ubmVjdChTREwyLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7IFNETDIuY2FwdHVyZS5zdHJlYW0gPSBzdHJlYW07IH07IHZhciBub19taWNyb3Bob25lID0gZnVuY3Rpb24oZXJyb3IpIHsgfTsgU0RMMi5jYXB0dXJlLnNpbGVuY2VCdWZmZXIgPSBTREwyLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoJDAsICQxLCBTREwyLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTsgU0RMMi5jYXB0dXJlLnNpbGVuY2VCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCkuZmlsbCgwLjApOyB2YXIgc2lsZW5jZV9jYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyBTREwyLmNhcHR1cmUuY3VycmVudENhcHR1cmVCdWZmZXIgPSBTREwyLmNhcHR1cmUuc2lsZW5jZUJ1ZmZlcjsgZHluQ2FsbCgndmknLCAkMiwgWyQzXSk7IH07IFNETDIuY2FwdHVyZS5zaWxlbmNlVGltZXIgPSBzZXRUaW1lb3V0KHNpbGVuY2VfY2FsbGJhY2ssICgkMSAvIFNETDIuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpICogMTAwMCk7IGlmICgobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAhPT0gdW5kZWZpbmVkKSAmJiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgIT09IHVuZGVmaW5lZCkpIHsgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogdHJ1ZSwgdmlkZW86IGZhbHNlIH0pLnRoZW4oaGF2ZV9taWNyb3Bob25lKS5jYXRjaChub19taWNyb3Bob25lKTsgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhICE9PSB1bmRlZmluZWQpIHsgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSh7IGF1ZGlvOiB0cnVlLCB2aWRlbzogZmFsc2UgfSwgaGF2ZV9taWNyb3Bob25lLCBub19taWNyb3Bob25lKTsgfX0sICBcbiAgICAgICAgMjk1ODMzOiBmdW5jdGlvbigkMCwgJDEsICQyLCAkMykge3ZhciBTREwyID0gTW9kdWxlWydTREwyJ107IFNETDIuYXVkaW8uc2NyaXB0UHJvY2Vzc29yTm9kZSA9IFNETDIuYXVkaW9Db250ZXh0WydjcmVhdGVTY3JpcHRQcm9jZXNzb3InXSgkMSwgMCwgJDApOyBTREwyLmF1ZGlvLnNjcmlwdFByb2Nlc3Nvck5vZGVbJ29uYXVkaW9wcm9jZXNzJ10gPSBmdW5jdGlvbiAoZSkgeyBpZiAoKFNETDIgPT09IHVuZGVmaW5lZCkgfHwgKFNETDIuYXVkaW8gPT09IHVuZGVmaW5lZCkpIHsgcmV0dXJuOyB9IFNETDIuYXVkaW8uY3VycmVudE91dHB1dEJ1ZmZlciA9IGVbJ291dHB1dEJ1ZmZlciddOyBkeW5DYWxsKCd2aScsICQyLCBbJDNdKTsgfTsgU0RMMi5hdWRpby5zY3JpcHRQcm9jZXNzb3JOb2RlWydjb25uZWN0J10oU0RMMi5hdWRpb0NvbnRleHRbJ2Rlc3RpbmF0aW9uJ10pO30sICBcbiAgICAgICAgMjk2MjQzOiBmdW5jdGlvbigkMCwgJDEpIHt2YXIgU0RMMiA9IE1vZHVsZVsnU0RMMiddOyB2YXIgbnVtQ2hhbm5lbHMgPSBTREwyLmNhcHR1cmUuY3VycmVudENhcHR1cmVCdWZmZXIubnVtYmVyT2ZDaGFubmVsczsgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1DaGFubmVsczsgKytjKSB7IHZhciBjaGFubmVsRGF0YSA9IFNETDIuY2FwdHVyZS5jdXJyZW50Q2FwdHVyZUJ1ZmZlci5nZXRDaGFubmVsRGF0YShjKTsgaWYgKGNoYW5uZWxEYXRhLmxlbmd0aCAhPSAkMSkgeyB0aHJvdyAnV2ViIEF1ZGlvIGNhcHR1cmUgYnVmZmVyIGxlbmd0aCBtaXNtYXRjaCEgRGVzdGluYXRpb24gc2l6ZTogJyArIGNoYW5uZWxEYXRhLmxlbmd0aCArICcgc2FtcGxlcyB2cyBleHBlY3RlZCAnICsgJDEgKyAnIHNhbXBsZXMhJzsgfSBpZiAobnVtQ2hhbm5lbHMgPT0gMSkgeyBmb3IgKHZhciBqID0gMDsgaiA8ICQxOyArK2opIHsgc2V0VmFsdWUoJDAgKyAoaiAqIDQpLCBjaGFubmVsRGF0YVtqXSwgJ2Zsb2F0Jyk7IH0gfSBlbHNlIHsgZm9yICh2YXIgaiA9IDA7IGogPCAkMTsgKytqKSB7IHNldFZhbHVlKCQwICsgKCgoaiAqIG51bUNoYW5uZWxzKSArIGMpICogNCksIGNoYW5uZWxEYXRhW2pdLCAnZmxvYXQnKTsgfSB9IH19LCAgXG4gICAgICAgIDI5Njg0ODogZnVuY3Rpb24oJDAsICQxKSB7dmFyIFNETDIgPSBNb2R1bGVbJ1NETDInXTsgdmFyIG51bUNoYW5uZWxzID0gU0RMMi5hdWRpby5jdXJyZW50T3V0cHV0QnVmZmVyWydudW1iZXJPZkNoYW5uZWxzJ107IGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ2hhbm5lbHM7ICsrYykgeyB2YXIgY2hhbm5lbERhdGEgPSBTREwyLmF1ZGlvLmN1cnJlbnRPdXRwdXRCdWZmZXJbJ2dldENoYW5uZWxEYXRhJ10oYyk7IGlmIChjaGFubmVsRGF0YS5sZW5ndGggIT0gJDEpIHsgdGhyb3cgJ1dlYiBBdWRpbyBvdXRwdXQgYnVmZmVyIGxlbmd0aCBtaXNtYXRjaCEgRGVzdGluYXRpb24gc2l6ZTogJyArIGNoYW5uZWxEYXRhLmxlbmd0aCArICcgc2FtcGxlcyB2cyBleHBlY3RlZCAnICsgJDEgKyAnIHNhbXBsZXMhJzsgfSBmb3IgKHZhciBqID0gMDsgaiA8ICQxOyArK2opIHsgY2hhbm5lbERhdGFbal0gPSBIRUFQRjMyWyQwICsgKChqKm51bUNoYW5uZWxzICsgYykgPDwgMikgPj4gMl07IH0gfX0sICBcbiAgICAgICAgMjk3MzI4OiBmdW5jdGlvbigkMCkge3ZhciBTREwyID0gTW9kdWxlWydTREwyJ107IGlmICgkMCkgeyBpZiAoU0RMMi5jYXB0dXJlLnNpbGVuY2VUaW1lciAhPT0gdW5kZWZpbmVkKSB7IGNsZWFyVGltZW91dChTREwyLmNhcHR1cmUuc2lsZW5jZVRpbWVyKTsgfSBpZiAoU0RMMi5jYXB0dXJlLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7IHZhciB0cmFja3MgPSBTREwyLmNhcHR1cmUuc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCk7IGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7IFNETDIuY2FwdHVyZS5zdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2tzW2ldKTsgfSBTREwyLmNhcHR1cmUuc3RyZWFtID0gdW5kZWZpbmVkOyB9IGlmIChTREwyLmNhcHR1cmUuc2NyaXB0UHJvY2Vzc29yTm9kZSAhPT0gdW5kZWZpbmVkKSB7IFNETDIuY2FwdHVyZS5zY3JpcHRQcm9jZXNzb3JOb2RlLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oYXVkaW9Qcm9jZXNzaW5nRXZlbnQpIHt9OyBTREwyLmNhcHR1cmUuc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNjb25uZWN0KCk7IFNETDIuY2FwdHVyZS5zY3JpcHRQcm9jZXNzb3JOb2RlID0gdW5kZWZpbmVkOyB9IGlmIChTREwyLmNhcHR1cmUubWVkaWFTdHJlYW1Ob2RlICE9PSB1bmRlZmluZWQpIHsgU0RMMi5jYXB0dXJlLm1lZGlhU3RyZWFtTm9kZS5kaXNjb25uZWN0KCk7IFNETDIuY2FwdHVyZS5tZWRpYVN0cmVhbU5vZGUgPSB1bmRlZmluZWQ7IH0gaWYgKFNETDIuY2FwdHVyZS5zaWxlbmNlQnVmZmVyICE9PSB1bmRlZmluZWQpIHsgU0RMMi5jYXB0dXJlLnNpbGVuY2VCdWZmZXIgPSB1bmRlZmluZWQgfSBTREwyLmNhcHR1cmUgPSB1bmRlZmluZWQ7IH0gZWxzZSB7IGlmIChTREwyLmF1ZGlvLnNjcmlwdFByb2Nlc3Nvck5vZGUgIT0gdW5kZWZpbmVkKSB7IFNETDIuYXVkaW8uc2NyaXB0UHJvY2Vzc29yTm9kZS5kaXNjb25uZWN0KCk7IFNETDIuYXVkaW8uc2NyaXB0UHJvY2Vzc29yTm9kZSA9IHVuZGVmaW5lZDsgfSBTREwyLmF1ZGlvID0gdW5kZWZpbmVkOyB9IGlmICgoU0RMMi5hdWRpb0NvbnRleHQgIT09IHVuZGVmaW5lZCkgJiYgKFNETDIuYXVkaW8gPT09IHVuZGVmaW5lZCkgJiYgKFNETDIuY2FwdHVyZSA9PT0gdW5kZWZpbmVkKSkgeyBTREwyLmF1ZGlvQ29udGV4dC5jbG9zZSgpOyBTREwyLmF1ZGlvQ29udGV4dCA9IHVuZGVmaW5lZDsgfX0sICBcbiAgICAgICAgMjk4NTAwOiBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQpIHt2YXIgdyA9ICQwOyB2YXIgaCA9ICQxOyB2YXIgaG90X3ggPSAkMjsgdmFyIGhvdF95ID0gJDM7IHZhciBwaXhlbHMgPSAkNDsgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IGNhbnZhcy53aWR0aCA9IHc7IGNhbnZhcy5oZWlnaHQgPSBoOyB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTsgdmFyIGltYWdlID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3LCBoKTsgdmFyIGRhdGEgPSBpbWFnZS5kYXRhOyB2YXIgc3JjID0gcGl4ZWxzID4+IDI7IHZhciBkc3QgPSAwOyB2YXIgbnVtOyBpZiAodHlwZW9mIENhbnZhc1BpeGVsQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBDYW52YXNQaXhlbEFycmF5KSB7IG51bSA9IGRhdGEubGVuZ3RoOyB3aGlsZSAoZHN0IDwgbnVtKSB7IHZhciB2YWwgPSBIRUFQMzJbc3JjXTsgZGF0YVtkc3QgXSA9IHZhbCAmIDB4ZmY7IGRhdGFbZHN0KzFdID0gKHZhbCA+PiA4KSAmIDB4ZmY7IGRhdGFbZHN0KzJdID0gKHZhbCA+PiAxNikgJiAweGZmOyBkYXRhW2RzdCszXSA9ICh2YWwgPj4gMjQpICYgMHhmZjsgc3JjKys7IGRzdCArPSA0OyB9IH0gZWxzZSB7IHZhciBkYXRhMzIgPSBuZXcgSW50MzJBcnJheShkYXRhLmJ1ZmZlcik7IG51bSA9IGRhdGEzMi5sZW5ndGg7IGRhdGEzMi5zZXQoSEVBUDMyLnN1YmFycmF5KHNyYywgc3JjICsgbnVtKSk7IH0gY3R4LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7IHZhciB1cmwgPSBob3RfeCA9PT0gMCAmJiBob3RfeSA9PT0gMCA/IFwidXJsKFwiICsgY2FudmFzLnRvRGF0YVVSTCgpICsgXCIpLCBhdXRvXCIgOiBcInVybChcIiArIGNhbnZhcy50b0RhdGFVUkwoKSArIFwiKSBcIiArIGhvdF94ICsgXCIgXCIgKyBob3RfeSArIFwiLCBhdXRvXCI7IHZhciB1cmxCdWYgPSBfbWFsbG9jKHVybC5sZW5ndGggKyAxKTsgc3RyaW5nVG9VVEY4KHVybCwgdXJsQnVmLCB1cmwubGVuZ3RoICsgMSk7IHJldHVybiB1cmxCdWY7fSwgIFxuICAgICAgICAyOTk0ODk6IGZ1bmN0aW9uKCQwKSB7aWYgKE1vZHVsZVsnY2FudmFzJ10pIHsgTW9kdWxlWydjYW52YXMnXS5zdHlsZVsnY3Vyc29yJ10gPSBVVEY4VG9TdHJpbmcoJDApOyB9IHJldHVybiAwO30sICBcbiAgICAgICAgMjk5NTgyOiBmdW5jdGlvbigpIHtpZiAoTW9kdWxlWydjYW52YXMnXSkgeyBNb2R1bGVbJ2NhbnZhcyddLnN0eWxlWydjdXJzb3InXSA9ICdub25lJzsgfX0sICBcbiAgICAgICAgMjk5NjUxOiBmdW5jdGlvbigpIHtyZXR1cm4gd2luZG93LmlubmVyV2lkdGg7fSwgIFxuICAgICAgICAyOTk2ODE6IGZ1bmN0aW9uKCkge3JldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7fVxuICAgIH07XG5cbiAgICB2YXIgQnJvd3NlciA9IHtcbiAgICAgICAgbWFpbkxvb3A6IHtcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZhbHNlLCBzY2hlZHVsZXI6IG51bGwsIG1ldGhvZDogXCJcIiwgY3VycmVudGx5UnVubmluZ01haW5sb29wOiAwLCBmdW5jOiBudWxsLCBhcmc6IDAsIHRpbWluZ01vZGU6IDAsIHRpbWluZ1ZhbHVlOiAwLCBjdXJyZW50RnJhbWVOdW1iZXI6IDAsIHF1ZXVlOiBbXSwgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLnNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50aW5nIHRoaXMgc2lnbmFscyB0aGUgcHJldmlvdXMgbWFpbiBsb29wIHRoYXQgaXQncyBub3cgYmVjb21lIG9sZCwgYW5kIGl0IG11c3QgcmV0dXJuLlxuICAgICAgICAgICAgICAgIEJyb3dzZXIubWFpbkxvb3AuY3VycmVudGx5UnVubmluZ01haW5sb29wKys7XG4gICAgICAgICAgICB9LCByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLmN1cnJlbnRseVJ1bm5pbmdNYWlubG9vcCsrO1xuICAgICAgICAgICAgICAgIHZhciB0aW1pbmdNb2RlID0gQnJvd3Nlci5tYWluTG9vcC50aW1pbmdNb2RlO1xuICAgICAgICAgICAgICAgIHZhciB0aW1pbmdWYWx1ZSA9IEJyb3dzZXIubWFpbkxvb3AudGltaW5nVmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBCcm93c2VyLm1haW5Mb29wLmZ1bmM7XG4gICAgICAgICAgICAgICAgQnJvd3Nlci5tYWluTG9vcC5mdW5jID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3Qgc2V0IHRpbWluZyBhbmQgY2FsbCBzY2hlZHVsZXIsIHdlIHdpbGwgZG8gaXQgb24gdGhlIG5leHQgbGluZXNcbiAgICAgICAgICAgICAgICBzZXRNYWluTG9vcChmdW5jLCAwLCBmYWxzZSwgQnJvd3Nlci5tYWluTG9vcC5hcmcsIHRydWUpO1xuICAgICAgICAgICAgICAgIF9lbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nKHRpbWluZ01vZGUsIHRpbWluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLnNjaGVkdWxlcigpO1xuICAgICAgICAgICAgfSwgdXBkYXRlU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBNb2R1bGVbJ3N0YXR1c01lc3NhZ2UnXSB8fCAnUGxlYXNlIHdhaXQuLi4nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gQnJvd3Nlci5tYWluTG9vcC5yZW1haW5pbmdCbG9ja2VycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gQnJvd3Nlci5tYWluTG9vcC5leHBlY3RlZEJsb2NrZXJzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nIDwgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKG1lc3NhZ2UgKyAnICgnICsgKGV4cGVjdGVkIC0gcmVtYWluaW5nKSArICcvJyArIGV4cGVjdGVkICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcnVuSXRlcjogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQUJPUlQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoTW9kdWxlWydwcmVNYWluTG9vcCddKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVSZXQgPSBNb2R1bGVbJ3ByZU1haW5Mb29wJ10oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZVJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gfHJldHVybiBmYWxzZXwgc2tpcHMgYSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxVc2VyQ2FsbGJhY2soZnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKE1vZHVsZVsncG9zdE1haW5Mb29wJ10pIE1vZHVsZVsncG9zdE1haW5Mb29wJ10oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXNGdWxsc2NyZWVuOiBmYWxzZSwgcG9pbnRlckxvY2s6IGZhbHNlLCBtb2R1bGVDb250ZXh0Q3JlYXRlZENhbGxiYWNrczogW10sIHdvcmtlcnM6IFtdLCBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIU1vZHVsZVtcInByZWxvYWRQbHVnaW5zXCJdKSBNb2R1bGVbXCJwcmVsb2FkUGx1Z2luc1wiXSA9IFtdOyAvLyBuZWVkcyB0byBleGlzdCBldmVuIGluIHdvcmtlcnNcblxuICAgICAgICAgICAgaWYgKEJyb3dzZXIuaW5pdHRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgQnJvd3Nlci5pbml0dGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgICAgICAgIEJyb3dzZXIuaGFzQmxvYkNvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBCcm93c2VyLmhhc0Jsb2JDb25zdHJ1Y3RvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG91dChcIndhcm5pbmc6IG5vIGJsb2IgY29uc3RydWN0b3IsIGNhbm5vdCBjcmVhdGUgYmxvYnMgd2l0aCBtaW1ldHlwZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCcm93c2VyLkJsb2JCdWlsZGVyID0gdHlwZW9mIE1vekJsb2JCdWlsZGVyICE9IFwidW5kZWZpbmVkXCIgPyBNb3pCbG9iQnVpbGRlciA6ICh0eXBlb2YgV2ViS2l0QmxvYkJ1aWxkZXIgIT0gXCJ1bmRlZmluZWRcIiA/IFdlYktpdEJsb2JCdWlsZGVyIDogKCFCcm93c2VyLmhhc0Jsb2JDb25zdHJ1Y3RvciA/IG91dChcIndhcm5pbmc6IG5vIEJsb2JCdWlsZGVyXCIpIDogbnVsbCkpO1xuICAgICAgICAgICAgQnJvd3Nlci5VUkxPYmplY3QgPSB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyAod2luZG93LlVSTCA/IHdpbmRvdy5VUkwgOiB3aW5kb3cud2Via2l0VVJMKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghTW9kdWxlLm5vSW1hZ2VEZWNvZGluZyAmJiB0eXBlb2YgQnJvd3Nlci5VUkxPYmplY3QgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvdXQoXCJ3YXJuaW5nOiBCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3JlYXRpbmcgb2JqZWN0IFVSTHMuIEJ1aWx0LWluIGJyb3dzZXIgaW1hZ2UgZGVjb2Rpbmcgd2lsbCBub3QgYmUgYXZhaWxhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICBNb2R1bGUubm9JbWFnZURlY29kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgcGx1Z2lucyB0aGF0IGNhbiBwcm9jZXNzIHByZWxvYWRlZCBmaWxlcy4gWW91IGNhbiBhZGQgbW9yZSBvZiB0aGVzZSB0b1xuICAgICAgICAgICAgLy8geW91ciBhcHAgYnkgY3JlYXRpbmcgYW5kIGFwcGVuZGluZyB0byBNb2R1bGUucHJlbG9hZFBsdWdpbnMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRWFjaCBwbHVnaW4gaXMgYXNrZWQgaWYgaXQgY2FuIGhhbmRsZSBhIGZpbGUgYmFzZWQgb24gdGhlIGZpbGUncyBuYW1lLiBJZiBpdCBjYW4sXG4gICAgICAgICAgICAvLyBpdCBpcyBnaXZlbiB0aGUgZmlsZSdzIHJhdyBkYXRhLiBXaGVuIGl0IGlzIGRvbmUsIGl0IGNhbGxzIGEgY2FsbGJhY2sgd2l0aCB0aGUgZmlsZSdzXG4gICAgICAgICAgICAvLyAocG9zc2libHkgbW9kaWZpZWQpIGRhdGEuIEZvciBleGFtcGxlLCBhIHBsdWdpbiBtaWdodCBkZWNvbXByZXNzIGEgZmlsZSwgb3IgaXRcbiAgICAgICAgICAgIC8vIG1pZ2h0IGNyZWF0ZSBzb21lIHNpZGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHVzZSBsYXRlciAobGlrZSBhbiBJbWFnZSBlbGVtZW50LCBldGMuKS5cblxuICAgICAgICAgICAgdmFyIGltYWdlUGx1Z2luID0ge307XG4gICAgICAgICAgICBpbWFnZVBsdWdpblsnY2FuSGFuZGxlJ10gPSBmdW5jdGlvbiBpbWFnZVBsdWdpbl9jYW5IYW5kbGUobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhTW9kdWxlLm5vSW1hZ2VEZWNvZGluZyAmJiAvXFwuKGpwZ3xqcGVnfHBuZ3xibXApJC9pLnRlc3QobmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2VQbHVnaW5bJ2hhbmRsZSddID0gZnVuY3Rpb24gaW1hZ2VQbHVnaW5faGFuZGxlKGJ5dGVBcnJheSwgbmFtZSwgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChCcm93c2VyLmhhc0Jsb2JDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IG5ldyBCbG9iKFtieXRlQXJyYXldLCB7IHR5cGU6IEJyb3dzZXIuZ2V0TWltZXR5cGUobmFtZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5zaXplICE9PSBieXRlQXJyYXkubGVuZ3RoKSB7IC8vIFNhZmFyaSBidWcgIzExODYzMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSdzIEJsb2IgY2FuIG9ubHkgdGFrZSBhbiBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBuZXcgQmxvYihbKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpLmJ1ZmZlcl0sIHsgdHlwZTogQnJvd3Nlci5nZXRNaW1ldHlwZShuYW1lKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fybk9uY2UoJ0Jsb2IgY29uc3RydWN0b3IgcHJlc2VudCBidXQgZmFpbHM6ICcgKyBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGJsb2IgYnVpbGRlcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmIgPSBuZXcgQnJvd3Nlci5CbG9iQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICBiYi5hcHBlbmQoKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpLmJ1ZmZlcik7IC8vIHdlIG5lZWQgdG8gcGFzcyBhIGJ1ZmZlciwgYW5kIG11c3QgY29weSB0aGUgYXJyYXkgdG8gZ2V0IHRoZSByaWdodCBkYXRhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIGIgPSBiYi5nZXRCbG9iKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBCcm93c2VyLlVSTE9iamVjdC5jcmVhdGVPYmplY3RVUkwoYik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiB1cmwgPT0gJ3N0cmluZycsICdjcmVhdGVPYmplY3RVUkwgbXVzdCByZXR1cm4gYSB1cmwgYXMgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0KGltZy5jb21wbGV0ZSwgJ0ltYWdlICcgKyBuYW1lICsgJyBjb3VsZCBub3QgYmUgZGVjb2RlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gLyoqIEB0eXBlIHshSFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBNb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl1bbmFtZV0gPSBjYW52YXM7XG4gICAgICAgICAgICAgICAgICAgIEJyb3dzZXIuVVJMT2JqZWN0LnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25sb2FkKSBvbmxvYWQoYnl0ZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCgnSW1hZ2UgJyArIHVybCArICcgY291bGQgbm90IGJlIGRlY29kZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uZXJyb3IpIG9uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTW9kdWxlWydwcmVsb2FkUGx1Z2lucyddLnB1c2goaW1hZ2VQbHVnaW4pO1xuXG4gICAgICAgICAgICB2YXIgYXVkaW9QbHVnaW4gPSB7fTtcbiAgICAgICAgICAgIGF1ZGlvUGx1Z2luWydjYW5IYW5kbGUnXSA9IGZ1bmN0aW9uIGF1ZGlvUGx1Z2luX2NhbkhhbmRsZShuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFNb2R1bGUubm9BdWRpb0RlY29kaW5nICYmIG5hbWUuc3Vic3RyKC00KSBpbiB7ICcub2dnJzogMSwgJy53YXYnOiAxLCAnLm1wMyc6IDEgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdWRpb1BsdWdpblsnaGFuZGxlJ10gPSBmdW5jdGlvbiBhdWRpb1BsdWdpbl9oYW5kbGUoYnl0ZUFycmF5LCBuYW1lLCBvbmxvYWQsIG9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaChhdWRpbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdW25hbWVdID0gYXVkaW87XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbmxvYWQpIG9ubG9hZChieXRlQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmYWlsKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgTW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdW25hbWVdID0gbmV3IEF1ZGlvKCk7IC8vIGVtcHR5IHNoaW1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uZXJyb3IpIG9uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEJyb3dzZXIuaGFzQmxvYkNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBCbG9iKFtieXRlQXJyYXldLCB7IHR5cGU6IEJyb3dzZXIuZ2V0TWltZXR5cGUobmFtZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IEJyb3dzZXIuVVJMT2JqZWN0LmNyZWF0ZU9iamVjdFVSTChiKTsgLy8gWFhYIHdlIG5ldmVyIHJldm9rZSB0aGlzIVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQodHlwZW9mIHVybCA9PSAnc3RyaW5nJywgJ2NyZWF0ZU9iamVjdFVSTCBtdXN0IHJldHVybiBhIHVybCBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXVkaW8gPSBuZXcgQXVkaW8oKTtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBmdW5jdGlvbiAoKSB7IGZpbmlzaChhdWRpbykgfSwgZmFsc2UpOyAvLyB1c2UgYWRkRXZlbnRMaXN0ZW5lciBkdWUgdG8gY2hyb21pdW0gYnVnIDEyNDkyNlxuICAgICAgICAgICAgICAgICAgICBhdWRpby5vbmVycm9yID0gZnVuY3Rpb24gYXVkaW9fb25lcnJvcihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCgnd2FybmluZzogYnJvd3NlciBjb3VsZCBub3QgZnVsbHkgZGVjb2RlIGF1ZGlvICcgKyBuYW1lICsgJywgdHJ5aW5nIHNsb3dlciBiYXNlNjQgYXBwcm9hY2gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVuY29kZTY0KGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQkFTRSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgUEFEID0gJz0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdGNoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0Yml0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRjaGFyID0gKGxlZnRjaGFyIDw8IDgpIHwgZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlZnRiaXRzID49IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyID0gKGxlZnRjaGFyID4+IChsZWZ0Yml0cyAtIDYpKSAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0Yml0cyAtPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IEJBU0VbY3Vycl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRiaXRzID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IEJBU0VbKGxlZnRjaGFyICYgMykgPDwgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBQQUQgKyBQQUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0Yml0cyA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBCQVNFWyhsZWZ0Y2hhciAmIDB4ZikgPDwgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSBQQUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWRpby5zcmMgPSAnZGF0YTphdWRpby94LScgKyBuYW1lLnN1YnN0cigtMykgKyAnO2Jhc2U2NCwnICsgZW5jb2RlNjQoYnl0ZUFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChhdWRpbyk7IC8vIHdlIGRvbid0IHdhaXQgZm9yIGNvbmZpcm1hdGlvbiB0aGlzIHdvcmtlZCAtIGJ1dCBpdCdzIHdvcnRoIHRyeWluZ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhdWRpby5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGNocm9tZSBidWcgMTI0OTI2IC0gd2UgZG8gbm90IGFsd2F5cyBnZXQgb25jYW5wbGF5dGhyb3VnaCBvciBvbmVycm9yXG4gICAgICAgICAgICAgICAgICAgIHNhZmVTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChhdWRpbyk7IC8vIHRyeSB0byB1c2UgaXQgZXZlbiB0aG91Z2ggaXQgaXMgbm90IG5lY2Vzc2FyaWx5IHJlYWR5IHRvIHBsYXlcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE1vZHVsZVsncHJlbG9hZFBsdWdpbnMnXS5wdXNoKGF1ZGlvUGx1Z2luKTtcblxuICAgICAgICAgICAgLy8gVXNlIHN0cmluZyBrZXlzIGhlcmUgdG8gYXZvaWQgbWluaWZpY2F0aW9uIHNpbmNlIHRoZSBwbHVnaW4gY29uc3VtZXJcbiAgICAgICAgICAgIC8vIGFsc28gdXNlcyBzdHJpbmcga2V5cy5cbiAgICAgICAgICAgIHZhciB3YXNtUGx1Z2luID0ge1xuICAgICAgICAgICAgICAgICdhc3luY1dhc21Mb2FkUHJvbWlzZSc6IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSksXG4gICAgICAgICAgICAgICAgJ2NhbkhhbmRsZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhTW9kdWxlLm5vV2FzbURlY29kaW5nICYmIG5hbWUuZW5kc1dpdGgoJy5zbycpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnaGFuZGxlJzogZnVuY3Rpb24gKGJ5dGVBcnJheSwgbmFtZSwgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvYWRXZWJBc3NlbWJseU1vZHVsZSBjYW4gbm90IGxvYWQgbW9kdWxlcyBvdXQtb2Ytb3JkZXIsIHNvIHJhdGhlclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGFuIGp1c3QgcnVubmluZyB0aGUgcHJvbWlzZXMgaW4gcGFyYWxsZWwsIHRoaXMgbWFrZXMgYSBjaGFpbiBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9taXNlcyB0byBydW4gaW4gc2VyaWVzLlxuICAgICAgICAgICAgICAgICAgICB3YXNtUGx1Z2luWydhc3luY1dhc21Mb2FkUHJvbWlzZSddID0gd2FzbVBsdWdpblsnYXN5bmNXYXNtTG9hZFByb21pc2UnXS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkV2ViQXNzZW1ibHlNb2R1bGUoYnl0ZUFycmF5LCB7IGxvYWRBc3luYzogdHJ1ZSwgbm9kZWxldGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kdWxlWydwcmVsb2FkZWRXYXNtJ11bbmFtZV0gPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZG4ndCBpbnN0YW50aWF0ZSB3YXNtOiBcIiArIG5hbWUgKyBcIiAnXCIgKyBlcnIgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgTW9kdWxlWydwcmVsb2FkUGx1Z2lucyddLnB1c2god2FzbVBsdWdpbik7XG5cbiAgICAgICAgICAgIC8vIENhbnZhcyBldmVudCBzZXR1cFxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludGVyTG9ja0NoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICBCcm93c2VyLnBvaW50ZXJMb2NrID0gZG9jdW1lbnRbJ3BvaW50ZXJMb2NrRWxlbWVudCddID09PSBNb2R1bGVbJ2NhbnZhcyddIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Wydtb3pQb2ludGVyTG9ja0VsZW1lbnQnXSA9PT0gTW9kdWxlWydjYW52YXMnXSB8fFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFsnd2Via2l0UG9pbnRlckxvY2tFbGVtZW50J10gPT09IE1vZHVsZVsnY2FudmFzJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRbJ21zUG9pbnRlckxvY2tFbGVtZW50J10gPT09IE1vZHVsZVsnY2FudmFzJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gTW9kdWxlWydjYW52YXMnXTtcbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZWQgYXNwZWN0IHJhdGlvIGNhbiBiZSBlbmFibGVkIGJ5IGRlZmluaW5nICdmb3JjZWRBc3BlY3RSYXRpbycgb24gTW9kdWxlXG4gICAgICAgICAgICAgICAgLy8gTW9kdWxlWydmb3JjZWRBc3BlY3RSYXRpbyddID0gNCAvIDM7XG5cbiAgICAgICAgICAgICAgICBjYW52YXMucmVxdWVzdFBvaW50ZXJMb2NrID0gY2FudmFzWydyZXF1ZXN0UG9pbnRlckxvY2snXSB8fFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNbJ21velJlcXVlc3RQb2ludGVyTG9jayddIHx8XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1snd2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzWydtc1JlcXVlc3RQb2ludGVyTG9jayddIHx8XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgICAgICBjYW52YXMuZXhpdFBvaW50ZXJMb2NrID0gZG9jdW1lbnRbJ2V4aXRQb2ludGVyTG9jayddIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Wydtb3pFeGl0UG9pbnRlckxvY2snXSB8fFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFsnd2Via2l0RXhpdFBvaW50ZXJMb2NrJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRbJ21zRXhpdFBvaW50ZXJMb2NrJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyB9OyAvLyBuby1vcCBpZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdFxuICAgICAgICAgICAgICAgIGNhbnZhcy5leGl0UG9pbnRlckxvY2sgPSBjYW52YXMuZXhpdFBvaW50ZXJMb2NrLmJpbmQoZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxvY2tjaGFuZ2UnLCBwb2ludGVyTG9ja0NoYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21venBvaW50ZXJsb2NrY2hhbmdlJywgcG9pbnRlckxvY2tDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRwb2ludGVybG9ja2NoYW5nZScsIHBvaW50ZXJMb2NrQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbXNwb2ludGVybG9ja2NoYW5nZScsIHBvaW50ZXJMb2NrQ2hhbmdlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTW9kdWxlWydlbGVtZW50UG9pbnRlckxvY2snXSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFCcm93c2VyLnBvaW50ZXJMb2NrICYmIE1vZHVsZVsnY2FudmFzJ10ucmVxdWVzdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kdWxlWydjYW52YXMnXS5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVkQnlQcmVsb2FkUGx1Z2luOiBmdW5jdGlvbiAoYnl0ZUFycmF5LCBmdWxsbmFtZSwgZmluaXNoLCBvbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcGx1Z2lucyBhcmUgcmVhZHkuXG4gICAgICAgICAgICBCcm93c2VyLmluaXQoKTtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIE1vZHVsZVsncHJlbG9hZFBsdWdpbnMnXS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5bJ2NhbkhhbmRsZSddKGZ1bGxuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5bJ2hhbmRsZSddKGJ5dGVBcnJheSwgZnVsbG5hbWUsIGZpbmlzaCwgb25lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgICAgIH0sIGNyZWF0ZUNvbnRleHQ6IGZ1bmN0aW9uICgvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyBjYW52YXMsIHVzZVdlYkdMLCBzZXRJbk1vZHVsZSwgd2ViR0xDb250ZXh0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKHVzZVdlYkdMICYmIE1vZHVsZS5jdHggJiYgY2FudmFzID09IE1vZHVsZS5jYW52YXMpIHJldHVybiBNb2R1bGUuY3R4OyAvLyBubyBuZWVkIHRvIHJlY3JlYXRlIEdMIGNvbnRleHQgaWYgaXQncyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhpcyBjYW52YXMuXG5cbiAgICAgICAgICAgIHZhciBjdHg7XG4gICAgICAgICAgICB2YXIgY29udGV4dEhhbmRsZTtcbiAgICAgICAgICAgIGlmICh1c2VXZWJHTCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBHTEVTMi9kZXNrdG9wIEdMIGNvbXBhdGliaWxpdHksIGFkanVzdCBhIGZldyBkZWZhdWx0cyB0byBiZSBkaWZmZXJlbnQgdG8gV2ViR0wgZGVmYXVsdHMsIHNvIHRoYXQgdGhleSBhbGlnbiBiZXR0ZXIgd2l0aCB0aGUgZGVza3RvcCBkZWZhdWx0cy5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWFqb3JWZXJzaW9uOiAxLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAod2ViR0xDb250ZXh0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gd2ViR0xDb250ZXh0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHdlYkdMQ29udGV4dEF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgb2YgZXhpc3RlbmNlIG9mIEdMIGlzIGhlcmUgdG8gc2F0aXNmeSBDbG9zdXJlIGNvbXBpbGVyLCB3aGljaCB5ZWxscyBpZiB2YXJpYWJsZSBHTCBpcyByZWZlcmVuY2VkIGJlbG93IGJ1dCBHTCBvYmplY3QgaXMgbm90XG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgY29tcGlsZWQgaW4gYmVjYXVzZSBhcHBsaWNhdGlvbiBpcyBub3QgZG9pbmcgYW55IEdMIG9wZXJhdGlvbnMuIFRPRE86IElkZWFsbHkgaWYgR0wgaXMgbm90IGJlaW5nIHVzZWQsIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyLmNyZWF0ZUNvbnRleHQoKSBzaG91bGQgbm90IGV2ZW4gYmUgZW1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEdMICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRIYW5kbGUgPSBHTC5jcmVhdGVDb250ZXh0KGNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dEhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gR0wuZ2V0Q29udGV4dChjb250ZXh0SGFuZGxlKS5HTGN0eDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY3R4KSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHNldEluTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VXZWJHTCkgYXNzZXJ0KHR5cGVvZiBHTGN0eCA9PSAndW5kZWZpbmVkJywgJ2Nhbm5vdCBzZXQgaW4gbW9kdWxlIGlmIEdMY3R4IGlzIHVzZWQsIGJ1dCB3ZSBhcmUgYSBub24tR0wgY29udGV4dCB0aGF0IHdvdWxkIHJlcGxhY2UgaXQnKTtcblxuICAgICAgICAgICAgICAgIE1vZHVsZS5jdHggPSBjdHg7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVdlYkdMKSBHTC5tYWtlQ29udGV4dEN1cnJlbnQoY29udGV4dEhhbmRsZSk7XG4gICAgICAgICAgICAgICAgTW9kdWxlLnVzZVdlYkdMID0gdXNlV2ViR0w7XG4gICAgICAgICAgICAgICAgQnJvd3Nlci5tb2R1bGVDb250ZXh0Q3JlYXRlZENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyBjYWxsYmFjaygpIH0pO1xuICAgICAgICAgICAgICAgIEJyb3dzZXIuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSwgZGVzdHJveUNvbnRleHQ6IGZ1bmN0aW9uIChjYW52YXMsIHVzZVdlYkdMLCBzZXRJbk1vZHVsZSkgeyB9LCBmdWxsc2NyZWVuSGFuZGxlcnNJbnN0YWxsZWQ6IGZhbHNlLCBsb2NrUG9pbnRlcjogdW5kZWZpbmVkLCByZXNpemVDYW52YXM6IHVuZGVmaW5lZCwgcmVxdWVzdEZ1bGxzY3JlZW46IGZ1bmN0aW9uIChsb2NrUG9pbnRlciwgcmVzaXplQ2FudmFzKSB7XG4gICAgICAgICAgICBCcm93c2VyLmxvY2tQb2ludGVyID0gbG9ja1BvaW50ZXI7XG4gICAgICAgICAgICBCcm93c2VyLnJlc2l6ZUNhbnZhcyA9IHJlc2l6ZUNhbnZhcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgQnJvd3Nlci5sb2NrUG9pbnRlciA9PSAndW5kZWZpbmVkJykgQnJvd3Nlci5sb2NrUG9pbnRlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEJyb3dzZXIucmVzaXplQ2FudmFzID09ICd1bmRlZmluZWQnKSBCcm93c2VyLnJlc2l6ZUNhbnZhcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gTW9kdWxlWydjYW52YXMnXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgQnJvd3Nlci5pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gY2FudmFzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKChkb2N1bWVudFsnZnVsbHNjcmVlbkVsZW1lbnQnXSB8fCBkb2N1bWVudFsnbW96RnVsbFNjcmVlbkVsZW1lbnQnXSB8fFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFsnbXNGdWxsc2NyZWVuRWxlbWVudCddIHx8IGRvY3VtZW50Wyd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCddIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Wyd3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnQnXSkgPT09IGNhbnZhc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuZXhpdEZ1bGxzY3JlZW4gPSBCcm93c2VyLmV4aXRGdWxsc2NyZWVuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQnJvd3Nlci5sb2NrUG9pbnRlcikgY2FudmFzLnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBCcm93c2VyLmlzRnVsbHNjcmVlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChCcm93c2VyLnJlc2l6ZUNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5zZXRGdWxsc2NyZWVuQ2FudmFzU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci51cGRhdGVDYW52YXNEaW1lbnNpb25zKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZ1bGwgc2NyZWVuIHNwZWNpZmljIHBhcmVudCBvZiB0aGUgY2FudmFzIGFnYWluIHRvIHJlc3RvcmUgdGhlIEhUTUwgc3RydWN0dXJlIGZyb20gYmVmb3JlIGdvaW5nIGZ1bGwgc2NyZWVuXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjYW52YXMsIGNhbnZhc0NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEJyb3dzZXIucmVzaXplQ2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcm93c2VyLnNldFdpbmRvd2VkQ2FudmFzU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci51cGRhdGVDYW52YXNEaW1lbnNpb25zKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE1vZHVsZVsnb25GdWxsU2NyZWVuJ10pIE1vZHVsZVsnb25GdWxsU2NyZWVuJ10oQnJvd3Nlci5pc0Z1bGxzY3JlZW4pO1xuICAgICAgICAgICAgICAgIGlmIChNb2R1bGVbJ29uRnVsbHNjcmVlbiddKSBNb2R1bGVbJ29uRnVsbHNjcmVlbiddKEJyb3dzZXIuaXNGdWxsc2NyZWVuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFCcm93c2VyLmZ1bGxzY3JlZW5IYW5kbGVyc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgICAgIEJyb3dzZXIuZnVsbHNjcmVlbkhhbmRsZXJzSW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgZnVsbHNjcmVlbkNoYW5nZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBmdWxsc2NyZWVuQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGZ1bGxzY3JlZW5DaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCBmdWxsc2NyZWVuQ2hhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwYXJlbnQgdG8gZW5zdXJlIHRoZSBjYW52YXMgaGFzIG5vIHNpYmxpbmdzLiB0aGlzIGFsbG93cyBicm93c2VycyB0byBvcHRpbWl6ZSBmdWxsIHNjcmVlbiBwZXJmb3JtYW5jZSB3aGVuIGl0cyBwYXJlbnQgaXMgdGhlIGZ1bGwgc2NyZWVuIHJvb3RcbiAgICAgICAgICAgIHZhciBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgY2FudmFzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNhbnZhc0NvbnRhaW5lciwgY2FudmFzKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG4gICAgICAgICAgICAvLyB1c2UgcGFyZW50IG9mIGNhbnZhcyBhcyBmdWxsIHNjcmVlbiByb290IHRvIGFsbG93IGFzcGVjdCByYXRpbyBjb3JyZWN0aW9uIChGaXJlZm94IHN0cmV0Y2hlcyB0aGUgcm9vdCB0byBzY3JlZW4gc2l6ZSlcbiAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbiA9IGNhbnZhc0NvbnRhaW5lclsncmVxdWVzdEZ1bGxzY3JlZW4nXSB8fFxuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lclsnbW96UmVxdWVzdEZ1bGxTY3JlZW4nXSB8fFxuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lclsnbXNSZXF1ZXN0RnVsbHNjcmVlbiddIHx8XG4gICAgICAgICAgICAgICAgKGNhbnZhc0NvbnRhaW5lclsnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nXSA/IGZ1bmN0aW9uICgpIHsgY2FudmFzQ29udGFpbmVyWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiddKEVsZW1lbnRbJ0FMTE9XX0tFWUJPQVJEX0lOUFVUJ10pIH0gOiBudWxsKSB8fFxuICAgICAgICAgICAgICAgIChjYW52YXNDb250YWluZXJbJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJ10gPyBmdW5jdGlvbiAoKSB7IGNhbnZhc0NvbnRhaW5lclsnd2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4nXShFbGVtZW50WydBTExPV19LRVlCT0FSRF9JTlBVVCddKSB9IDogbnVsbCk7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgICB9LCByZXF1ZXN0RnVsbFNjcmVlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYWJvcnQoJ01vZHVsZS5yZXF1ZXN0RnVsbFNjcmVlbiBoYXMgYmVlbiByZXBsYWNlZCBieSBNb2R1bGUucmVxdWVzdEZ1bGxzY3JlZW4gKHdpdGhvdXQgYSBjYXBpdGFsIFMpJyk7XG4gICAgICAgIH0sIGV4aXRGdWxsc2NyZWVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHdvcmthcm91bmQgZm9yIGNocm9tZS4gVHJ5aW5nIHRvIGV4aXQgZnJvbSBmdWxsc2NyZWVuXG4gICAgICAgICAgICAvLyBub3QgaW4gZnVsbHNjcmVlbiBzdGF0ZSB3aWxsIGNhdXNlIFwiVHlwZUVycm9yOiBEb2N1bWVudCBub3QgYWN0aXZlXCJcbiAgICAgICAgICAgIC8vIGluIGNocm9tZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9wdWxsLzgyMzZcbiAgICAgICAgICAgIGlmICghQnJvd3Nlci5pc0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBDRlMgPSBkb2N1bWVudFsnZXhpdEZ1bGxzY3JlZW4nXSB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50WydjYW5jZWxGdWxsU2NyZWVuJ10gfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFsnbW96Q2FuY2VsRnVsbFNjcmVlbiddIHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRbJ21zRXhpdEZ1bGxzY3JlZW4nXSB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50Wyd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJ10gfHxcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIENGUy5hcHBseShkb2N1bWVudCwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sIG5leHRSQUY6IDAsIGZha2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8ga2VlcCA2MGZwcyBiZXR3ZWVuIGNhbGxzIHRvIGhlcmVcbiAgICAgICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKEJyb3dzZXIubmV4dFJBRiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIEJyb3dzZXIubmV4dFJBRiA9IG5vdyArIDEwMDAgLyA2MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vdyArIDIgPj0gQnJvd3Nlci5uZXh0UkFGKSB7IC8vIGZ1ZGdlIGEgbGl0dGxlLCB0byBhdm9pZCB0aW1lciBqaXR0ZXIgY2F1c2luZyB1cyB0byBkbyBsb3RzIG9mIGRlbGF5OjBcbiAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5uZXh0UkFGICs9IDEwMDAgLyA2MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVsYXkgPSBNYXRoLm1heChCcm93c2VyLm5leHRSQUYgLSBub3csIDApO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jLCBkZWxheSk7XG4gICAgICAgIH0sIHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIFJBRiA9IEJyb3dzZXIuZmFrZVJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICAgIFJBRihmdW5jKTtcbiAgICAgICAgfSwgc2FmZVNldFRpbWVvdXQ6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAvLyBMZWdhY3kgZnVuY3Rpb24sIHRoaXMgaXMgdXNlZCBieSB0aGUgU0RMMiBwb3J0IHNvIHdlIG5lZWQgdG8ga2VlcCBpdFxuICAgICAgICAgICAgLy8gYXJvdW5kIGF0IGxlYXN0IHVudGlsIHRoYXQgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgIHJldHVybiBzYWZlU2V0VGltZW91dChmdW5jKTtcbiAgICAgICAgfSwgc2FmZVJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24gKGZ1bmMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIEJyb3dzZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgIGNhbGxVc2VyQ2FsbGJhY2soZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZ2V0TWltZXR5cGU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdqcGcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAgICAgJ2pwZWcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAgICAgJ3BuZyc6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgICAgICdibXAnOiAnaW1hZ2UvYm1wJyxcbiAgICAgICAgICAgICAgICAnb2dnJzogJ2F1ZGlvL29nZycsXG4gICAgICAgICAgICAgICAgJ3dhdic6ICdhdWRpby93YXYnLFxuICAgICAgICAgICAgICAgICdtcDMnOiAnYXVkaW8vbXBlZydcbiAgICAgICAgICAgIH1bbmFtZS5zdWJzdHIobmFtZS5sYXN0SW5kZXhPZignLicpICsgMSldO1xuICAgICAgICB9LCBnZXRVc2VyTWVkaWE6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5nZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yWydnZXRVc2VyTWVkaWEnXSB8fFxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3JbJ21vekdldFVzZXJNZWRpYSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmdldFVzZXJNZWRpYShmdW5jKTtcbiAgICAgICAgfSwgZ2V0TW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudFsnbW92ZW1lbnRYJ10gfHxcbiAgICAgICAgICAgICAgICBldmVudFsnbW96TW92ZW1lbnRYJ10gfHxcbiAgICAgICAgICAgICAgICBldmVudFsnd2Via2l0TW92ZW1lbnRYJ10gfHxcbiAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9LCBnZXRNb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50Wydtb3ZlbWVudFknXSB8fFxuICAgICAgICAgICAgICAgIGV2ZW50Wydtb3pNb3ZlbWVudFknXSB8fFxuICAgICAgICAgICAgICAgIGV2ZW50Wyd3ZWJraXRNb3ZlbWVudFknXSB8fFxuICAgICAgICAgICAgICAgIDA7XG4gICAgICAgIH0sIGdldE1vdXNlV2hlZWxEZWx0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAwO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnRE9NTW91c2VTY3JvbGwnOlxuICAgICAgICAgICAgICAgICAgICAvLyAzIGxpbmVzIG1ha2UgdXAgYSBzdGVwXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQuZGV0YWlsIC8gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW91c2V3aGVlbCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEyMCB1bml0cyBtYWtlIHVwIGEgc3RlcFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBldmVudC5kZWx0YVlcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5kZWx0YU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET01fREVMVEFfUElYRUw6IDEwMCBwaXhlbHMgbWFrZSB1cCBhIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRE9NX0RFTFRBX0xJTkU6IDMgbGluZXMgbWFrZSB1cCBhIHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSAvPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERPTV9ERUxUQV9QQUdFOiBBIHBhZ2UgbWFrZXMgdXAgODAgc3RlcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSAqPSA4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VucmVjb2duaXplZCBtb3VzZSB3aGVlbCBkZWx0YSBtb2RlOiAnICsgZXZlbnQuZGVsdGFNb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bnJlY29nbml6ZWQgbW91c2Ugd2hlZWwgZXZlbnQ6ICcgKyBldmVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgICAgICB9LCBtb3VzZVg6IDAsIG1vdXNlWTogMCwgbW91c2VNb3ZlbWVudFg6IDAsIG1vdXNlTW92ZW1lbnRZOiAwLCB0b3VjaGVzOiB7fSwgbGFzdFRvdWNoZXM6IHt9LCBjYWxjdWxhdGVNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHsgLy8gZXZlbnQgc2hvdWxkIGJlIG1vdXNlbW92ZSwgbW91c2Vkb3duIG9yIG1vdXNldXBcbiAgICAgICAgICAgIGlmIChCcm93c2VyLnBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcG9pbnRlciBpcyBsb2NrZWQsIGNhbGN1bGF0ZSB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgbW92ZW1lbnQgb2YgdGhlIG1vdXNlLlxuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIEZpcmVmb3ggYnVnIDc2NDQ5OFxuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlICE9ICdtb3VzZW1vdmUnICYmXG4gICAgICAgICAgICAgICAgICAgICgnbW96TW92ZW1lbnRYJyBpbiBldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5tb3VzZU1vdmVtZW50WCA9IEJyb3dzZXIubW91c2VNb3ZlbWVudFkgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VNb3ZlbWVudFggPSBCcm93c2VyLmdldE1vdmVtZW50WChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VNb3ZlbWVudFkgPSBCcm93c2VyLmdldE1vdmVtZW50WShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgU0RMIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgU0RMICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5tb3VzZVggPSBTREwubW91c2VYICsgQnJvd3Nlci5tb3VzZU1vdmVtZW50WDtcbiAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5tb3VzZVkgPSBTREwubW91c2VZICsgQnJvd3Nlci5tb3VzZU1vdmVtZW50WTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGFkZCB0aGUgbW91c2UgZGVsdGEgdG8gdGhlIGN1cnJlbnQgYWJzb2x1dCBtb3VzZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogaWRlYWxseSB0aGlzIHNob3VsZCBiZSBjbGFtcGVkIGFnYWluc3QgdGhlIGNhbnZhcyBzaXplIGFuZCB6ZXJvXG4gICAgICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VYICs9IEJyb3dzZXIubW91c2VNb3ZlbWVudFg7XG4gICAgICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VZICs9IEJyb3dzZXIubW91c2VNb3ZlbWVudFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNhbGN1bGF0ZSB0aGUgbW92ZW1lbnQgYmFzZWQgb24gdGhlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBNb2R1bGVbXCJjYW52YXNcIl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGN3ID0gTW9kdWxlW1wiY2FudmFzXCJdLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IE1vZHVsZVtcImNhbnZhc1wiXS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBOZWl0aGVyIC5zY3JvbGxYIG9yIC5wYWdlWE9mZnNldCBhcmUgZGVmaW5lZCBpbiBhIHNwZWMsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIHdlIHByZWZlciAuc2Nyb2xsWCBiZWNhdXNlIGl0IGlzIGN1cnJlbnRseSBpbiBhIHNwZWMgZHJhZnQuXG4gICAgICAgICAgICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1jc3NvbS12aWV3LTIwMTMxMjE3LylcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWCA9ICgodHlwZW9mIHdpbmRvdy5zY3JvbGxYICE9ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5zY3JvbGxYIDogd2luZG93LnBhZ2VYT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9ICgodHlwZW9mIHdpbmRvdy5zY3JvbGxZICE9ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGFzc2VydCBsYW5kcywgaXQncyBsaWtlbHkgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgc2Nyb2xsWCBvciBwYWdlWE9mZnNldFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBoYXZlIG5vIHZpYWJsZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgICBhc3NlcnQoKHR5cGVvZiBzY3JvbGxYICE9ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIHNjcm9sbFkgIT0gJ3VuZGVmaW5lZCcpLCAnVW5hYmxlIHRvIHJldHJpZXZlIHNjcm9sbCBwb3NpdGlvbiwgbW91c2UgcG9zaXRpb25zIGxpa2VseSBicm9rZW4uJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRoZSBcInRvdWNoXCIgcHJvcGVydHkgaXMgb25seSBkZWZpbmVkIGluIFNETFxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkWCA9IHRvdWNoLnBhZ2VYIC0gKHNjcm9sbFggKyByZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRZID0gdG91Y2gucGFnZVkgLSAoc2Nyb2xsWSArIHJlY3QudG9wKTtcblxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZFggPSBhZGp1c3RlZFggKiAoY3cgLyByZWN0LndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRZID0gYWRqdXN0ZWRZICogKGNoIC8gcmVjdC5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSB7IHg6IGFkanVzdGVkWCwgeTogYWRqdXN0ZWRZIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci5sYXN0VG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXSA9IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyb3dzZXIudG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXSA9IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IEJyb3dzZXIudG91Y2hlc1t0b3VjaC5pZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGFzdCkgbGFzdCA9IGNvb3JkcztcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyb3dzZXIubGFzdFRvdWNoZXNbdG91Y2guaWRlbnRpZmllcl0gPSBsYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3Nlci50b3VjaGVzW3RvdWNoLmlkZW50aWZpZXJdID0gY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IGV2ZW50LnBhZ2VYIC0gKHNjcm9sbFggKyByZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZXZlbnQucGFnZVkgLSAoc2Nyb2xsWSArIHJlY3QudG9wKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYW52YXMgbWlnaHQgYmUgQ1NTLXNjYWxlZCBjb21wYXJlZCB0byBpdHMgYmFja2J1ZmZlcjtcbiAgICAgICAgICAgICAgICAvLyBTREwtdXNpbmcgY29udGVudCB3aWxsIHdhbnQgbW91c2UgY29vcmRpbmF0ZXMgaW4gdGVybXNcbiAgICAgICAgICAgICAgICAvLyBvZiBiYWNrYnVmZmVyIHVuaXRzLlxuICAgICAgICAgICAgICAgIHggPSB4ICogKGN3IC8gcmVjdC53aWR0aCk7XG4gICAgICAgICAgICAgICAgeSA9IHkgKiAoY2ggLyByZWN0LmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBCcm93c2VyLm1vdXNlTW92ZW1lbnRYID0geCAtIEJyb3dzZXIubW91c2VYO1xuICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VNb3ZlbWVudFkgPSB5IC0gQnJvd3Nlci5tb3VzZVk7XG4gICAgICAgICAgICAgICAgQnJvd3Nlci5tb3VzZVggPSB4O1xuICAgICAgICAgICAgICAgIEJyb3dzZXIubW91c2VZID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVzaXplTGlzdGVuZXJzOiBbXSwgdXBkYXRlUmVzaXplTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gTW9kdWxlWydjYW52YXMnXTtcbiAgICAgICAgICAgIEJyb3dzZXIucmVzaXplTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzZXRDYW52YXNTaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgbm9VcGRhdGVzKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gTW9kdWxlWydjYW52YXMnXTtcbiAgICAgICAgICAgIEJyb3dzZXIudXBkYXRlQ2FudmFzRGltZW5zaW9ucyhjYW52YXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKCFub1VwZGF0ZXMpIEJyb3dzZXIudXBkYXRlUmVzaXplTGlzdGVuZXJzKCk7XG4gICAgICAgIH0sIHdpbmRvd2VkV2lkdGg6IDAsIHdpbmRvd2VkSGVpZ2h0OiAwLCBzZXRGdWxsc2NyZWVuQ2FudmFzU2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgU0RMIGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTREwgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhciBmbGFncyA9IEhFQVBVMzJbKChTREwuc2NyZWVuKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBmbGFncyB8IDB4MDA4MDAwMDA7IC8vIHNldCBTRExfRlVMTFNDUkVFTiBmbGFnXG4gICAgICAgICAgICAgICAgSEVBUDMyWygoU0RMLnNjcmVlbikgPj4gMildID0gZmxhZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCcm93c2VyLnVwZGF0ZUNhbnZhc0RpbWVuc2lvbnMoTW9kdWxlWydjYW52YXMnXSk7XG4gICAgICAgICAgICBCcm93c2VyLnVwZGF0ZVJlc2l6ZUxpc3RlbmVycygpO1xuICAgICAgICB9LCBzZXRXaW5kb3dlZENhbnZhc1NpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIFNETCBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgU0RMICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSBIRUFQVTMyWygoU0RMLnNjcmVlbikgPj4gMildO1xuICAgICAgICAgICAgICAgIGZsYWdzID0gZmxhZ3MgJiB+MHgwMDgwMDAwMDsgLy8gY2xlYXIgU0RMX0ZVTExTQ1JFRU4gZmxhZ1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKFNETC5zY3JlZW4pID4+IDIpXSA9IGZsYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQnJvd3Nlci51cGRhdGVDYW52YXNEaW1lbnNpb25zKE1vZHVsZVsnY2FudmFzJ10pO1xuICAgICAgICAgICAgQnJvd3Nlci51cGRhdGVSZXNpemVMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSwgdXBkYXRlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24gKGNhbnZhcywgd05hdGl2ZSwgaE5hdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHdOYXRpdmUgJiYgaE5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aE5hdGl2ZSA9IHdOYXRpdmU7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodE5hdGl2ZSA9IGhOYXRpdmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdOYXRpdmUgPSBjYW52YXMud2lkdGhOYXRpdmU7XG4gICAgICAgICAgICAgICAgaE5hdGl2ZSA9IGNhbnZhcy5oZWlnaHROYXRpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdyA9IHdOYXRpdmU7XG4gICAgICAgICAgICB2YXIgaCA9IGhOYXRpdmU7XG4gICAgICAgICAgICBpZiAoTW9kdWxlWydmb3JjZWRBc3BlY3RSYXRpbyddICYmIE1vZHVsZVsnZm9yY2VkQXNwZWN0UmF0aW8nXSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodyAvIGggPCBNb2R1bGVbJ2ZvcmNlZEFzcGVjdFJhdGlvJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IE1hdGgucm91bmQoaCAqIE1vZHVsZVsnZm9yY2VkQXNwZWN0UmF0aW8nXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IE1hdGgucm91bmQodyAvIE1vZHVsZVsnZm9yY2VkQXNwZWN0UmF0aW8nXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgoZG9jdW1lbnRbJ2Z1bGxzY3JlZW5FbGVtZW50J10gfHwgZG9jdW1lbnRbJ21vekZ1bGxTY3JlZW5FbGVtZW50J10gfHxcbiAgICAgICAgICAgICAgICBkb2N1bWVudFsnbXNGdWxsc2NyZWVuRWxlbWVudCddIHx8IGRvY3VtZW50Wyd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCddIHx8XG4gICAgICAgICAgICAgICAgZG9jdW1lbnRbJ3dlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCddKSA9PT0gY2FudmFzLnBhcmVudE5vZGUpICYmICh0eXBlb2Ygc2NyZWVuICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLm1pbihzY3JlZW4ud2lkdGggLyB3LCBzY3JlZW4uaGVpZ2h0IC8gaCk7XG4gICAgICAgICAgICAgICAgdyA9IE1hdGgucm91bmQodyAqIGZhY3Rvcik7XG4gICAgICAgICAgICAgICAgaCA9IE1hdGgucm91bmQoaCAqIGZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQnJvd3Nlci5yZXNpemVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9IHcpIGNhbnZhcy53aWR0aCA9IHc7XG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5oZWlnaHQgIT0gaCkgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW52YXMuc3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwid2lkdGhcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImhlaWdodFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjYW52YXMud2lkdGggIT0gd05hdGl2ZSkgY2FudmFzLndpZHRoID0gd05hdGl2ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLmhlaWdodCAhPSBoTmF0aXZlKSBjYW52YXMuaGVpZ2h0ID0gaE5hdGl2ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbnZhcy5zdHlsZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodyAhPSB3TmF0aXZlIHx8IGggIT0gaE5hdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KFwid2lkdGhcIiwgdyArIFwicHhcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgaCArIFwicHhcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ3aWR0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImhlaWdodFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIEVHTCA9IHtcbiAgICAgICAgZXJyb3JDb2RlOiAxMjI4OCwgZGVmYXVsdERpc3BsYXlJbml0aWFsaXplZDogZmFsc2UsIGN1cnJlbnRDb250ZXh0OiAwLCBjdXJyZW50UmVhZFN1cmZhY2U6IDAsIGN1cnJlbnREcmF3U3VyZmFjZTogMCwgY29udGV4dEF0dHJpYnV0ZXM6IHsgYWxwaGE6IGZhbHNlLCBkZXB0aDogZmFsc2UsIHN0ZW5jaWw6IGZhbHNlLCBhbnRpYWxpYXM6IGZhbHNlIH0sIHN0cmluZ0NhY2hlOiB7fSwgc2V0RXJyb3JDb2RlOiBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgRUdMLmVycm9yQ29kZSA9IGNvZGU7XG4gICAgICAgIH0sIGNob29zZUNvbmZpZzogZnVuY3Rpb24gKGRpc3BsYXksIGF0dHJpYkxpc3QsIGNvbmZpZywgY29uZmlnX3NpemUsIG51bUNvbmZpZ3MpIHtcbiAgICAgICAgICAgIGlmIChkaXNwbGF5ICE9IDYyMDAwIC8qIE1hZ2ljIElEIGZvciBFbXNjcmlwdGVuICdkZWZhdWx0IGRpc3BsYXknICovKSB7XG4gICAgICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDggLyogRUdMX0JBRF9ESVNQTEFZICovKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJpYkxpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGF0dHJpYkxpc3QgaWYgaXQgaXMgbm9uLW51bGxcbiAgICAgICAgICAgICAgICBmb3IgKDsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBIRUFQMzJbKChhdHRyaWJMaXN0KSA+PiAyKV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbSA9PSAweDMwMjEgLypFR0xfQUxQSEFfU0laRSovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxwaGFTaXplID0gSEVBUDMyWygoKGF0dHJpYkxpc3QpICsgKDQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBFR0wuY29udGV4dEF0dHJpYnV0ZXMuYWxwaGEgPSAoYWxwaGFTaXplID4gMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gPT0gMHgzMDI1IC8qRUdMX0RFUFRIX1NJWkUqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoU2l6ZSA9IEhFQVAzMlsoKChhdHRyaWJMaXN0KSArICg0KSkgPj4gMildO1xuICAgICAgICAgICAgICAgICAgICAgICAgRUdMLmNvbnRleHRBdHRyaWJ1dGVzLmRlcHRoID0gKGRlcHRoU2l6ZSA+IDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09IDB4MzAyNiAvKkVHTF9TVEVOQ0lMX1NJWkUqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZW5jaWxTaXplID0gSEVBUDMyWygoKGF0dHJpYkxpc3QpICsgKDQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBFR0wuY29udGV4dEF0dHJpYnV0ZXMuc3RlbmNpbCA9IChzdGVuY2lsU2l6ZSA+IDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09IDB4MzAzMSAvKkVHTF9TQU1QTEVTKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW1wbGVzID0gSEVBUDMyWygoKGF0dHJpYkxpc3QpICsgKDQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBFR0wuY29udGV4dEF0dHJpYnV0ZXMuYW50aWFsaWFzID0gKHNhbXBsZXMgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSA9PSAweDMwMzIgLypFR0xfU0FNUExFX0JVRkZFUlMqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBIRUFQMzJbKCgoYXR0cmliTGlzdCkgKyAoNCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVHTC5jb250ZXh0QXR0cmlidXRlcy5hbnRpYWxpYXMgPSAoc2FtcGxlcyA9PSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSA9PSAweDMxMDAgLypFR0xfQ09OVEVYVF9QUklPUklUWV9MRVZFTF9JTUcqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFByaW9yaXR5ID0gSEVBUDMyWygoKGF0dHJpYkxpc3QpICsgKDQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBFR0wuY29udGV4dEF0dHJpYnV0ZXMubG93TGF0ZW5jeSA9IChyZXF1ZXN0ZWRQcmlvcml0eSAhPSAweDMxMDMgLypFR0xfQ09OVEVYVF9QUklPUklUWV9MT1dfSU1HKi8pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09IDB4MzAzOCAvKkVHTF9OT05FKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYkxpc3QgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoIWNvbmZpZyB8fCAhY29uZmlnX3NpemUpICYmICFudW1Db25maWdzKSB7XG4gICAgICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMEMgLyogRUdMX0JBRF9QQVJBTUVURVIgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bUNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICBIRUFQMzJbKChudW1Db25maWdzKSA+PiAyKV0gPSAxOyAvLyBUb3RhbCBudW1iZXIgb2Ygc3VwcG9ydGVkIGNvbmZpZ3M6IDEuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZ19zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKGNvbmZpZykgPj4gMildID0gNjIwMDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZWdsQmluZEFQSShhcGkpIHtcbiAgICAgICAgaWYgKGFwaSA9PSAweDMwQTAgLyogRUdMX09QRU5HTF9FU19BUEkgKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgeyAvLyBpZiAoYXBpID09IDB4MzBBMSAvKiBFR0xfT1BFTlZHX0FQSSAqLyB8fCBhcGkgPT0gMHgzMEEyIC8qIEVHTF9PUEVOR0xfQVBJICovKSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwQyAvKiBFR0xfQkFEX1BBUkFNRVRFUiAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZWdsQmluZEFQSS5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2VnbENob29zZUNvbmZpZyhkaXNwbGF5LCBhdHRyaWJfbGlzdCwgY29uZmlncywgY29uZmlnX3NpemUsIG51bUNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIEVHTC5jaG9vc2VDb25maWcoZGlzcGxheSwgYXR0cmliX2xpc3QsIGNvbmZpZ3MsIGNvbmZpZ19zaXplLCBudW1Db25maWdzKTtcbiAgICB9XG4gICAgX2VnbENob29zZUNvbmZpZy5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9fd2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXMoY3R4KSB7XG4gICAgICAgIC8vIEV4dGVuc2lvbiBhdmFpbGFibGUgaW4gV2ViR0wgMSBmcm9tIEZpcmVmb3ggMjYgYW5kIEdvb2dsZSBDaHJvbWUgMzAgb253YXJkcy4gQ29yZSBmZWF0dXJlIGluIFdlYkdMIDIuXG4gICAgICAgIHZhciBleHQgPSBjdHguZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgIGN0eFsndmVydGV4QXR0cmliRGl2aXNvciddID0gZnVuY3Rpb24gKGluZGV4LCBkaXZpc29yKSB7IGV4dFsndmVydGV4QXR0cmliRGl2aXNvckFOR0xFJ10oaW5kZXgsIGRpdmlzb3IpOyB9O1xuICAgICAgICAgICAgY3R4WydkcmF3QXJyYXlzSW5zdGFuY2VkJ10gPSBmdW5jdGlvbiAobW9kZSwgZmlyc3QsIGNvdW50LCBwcmltY291bnQpIHsgZXh0WydkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUnXShtb2RlLCBmaXJzdCwgY291bnQsIHByaW1jb3VudCk7IH07XG4gICAgICAgICAgICBjdHhbJ2RyYXdFbGVtZW50c0luc3RhbmNlZCddID0gZnVuY3Rpb24gKG1vZGUsIGNvdW50LCB0eXBlLCBpbmRpY2VzLCBwcmltY291bnQpIHsgZXh0WydkcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSddKG1vZGUsIGNvdW50LCB0eXBlLCBpbmRpY2VzLCBwcmltY291bnQpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX3dlYmdsX2VuYWJsZV9PRVNfdmVydGV4X2FycmF5X29iamVjdChjdHgpIHtcbiAgICAgICAgLy8gRXh0ZW5zaW9uIGF2YWlsYWJsZSBpbiBXZWJHTCAxIGZyb20gRmlyZWZveCAyNSBhbmQgV2ViS2l0IDUzNi4yOC9kZXNrdG9wIFNhZmFyaSA2LjAuMyBvbndhcmRzLiBDb3JlIGZlYXR1cmUgaW4gV2ViR0wgMi5cbiAgICAgICAgdmFyIGV4dCA9IGN0eC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgIGN0eFsnY3JlYXRlVmVydGV4QXJyYXknXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4dFsnY3JlYXRlVmVydGV4QXJyYXlPRVMnXSgpOyB9O1xuICAgICAgICAgICAgY3R4WydkZWxldGVWZXJ0ZXhBcnJheSddID0gZnVuY3Rpb24gKHZhbykgeyBleHRbJ2RlbGV0ZVZlcnRleEFycmF5T0VTJ10odmFvKTsgfTtcbiAgICAgICAgICAgIGN0eFsnYmluZFZlcnRleEFycmF5J10gPSBmdW5jdGlvbiAodmFvKSB7IGV4dFsnYmluZFZlcnRleEFycmF5T0VTJ10odmFvKTsgfTtcbiAgICAgICAgICAgIGN0eFsnaXNWZXJ0ZXhBcnJheSddID0gZnVuY3Rpb24gKHZhbykgeyByZXR1cm4gZXh0Wydpc1ZlcnRleEFycmF5T0VTJ10odmFvKTsgfTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX193ZWJnbF9lbmFibGVfV0VCR0xfZHJhd19idWZmZXJzKGN0eCkge1xuICAgICAgICAvLyBFeHRlbnNpb24gYXZhaWxhYmxlIGluIFdlYkdMIDEgZnJvbSBGaXJlZm94IDI4IG9ud2FyZHMuIENvcmUgZmVhdHVyZSBpbiBXZWJHTCAyLlxuICAgICAgICB2YXIgZXh0ID0gY3R4LmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XG4gICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgIGN0eFsnZHJhd0J1ZmZlcnMnXSA9IGZ1bmN0aW9uIChuLCBidWZzKSB7IGV4dFsnZHJhd0J1ZmZlcnNXRUJHTCddKG4sIGJ1ZnMpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX3dlYmdsX2VuYWJsZV9XRUJHTF9tdWx0aV9kcmF3KGN0eCkge1xuICAgICAgICAvLyBDbG9zdXJlIGlzIGV4cGVjdGVkIHRvIGJlIGFsbG93ZWQgdG8gbWluaWZ5IHRoZSAnLm11bHRpRHJhd1dlYmdsJyBwcm9wZXJ0eSwgc28gbm90IGFjY2Vzc2luZyBpdCBxdW90ZWQuXG4gICAgICAgIHJldHVybiAhIShjdHgubXVsdGlEcmF3V2ViZ2wgPSBjdHguZ2V0RXh0ZW5zaW9uKCdXRUJHTF9tdWx0aV9kcmF3JykpO1xuICAgIH1cbiAgICB2YXIgR0wgPSB7XG4gICAgICAgIGNvdW50ZXI6IDEsIGJ1ZmZlcnM6IFtdLCBwcm9ncmFtczogW10sIGZyYW1lYnVmZmVyczogW10sIHJlbmRlcmJ1ZmZlcnM6IFtdLCB0ZXh0dXJlczogW10sIHNoYWRlcnM6IFtdLCB2YW9zOiBbXSwgY29udGV4dHM6IFtdLCBvZmZzY3JlZW5DYW52YXNlczoge30sIHF1ZXJpZXM6IFtdLCBzdHJpbmdDYWNoZToge30sIHVucGFja0FsaWdubWVudDogNCwgcmVjb3JkRXJyb3I6IGZ1bmN0aW9uIHJlY29yZEVycm9yKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgaWYgKCFHTC5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBHTC5sYXN0RXJyb3IgPSBlcnJvckNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGdldE5ld0lkOiBmdW5jdGlvbiAodGFibGUpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBHTC5jb3VudGVyKys7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGFibGUubGVuZ3RoOyBpIDwgcmV0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YWJsZVtpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LCBnZXRTb3VyY2U6IGZ1bmN0aW9uIChzaGFkZXIsIGNvdW50LCBzdHJpbmcsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxlbmd0aCA/IEhFQVAzMlsoKChsZW5ndGgpICsgKGkgKiA0KSkgPj4gMildIDogLTE7XG4gICAgICAgICAgICAgICAgc291cmNlICs9IFVURjhUb1N0cmluZyhIRUFQMzJbKCgoc3RyaW5nKSArIChpICogNCkpID4+IDIpXSwgbGVuIDwgMCA/IHVuZGVmaW5lZCA6IGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9LCBjcmVhdGVDb250ZXh0OiBmdW5jdGlvbiAoLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gY2FudmFzLCB3ZWJHTENvbnRleHRBdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgICAgIC8vIEJVRzogV29ya2Fyb3VuZCBTYWZhcmkgV2ViR0wgaXNzdWU6IEFmdGVyIHN1Y2Nlc3NmdWxseSBhY3F1aXJpbmcgV2ViR0wgY29udGV4dCBvbiBhIGNhbnZhcyxcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgLmdldENvbnRleHQoKSB3aWxsIGFsd2F5cyByZXR1cm4gdGhhdCBjb250ZXh0IGluZGVwZW5kZW50IG9mIHdoaWNoICd3ZWJnbCcgb3IgJ3dlYmdsMidcbiAgICAgICAgICAgIC8vIGNvbnRleHQgdmVyc2lvbiB3YXMgcGFzc2VkLiBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyMjc1OCBhbmRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9pc3N1ZXMvMTMyOTUuXG4gICAgICAgICAgICAvLyBUT0RPOiBPbmNlIHRoZSBidWcgaXMgZml4ZWQgYW5kIHNoaXBwZWQgaW4gU2FmYXJpLCBhZGp1c3QgdGhlIFNhZmFyaSB2ZXJzaW9uIGZpZWxkIGluIGFib3ZlIGNoZWNrLlxuICAgICAgICAgICAgaWYgKCFjYW52YXMuZ2V0Q29udGV4dFNhZmFyaVdlYkdMMkZpeGVkKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHRTYWZhcmlXZWJHTDJGaXhlZCA9IGNhbnZhcy5nZXRDb250ZXh0O1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24odGhpczpIVE1MQ2FudmFzRWxlbWVudCwgc3RyaW5nLCAoT2JqZWN0fG51bGwpPSk6IChPYmplY3R8bnVsbCl9ICovXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZml4ZWRHZXRDb250ZXh0KHZlciwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHRTYWZhcmlXZWJHTDJGaXhlZCh2ZXIsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodmVyID09ICd3ZWJnbCcpID09IChnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dCkpID8gZ2wgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCA9IGZpeGVkR2V0Q29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN0eCA9XG4gICAgICAgICAgICAgICAgKGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgd2ViR0xDb250ZXh0QXR0cmlidXRlcylcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD13ZWJnbFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghY3R4KSByZXR1cm4gMDtcblxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IEdMLnJlZ2lzdGVyQ29udGV4dChjdHgsIHdlYkdMQ29udGV4dEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9LCByZWdpc3RlckNvbnRleHQ6IGZ1bmN0aW9uIChjdHgsIHdlYkdMQ29udGV4dEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgcHRocmVhZHMgYSBjb250ZXh0IGlzIGp1c3QgYW4gaW50ZWdlciBJRFxuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IEdMLmdldE5ld0lkKEdMLmNvbnRleHRzKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogd2ViR0xDb250ZXh0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB3ZWJHTENvbnRleHRBdHRyaWJ1dGVzLm1ham9yVmVyc2lvbixcbiAgICAgICAgICAgICAgICBHTGN0eDogY3R4XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3JlYXRlZCBjb250ZXh0IG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgdGhlIGNvbnRleHQgZ2l2ZW4gYSBjYW52YXMgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyB0aGUgcGFyYW1ldGVycyBhZ2Fpbi5cbiAgICAgICAgICAgIGlmIChjdHguY2FudmFzKSBjdHguY2FudmFzLkdMY3R4T2JqZWN0ID0gY29udGV4dDtcbiAgICAgICAgICAgIEdMLmNvbnRleHRzW2hhbmRsZV0gPSBjb250ZXh0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3ZWJHTENvbnRleHRBdHRyaWJ1dGVzLmVuYWJsZUV4dGVuc2lvbnNCeURlZmF1bHQgPT0gJ3VuZGVmaW5lZCcgfHwgd2ViR0xDb250ZXh0QXR0cmlidXRlcy5lbmFibGVFeHRlbnNpb25zQnlEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgR0wuaW5pdEV4dGVuc2lvbnMoY29udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH0sIG1ha2VDb250ZXh0Q3VycmVudDogZnVuY3Rpb24gKGNvbnRleHRIYW5kbGUpIHtcblxuICAgICAgICAgICAgR0wuY3VycmVudENvbnRleHQgPSBHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXTsgLy8gQWN0aXZlIEVtc2NyaXB0ZW4gR0wgbGF5ZXIgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAgICBNb2R1bGUuY3R4ID0gR0xjdHggPSBHTC5jdXJyZW50Q29udGV4dCAmJiBHTC5jdXJyZW50Q29udGV4dC5HTGN0eDsgLy8gQWN0aXZlIFdlYkdMIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICAgICAgcmV0dXJuICEoY29udGV4dEhhbmRsZSAmJiAhR0xjdHgpO1xuICAgICAgICB9LCBnZXRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dEhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIEdMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdO1xuICAgICAgICB9LCBkZWxldGVDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dEhhbmRsZSkge1xuICAgICAgICAgICAgaWYgKEdMLmN1cnJlbnRDb250ZXh0ID09PSBHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXSkgR0wuY3VycmVudENvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBKU0V2ZW50cyA9PSAnb2JqZWN0JykgSlNFdmVudHMucmVtb3ZlQWxsSGFuZGxlcnNPblRhcmdldChHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXS5HTGN0eC5jYW52YXMpOyAvLyBSZWxlYXNlIGFsbCBKUyBldmVudCBoYW5kbGVycyBvbiB0aGUgRE9NIGVsZW1lbnQgdGhhdCB0aGUgR0wgY29udGV4dCBpcyBhc3NvY2lhdGVkIHdpdGggc2luY2UgdGhlIGNvbnRleHQgaXMgbm93IGRlbGV0ZWQuXG4gICAgICAgICAgICBpZiAoR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0gJiYgR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0uR0xjdHguY2FudmFzKSBHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXS5HTGN0eC5jYW52YXMuR0xjdHhPYmplY3QgPSB1bmRlZmluZWQ7IC8vIE1ha2Ugc3VyZSB0aGUgY2FudmFzIG9iamVjdCBubyBsb25nZXIgcmVmZXJzIHRvIHRoZSBjb250ZXh0IG9iamVjdCBzbyB0aGVyZSBhcmUgbm8gR0Mgc3VycHJpc2VzLlxuICAgICAgICAgICAgR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0gPSBudWxsO1xuICAgICAgICB9LCBpbml0RXh0ZW5zaW9uczogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGhvdXQgYSBzcGVjaWZpYyBjb250ZXh0IG9iamVjdCwgaW5pdCB0aGUgZXh0ZW5zaW9ucyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb250ZXh0LlxuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gR0wuY3VycmVudENvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LmluaXRFeHRlbnNpb25zRG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29udGV4dC5pbml0RXh0ZW5zaW9uc0RvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgR0xjdHggPSBjb250ZXh0LkdMY3R4O1xuXG4gICAgICAgICAgICAvLyBEZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgZmV3IGV4dGVuc2lvbnMgbWFudWFsbHksIHRoaXMgR0wgaW50ZXJvcCBsYXllciBpdHNlbGYgd2lsbCBuZWVkIHRvIGtub3cgaWYgdGhleSBleGlzdC5cblxuICAgICAgICAgICAgLy8gRXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IGF2YWlsYWJsZSBpbiBXZWJHTCAxICh0aGUgY2FsbHMgd2lsbCBiZSBuby1vcHMgaWYgY2FsbGVkIG9uIGEgV2ViR0wgMiBjb250ZXh0IGFjdGl2ZSlcbiAgICAgICAgICAgIF9fd2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXMoR0xjdHgpO1xuICAgICAgICAgICAgX193ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QoR0xjdHgpO1xuICAgICAgICAgICAgX193ZWJnbF9lbmFibGVfV0VCR0xfZHJhd19idWZmZXJzKEdMY3R4KTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIEdMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dCA9IEdMY3R4LmdldEV4dGVuc2lvbihcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX193ZWJnbF9lbmFibGVfV0VCR0xfbXVsdGlfZHJhdyhHTGN0eCk7XG5cbiAgICAgICAgICAgIC8vIC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgY2FuIHJldHVybiBudWxsIGlmIGNvbnRleHQgaXMgbG9zdCwgc28gY29lcmNlIHRvIGVtcHR5IGFycmF5LlxuICAgICAgICAgICAgdmFyIGV4dHMgPSBHTGN0eC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgfHwgW107XG4gICAgICAgICAgICBleHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFdFQkdMX2xvc2VfY29udGV4dCwgV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbyBhbmQgV0VCR0xfZGVidWdfc2hhZGVycyBhcmUgbm90IGVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICBpZiAoIWV4dC5pbmNsdWRlcygnbG9zZV9jb250ZXh0JykgJiYgIWV4dC5pbmNsdWRlcygnZGVidWcnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIC5nZXRFeHRlbnNpb24oKSB0byBlbmFibGUgdGhhdCBleHRlbnNpb24gcGVybWFuZW50bHkuXG4gICAgICAgICAgICAgICAgICAgIEdMY3R4LmdldEV4dGVuc2lvbihleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfZWdsQ3JlYXRlQ29udGV4dChkaXNwbGF5LCBjb25maWcsIGhtbSwgY29udGV4dEF0dHJpYnMpIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT0gNjIwMDAgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgZGlzcGxheScgKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA4IC8qIEVHTF9CQURfRElTUExBWSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVHTCAxLjQgc3BlYyBzYXlzIGRlZmF1bHQgRUdMX0NPTlRFWFRfQ0xJRU5UX1ZFUlNJT04gaXMgR0xFUzEsIGJ1dCB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgRW1zY3JpcHRlbi5cbiAgICAgICAgLy8gU28gdXNlciBtdXN0IHBhc3MgRUdMX0NPTlRFWFRfQ0xJRU5UX1ZFUlNJT04gPT0gMiB0byBpbml0aWFsaXplIEVHTC5cbiAgICAgICAgdmFyIGdsZXNDb250ZXh0VmVyc2lvbiA9IDE7XG4gICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBIRUFQMzJbKChjb250ZXh0QXR0cmlicykgPj4gMildO1xuICAgICAgICAgICAgaWYgKHBhcmFtID09IDB4MzA5OCAvKkVHTF9DT05URVhUX0NMSUVOVF9WRVJTSU9OKi8pIHtcbiAgICAgICAgICAgICAgICBnbGVzQ29udGV4dFZlcnNpb24gPSBIRUFQMzJbKCgoY29udGV4dEF0dHJpYnMpICsgKDQpKSA+PiAyKV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09IDB4MzAzOCAvKkVHTF9OT05FKi8pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogRUdMMS40IHNwZWNpZmllcyBvbmx5IEVHTF9DT05URVhUX0NMSUVOVF9WRVJTSU9OIGFzIHN1cHBvcnRlZCBhdHRyaWJ1dGUgKi9cbiAgICAgICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwNCAvKkVHTF9CQURfQVRUUklCVVRFKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dEF0dHJpYnMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xlc0NvbnRleHRWZXJzaW9uICE9IDIpIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA1IC8qIEVHTF9CQURfQ09ORklHICovKTtcbiAgICAgICAgICAgIHJldHVybiAwOyAvKiBFR0xfTk9fQ09OVEVYVCAqL1xuICAgICAgICB9XG5cbiAgICAgICAgRUdMLmNvbnRleHRBdHRyaWJ1dGVzLm1ham9yVmVyc2lvbiA9IGdsZXNDb250ZXh0VmVyc2lvbiAtIDE7IC8vIFdlYkdMIDEgaXMgR0xFUyAyLCBXZWJHTDIgaXMgR0xFUzNcbiAgICAgICAgRUdMLmNvbnRleHRBdHRyaWJ1dGVzLm1pbm9yVmVyc2lvbiA9IDA7XG5cbiAgICAgICAgRUdMLmNvbnRleHQgPSBHTC5jcmVhdGVDb250ZXh0KE1vZHVsZVsnY2FudmFzJ10sIEVHTC5jb250ZXh0QXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKEVHTC5jb250ZXh0ICE9IDApIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcblxuICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrcyBzbyB0aGF0IEdMIGVtdWxhdGlvbiB3b3Jrc1xuICAgICAgICAgICAgR0wubWFrZUNvbnRleHRDdXJyZW50KEVHTC5jb250ZXh0KTtcbiAgICAgICAgICAgIE1vZHVsZS51c2VXZWJHTCA9IHRydWU7XG4gICAgICAgICAgICBCcm93c2VyLm1vZHVsZUNvbnRleHRDcmVhdGVkQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7IGNhbGxiYWNrKCkgfSk7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gb25seSBjcmVhdGVzIGEgY29udGV4dCwgYnV0IGl0IHNoYWxsIG5vdCBtYWtlIGl0IGFjdGl2ZS5cbiAgICAgICAgICAgIEdMLm1ha2VDb250ZXh0Q3VycmVudChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiA2MjAwNDsgLy8gTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gRUdMQ29udGV4dFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDkgLyogRUdMX0JBRF9NQVRDSCAqLyk7IC8vIEJ5IHRoZSBFR0wgMS40IHNwZWMsIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBHTEVTMiAoV2ViR0wgaW4gdGhpcyBjYXNlKSwgdGhpcyBlcnJvciBjb2RlIGlzIHNldC5cbiAgICAgICAgICAgIHJldHVybiAwOyAvKiBFR0xfTk9fQ09OVEVYVCAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lZ2xDcmVhdGVDb250ZXh0LnNpZyA9ICdpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsQ3JlYXRlV2luZG93U3VyZmFjZShkaXNwbGF5LCBjb25maWcsIHdpbiwgYXR0cmliX2xpc3QpIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT0gNjIwMDAgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgZGlzcGxheScgKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA4IC8qIEVHTF9CQURfRElTUExBWSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnICE9IDYyMDAyIC8qIE1hZ2ljIElEIGZvciB0aGUgb25seSBFR0xDb25maWcgc3VwcG9ydGVkIGJ5IEVtc2NyaXB0ZW4gKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA1IC8qIEVHTF9CQURfQ09ORklHICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IEV4YW1pbmUgYXR0cmliX2xpc3QhIFBhcmFtZXRlcnMgdGhhdCBjYW4gYmUgcHJlc2VudCB0aGVyZSBhcmU6XG4gICAgICAgIC8vIC0gRUdMX1JFTkRFUl9CVUZGRVIgKG11c3QgYmUgRUdMX0JBQ0tfQlVGRkVSKVxuICAgICAgICAvLyAtIEVHTF9WR19DT0xPUlNQQUNFIChjYW4ndCBiZSBzZXQpXG4gICAgICAgIC8vIC0gRUdMX1ZHX0FMUEhBX0ZPUk1BVCAoY2FuJ3QgYmUgc2V0KVxuICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwMCAvKiBFR0xfU1VDQ0VTUyAqLyk7XG4gICAgICAgIHJldHVybiA2MjAwNjsgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgc3VyZmFjZScgKi9cbiAgICB9XG4gICAgX2VnbENyZWF0ZVdpbmRvd1N1cmZhY2Uuc2lnID0gJ2lpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lZ2xEZXN0cm95Q29udGV4dChkaXNwbGF5LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChkaXNwbGF5ICE9IDYyMDAwIC8qIE1hZ2ljIElEIGZvciBFbXNjcmlwdGVuICdkZWZhdWx0IGRpc3BsYXknICovKSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwOCAvKiBFR0xfQkFEX0RJU1BMQVkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgIT0gNjIwMDQgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gRUdMQ29udGV4dCAqLykge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDYgLyogRUdMX0JBRF9DT05URVhUICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgR0wuZGVsZXRlQ29udGV4dChFR0wuY29udGV4dCk7XG4gICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgaWYgKEVHTC5jdXJyZW50Q29udGV4dCA9PSBjb250ZXh0KSB7XG4gICAgICAgICAgICBFR0wuY3VycmVudENvbnRleHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxIC8qIEVHTF9UUlVFICovO1xuICAgIH1cbiAgICBfZWdsRGVzdHJveUNvbnRleHQuc2lnID0gJ2lpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsRGVzdHJveVN1cmZhY2UoZGlzcGxheSwgc3VyZmFjZSkge1xuICAgICAgICBpZiAoZGlzcGxheSAhPSA2MjAwMCAvKiBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiAnZGVmYXVsdCBkaXNwbGF5JyAqLykge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDggLyogRUdMX0JBRF9ESVNQTEFZICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXJmYWNlICE9IDYyMDA2IC8qIE1hZ2ljIElEIGZvciB0aGUgb25seSBFR0xTdXJmYWNlIHN1cHBvcnRlZCBieSBFbXNjcmlwdGVuICovKSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwRCAvKiBFR0xfQkFEX1NVUkZBQ0UgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEVHTC5jdXJyZW50UmVhZFN1cmZhY2UgPT0gc3VyZmFjZSkge1xuICAgICAgICAgICAgRUdMLmN1cnJlbnRSZWFkU3VyZmFjZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEVHTC5jdXJyZW50RHJhd1N1cmZhY2UgPT0gc3VyZmFjZSkge1xuICAgICAgICAgICAgRUdMLmN1cnJlbnREcmF3U3VyZmFjZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDAgLyogRUdMX1NVQ0NFU1MgKi8pO1xuICAgICAgICByZXR1cm4gMTsgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgc3VyZmFjZScgKi9cbiAgICB9XG4gICAgX2VnbERlc3Ryb3lTdXJmYWNlLnNpZyA9ICdpaWknO1xuXG4gICAgZnVuY3Rpb24gX2VnbEdldENvbmZpZ0F0dHJpYihkaXNwbGF5LCBjb25maWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT0gNjIwMDAgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgZGlzcGxheScgKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA4IC8qIEVHTF9CQURfRElTUExBWSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnICE9IDYyMDAyIC8qIE1hZ2ljIElEIGZvciB0aGUgb25seSBFR0xDb25maWcgc3VwcG9ydGVkIGJ5IEVtc2NyaXB0ZW4gKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA1IC8qIEVHTF9CQURfQ09ORklHICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDBDIC8qIEVHTF9CQURfUEFSQU1FVEVSICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGNhc2UgMHgzMDIwOiAvLyBFR0xfQlVGRkVSX1NJWkVcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gRUdMLmNvbnRleHRBdHRyaWJ1dGVzLmFscGhhID8gMzIgOiAyNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDIxOiAvLyBFR0xfQUxQSEFfU0laRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSBFR0wuY29udGV4dEF0dHJpYnV0ZXMuYWxwaGEgPyA4IDogMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDIyOiAvLyBFR0xfQkxVRV9TSVpFXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAyMzogLy8gRUdMX0dSRUVOX1NJWkVcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDI0OiAvLyBFR0xfUkVEX1NJWkVcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gODtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDI1OiAvLyBFR0xfREVQVEhfU0laRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSBFR0wuY29udGV4dEF0dHJpYnV0ZXMuZGVwdGggPyAyNCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAyNjogLy8gRUdMX1NURU5DSUxfU0laRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSBFR0wuY29udGV4dEF0dHJpYnV0ZXMuc3RlbmNpbCA/IDggOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMjc6IC8vIEVHTF9DT05GSUdfQ0FWRUFUXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHJldHVybiBoZXJlIG9uZSBvZiBFR0xfTk9ORSAoMHgzMDM4KSwgRUdMX1NMT1dfQ09ORklHICgweDMwNTApIG9yIEVHTF9OT05fQ09ORk9STUFOVF9DT05GSUcgKDB4MzA1MSkuXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDB4MzAzODtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDI4OiAvLyBFR0xfQ09ORklHX0lEXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDYyMDAyO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMjk6IC8vIEVHTF9MRVZFTFxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMkE6IC8vIEVHTF9NQVhfUEJVRkZFUl9IRUlHSFRcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gNDA5NjtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDJCOiAvLyBFR0xfTUFYX1BCVUZGRVJfUElYRUxTXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDE2Nzc3MjE2O1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMkM6IC8vIEVHTF9NQVhfUEJVRkZFUl9XSURUSFxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSA0MDk2O1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMkQ6IC8vIEVHTF9OQVRJVkVfUkVOREVSQUJMRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMkU6IC8vIEVHTF9OQVRJVkVfVklTVUFMX0lEXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAyRjogLy8gRUdMX05BVElWRV9WSVNVQUxfVFlQRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAweDMwMzg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAzMTogLy8gRUdMX1NBTVBMRVNcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gRUdMLmNvbnRleHRBdHRyaWJ1dGVzLmFudGlhbGlhcyA/IDQgOiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMzI6IC8vIEVHTF9TQU1QTEVfQlVGRkVSU1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSBFR0wuY29udGV4dEF0dHJpYnV0ZXMuYW50aWFsaWFzID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAzMzogLy8gRUdMX1NVUkZBQ0VfVFlQRVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAweDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBjYXNlIDB4MzAzNDogLy8gRUdMX1RSQU5TUEFSRU5UX1RZUEVcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHJldHVybnMgRUdMX1RSQU5TUEFSRU5UX1JHQiAoMHgzMDUyKSwgdHJhbnNwYXJlbmN5IGlzIHVzZWQgdGhyb3VnaCBjb2xvci1rZXlpbmcuIE5vIHN1Y2ggdGhpbmcgYXBwbGllcyB0byBFbXNjcmlwdGVuIGNhbnZhcy5cbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gMHgzMDM4O1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwMzU6IC8vIEVHTF9UUkFOU1BBUkVOVF9CTFVFX1ZBTFVFXG4gICAgICAgICAgICBjYXNlIDB4MzAzNjogLy8gRUdMX1RSQU5TUEFSRU5UX0dSRUVOX1ZBTFVFXG4gICAgICAgICAgICBjYXNlIDB4MzAzNzogLy8gRUdMX1RSQU5TUEFSRU5UX1JFRF9WQUxVRVxuICAgICAgICAgICAgICAgIC8vIFwiSWYgRUdMX1RSQU5TUEFSRU5UX1RZUEUgaXMgRUdMX05PTkUsIHRoZW4gdGhlIHZhbHVlcyBmb3IgRUdMX1RSQU5TUEFSRU5UX1JFRF9WQUxVRSwgRUdMX1RSQU5TUEFSRU5UX0dSRUVOX1ZBTFVFLCBhbmQgRUdMX1RSQU5TUEFSRU5UX0JMVUVfVkFMVUUgYXJlIHVuZGVmaW5lZC5cIlxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDM5OiAvLyBFR0xfQklORF9UT19URVhUVVJFX1JHQlxuICAgICAgICAgICAgY2FzZSAweDMwM0E6IC8vIEVHTF9CSU5EX1RPX1RFWFRVUkVfUkdCQVxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwM0I6IC8vIEVHTF9NSU5fU1dBUF9JTlRFUlZBTFxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwM0M6IC8vIEVHTF9NQVhfU1dBUF9JTlRFUlZBTFxuICAgICAgICAgICAgICAgIEhFQVAzMlsoKHZhbHVlKSA+PiAyKV0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwM0Q6IC8vIEVHTF9MVU1JTkFOQ0VfU0laRVxuICAgICAgICAgICAgY2FzZSAweDMwM0U6IC8vIEVHTF9BTFBIQV9NQVNLX1NJWkVcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDNGOiAvLyBFR0xfQ09MT1JfQlVGRkVSX1RZUEVcbiAgICAgICAgICAgICAgICAvLyBFR0wgaGFzIHR3byB0eXBlcyBvZiBidWZmZXJzOiBFR0xfUkdCX0JVRkZFUiBhbmQgRUdMX0xVTUlOQU5DRV9CVUZGRVIuXG4gICAgICAgICAgICAgICAgSEVBUDMyWygodmFsdWUpID4+IDIpXSA9IDB4MzA4RTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHgzMDQwOiAvLyBFR0xfUkVOREVSQUJMRV9UWVBFXG4gICAgICAgICAgICAgICAgLy8gQSBiaXQgY29tYmluYXRpb24gb2YgRUdMX09QRU5HTF9FU19CSVQsRUdMX09QRU5WR19CSVQsRUdMX09QRU5HTF9FUzJfQklUIGFuZCBFR0xfT1BFTkdMX0JJVC5cbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gMHg0O1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgY2FzZSAweDMwNDI6IC8vIEVHTF9DT05GT1JNQU5UXG4gICAgICAgICAgICAgICAgLy8gXCJFR0xfQ09ORk9STUFOVCBpcyBhIG1hc2sgaW5kaWNhdGluZyBpZiBhIGNsaWVudCBBUEkgY29udGV4dCBjcmVhdGVkIHdpdGggcmVzcGVjdCB0byB0aGUgY29ycmVzcG9uZGluZyBFR0xDb25maWcgd2lsbCBwYXNzIHRoZSByZXF1aXJlZCBjb25mb3JtYW5jZSB0ZXN0cyBmb3IgdGhhdCBBUEkuXCJcbiAgICAgICAgICAgICAgICBIRUFQMzJbKCh2YWx1ZSkgPj4gMildID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDQgLyogRUdMX0JBRF9BVFRSSUJVVEUgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lZ2xHZXRDb25maWdBdHRyaWIuc2lnID0gJ2lpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lZ2xHZXREaXNwbGF5KG5hdGl2ZURpc3BsYXlUeXBlKSB7XG4gICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgLy8gTm90ZTogQXMgYSAnY29uZm9ybWFudCcgaW1wbGVtZW50YXRpb24gb2YgRUdMLCB3ZSB3b3VsZCBwcmVmZXIgdG8gaW5pdCBoZXJlIG9ubHkgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gICAgICAgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIEVHTF9ERUZBVUxUX0RJU1BMQVkuIE90aGVyIGRpc3BsYXkgSURzIHdvdWxkIGJlIHByZWZlcnJlZCB0byBiZSB1bnN1cHBvcnRlZFxuICAgICAgICAvLyAgICAgICBhbmQgRUdMX05PX0RJU1BMQVkgcmV0dXJuZWQuIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGNvZGUgbGluZXMgdG8gZG8gdGhpcy5cbiAgICAgICAgLy8gSW5zdGVhZCwgYW4gYWx0ZXJuYXRpdmUgcm91dGUgaGFzIGJlZW4gcHJlZmVycmVkLCBuYW1lbHkgdGhhdCB0aGUgRW1zY3JpcHRlbiBFR0wgaW1wbGVtZW50YXRpb25cbiAgICAgICAgLy8gXCJlbXVsYXRlc1wiIFgxMSwgYW5kIGVnbEdldERpc3BsYXkgaXMgZXhwZWN0ZWQgdG8gYWNjZXB0L3JlY2VpdmUgYSBwb2ludGVyIHRvIGFuIFgxMSBEaXNwbGF5IG9iamVjdC5cbiAgICAgICAgLy8gVGhlcmVmb3JlLCBiZSBsYXggYW5kIGFsbG93IGFueXRoaW5nIHRvIGJlIHBhc3NlZCBpbiwgYW5kIHJldHVybiB0aGUgbWFnaWMgaGFuZGxlIHRvIG91ciBkZWZhdWx0IEVHTERpc3BsYXkgb2JqZWN0LlxuXG4gICAgICAgIC8vICAgIGlmIChuYXRpdmVEaXNwbGF5VHlwZSA9PSAwIC8qIEVHTF9ERUZBVUxUX0RJU1BMQVkgKi8pIHtcbiAgICAgICAgcmV0dXJuIDYyMDAwOyAvLyBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiAnZGVmYXVsdCBkaXNwbGF5J1xuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vICAgIGVsc2VcbiAgICAgICAgLy8gICAgICByZXR1cm4gMDsgLy8gRUdMX05PX0RJU1BMQVlcbiAgICB9XG4gICAgX2VnbEdldERpc3BsYXkuc2lnID0gJ2lpJztcblxuICAgIGZ1bmN0aW9uIF9lZ2xHZXRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIEVHTC5lcnJvckNvZGU7XG4gICAgfVxuICAgIF9lZ2xHZXRFcnJvci5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsSW5pdGlhbGl6ZShkaXNwbGF5LCBtYWpvclZlcnNpb24sIG1pbm9yVmVyc2lvbikge1xuICAgICAgICBpZiAoZGlzcGxheSA9PSA2MjAwMCAvKiBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiAnZGVmYXVsdCBkaXNwbGF5JyAqLykge1xuICAgICAgICAgICAgaWYgKG1ham9yVmVyc2lvbikge1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKG1ham9yVmVyc2lvbikgPj4gMildID0gMTsgLy8gQWR2ZXJ0aXNlIEVHTCBNYWpvciB2ZXJzaW9uOiAnMSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW5vclZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBIRUFQMzJbKChtaW5vclZlcnNpb24pID4+IDIpXSA9IDQ7IC8vIEFkdmVydGlzZSBFR0wgTWlub3IgdmVyc2lvbjogJzQnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBFR0wuZGVmYXVsdERpc3BsYXlJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwMCAvKiBFR0xfU1VDQ0VTUyAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA4IC8qIEVHTF9CQURfRElTUExBWSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZWdsSW5pdGlhbGl6ZS5zaWcgPSAnaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsTWFrZUN1cnJlbnQoZGlzcGxheSwgZHJhdywgcmVhZCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZGlzcGxheSAhPSA2MjAwMCAvKiBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiAnZGVmYXVsdCBkaXNwbGF5JyAqLykge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDggLyogRUdMX0JBRF9ESVNQTEFZICovKTtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIEVHTF9GQUxTRSAqLztcbiAgICAgICAgfVxuICAgICAgICAvL1xcdG9kbyBBbiBFR0xfTk9UX0lOSVRJQUxJWkVEIGVycm9yIGlzIGdlbmVyYXRlZCBpZiBFR0wgaXMgbm90IGluaXRpYWxpemVkIGZvciBkcHkuXG4gICAgICAgIGlmIChjb250ZXh0ICE9IDAgJiYgY29udGV4dCAhPSA2MjAwNCAvKiBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiBFR0xDb250ZXh0ICovKSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwNiAvKiBFR0xfQkFEX0NPTlRFWFQgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyZWFkICE9IDAgJiYgcmVhZCAhPSA2MjAwNikgfHwgKGRyYXcgIT0gMCAmJiBkcmF3ICE9IDYyMDA2IC8qIE1hZ2ljIElEIGZvciBFbXNjcmlwdGVuICdkZWZhdWx0IHN1cmZhY2UnICovKSkge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMEQgLyogRUdMX0JBRF9TVVJGQUNFICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgR0wubWFrZUNvbnRleHRDdXJyZW50KGNvbnRleHQgPyBFR0wuY29udGV4dCA6IG51bGwpO1xuXG4gICAgICAgIEVHTC5jdXJyZW50Q29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIEVHTC5jdXJyZW50RHJhd1N1cmZhY2UgPSBkcmF3O1xuICAgICAgICBFR0wuY3VycmVudFJlYWRTdXJmYWNlID0gcmVhZDtcbiAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDAgLyogRUdMX1NVQ0NFU1MgKi8pO1xuICAgICAgICByZXR1cm4gMSAvKiBFR0xfVFJVRSAqLztcbiAgICB9XG4gICAgX2VnbE1ha2VDdXJyZW50LnNpZyA9ICdpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsUXVlcnlTdHJpbmcoZGlzcGxheSwgbmFtZSkge1xuICAgICAgICBpZiAoZGlzcGxheSAhPSA2MjAwMCAvKiBNYWdpYyBJRCBmb3IgRW1zY3JpcHRlbiAnZGVmYXVsdCBkaXNwbGF5JyAqLykge1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDggLyogRUdMX0JBRF9ESVNQTEFZICovKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vXFx0b2RvIEFuIEVHTF9OT1RfSU5JVElBTElaRUQgZXJyb3IgaXMgZ2VuZXJhdGVkIGlmIEVHTCBpcyBub3QgaW5pdGlhbGl6ZWQgZm9yIGRweS5cbiAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDAgLyogRUdMX1NVQ0NFU1MgKi8pO1xuICAgICAgICBpZiAoRUdMLnN0cmluZ0NhY2hlW25hbWVdKSByZXR1cm4gRUdMLnN0cmluZ0NhY2hlW25hbWVdO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgMHgzMDUzIC8qIEVHTF9WRU5ET1IgKi86IHJldCA9IGFsbG9jYXRlVVRGOChcIkVtc2NyaXB0ZW5cIik7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDMwNTQgLyogRUdMX1ZFUlNJT04gKi86IHJldCA9IGFsbG9jYXRlVVRGOChcIjEuNCBFbXNjcmlwdGVuIEVHTFwiKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4MzA1NSAvKiBFR0xfRVhURU5TSU9OUyAqLzogcmV0ID0gYWxsb2NhdGVVVEY4KFwiXCIpOyBicmVhazsgLy8gQ3VycmVudGx5IG5vdCBzdXBwb3J0aW5nIGFueSBFR0wgZXh0ZW5zaW9ucy5cbiAgICAgICAgICAgIGNhc2UgMHgzMDhEIC8qIEVHTF9DTElFTlRfQVBJUyAqLzogcmV0ID0gYWxsb2NhdGVVVEY4KFwiT3BlbkdMX0VTXCIpOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMEMgLyogRUdMX0JBRF9QQVJBTUVURVIgKi8pO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIEVHTC5zdHJpbmdDYWNoZVtuYW1lXSA9IHJldDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgX2VnbFF1ZXJ5U3RyaW5nLnNpZyA9ICdpaWknO1xuXG4gICAgZnVuY3Rpb24gX2VnbFN3YXBCdWZmZXJzKCkge1xuXG4gICAgICAgIGlmICghRUdMLmRlZmF1bHREaXNwbGF5SW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAxIC8qIEVHTF9OT1RfSU5JVElBTElaRUQgKi8pO1xuICAgICAgICB9IGVsc2UgaWYgKCFNb2R1bGUuY3R4KSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwMiAvKiBFR0xfQkFEX0FDQ0VTUyAqLyk7XG4gICAgICAgIH0gZWxzZSBpZiAoTW9kdWxlLmN0eC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDBFIC8qIEVHTF9DT05URVhUX0xPU1QgKi8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24gdGhpcyBkb2VzIGFuIGltcGxpY2l0IGZsdXNoLlxuICAgICAgICAgICAgLy8gRHVlIHRvIGRpc2N1c3Npb24gYXQgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3B1bGwvMTg3MVxuICAgICAgICAgICAgLy8gdGhlIGZsdXNoIHdhcyByZW1vdmVkIHNpbmNlIHRoaXMgX21heV8gcmVzdWx0IGluIHNsb3dpbmcgY29kZSBkb3duLlxuICAgICAgICAgICAgLy9fZ2xGbHVzaCgpO1xuICAgICAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDAgLyogRUdMX1NVQ0NFU1MgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogRUdMX1RSVUUgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogRUdMX0ZBTFNFICovO1xuICAgIH1cbiAgICBfZWdsU3dhcEJ1ZmZlcnMuc2lnID0gJ2lpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsU3dhcEludGVydmFsKGRpc3BsYXksIGludGVydmFsKSB7XG4gICAgICAgIGlmIChkaXNwbGF5ICE9IDYyMDAwIC8qIE1hZ2ljIElEIGZvciBFbXNjcmlwdGVuICdkZWZhdWx0IGRpc3BsYXknICovKSB7XG4gICAgICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwOCAvKiBFR0xfQkFEX0RJU1BMQVkgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVydmFsID09IDApIF9lbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nKDAvKkVNX1RJTUlOR19TRVRUSU1FT1VUKi8sIDApO1xuICAgICAgICBlbHNlIF9lbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nKDEvKkVNX1RJTUlOR19SQUYqLywgaW50ZXJ2YWwpO1xuXG4gICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIF9lZ2xTd2FwSW50ZXJ2YWwuc2lnID0gJ2lpaSc7XG5cbiAgICBmdW5jdGlvbiBfZWdsVGVybWluYXRlKGRpc3BsYXkpIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT0gNjIwMDAgLyogTWFnaWMgSUQgZm9yIEVtc2NyaXB0ZW4gJ2RlZmF1bHQgZGlzcGxheScgKi8pIHtcbiAgICAgICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDA4IC8qIEVHTF9CQURfRElTUExBWSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBFR0wuY3VycmVudENvbnRleHQgPSAwO1xuICAgICAgICBFR0wuY3VycmVudFJlYWRTdXJmYWNlID0gMDtcbiAgICAgICAgRUdMLmN1cnJlbnREcmF3U3VyZmFjZSA9IDA7XG4gICAgICAgIEVHTC5kZWZhdWx0RGlzcGxheUluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIEVHTC5zZXRFcnJvckNvZGUoMHgzMDAwIC8qIEVHTF9TVUNDRVNTICovKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIF9lZ2xUZXJtaW5hdGUuc2lnID0gJ2lpJztcblxuICAgIGZ1bmN0aW9uIF9lZ2xXYWl0Q2xpZW50KCkge1xuICAgICAgICBFR0wuc2V0RXJyb3JDb2RlKDB4MzAwMCAvKiBFR0xfU1VDQ0VTUyAqLyk7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBfZWdsV2FpdENsaWVudC5zaWcgPSAnaSc7XG4gICAgZnVuY3Rpb24gX2VnbFdhaXRHTChcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIF9lZ2xXYWl0Q2xpZW50KCk7XG4gICAgfVxuICAgIF9lZ2xXYWl0R0wuc2lnID0gJ2knO1xuXG4gICAgZnVuY3Rpb24gX2VnbFdhaXROYXRpdmUobmF0aXZlRW5naW5lSWQpIHtcbiAgICAgICAgRUdMLnNldEVycm9yQ29kZSgweDMwMDAgLyogRUdMX1NVQ0NFU1MgKi8pO1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgX2VnbFdhaXROYXRpdmUuc2lnID0gJ2lpJztcblxuICAgIHZhciByZWFkQXNtQ29uc3RBcmdzQXJyYXkgPSBbXTtcbiAgICBmdW5jdGlvbiByZWFkQXNtQ29uc3RBcmdzKHNpZ1B0ciwgYnVmKSB7XG4gICAgICAgIDtcbiAgICAgICAgLy8gTm9ib2R5IHNob3VsZCBoYXZlIG11dGF0ZWQgX3JlYWRBc21Db25zdEFyZ3NBcnJheSB1bmRlcm5lYXRoIHVzIHRvIGJlIHNvbWV0aGluZyBlbHNlIHRoYW4gYW4gYXJyYXkuXG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHJlYWRBc21Db25zdEFyZ3NBcnJheSkpO1xuICAgICAgICAvLyBUaGUgaW5wdXQgYnVmZmVyIGlzIGFsbG9jYXRlZCBvbiB0aGUgc3RhY2ssIHNvIGl0IG11c3QgYmUgc3RhY2stYWxpZ25lZC5cbiAgICAgICAgYXNzZXJ0KGJ1ZiAlIDE2ID09IDApO1xuICAgICAgICByZWFkQXNtQ29uc3RBcmdzQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIGNoO1xuICAgICAgICAvLyBNb3N0IGFyZ3VtZW50cyBhcmUgaTMycywgc28gc2hpZnQgdGhlIGJ1ZmZlciBwb2ludGVyIHNvIGl0IGlzIGEgcGxhaW5cbiAgICAgICAgLy8gaW5kZXggaW50byBIRUFQMzIuXG4gICAgICAgIGJ1ZiA+Pj0gMjtcbiAgICAgICAgd2hpbGUgKGNoID0gSEVBUFU4W3NpZ1B0cisrXSkge1xuICAgICAgICAgICAgYXNzZXJ0KGNoID09PSAxMDAvKidkJyovIHx8IGNoID09PSAxMDIvKidmJyovIHx8IGNoID09PSAxMDUgLyonaScqLywgJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBjaCArICcoXCInICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaCkgKyAnXCIpIGluIHJlYWRBc21Db25zdEFyZ3MhIFVzZSBvbmx5IFwiZFwiLCBcImZcIiBvciBcImlcIiwgYW5kIGRvIG5vdCBzcGVjaWZ5IFwidlwiIGZvciB2b2lkIHJldHVybiBhcmd1bWVudC4nKTtcbiAgICAgICAgICAgIC8vIEEgZG91YmxlIHRha2VzIHR3byAzMi1iaXQgc2xvdHMsIGFuZCBtdXN0IGFsc28gYmUgYWxpZ25lZCAtIHRoZSBiYWNrZW5kXG4gICAgICAgICAgICAvLyB3aWxsIGVtaXQgcGFkZGluZyB0byBhdm9pZCB0aGF0LlxuICAgICAgICAgICAgdmFyIHJlYWRBc21Db25zdEFyZ3NEb3VibGUgPSBjaCA8IDEwNTtcbiAgICAgICAgICAgIGlmIChyZWFkQXNtQ29uc3RBcmdzRG91YmxlICYmIChidWYgJiAxKSkgYnVmKys7XG4gICAgICAgICAgICByZWFkQXNtQ29uc3RBcmdzQXJyYXkucHVzaChyZWFkQXNtQ29uc3RBcmdzRG91YmxlID8gSEVBUEY2NFtidWYrKyA+PiAxXSA6IEhFQVAzMltidWZdKTtcbiAgICAgICAgICAgICsrYnVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkQXNtQ29uc3RBcmdzQXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2FzbV9jb25zdF9pbnQoY29kZSwgc2lnUHRyLCBhcmdidWYpIHtcbiAgICAgICAgY29kZSAtPSAxMDI0O1xuICAgICAgICB2YXIgYXJncyA9IHJlYWRBc21Db25zdEFyZ3Moc2lnUHRyLCBhcmdidWYpO1xuICAgICAgICBpZiAoIUFTTV9DT05TVFMuaGFzT3duUHJvcGVydHkoY29kZSkpIGFib3J0KCdObyBFTV9BU00gY29uc3RhbnQgZm91bmQgYXQgYWRkcmVzcyAnICsgY29kZSk7XG4gICAgICAgIHJldHVybiBBU01fQ09OU1RTW2NvZGVdLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9hc21fY29uc3RfaW50LnNpZyA9ICdpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3Ioc3RyKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc3RyID09ICdudW1iZXInKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihVVEY4VG9TdHJpbmcoc3RyKSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3Iuc2lnID0gJ3ZpJztcblxuICAgIHZhciBKU0V2ZW50cyA9IHtcbiAgICAgICAgaW5FdmVudEhhbmRsZXI6IDAsIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gSlNFdmVudHMuZXZlbnRIYW5kbGVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIEpTRXZlbnRzLl9yZW1vdmVIYW5kbGVyKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSlNFdmVudHMuZXZlbnRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgSlNFdmVudHMuZGVmZXJyZWRDYWxscyA9IFtdO1xuICAgICAgICB9LCByZWdpc3RlclJlbW92ZUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIUpTRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIF9fQVRFWElUX18ucHVzaChKU0V2ZW50cy5yZW1vdmVBbGxFdmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgSlNFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcnNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZGVmZXJyZWRDYWxsczogW10sIGRlZmVyQ2FsbDogZnVuY3Rpb24gKHRhcmdldEZ1bmN0aW9uLCBwcmVjZWRlbmNlLCBhcmdzTGlzdCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gYXJyYXlzSGF2ZUVxdWFsQ29udGVudChhcnJBLCBhcnJCKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyckEubGVuZ3RoICE9IGFyckIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGFyckEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyckFbaV0gIT0gYXJyQltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIGdpdmVuIGNhbGwgd2FzIGFscmVhZHkgcXVldWVkLCBhbmQgaWYgc28sIGRvbid0IGFkZCBpdCBhZ2Fpbi5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gSlNFdmVudHMuZGVmZXJyZWRDYWxscykge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsID0gSlNFdmVudHMuZGVmZXJyZWRDYWxsc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbC50YXJnZXRGdW5jdGlvbiA9PSB0YXJnZXRGdW5jdGlvbiAmJiBhcnJheXNIYXZlRXF1YWxDb250ZW50KGNhbGwuYXJnc0xpc3QsIGFyZ3NMaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSlNFdmVudHMuZGVmZXJyZWRDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YXJnZXRGdW5jdGlvbjogdGFyZ2V0RnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogcHJlY2VkZW5jZSxcbiAgICAgICAgICAgICAgICBhcmdzTGlzdDogYXJnc0xpc3RcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBKU0V2ZW50cy5kZWZlcnJlZENhbGxzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHgucHJlY2VkZW5jZSA8IHkucHJlY2VkZW5jZTsgfSk7XG4gICAgICAgIH0sIHJlbW92ZURlZmVycmVkQ2FsbHM6IGZ1bmN0aW9uICh0YXJnZXRGdW5jdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKU0V2ZW50cy5kZWZlcnJlZENhbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEpTRXZlbnRzLmRlZmVycmVkQ2FsbHNbaV0udGFyZ2V0RnVuY3Rpb24gPT0gdGFyZ2V0RnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgSlNFdmVudHMuZGVmZXJyZWRDYWxscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNhblBlcmZvcm1FdmVudEhhbmRsZXJSZXF1ZXN0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTRXZlbnRzLmluRXZlbnRIYW5kbGVyICYmIEpTRXZlbnRzLmN1cnJlbnRFdmVudEhhbmRsZXIuYWxsb3dzRGVmZXJyZWRDYWxscztcbiAgICAgICAgfSwgcnVuRGVmZXJyZWRDYWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFKU0V2ZW50cy5jYW5QZXJmb3JtRXZlbnRIYW5kbGVyUmVxdWVzdHMoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSlNFdmVudHMuZGVmZXJyZWRDYWxscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsID0gSlNFdmVudHMuZGVmZXJyZWRDYWxsc1tpXTtcbiAgICAgICAgICAgICAgICBKU0V2ZW50cy5kZWZlcnJlZENhbGxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgY2FsbC50YXJnZXRGdW5jdGlvbi5hcHBseShudWxsLCBjYWxsLmFyZ3NMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXZlbnRIYW5kbGVyczogW10sIHJlbW92ZUFsbEhhbmRsZXJzT25UYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZVN0cmluZykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKU0V2ZW50cy5ldmVudEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKEpTRXZlbnRzLmV2ZW50SGFuZGxlcnNbaV0udGFyZ2V0ID09IHRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAoIWV2ZW50VHlwZVN0cmluZyB8fCBldmVudFR5cGVTdHJpbmcgPT0gSlNFdmVudHMuZXZlbnRIYW5kbGVyc1tpXS5ldmVudFR5cGVTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIEpTRXZlbnRzLl9yZW1vdmVIYW5kbGVyKGktLSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBfcmVtb3ZlSGFuZGxlcjogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBoID0gSlNFdmVudHMuZXZlbnRIYW5kbGVyc1tpXTtcbiAgICAgICAgICAgIGgudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaC5ldmVudFR5cGVTdHJpbmcsIGguZXZlbnRMaXN0ZW5lckZ1bmMsIGgudXNlQ2FwdHVyZSk7XG4gICAgICAgICAgICBKU0V2ZW50cy5ldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSwgcmVnaXN0ZXJPclJlbW92ZUhhbmRsZXI6IGZ1bmN0aW9uIChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBqc0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIGpzRXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IG5lc3RpbmcgY291bnQgZm9yIHRoZSBldmVudCBoYW5kbGVyLlxuICAgICAgICAgICAgICAgICsrSlNFdmVudHMuaW5FdmVudEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgSlNFdmVudHMuY3VycmVudEV2ZW50SGFuZGxlciA9IGV2ZW50SGFuZGxlcjtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFueSBvbGQgZGVmZXJyZWQgY2FsbHMgdGhlIHVzZXIgaGFzIHBsYWNlZC5cbiAgICAgICAgICAgICAgICBKU0V2ZW50cy5ydW5EZWZlcnJlZENhbGxzKCk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgYWN0dWFsIGV2ZW50LCBjYWxscyBiYWNrIHRvIHVzZXIgQyBjb2RlIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmhhbmRsZXJGdW5jKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFueSBuZXcgZGVmZXJyZWQgY2FsbHMgdGhhdCB3ZXJlIHBsYWNlZCByaWdodCBub3cgZnJvbSB0aGlzIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgSlNFdmVudHMucnVuRGVmZXJyZWRDYWxscygpO1xuICAgICAgICAgICAgICAgIC8vIE91dCBvZiBldmVudCBoYW5kbGVyIC0gcmVzdG9yZSBuZXN0aW5nIGNvdW50LlxuICAgICAgICAgICAgICAgIC0tSlNFdmVudHMuaW5FdmVudEhhbmRsZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyLmNhbGxiYWNrZnVuYykge1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci5ldmVudExpc3RlbmVyRnVuYyA9IGpzRXZlbnRIYW5kbGVyO1xuICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudEhhbmRsZXIuZXZlbnRUeXBlU3RyaW5nLCBqc0V2ZW50SGFuZGxlciwgZXZlbnRIYW5kbGVyLnVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIEpTRXZlbnRzLmV2ZW50SGFuZGxlcnMucHVzaChldmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIEpTRXZlbnRzLnJlZ2lzdGVyUmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBKU0V2ZW50cy5ldmVudEhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChKU0V2ZW50cy5ldmVudEhhbmRsZXJzW2ldLnRhcmdldCA9PSBldmVudEhhbmRsZXIudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBKU0V2ZW50cy5ldmVudEhhbmRsZXJzW2ldLmV2ZW50VHlwZVN0cmluZyA9PSBldmVudEhhbmRsZXIuZXZlbnRUeXBlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBKU0V2ZW50cy5fcmVtb3ZlSGFuZGxlcihpLS0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBnZXROb2RlTmFtZUZvclRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybiAnJztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gd2luZG93KSByZXR1cm4gJyN3aW5kb3cnO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PSBzY3JlZW4pIHJldHVybiAnI3NjcmVlbic7XG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUpID8gdGFyZ2V0Lm5vZGVOYW1lIDogJyc7XG4gICAgICAgIH0sIGZ1bGxzY3JlZW5FbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgMTMuMC4zIG9uIG1hY09TIENhdGFsaW5hIDEwLjE1LjEgc3RpbGwgc2hpcHMgd2l0aCBwcmVmaXhlZCB3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZC5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJZiBTYWZhcmkgYXQgc29tZSBwb2ludCBzaGlwcyB3aXRoIHVucHJlZml4ZWQgdmVyc2lvbiwgdXBkYXRlIHRoZSB2ZXJzaW9uIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbmFibGVkXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjdXJyZW50RnVsbHNjcmVlblN0cmF0ZWd5ID0ge307XG5cbiAgICBmdW5jdGlvbiBtYXliZUNTdHJpbmdUb0pzU3RyaW5nKGNTdHJpbmcpIHtcbiAgICAgICAgLy8gXCJjU3RyaW5nID4gMlwiIGNoZWNrcyBpZiB0aGUgaW5wdXQgaXMgYSBudW1iZXIsIGFuZCBpc24ndCBvZiB0aGUgc3BlY2lhbFxuICAgICAgICAvLyB2YWx1ZXMgd2UgYWNjZXB0IGhlcmUsIEVNU0NSSVBURU5fRVZFTlRfVEFSR0VUXyogKHdoaWNoIG1hcCB0byAwLCAxLCAyKS5cbiAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIGlmIGNTdHJpbmcgPiAyIHRoZW4gaXQncyBhIHBvaW50ZXIgdG8gYSB2YWxpZCBwbGFjZSBpblxuICAgICAgICAvLyBtZW1vcnksIGFuZCBwb2ludHMgdG8gYSBDIHN0cmluZy5cbiAgICAgICAgcmV0dXJuIGNTdHJpbmcgPiAyID8gVVRGOFRvU3RyaW5nKGNTdHJpbmcpIDogY1N0cmluZztcbiAgICB9XG5cbiAgICB2YXIgc3BlY2lhbEhUTUxUYXJnZXRzID0gWzAsIHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogMCwgdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IDBdO1xuICAgIGZ1bmN0aW9uIGZpbmRFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gbWF5YmVDU3RyaW5nVG9Kc1N0cmluZyh0YXJnZXQpO1xuICAgICAgICB2YXIgZG9tRWxlbWVudCA9IHNwZWNpYWxIVE1MVGFyZ2V0c1t0YXJnZXRdIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCkgeyByZXR1cm4gZmluZEV2ZW50VGFyZ2V0KHRhcmdldCk7IH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSh0YXJnZXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGZpbmRDYW52YXNFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIWNhbnZhcykgcmV0dXJuIC00O1xuICAgICAgICBIRUFQMzJbKCh3aWR0aCkgPj4gMildID0gY2FudmFzLndpZHRoO1xuICAgICAgICBIRUFQMzJbKChoZWlnaHQpID4+IDIpXSA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENhbnZhc0VsZW1lbnRTaXplKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gd2l0aFN0YWNrU2F2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdyA9IHN0YWNrQWxsb2MoOCk7XG4gICAgICAgICAgICB2YXIgaCA9IHcgKyA0O1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0SW50ID0gc3RhY2tBbGxvYyh0YXJnZXQuaWQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBzdHJpbmdUb1VURjgodGFyZ2V0LmlkLCB0YXJnZXRJbnQsIHRhcmdldC5pZC5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBfZW1zY3JpcHRlbl9nZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSh0YXJnZXRJbnQsIHcsIGgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBbSEVBUDMyWygodykgPj4gMildLCBIRUFQMzJbKChoKSA+PiAyKV1dO1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplKHRhcmdldCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghY2FudmFzKSByZXR1cm4gLTQ7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X2NhbnZhc19lbGVtZW50X3NpemUuc2lnID0gJ2lpaWknO1xuICAgIGZ1bmN0aW9uIHNldENhbnZhc0VsZW1lbnRTaXplKHRhcmdldCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAoIXRhcmdldC5jb250cm9sVHJhbnNmZXJyZWRPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgIHRhcmdldC53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGFyZ2V0LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkIGZyb20gaGlnaC1sZXZlbCBKYXZhU2NyaXB0IGNvZGUgaW5zdGVhZCBvZiBhc20uanMvV2FzbSxcbiAgICAgICAgICAgIC8vIGFuZCBpdCBuZWVkcyB0byBzeW5jaHJvbm91c2x5IHByb3h5IG92ZXIgdG8gYW5vdGhlciB0aHJlYWQsIHNvIG1hcnNoYWwgdGhlIHN0cmluZyBvbnRvIHRoZSBoZWFwIHRvIGRvIHRoZSBjYWxsLlxuICAgICAgICAgICAgd2l0aFN0YWNrU2F2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEludCA9IHN0YWNrQWxsb2ModGFyZ2V0LmlkLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIHN0cmluZ1RvVVRGOCh0YXJnZXQuaWQsIHRhcmdldEludCwgdGFyZ2V0LmlkLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplKHRhcmdldEludCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlclJlc3RvcmVPbGRTdHlsZShjYW52YXMpIHtcbiAgICAgICAgdmFyIGNhbnZhc1NpemUgPSBnZXRDYW52YXNFbGVtZW50U2l6ZShjYW52YXMpO1xuICAgICAgICB2YXIgb2xkV2lkdGggPSBjYW52YXNTaXplWzBdO1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gY2FudmFzU2l6ZVsxXTtcbiAgICAgICAgdmFyIG9sZENzc1dpZHRoID0gY2FudmFzLnN0eWxlLndpZHRoO1xuICAgICAgICB2YXIgb2xkQ3NzSGVpZ2h0ID0gY2FudmFzLnN0eWxlLmhlaWdodDtcbiAgICAgICAgdmFyIG9sZEJhY2tncm91bmRDb2xvciA9IGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7IC8vIENocm9tZSByZWFkcyBjb2xvciBmcm9tIGhlcmUuXG4gICAgICAgIHZhciBvbGREb2N1bWVudEJhY2tncm91bmRDb2xvciA9IGRvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yOyAvLyBJRTExIHJlYWRzIGNvbG9yIGZyb20gaGVyZS5cbiAgICAgICAgLy8gRmlyZWZveCBhbHdheXMgaGFzIGJsYWNrIGJhY2tncm91bmQgY29sb3IuXG4gICAgICAgIHZhciBvbGRQYWRkaW5nTGVmdCA9IGNhbnZhcy5zdHlsZS5wYWRkaW5nTGVmdDsgLy8gQ2hyb21lLCBGRiwgU2FmYXJpXG4gICAgICAgIHZhciBvbGRQYWRkaW5nUmlnaHQgPSBjYW52YXMuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICB2YXIgb2xkUGFkZGluZ1RvcCA9IGNhbnZhcy5zdHlsZS5wYWRkaW5nVG9wO1xuICAgICAgICB2YXIgb2xkUGFkZGluZ0JvdHRvbSA9IGNhbnZhcy5zdHlsZS5wYWRkaW5nQm90dG9tO1xuICAgICAgICB2YXIgb2xkTWFyZ2luTGVmdCA9IGNhbnZhcy5zdHlsZS5tYXJnaW5MZWZ0OyAvLyBJRTExXG4gICAgICAgIHZhciBvbGRNYXJnaW5SaWdodCA9IGNhbnZhcy5zdHlsZS5tYXJnaW5SaWdodDtcbiAgICAgICAgdmFyIG9sZE1hcmdpblRvcCA9IGNhbnZhcy5zdHlsZS5tYXJnaW5Ub3A7XG4gICAgICAgIHZhciBvbGRNYXJnaW5Cb3R0b20gPSBjYW52YXMuc3R5bGUubWFyZ2luQm90dG9tO1xuICAgICAgICB2YXIgb2xkRG9jdW1lbnRCb2R5TWFyZ2luID0gZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW47XG4gICAgICAgIHZhciBvbGREb2N1bWVudE92ZXJmbG93ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93OyAvLyBDaHJvbWUsIEZpcmVmb3hcbiAgICAgICAgdmFyIG9sZERvY3VtZW50U2Nyb2xsID0gZG9jdW1lbnQuYm9keS5zY3JvbGw7IC8vIElFXG4gICAgICAgIHZhciBvbGRJbWFnZVJlbmRlcmluZyA9IGNhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZztcblxuICAgICAgICBmdW5jdGlvbiByZXN0b3JlT2xkU3R5bGUoKSB7XG4gICAgICAgICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudFxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50XG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudFxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICghZnVsbHNjcmVlbkVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzdG9yZU9sZFN0eWxlKTtcblxuICAgICAgICAgICAgICAgIC8vIFVucHJlZml4ZWQgRnVsbHNjcmVlbiBBUEkgc2hpcHBlZCBpbiBDaHJvbWl1bSA3MSAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzgzODEzKVxuICAgICAgICAgICAgICAgIC8vIEFzIG9mIFNhZmFyaSAxMy4wLjMgb24gbWFjT1MgQ2F0YWxpbmEgMTAuMTUuMSBzdGlsbCBzaGlwcyB3aXRoIHByZWZpeGVkIHdlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UuIFRPRE86IHJldmlzaXQgdGhpcyBjaGVjayBvbmNlIFNhZmFyaSBzaGlwcyB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIHJlc3RvcmVPbGRTdHlsZSk7XG5cbiAgICAgICAgICAgICAgICBzZXRDYW52YXNFbGVtZW50U2l6ZShjYW52YXMsIG9sZFdpZHRoLCBvbGRIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gb2xkQ3NzV2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9sZENzc0hlaWdodDtcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb2xkQmFja2dyb3VuZENvbG9yOyAvLyBDaHJvbWVcbiAgICAgICAgICAgICAgICAvLyBJRTExIGhhY2s6IGFzc2lnbmluZyAndW5kZWZpbmVkJyBvciBhbiBlbXB0eSBzdHJpbmcgdG8gZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgaGFzIG5vIGVmZmVjdCwgc28gZmlyc3QgYXNzaWduIGJhY2sgdGhlIGRlZmF1bHQgY29sb3JcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgc2V0dGluZyB0aGUgdW5kZWZpbmVkIHZhbHVlLiBTZXR0aW5nIHVuZGVmaW5lZCB2YWx1ZSBpcyBhbHNvIGltcG9ydGFudCwgb3Igb3RoZXJ3aXNlIHdlIHdvdWxkIGxhdGVyIHRyZWF0IHRoYXQgYXMgc29tZXRoaW5nIHRoYXQgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAvLyBoYWQgZXhwbGljaXRseSBzZXQgc28gc3Vic2VxdWVudCBmdWxsc2NyZWVuIHRyYW5zaXRpb25zIHdvdWxkIG5vdCBzZXQgYmFja2dyb3VuZCBjb2xvciBwcm9wZXJseS5cbiAgICAgICAgICAgICAgICBpZiAoIW9sZERvY3VtZW50QmFja2dyb3VuZENvbG9yKSBkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvbGREb2N1bWVudEJhY2tncm91bmRDb2xvcjsgLy8gSUUxMVxuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wYWRkaW5nTGVmdCA9IG9sZFBhZGRpbmdMZWZ0OyAvLyBDaHJvbWUsIEZGLCBTYWZhcmlcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUucGFkZGluZ1JpZ2h0ID0gb2xkUGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wYWRkaW5nVG9wID0gb2xkUGFkZGluZ1RvcDtcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUucGFkZGluZ0JvdHRvbSA9IG9sZFBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLm1hcmdpbkxlZnQgPSBvbGRNYXJnaW5MZWZ0OyAvLyBJRTExXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLm1hcmdpblJpZ2h0ID0gb2xkTWFyZ2luUmlnaHQ7XG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLm1hcmdpblRvcCA9IG9sZE1hcmdpblRvcDtcbiAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUubWFyZ2luQm90dG9tID0gb2xkTWFyZ2luQm90dG9tO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gb2xkRG9jdW1lbnRCb2R5TWFyZ2luO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IG9sZERvY3VtZW50T3ZlcmZsb3c7IC8vIENocm9tZSwgRmlyZWZveFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsID0gb2xkRG9jdW1lbnRTY3JvbGw7IC8vIElFXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmltYWdlUmVuZGVyaW5nID0gb2xkSW1hZ2VSZW5kZXJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5HTGN0eE9iamVjdCkgY2FudmFzLkdMY3R4T2JqZWN0LkdMY3R4LnZpZXdwb3J0KDAsIDAsIG9sZFdpZHRoLCBvbGRIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3kuY2FudmFzUmVzaXplZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFdhc21UYWJsZUVudHJ5KGN1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3kuY2FudmFzUmVzaXplZENhbGxiYWNrKSgzNywgMCwgY3VycmVudEZ1bGxzY3JlZW5TdHJhdGVneS5jYW52YXNSZXNpemVkQ2FsbGJhY2tVc2VyRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCByZXN0b3JlT2xkU3R5bGUpO1xuICAgICAgICAvLyBVbnByZWZpeGVkIEZ1bGxzY3JlZW4gQVBJIHNoaXBwZWQgaW4gQ2hyb21pdW0gNzEgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM4MzgxMylcbiAgICAgICAgLy8gQXMgb2YgU2FmYXJpIDEzLjAuMyBvbiBtYWNPUyBDYXRhbGluYSAxMC4xNS4xIHN0aWxsIHNoaXBzIHdpdGggcHJlZml4ZWQgd2Via2l0ZnVsbHNjcmVlbmNoYW5nZS4gVE9ETzogcmV2aXNpdCB0aGlzIGNoZWNrIG9uY2UgU2FmYXJpIHNoaXBzIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIHJlc3RvcmVPbGRTdHlsZSk7XG4gICAgICAgIHJldHVybiByZXN0b3JlT2xkU3R5bGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TGV0dGVyYm94KGVsZW1lbnQsIHRvcEJvdHRvbSwgbGVmdFJpZ2h0KSB7XG4gICAgICAgIC8vIENhbm5vdCB1c2UgbWFyZ2luIHRvIHNwZWNpZnkgbGV0dGVyYm94ZXMgaW4gRkYgb3IgQ2hyb21lLCBzaW5jZSB0aG9zZSBpZ25vcmUgbWFyZ2lucyBpbiBmdWxsc2NyZWVuIG1vZGUuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGxlZnRSaWdodCArICdweCc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCA9IGVsZW1lbnQuc3R5bGUucGFkZGluZ0JvdHRvbSA9IHRvcEJvdHRvbSArICdweCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGUpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpYWxIVE1MVGFyZ2V0cy5pbmRleE9mKGUpIDwgMCA/IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7ICdsZWZ0JzogMCwgJ3RvcCc6IDAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX0pTRXZlbnRzX3Jlc2l6ZUNhbnZhc0ZvckZ1bGxzY3JlZW4odGFyZ2V0LCBzdHJhdGVneSkge1xuICAgICAgICB2YXIgcmVzdG9yZU9sZFN0eWxlID0gcmVnaXN0ZXJSZXN0b3JlT2xkU3R5bGUodGFyZ2V0KTtcbiAgICAgICAgdmFyIGNzc1dpZHRoID0gc3RyYXRlZ3kuc29mdEZ1bGxzY3JlZW4gPyBpbm5lcldpZHRoIDogc2NyZWVuLndpZHRoO1xuICAgICAgICB2YXIgY3NzSGVpZ2h0ID0gc3RyYXRlZ3kuc29mdEZ1bGxzY3JlZW4gPyBpbm5lckhlaWdodCA6IHNjcmVlbi5oZWlnaHQ7XG4gICAgICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciB3aW5kb3dlZENzc1dpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgICAgdmFyIHdpbmRvd2VkQ3NzSGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciBjYW52YXNTaXplID0gZ2V0Q2FudmFzRWxlbWVudFNpemUodGFyZ2V0KTtcbiAgICAgICAgdmFyIHdpbmRvd2VkUnR0V2lkdGggPSBjYW52YXNTaXplWzBdO1xuICAgICAgICB2YXIgd2luZG93ZWRSdHRIZWlnaHQgPSBjYW52YXNTaXplWzFdO1xuXG4gICAgICAgIGlmIChzdHJhdGVneS5zY2FsZU1vZGUgPT0gMykge1xuICAgICAgICAgICAgc2V0TGV0dGVyYm94KHRhcmdldCwgKGNzc0hlaWdodCAtIHdpbmRvd2VkQ3NzSGVpZ2h0KSAvIDIsIChjc3NXaWR0aCAtIHdpbmRvd2VkQ3NzV2lkdGgpIC8gMik7XG4gICAgICAgICAgICBjc3NXaWR0aCA9IHdpbmRvd2VkQ3NzV2lkdGg7XG4gICAgICAgICAgICBjc3NIZWlnaHQgPSB3aW5kb3dlZENzc0hlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJhdGVneS5zY2FsZU1vZGUgPT0gMikge1xuICAgICAgICAgICAgaWYgKGNzc1dpZHRoICogd2luZG93ZWRSdHRIZWlnaHQgPCB3aW5kb3dlZFJ0dFdpZHRoICogY3NzSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRDc3NIZWlnaHQgPSB3aW5kb3dlZFJ0dEhlaWdodCAqIGNzc1dpZHRoIC8gd2luZG93ZWRSdHRXaWR0aDtcbiAgICAgICAgICAgICAgICBzZXRMZXR0ZXJib3godGFyZ2V0LCAoY3NzSGVpZ2h0IC0gZGVzaXJlZENzc0hlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgICAgICAgICBjc3NIZWlnaHQgPSBkZXNpcmVkQ3NzSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzaXJlZENzc1dpZHRoID0gd2luZG93ZWRSdHRXaWR0aCAqIGNzc0hlaWdodCAvIHdpbmRvd2VkUnR0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNldExldHRlcmJveCh0YXJnZXQsIDAsIChjc3NXaWR0aCAtIGRlc2lyZWRDc3NXaWR0aCkgLyAyKTtcbiAgICAgICAgICAgICAgICBjc3NXaWR0aCA9IGRlc2lyZWRDc3NXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGFyZSBhZGRpbmcgcGFkZGluZywgbXVzdCBjaG9vc2UgYSBiYWNrZ3JvdW5kIGNvbG9yIG9yIG90aGVyd2lzZSBDaHJvbWUgd2lsbCBnaXZlIHRoZVxuICAgICAgICAvLyBwYWRkaW5nIGEgZGVmYXVsdCB3aGl0ZSBjb2xvci4gRG8gaXQgb25seSBpZiB1c2VyIGhhcyBub3QgY3VzdG9taXplZCB0aGVpciBvd24gYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgaWYgKCF0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yKSB0YXJnZXQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgLy8gSUUxMSBkb2VzIHRoZSBzYW1lLCBidXQgcmVxdWlyZXMgdGhlIGNvbG9yIHRvIGJlIHNldCBpbiB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmRDb2xvcikgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnYmxhY2snOyAvLyBJRTExXG4gICAgICAgIC8vIEZpcmVmb3ggYWx3YXlzIHNob3dzIGJsYWNrIGxldHRlcmJveGVzIGluZGVwZW5kZW50IG9mIHN0eWxlIGNvbG9yLlxuXG4gICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IGNzc1dpZHRoICsgJ3B4JztcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGNzc0hlaWdodCArICdweCc7XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5LmZpbHRlcmluZ01vZGUgPT0gMSkge1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJ29wdGltaXplU3BlZWQnO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJy1tb3otY3Jpc3AtZWRnZXMnO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJy1vLWNyaXNwLWVkZ2VzJztcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICctd2Via2l0LW9wdGltaXplLWNvbnRyYXN0JztcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdvcHRpbWl6ZS1jb250cmFzdCc7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAnY3Jpc3AtZWRnZXMnO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJ3BpeGVsYXRlZCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHBpU2NhbGUgPSAoc3RyYXRlZ3kuY2FudmFzUmVzb2x1dGlvblNjYWxlTW9kZSA9PSAyKSA/IGRldmljZVBpeGVsUmF0aW8gOiAxO1xuICAgICAgICBpZiAoc3RyYXRlZ3kuY2FudmFzUmVzb2x1dGlvblNjYWxlTW9kZSAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSAoY3NzV2lkdGggKiBkcGlTY2FsZSkgfCAwO1xuICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IChjc3NIZWlnaHQgKiBkcGlTY2FsZSkgfCAwO1xuICAgICAgICAgICAgc2V0Q2FudmFzRWxlbWVudFNpemUodGFyZ2V0LCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuR0xjdHhPYmplY3QpIHRhcmdldC5HTGN0eE9iamVjdC5HTGN0eC52aWV3cG9ydCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdG9yZU9sZFN0eWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfSlNFdmVudHNfcmVxdWVzdEZ1bGxzY3JlZW4odGFyZ2V0LCBzdHJhdGVneSkge1xuICAgICAgICAvLyBFTVNDUklQVEVOX0ZVTExTQ1JFRU5fU0NBTEVfREVGQVVMVCArIEVNU0NSSVBURU5fRlVMTFNDUkVFTl9DQU5WQVNfU0NBTEVfTk9ORSBpcyBhIG1vZGUgd2hlcmUgbm8gZXh0cmEgbG9naWMgaXMgcGVyZm9ybWVkIHRvIHRoZSBET00gZWxlbWVudHMuXG4gICAgICAgIGlmIChzdHJhdGVneS5zY2FsZU1vZGUgIT0gMCB8fCBzdHJhdGVneS5jYW52YXNSZXNvbHV0aW9uU2NhbGVNb2RlICE9IDApIHtcbiAgICAgICAgICAgIF9KU0V2ZW50c19yZXNpemVDYW52YXNGb3JGdWxsc2NyZWVuKHRhcmdldCwgc3RyYXRlZ3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGFyZ2V0LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0YXJnZXQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSlNFdmVudHMuZnVsbHNjcmVlbkVuYWJsZWQoKSA/IC0zIDogLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RnVsbHNjcmVlblN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5LmNhbnZhc1Jlc2l6ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoc3RyYXRlZ3kuY2FudmFzUmVzaXplZENhbGxiYWNrKSgzNywgMCwgc3RyYXRlZ3kuY2FudmFzUmVzaXplZENhbGxiYWNrVXNlckRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2V4aXRfZnVsbHNjcmVlbigpIHtcbiAgICAgICAgaWYgKCFKU0V2ZW50cy5mdWxsc2NyZWVuRW5hYmxlZCgpKSByZXR1cm4gLTE7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBubyBxdWV1ZWQgdXAgY2FsbHMgd2lsbCBmaXJlIGFmdGVyIHRoaXMuXG4gICAgICAgIEpTRXZlbnRzLnJlbW92ZURlZmVycmVkQ2FsbHMoX0pTRXZlbnRzX3JlcXVlc3RGdWxsc2NyZWVuKTtcblxuICAgICAgICB2YXIgZCA9IHNwZWNpYWxIVE1MVGFyZ2V0c1sxXTtcbiAgICAgICAgaWYgKGQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGQuZnVsbHNjcmVlbkVsZW1lbnQgJiYgZC5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9IGVsc2UgaWYgKGQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIGQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgJiYgZC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2V4aXRfZnVsbHNjcmVlbi5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0UG9pbnRlckxvY2sodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQucmVxdWVzdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lm1zUmVxdWVzdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICB0YXJnZXQubXNSZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvY3VtZW50LmJvZHkgaXMga25vd24gdG8gYWNjZXB0IHBvaW50ZXIgbG9jaywgc28gdXNlIHRoYXQgdG8gZGlmZmVyZW50aWF0ZSBpZiB0aGUgdXNlciBwYXNzZWQgYSBiYWQgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIG9yIGlmIHRoZSB3aG9sZSBicm93c2VyIGp1c3QgZG9lc24ndCBzdXBwb3J0IHRoZSBmZWF0dXJlLlxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkucmVxdWVzdFBvaW50ZXJMb2NrXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5tc1JlcXVlc3RQb2ludGVyTG9ja1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2V4aXRfcG9pbnRlcmxvY2soKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBubyBxdWV1ZWQgdXAgY2FsbHMgd2lsbCBmaXJlIGFmdGVyIHRoaXMuXG4gICAgICAgIEpTRXZlbnRzLnJlbW92ZURlZmVycmVkQ2FsbHMocmVxdWVzdFBvaW50ZXJMb2NrKTtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgZG9jdW1lbnQubXNFeGl0UG9pbnRlckxvY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZXhpdF9wb2ludGVybG9jay5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfZGV2aWNlX3BpeGVsX3JhdGlvKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBkZXZpY2VQaXhlbFJhdGlvID09ICdudW1iZXInICYmIGRldmljZVBpeGVsUmF0aW8pIHx8IDEuMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2V0X2RldmljZV9waXhlbF9yYXRpby5zaWcgPSAnZCc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfZWxlbWVudF9jc3Nfc2l6ZSh0YXJnZXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGFyZ2V0ID0gZmluZEV2ZW50VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm4gLTQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgICAgICAgSEVBUEY2NFsoKHdpZHRoKSA+PiAzKV0gPSByZWN0LndpZHRoO1xuICAgICAgICBIRUFQRjY0WygoaGVpZ2h0KSA+PiAzKV0gPSByZWN0LmhlaWdodDtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2V0X2VsZW1lbnRfY3NzX3NpemUuc2lnID0gJ2lpaWknO1xuXG4gICAgZnVuY3Rpb24gZmlsbEdhbWVwYWRFdmVudERhdGEoZXZlbnRTdHJ1Y3QsIGUpIHtcbiAgICAgICAgSEVBUEY2NFsoKGV2ZW50U3RydWN0KSA+PiAzKV0gPSBlLnRpbWVzdGFtcDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIEhFQVBGNjRbKCgoZXZlbnRTdHJ1Y3QgKyBpICogOCkgKyAoMTYpKSA+PiAzKV0gPSBlLmF4ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmJ1dHRvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS5idXR0b25zW2ldID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgSEVBUEY2NFsoKChldmVudFN0cnVjdCArIGkgKiA4KSArICg1MjgpKSA+PiAzKV0gPSBlLmJ1dHRvbnNbaV0udmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEhFQVBGNjRbKCgoZXZlbnRTdHJ1Y3QgKyBpICogOCkgKyAoNTI4KSkgPj4gMyldID0gZS5idXR0b25zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5idXR0b25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGUuYnV0dG9uc1tpXSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCArIGkgKiA0KSArICgxMDQwKSkgPj4gMildID0gZS5idXR0b25zW2ldLnByZXNzZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFzc2lnbmluZyBhIGJvb2xlYW4gdG8gSEVBUDMyLCB0aGF0J3Mgb2ssIGJ1dCBDbG9zdXJlIHdvdWxkIGxpa2UgdG8gd2FybiBhYm91dCBpdDpcbiAgICAgICAgICAgICAgICAvKiogQHN1cHByZXNzIHtjaGVja1R5cGVzfSAqL1xuICAgICAgICAgICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCArIGkgKiA0KSArICgxMDQwKSkgPj4gMildID0gZS5idXR0b25zW2ldID09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygoKGV2ZW50U3RydWN0KSArICgxMjk2KSkgPj4gMildID0gZS5jb25uZWN0ZWQ7XG4gICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCkgKyAoMTMwMCkpID4+IDIpXSA9IGUuaW5kZXg7XG4gICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCkgKyAoOCkpID4+IDIpXSA9IGUuYXhlcy5sZW5ndGg7XG4gICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCkgKyAoMTIpKSA+PiAyKV0gPSBlLmJ1dHRvbnMubGVuZ3RoO1xuICAgICAgICBzdHJpbmdUb1VURjgoZS5pZCwgZXZlbnRTdHJ1Y3QgKyAxMzA0LCA2NCk7XG4gICAgICAgIHN0cmluZ1RvVVRGOChlLm1hcHBpbmcsIGV2ZW50U3RydWN0ICsgMTM2OCwgNjQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfZ2FtZXBhZF9zdGF0dXMoaW5kZXgsIGdhbWVwYWRTdGF0ZSkge1xuICAgICAgICBpZiAoIUpTRXZlbnRzLmxhc3RHYW1lcGFkU3RhdGUpIHRocm93ICdlbXNjcmlwdGVuX2dldF9nYW1lcGFkX3N0YXR1cygpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBoYXZpbmcgZmlyc3QgY2FsbGVkIGVtc2NyaXB0ZW5fc2FtcGxlX2dhbWVwYWRfZGF0YSgpIGFuZCB0aGF0IGZ1bmN0aW9uIGhhcyByZXR1cm5lZCBFTVNDUklQVEVOX1JFU1VMVF9TVUNDRVNTISc7XG5cbiAgICAgICAgLy8gSU5WQUxJRF9QQVJBTSBpcyByZXR1cm5lZCBvbiBhIEdhbWVwYWQgaW5kZXggdGhhdCBuZXZlciB3YXMgdGhlcmUuXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gSlNFdmVudHMubGFzdEdhbWVwYWRTdGF0ZS5sZW5ndGgpIHJldHVybiAtNTtcblxuICAgICAgICAvLyBOT19EQVRBIGlzIHJldHVybmVkIG9uIGEgR2FtZXBhZCBpbmRleCB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAgICAvLyBGb3IgcHJldmlvdXNseSBkaXNjb25uZWN0ZWQgZ2FtZXBhZHMgdGhlcmUgc2hvdWxkIGJlIGFuIGVtcHR5IHNsb3QgKG51bGwvdW5kZWZpbmVkL2ZhbHNlKSBhdCB0aGUgaW5kZXguXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBnYW1lcGFkcyBtdXN0IGtlZXAgdGhlaXIgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIGFycmF5LlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgcmVtb3ZpbmcgdGhlIGZpcnN0IG9mIHR3byBnYW1lcGFkcyBwcm9kdWNlcyBbbnVsbC91bmRlZmluZWQvZmFsc2UsIGdhbWVwYWRdLlxuICAgICAgICBpZiAoIUpTRXZlbnRzLmxhc3RHYW1lcGFkU3RhdGVbaW5kZXhdKSByZXR1cm4gLTc7XG5cbiAgICAgICAgZmlsbEdhbWVwYWRFdmVudERhdGEoZ2FtZXBhZFN0YXRlLCBKU0V2ZW50cy5sYXN0R2FtZXBhZFN0YXRlW2luZGV4XSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nZXRfZ2FtZXBhZF9zdGF0dXMuc2lnID0gJ2lpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgoKSB7XG4gICAgICAgIHJldHVybiBIRUFQVTgubGVuZ3RoO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X251bV9nYW1lcGFkcygpIHtcbiAgICAgICAgaWYgKCFKU0V2ZW50cy5sYXN0R2FtZXBhZFN0YXRlKSB0aHJvdyAnZW1zY3JpcHRlbl9nZXRfbnVtX2dhbWVwYWRzKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGhhdmluZyBmaXJzdCBjYWxsZWQgZW1zY3JpcHRlbl9zYW1wbGVfZ2FtZXBhZF9kYXRhKCkgYW5kIHRoYXQgZnVuY3Rpb24gaGFzIHJldHVybmVkIEVNU0NSSVBURU5fUkVTVUxUX1NVQ0NFU1MhJztcbiAgICAgICAgLy8gTi5CLiBEbyBub3QgY2FsbCBlbXNjcmlwdGVuX2dldF9udW1fZ2FtZXBhZHMoKSB1bmxlc3MgaGF2aW5nIGZpcnN0IGNhbGxlZCBlbXNjcmlwdGVuX3NhbXBsZV9nYW1lcGFkX2RhdGEoKSwgYW5kIHRoYXQgaGFzIHJldHVybmVkIEVNU0NSSVBURU5fUkVTVUxUX1NVQ0NFU1MuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgZm9sbG93aW5nIGxpbmUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICAgIHJldHVybiBKU0V2ZW50cy5sYXN0R2FtZXBhZFN0YXRlLmxlbmd0aDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2V0X251bV9nYW1lcGFkcy5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfc2NyZWVuX3NpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBIRUFQMzJbKCh3aWR0aCkgPj4gMildID0gc2NyZWVuLndpZHRoO1xuICAgICAgICBIRUFQMzJbKChoZWlnaHQpID4+IDIpXSA9IHNjcmVlbi5oZWlnaHQ7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dldF9zY3JlZW5fc2l6ZS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQWN0aXZlVGV4dHVyZSh4MCkgeyBHTGN0eFsnYWN0aXZlVGV4dHVyZSddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xBY3RpdmVUZXh0dXJlLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEF0dGFjaFNoYWRlcihwcm9ncmFtLCBzaGFkZXIpIHtcbiAgICAgICAgR0xjdHguYXR0YWNoU2hhZGVyKEdMLnByb2dyYW1zW3Byb2dyYW1dLCBHTC5zaGFkZXJzW3NoYWRlcl0pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEF0dGFjaFNoYWRlci5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQmVnaW5RdWVyeUVYVCh0YXJnZXQsIGlkKSB7XG4gICAgICAgIEdMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dFsnYmVnaW5RdWVyeUVYVCddKHRhcmdldCwgR0wucXVlcmllc1tpZF0pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEJlZ2luUXVlcnlFWFQuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBpbmRleCwgbmFtZSkge1xuICAgICAgICBHTGN0eC5iaW5kQXR0cmliTG9jYXRpb24oR0wucHJvZ3JhbXNbcHJvZ3JhbV0sIGluZGV4LCBVVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEJpbmRBdHRyaWJMb2NhdGlvbi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJpbmRCdWZmZXIodGFyZ2V0LCBidWZmZXIpIHtcblxuICAgICAgICBHTGN0eC5iaW5kQnVmZmVyKHRhcmdldCwgR0wuYnVmZmVyc1tidWZmZXJdKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCaW5kQnVmZmVyLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xCaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlcikge1xuXG4gICAgICAgIEdMY3R4LmJpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIEdMLmZyYW1lYnVmZmVyc1tmcmFtZWJ1ZmZlcl0pO1xuXG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQmluZEZyYW1lYnVmZmVyLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xCaW5kUmVuZGVyYnVmZmVyKHRhcmdldCwgcmVuZGVyYnVmZmVyKSB7XG4gICAgICAgIEdMY3R4LmJpbmRSZW5kZXJidWZmZXIodGFyZ2V0LCBHTC5yZW5kZXJidWZmZXJzW3JlbmRlcmJ1ZmZlcl0pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEJpbmRSZW5kZXJidWZmZXIuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSkge1xuICAgICAgICBHTGN0eC5iaW5kVGV4dHVyZSh0YXJnZXQsIEdMLnRleHR1cmVzW3RleHR1cmVdKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCaW5kVGV4dHVyZS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQmluZFZlcnRleEFycmF5T0VTKHZhbykge1xuICAgICAgICBHTGN0eFsnYmluZFZlcnRleEFycmF5J10oR0wudmFvc1t2YW9dKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCaW5kVmVydGV4QXJyYXlPRVMuc2lnID0gJ3ZpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQmxlbmRDb2xvcih4MCwgeDEsIHgyLCB4MykgeyBHTGN0eFsnYmxlbmRDb2xvciddKHgwLCB4MSwgeDIsIHgzKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCbGVuZENvbG9yLnNpZyA9ICd2ZmZmZic7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJsZW5kRXF1YXRpb24oeDApIHsgR0xjdHhbJ2JsZW5kRXF1YXRpb24nXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsQmxlbmRFcXVhdGlvbi5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xCbGVuZEVxdWF0aW9uU2VwYXJhdGUoeDAsIHgxKSB7IEdMY3R4WydibGVuZEVxdWF0aW9uU2VwYXJhdGUnXSh4MCwgeDEpIH1cbiAgICBfZW1zY3JpcHRlbl9nbEJsZW5kRXF1YXRpb25TZXBhcmF0ZS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQmxlbmRGdW5jKHgwLCB4MSkgeyBHTGN0eFsnYmxlbmRGdW5jJ10oeDAsIHgxKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCbGVuZEZ1bmMuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJsZW5kRnVuY1NlcGFyYXRlKHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4WydibGVuZEZ1bmNTZXBhcmF0ZSddKHgwLCB4MSwgeDIsIHgzKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCbGVuZEZ1bmNTZXBhcmF0ZS5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xCdWZmZXJEYXRhKHRhcmdldCwgc2l6ZSwgZGF0YSwgdXNhZ2UpIHtcblxuICAgICAgICAvLyBOLmIuIGhlcmUgZmlyc3QgZm9ybSBzcGVjaWZpZXMgYSBoZWFwIHN1YmFycmF5LCBzZWNvbmQgZm9ybSBhbiBpbnRlZ2VyIHNpemUsIHNvIHRoZSA/OiBjb2RlIGhlcmUgaXMgcG9seW1vcnBoaWMuIEl0IGlzIGFkdmlzZWQgdG8gYXZvaWRcbiAgICAgICAgLy8gcmFuZG9tbHkgbWl4aW5nIGJvdGggdXNlcyBpbiBjYWxsaW5nIGNvZGUsIHRvIGF2b2lkIGFueSBwb3RlbnRpYWwgSlMgZW5naW5lIEpJVCBpc3N1ZXMuXG4gICAgICAgIEdMY3R4LmJ1ZmZlckRhdGEodGFyZ2V0LCBkYXRhID8gSEVBUFU4LnN1YmFycmF5KGRhdGEsIGRhdGEgKyBzaXplKSA6IHNpemUsIHVzYWdlKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xCdWZmZXJEYXRhLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEJ1ZmZlclN1YkRhdGEodGFyZ2V0LCBvZmZzZXQsIHNpemUsIGRhdGEpIHtcbiAgICAgICAgR0xjdHguYnVmZmVyU3ViRGF0YSh0YXJnZXQsIG9mZnNldCwgSEVBUFU4LnN1YmFycmF5KGRhdGEsIGRhdGEgKyBzaXplKSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQnVmZmVyU3ViRGF0YS5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xDaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHgwKSB7IHJldHVybiBHTGN0eFsnY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xDaGVja0ZyYW1lYnVmZmVyU3RhdHVzLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENsZWFyKHgwKSB7IEdMY3R4WydjbGVhciddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xDbGVhci5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xDbGVhckNvbG9yKHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4WydjbGVhckNvbG9yJ10oeDAsIHgxLCB4MiwgeDMpIH1cbiAgICBfZW1zY3JpcHRlbl9nbENsZWFyQ29sb3Iuc2lnID0gJ3ZmZmZmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQ2xlYXJEZXB0aGYoeDApIHsgR0xjdHhbJ2NsZWFyRGVwdGgnXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ2xlYXJEZXB0aGYuc2lnID0gJ3ZmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQ2xlYXJTdGVuY2lsKHgwKSB7IEdMY3R4WydjbGVhclN0ZW5jaWwnXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ2xlYXJTdGVuY2lsLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENvbG9yTWFzayhyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICBHTGN0eC5jb2xvck1hc2soISFyZWQsICEhZ3JlZW4sICEhYmx1ZSwgISFhbHBoYSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ29sb3JNYXNrLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENvbXBpbGVTaGFkZXIoc2hhZGVyKSB7XG4gICAgICAgIEdMY3R4LmNvbXBpbGVTaGFkZXIoR0wuc2hhZGVyc1tzaGFkZXJdKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xDb21waWxlU2hhZGVyLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENvbXByZXNzZWRUZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGltYWdlU2l6ZSwgZGF0YSkge1xuICAgICAgICBHTGN0eFsnY29tcHJlc3NlZFRleEltYWdlMkQnXSh0YXJnZXQsIGxldmVsLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgYm9yZGVyLCBkYXRhID8gSEVBUFU4LnN1YmFycmF5KChkYXRhKSwgKGRhdGEgKyBpbWFnZVNpemUpKSA6IG51bGwpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbENvbXByZXNzZWRUZXhJbWFnZTJELnNpZyA9ICd2aWlpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xDb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCh0YXJnZXQsIGxldmVsLCB4b2Zmc2V0LCB5b2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGltYWdlU2l6ZSwgZGF0YSkge1xuICAgICAgICBHTGN0eFsnY29tcHJlc3NlZFRleFN1YkltYWdlMkQnXSh0YXJnZXQsIGxldmVsLCB4b2Zmc2V0LCB5b2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIGRhdGEgPyBIRUFQVTguc3ViYXJyYXkoKGRhdGEpLCAoZGF0YSArIGltYWdlU2l6ZSkpIDogbnVsbCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ29tcHJlc3NlZFRleFN1YkltYWdlMkQuc2lnID0gJ3ZpaWlpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xDb3B5VGV4SW1hZ2UyRCh4MCwgeDEsIHgyLCB4MywgeDQsIHg1LCB4NiwgeDcpIHsgR0xjdHhbJ2NvcHlUZXhJbWFnZTJEJ10oeDAsIHgxLCB4MiwgeDMsIHg0LCB4NSwgeDYsIHg3KSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xDb3B5VGV4SW1hZ2UyRC5zaWcgPSAndmlpaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsQ29weVRleFN1YkltYWdlMkQoeDAsIHgxLCB4MiwgeDMsIHg0LCB4NSwgeDYsIHg3KSB7IEdMY3R4Wydjb3B5VGV4U3ViSW1hZ2UyRCddKHgwLCB4MSwgeDIsIHgzLCB4NCwgeDUsIHg2LCB4NykgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ29weVRleFN1YkltYWdlMkQuc2lnID0gJ3ZpaWlpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENyZWF0ZVByb2dyYW0oKSB7XG4gICAgICAgIHZhciBpZCA9IEdMLmdldE5ld0lkKEdMLnByb2dyYW1zKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBHTGN0eC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIC8vIFN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gbmVlZGVkIGZvciBlYWNoIHNoYWRlciBwcm9ncmFtOlxuICAgICAgICBwcm9ncmFtLm5hbWUgPSBpZDtcbiAgICAgICAgLy8gTGF6eSBjYWNoZSByZXN1bHRzIG9mIGdsR2V0UHJvZ3JhbWl2KEdMX0FDVElWRV9VTklGT1JNX01BWF9MRU5HVEgvR0xfQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIL0dMX0FDVElWRV9VTklGT1JNX0JMT0NLX01BWF9OQU1FX0xFTkdUSClcbiAgICAgICAgcHJvZ3JhbS5tYXhVbmlmb3JtTGVuZ3RoID0gcHJvZ3JhbS5tYXhBdHRyaWJ1dGVMZW5ndGggPSBwcm9ncmFtLm1heFVuaWZvcm1CbG9ja05hbWVMZW5ndGggPSAwO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1JZENvdW50ZXIgPSAxO1xuICAgICAgICBHTC5wcm9ncmFtc1tpZF0gPSBwcm9ncmFtO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ3JlYXRlUHJvZ3JhbS5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbENyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKSB7XG4gICAgICAgIHZhciBpZCA9IEdMLmdldE5ld0lkKEdMLnNoYWRlcnMpO1xuICAgICAgICBHTC5zaGFkZXJzW2lkXSA9IEdMY3R4LmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsQ3JlYXRlU2hhZGVyLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEN1bGxGYWNlKHgwKSB7IEdMY3R4WydjdWxsRmFjZSddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xDdWxsRmFjZS5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEZWxldGVCdWZmZXJzKG4sIGJ1ZmZlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IEhFQVAzMlsoKChidWZmZXJzKSArIChpICogNCkpID4+IDIpXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBHTC5idWZmZXJzW2lkXTtcblxuICAgICAgICAgICAgLy8gRnJvbSBzcGVjOiBcImdsRGVsZXRlQnVmZmVycyBzaWxlbnRseSBpZ25vcmVzIDAncyBhbmQgbmFtZXMgdGhhdCBkbyBub3RcbiAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gZXhpc3RpbmcgYnVmZmVyIG9iamVjdHMuXCJcbiAgICAgICAgICAgIGlmICghYnVmZmVyKSBjb250aW51ZTtcblxuICAgICAgICAgICAgR0xjdHguZGVsZXRlQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICBidWZmZXIubmFtZSA9IDA7XG4gICAgICAgICAgICBHTC5idWZmZXJzW2lkXSA9IG51bGw7XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbERlbGV0ZUJ1ZmZlcnMuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERlbGV0ZUZyYW1lYnVmZmVycyhuLCBmcmFtZWJ1ZmZlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IEhFQVAzMlsoKChmcmFtZWJ1ZmZlcnMpICsgKGkgKiA0KSkgPj4gMildO1xuICAgICAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gR0wuZnJhbWVidWZmZXJzW2lkXTtcbiAgICAgICAgICAgIGlmICghZnJhbWVidWZmZXIpIGNvbnRpbnVlOyAvLyBHTCBzcGVjOiBcImdsRGVsZXRlRnJhbWVidWZmZXJzIHNpbGVudGx5IGlnbm9yZXMgMHMgYW5kIG5hbWVzIHRoYXQgZG8gbm90IGNvcnJlc3BvbmQgdG8gZXhpc3RpbmcgZnJhbWVidWZmZXIgb2JqZWN0c1wiLlxuICAgICAgICAgICAgR0xjdHguZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgZnJhbWVidWZmZXIubmFtZSA9IDA7XG4gICAgICAgICAgICBHTC5mcmFtZWJ1ZmZlcnNbaWRdID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbERlbGV0ZUZyYW1lYnVmZmVycy5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRGVsZXRlUHJvZ3JhbShpZCkge1xuICAgICAgICBpZiAoIWlkKSByZXR1cm47XG4gICAgICAgIHZhciBwcm9ncmFtID0gR0wucHJvZ3JhbXNbaWRdO1xuICAgICAgICBpZiAoIXByb2dyYW0pIHsgLy8gZ2xEZWxldGVQcm9ncmFtIGFjdHVhbGx5IHNpZ25hbHMgYW4gZXJyb3Igd2hlbiBkZWxldGluZyBhIG5vbmV4aXN0aW5nIG9iamVjdCwgdW5saWtlIHNvbWUgb3RoZXIgR0wgZGVsZXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIHByb2dyYW0ubmFtZSA9IDA7XG4gICAgICAgIEdMLnByb2dyYW1zW2lkXSA9IG51bGw7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRGVsZXRlUHJvZ3JhbS5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEZWxldGVRdWVyaWVzRVhUKG4sIGlkcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gSEVBUDMyWygoKGlkcykgKyAoaSAqIDQpKSA+PiAyKV07XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBHTC5xdWVyaWVzW2lkXTtcbiAgICAgICAgICAgIGlmICghcXVlcnkpIGNvbnRpbnVlOyAvLyBHTCBzcGVjOiBcInVudXNlZCBuYW1lcyBpbiBpZHMgYXJlIGlnbm9yZWQsIGFzIGlzIHRoZSBuYW1lIHplcm8uXCJcbiAgICAgICAgICAgIEdMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dFsnZGVsZXRlUXVlcnlFWFQnXShxdWVyeSk7XG4gICAgICAgICAgICBHTC5xdWVyaWVzW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEZWxldGVRdWVyaWVzRVhULnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEZWxldGVSZW5kZXJidWZmZXJzKG4sIHJlbmRlcmJ1ZmZlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IEhFQVAzMlsoKChyZW5kZXJidWZmZXJzKSArIChpICogNCkpID4+IDIpXTtcbiAgICAgICAgICAgIHZhciByZW5kZXJidWZmZXIgPSBHTC5yZW5kZXJidWZmZXJzW2lkXTtcbiAgICAgICAgICAgIGlmICghcmVuZGVyYnVmZmVyKSBjb250aW51ZTsgLy8gR0wgc3BlYzogXCJnbERlbGV0ZVJlbmRlcmJ1ZmZlcnMgc2lsZW50bHkgaWdub3JlcyAwcyBhbmQgbmFtZXMgdGhhdCBkbyBub3QgY29ycmVzcG9uZCB0byBleGlzdGluZyByZW5kZXJidWZmZXIgb2JqZWN0c1wiLlxuICAgICAgICAgICAgR0xjdHguZGVsZXRlUmVuZGVyYnVmZmVyKHJlbmRlcmJ1ZmZlcik7XG4gICAgICAgICAgICByZW5kZXJidWZmZXIubmFtZSA9IDA7XG4gICAgICAgICAgICBHTC5yZW5kZXJidWZmZXJzW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEZWxldGVSZW5kZXJidWZmZXJzLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEZWxldGVTaGFkZXIoaWQpIHtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuO1xuICAgICAgICB2YXIgc2hhZGVyID0gR0wuc2hhZGVyc1tpZF07XG4gICAgICAgIGlmICghc2hhZGVyKSB7IC8vIGdsRGVsZXRlU2hhZGVyIGFjdHVhbGx5IHNpZ25hbHMgYW4gZXJyb3Igd2hlbiBkZWxldGluZyBhIG5vbmV4aXN0aW5nIG9iamVjdCwgdW5saWtlIHNvbWUgb3RoZXIgR0wgZGVsZXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICBHTC5zaGFkZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRGVsZXRlU2hhZGVyLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERlbGV0ZVRleHR1cmVzKG4sIHRleHR1cmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBIRUFQMzJbKCgodGV4dHVyZXMpICsgKGkgKiA0KSkgPj4gMildO1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBHTC50ZXh0dXJlc1tpZF07XG4gICAgICAgICAgICBpZiAoIXRleHR1cmUpIGNvbnRpbnVlOyAvLyBHTCBzcGVjOiBcImdsRGVsZXRlVGV4dHVyZXMgc2lsZW50bHkgaWdub3JlcyAwcyBhbmQgbmFtZXMgdGhhdCBkbyBub3QgY29ycmVzcG9uZCB0byBleGlzdGluZyB0ZXh0dXJlc1wiLlxuICAgICAgICAgICAgR0xjdHguZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgIHRleHR1cmUubmFtZSA9IDA7XG4gICAgICAgICAgICBHTC50ZXh0dXJlc1tpZF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRGVsZXRlVGV4dHVyZXMuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERlbGV0ZVZlcnRleEFycmF5c09FUyhuLCB2YW9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBIRUFQMzJbKCgodmFvcykgKyAoaSAqIDQpKSA+PiAyKV07XG4gICAgICAgICAgICBHTGN0eFsnZGVsZXRlVmVydGV4QXJyYXknXShHTC52YW9zW2lkXSk7XG4gICAgICAgICAgICBHTC52YW9zW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEZWxldGVWZXJ0ZXhBcnJheXNPRVMuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERlcHRoRnVuYyh4MCkgeyBHTGN0eFsnZGVwdGhGdW5jJ10oeDApIH1cbiAgICBfZW1zY3JpcHRlbl9nbERlcHRoRnVuYy5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEZXB0aE1hc2soZmxhZykge1xuICAgICAgICBHTGN0eC5kZXB0aE1hc2soISFmbGFnKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEZXB0aE1hc2suc2lnID0gJ3ZpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRGVwdGhSYW5nZWYoeDAsIHgxKSB7IEdMY3R4WydkZXB0aFJhbmdlJ10oeDAsIHgxKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEZXB0aFJhbmdlZi5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRGV0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcikge1xuICAgICAgICBHTGN0eC5kZXRhY2hTaGFkZXIoR0wucHJvZ3JhbXNbcHJvZ3JhbV0sIEdMLnNoYWRlcnNbc2hhZGVyXSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRGV0YWNoU2hhZGVyLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEaXNhYmxlKHgwKSB7IEdMY3R4WydkaXNhYmxlJ10oeDApIH1cbiAgICBfZW1zY3JpcHRlbl9nbERpc2FibGUuc2lnID0gJ3ZpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgICAgIEdMY3R4LmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRGlzYWJsZVZlcnRleEF0dHJpYkFycmF5LnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERyYXdBcnJheXMobW9kZSwgZmlyc3QsIGNvdW50KSB7XG5cbiAgICAgICAgR0xjdHguZHJhd0FycmF5cyhtb2RlLCBmaXJzdCwgY291bnQpO1xuXG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRHJhd0FycmF5cy5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShtb2RlLCBmaXJzdCwgY291bnQsIHByaW1jb3VudCkge1xuICAgICAgICBHTGN0eFsnZHJhd0FycmF5c0luc3RhbmNlZCddKG1vZGUsIGZpcnN0LCBjb3VudCwgcHJpbWNvdW50KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUuc2lnID0gJ3ZpaWlpJztcblxuICAgIHZhciB0ZW1wRml4ZWRMZW5ndGhBcnJheSA9IFtdO1xuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRHJhd0J1ZmZlcnNXRUJHTChuLCBidWZzKSB7XG5cbiAgICAgICAgdmFyIGJ1ZkFycmF5ID0gdGVtcEZpeGVkTGVuZ3RoQXJyYXlbbl07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBidWZBcnJheVtpXSA9IEhFQVAzMlsoKChidWZzKSArIChpICogNCkpID4+IDIpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIEdMY3R4WydkcmF3QnVmZmVycyddKGJ1ZkFycmF5KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xEcmF3QnVmZmVyc1dFQkdMLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xEcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHR5cGUsIGluZGljZXMpIHtcblxuICAgICAgICBHTGN0eC5kcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHR5cGUsIGluZGljZXMpO1xuXG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRHJhd0VsZW1lbnRzLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbERyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKG1vZGUsIGNvdW50LCB0eXBlLCBpbmRpY2VzLCBwcmltY291bnQpIHtcbiAgICAgICAgR0xjdHhbJ2RyYXdFbGVtZW50c0luc3RhbmNlZCddKG1vZGUsIGNvdW50LCB0eXBlLCBpbmRpY2VzLCBwcmltY291bnQpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbERyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFLnNpZyA9ICd2aWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xFbmFibGUoeDApIHsgR0xjdHhbJ2VuYWJsZSddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xFbmFibGUuc2lnID0gJ3ZpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgR0xjdHguZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEVuYWJsZVZlcnRleEF0dHJpYkFycmF5LnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEVuZFF1ZXJ5RVhUKHRhcmdldCkge1xuICAgICAgICBHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHRbJ2VuZFF1ZXJ5RVhUJ10odGFyZ2V0KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xFbmRRdWVyeUVYVC5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xGaW5pc2goKSB7IEdMY3R4WydmaW5pc2gnXSgpIH1cbiAgICBfZW1zY3JpcHRlbl9nbEZpbmlzaC5zaWcgPSAndic7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEZsdXNoKCkgeyBHTGN0eFsnZmx1c2gnXSgpIH1cbiAgICBfZW1zY3JpcHRlbl9nbEZsdXNoLnNpZyA9ICd2JztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRnJhbWVidWZmZXJSZW5kZXJidWZmZXIodGFyZ2V0LCBhdHRhY2htZW50LCByZW5kZXJidWZmZXJ0YXJnZXQsIHJlbmRlcmJ1ZmZlcikge1xuICAgICAgICBHTGN0eC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcih0YXJnZXQsIGF0dGFjaG1lbnQsIHJlbmRlcmJ1ZmZlcnRhcmdldCxcbiAgICAgICAgICAgIEdMLnJlbmRlcmJ1ZmZlcnNbcmVuZGVyYnVmZmVyXSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsRnJhbWVidWZmZXJSZW5kZXJidWZmZXIuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRnJhbWVidWZmZXJUZXh0dXJlMkQodGFyZ2V0LCBhdHRhY2htZW50LCB0ZXh0YXJnZXQsIHRleHR1cmUsIGxldmVsKSB7XG4gICAgICAgIEdMY3R4LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHRhcmdldCwgYXR0YWNobWVudCwgdGV4dGFyZ2V0LFxuICAgICAgICAgICAgR0wudGV4dHVyZXNbdGV4dHVyZV0sIGxldmVsKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xGcmFtZWJ1ZmZlclRleHR1cmUyRC5zaWcgPSAndmlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsRnJvbnRGYWNlKHgwKSB7IEdMY3R4Wydmcm9udEZhY2UnXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsRnJvbnRGYWNlLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfX2dsR2VuT2JqZWN0KG4sIGJ1ZmZlcnMsIGNyZWF0ZUZ1bmN0aW9uLCBvYmplY3RUYWJsZVxuICAgICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEdMY3R4W2NyZWF0ZUZ1bmN0aW9uXSgpO1xuICAgICAgICAgICAgdmFyIGlkID0gYnVmZmVyICYmIEdMLmdldE5ld0lkKG9iamVjdFRhYmxlKTtcbiAgICAgICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIubmFtZSA9IGlkO1xuICAgICAgICAgICAgICAgIG9iamVjdFRhYmxlW2lkXSA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDIgLyogR0xfSU5WQUxJRF9PUEVSQVRJT04gKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSEVBUDMyWygoKGJ1ZmZlcnMpICsgKGkgKiA0KSkgPj4gMildID0gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX19nbEdlbk9iamVjdC5zaWcgPSAndmlpJztcbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdlbkJ1ZmZlcnMobiwgYnVmZmVycykge1xuICAgICAgICBfX2dsR2VuT2JqZWN0KG4sIGJ1ZmZlcnMsICdjcmVhdGVCdWZmZXInLCBHTC5idWZmZXJzXG4gICAgICAgICk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2VuQnVmZmVycy5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2VuRnJhbWVidWZmZXJzKG4sIGlkcykge1xuICAgICAgICBfX2dsR2VuT2JqZWN0KG4sIGlkcywgJ2NyZWF0ZUZyYW1lYnVmZmVyJywgR0wuZnJhbWVidWZmZXJzXG4gICAgICAgICk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2VuRnJhbWVidWZmZXJzLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZW5RdWVyaWVzRVhUKG4sIGlkcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gR0xjdHguZGlzam9pbnRUaW1lclF1ZXJ5RXh0WydjcmVhdGVRdWVyeUVYVCddKCk7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDIgLyogR0xfSU5WQUxJRF9PUEVSQVRJT04gKi8pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbikgSEVBUDMyWygoKGlkcykgKyAoaSsrICogNCkpID4+IDIpXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gR0wuZ2V0TmV3SWQoR0wucXVlcmllcyk7XG4gICAgICAgICAgICBxdWVyeS5uYW1lID0gaWQ7XG4gICAgICAgICAgICBHTC5xdWVyaWVzW2lkXSA9IHF1ZXJ5O1xuICAgICAgICAgICAgSEVBUDMyWygoKGlkcykgKyAoaSAqIDQpKSA+PiAyKV0gPSBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdlblF1ZXJpZXNFWFQuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdlblJlbmRlcmJ1ZmZlcnMobiwgcmVuZGVyYnVmZmVycykge1xuICAgICAgICBfX2dsR2VuT2JqZWN0KG4sIHJlbmRlcmJ1ZmZlcnMsICdjcmVhdGVSZW5kZXJidWZmZXInLCBHTC5yZW5kZXJidWZmZXJzXG4gICAgICAgICk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2VuUmVuZGVyYnVmZmVycy5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2VuVGV4dHVyZXMobiwgdGV4dHVyZXMpIHtcbiAgICAgICAgX19nbEdlbk9iamVjdChuLCB0ZXh0dXJlcywgJ2NyZWF0ZVRleHR1cmUnLCBHTC50ZXh0dXJlc1xuICAgICAgICApO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdlblRleHR1cmVzLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZW5WZXJ0ZXhBcnJheXNPRVMobiwgYXJyYXlzKSB7XG4gICAgICAgIF9fZ2xHZW5PYmplY3QobiwgYXJyYXlzLCAnY3JlYXRlVmVydGV4QXJyYXknLCBHTC52YW9zXG4gICAgICAgICk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2VuVmVydGV4QXJyYXlzT0VTLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZW5lcmF0ZU1pcG1hcCh4MCkgeyBHTGN0eFsnZ2VuZXJhdGVNaXBtYXAnXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2VuZXJhdGVNaXBtYXAuc2lnID0gJ3ZpJztcblxuICAgIGZ1bmN0aW9uIF9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm0oZnVuY05hbWUsIHByb2dyYW0sIGluZGV4LCBidWZTaXplLCBsZW5ndGgsIHNpemUsIHR5cGUsIG5hbWUpIHtcbiAgICAgICAgcHJvZ3JhbSA9IEdMLnByb2dyYW1zW3Byb2dyYW1dO1xuICAgICAgICB2YXIgaW5mbyA9IEdMY3R4W2Z1bmNOYW1lXShwcm9ncmFtLCBpbmRleCk7XG4gICAgICAgIGlmIChpbmZvKSB7IC8vIElmIGFuIGVycm9yIG9jY3Vycywgbm90aGluZyB3aWxsIGJlIHdyaXR0ZW4gdG8gbGVuZ3RoLCBzaXplIGFuZCB0eXBlIGFuZCBuYW1lLlxuICAgICAgICAgICAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gbmFtZSAmJiBzdHJpbmdUb1VURjgoaW5mby5uYW1lLCBuYW1lLCBidWZTaXplKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIEhFQVAzMlsoKGxlbmd0aCkgPj4gMildID0gbnVtQnl0ZXNXcml0dGVuRXhjbE51bGw7XG4gICAgICAgICAgICBpZiAoc2l6ZSkgSEVBUDMyWygoc2l6ZSkgPj4gMildID0gaW5mby5zaXplO1xuICAgICAgICAgICAgaWYgKHR5cGUpIEhFQVAzMlsoKHR5cGUpID4+IDIpXSA9IGluZm8udHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpbmRleCwgYnVmU2l6ZSwgbGVuZ3RoLCBzaXplLCB0eXBlLCBuYW1lKSB7XG4gICAgICAgIF9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm0oJ2dldEFjdGl2ZUF0dHJpYicsIHByb2dyYW0sIGluZGV4LCBidWZTaXplLCBsZW5ndGgsIHNpemUsIHR5cGUsIG5hbWUpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldEFjdGl2ZUF0dHJpYi5zaWcgPSAndmlpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGluZGV4LCBidWZTaXplLCBsZW5ndGgsIHNpemUsIHR5cGUsIG5hbWUpIHtcbiAgICAgICAgX19nbEdldEFjdGl2ZUF0dHJpYk9yVW5pZm9ybSgnZ2V0QWN0aXZlVW5pZm9ybScsIHByb2dyYW0sIGluZGV4LCBidWZTaXplLCBsZW5ndGgsIHNpemUsIHR5cGUsIG5hbWUpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldEFjdGl2ZVVuaWZvcm0uc2lnID0gJ3ZpaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0QXR0YWNoZWRTaGFkZXJzKHByb2dyYW0sIG1heENvdW50LCBjb3VudCwgc2hhZGVycykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gR0xjdHguZ2V0QXR0YWNoZWRTaGFkZXJzKEdMLnByb2dyYW1zW3Byb2dyYW1dKTtcbiAgICAgICAgdmFyIGxlbiA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiBtYXhDb3VudCkge1xuICAgICAgICAgICAgbGVuID0gbWF4Q291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygoY291bnQpID4+IDIpXSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGlkID0gR0wuc2hhZGVycy5pbmRleE9mKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBIRUFQMzJbKCgoc2hhZGVycykgKyAoaSAqIDQpKSA+PiAyKV0gPSBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldEF0dGFjaGVkU2hhZGVycy5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBHTGN0eC5nZXRBdHRyaWJMb2NhdGlvbihHTC5wcm9ncmFtc1twcm9ncmFtXSwgVVRGOFRvU3RyaW5nKG5hbWUpKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRBdHRyaWJMb2NhdGlvbi5zaWcgPSAnaWlpJztcblxuICAgIGZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cikge1xuICAgICAgICByZXR1cm4gSEVBUFUzMltwdHIgPj4gMl0gKyBIRUFQMzJbcHRyICsgNCA+PiAyXSAqIDQyOTQ5NjcyOTY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEk1M0Zyb21VNjQocHRyKSB7XG4gICAgICAgIHJldHVybiBIRUFQVTMyW3B0ciA+PiAyXSArIEhFQVBVMzJbcHRyICsgNCA+PiAyXSAqIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlSTUzVG9JNjQocHRyLCBudW0pIHtcbiAgICAgICAgSEVBUFUzMltwdHIgPj4gMl0gPSBudW07XG4gICAgICAgIEhFQVBVMzJbcHRyICsgNCA+PiAyXSA9IChudW0gLSBIRUFQVTMyW3B0ciA+PiAyXSkgLyA0Mjk0OTY3Mjk2O1xuICAgICAgICB2YXIgZGVzZXJpYWxpemVkID0gKG51bSA+PSAwKSA/IHJlYWRJNTNGcm9tVTY0KHB0cikgOiByZWFkSTUzRnJvbUk2NChwdHIpO1xuICAgICAgICBpZiAoZGVzZXJpYWxpemVkICE9IG51bSkgd2Fybk9uY2UoJ3dyaXRlSTUzVG9JNjQoKSBvdXQgb2YgcmFuZ2U6IHNlcmlhbGl6ZWQgSlMgTnVtYmVyICcgKyBudW0gKyAnIHRvIFdhc20gaGVhcCBhcyBieXRlcyBsbz0weCcgKyBIRUFQVTMyW3B0ciA+PiAyXS50b1N0cmluZygxNikgKyAnLCBoaT0weCcgKyBIRUFQVTMyW3B0ciArIDQgPj4gMl0udG9TdHJpbmcoMTYpICsgJywgd2hpY2ggZGVzZXJpYWxpemVzIGJhY2sgdG8gJyArIGRlc2VyaWFsaXplZCArICcgaW5zdGVhZCEnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1zY3JpcHRlbldlYkdMR2V0KG5hbWVfLCBwLCB0eXBlKSB7XG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdXNlciBwYXNzaW5nIGEgbnVsbCBwb2ludGVyLlxuICAgICAgICAvLyBOb3RlIHRoYXQgR0xFUzIgc3BlYyBkb2VzIG5vdCBzYXkgYW55dGhpbmcgYWJvdXQgaG93IHBhc3NpbmcgYSBudWxsIHBvaW50ZXIgc2hvdWxkIGJlIHRyZWF0ZWQuXG4gICAgICAgIC8vIFRlc3Rpbmcgb24gZGVza3RvcCBjb3JlIEdMIDMsIHRoZSBhcHBsaWNhdGlvbiBjcmFzaGVzIG9uIGdsR2V0SW50ZWdlcnYgdG8gYSBudWxsIHBvaW50ZXIsIGJ1dFxuICAgICAgICAvLyBiZXR0ZXIgdG8gcmVwb3J0IGFuIGVycm9yIGluc3RlYWQgb2YgZG9pbmcgYW55dGhpbmcgcmFuZG9tLlxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAobmFtZV8pIHsgLy8gSGFuZGxlIGEgZmV3IHRyaXZpYWwgR0xFUyB2YWx1ZXNcbiAgICAgICAgICAgIGNhc2UgMHg4REZBOiAvLyBHTF9TSEFERVJfQ09NUElMRVJcbiAgICAgICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDhERjg6IC8vIEdMX1NIQURFUl9CSU5BUllfRk9STUFUU1xuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9IDAgJiYgdHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAwKTsgLy8gR0xfSU5WQUxJRF9FTlVNXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG8gbm90IHdyaXRlIGFueXRoaW5nIHRvIHRoZSBvdXQgcG9pbnRlciwgc2luY2Ugbm8gYmluYXJ5IGZvcm1hdHMgYXJlIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGNhc2UgMHg4REY5OiAvLyBHTF9OVU1fU0hBREVSX0JJTkFSWV9GT1JNQVRTXG4gICAgICAgICAgICAgICAgcmV0ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHg4NkEyOiAvLyBHTF9OVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFNcbiAgICAgICAgICAgICAgICAvLyBXZWJHTCBkb2Vzbid0IGhhdmUgR0xfTlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIChpdCdzIG9ic29sZXRlIHNpbmNlIEdMX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIHJldHVybnMgYSBKUyBhcnJheSB0aGF0IGNhbiBiZSBxdWVyaWVkIGZvciBsZW5ndGgpLFxuICAgICAgICAgICAgICAgIC8vIHNvIGltcGxlbWVudCBpdCBvdXJzZWx2ZXMgdG8gYWxsb3cgQysrIEdMRVMyIGNvZGUgZ2V0IHRoZSBsZW5ndGguXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSBHTGN0eC5nZXRQYXJhbWV0ZXIoMHg4NkEzIC8qR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMqLyk7XG4gICAgICAgICAgICAgICAgcmV0ID0gZm9ybWF0cyA/IGZvcm1hdHMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gR0xjdHguZ2V0UGFyYW1ldGVyKG5hbWVfKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICByZXQgPSByZXN1bHQgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMCk7IC8vIEdMX0lOVkFMSURfRU5VTVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGlzIGEgdmFsaWQgcmVzdWx0IGZvciBzb21lIChlLmcuLCB3aGljaCBidWZmZXIgaXMgYm91bmQgLSBwZXJoYXBzIG5vdGhpbmcgaXMgYm91bmQpLCBidXQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gbWVhbiBhbiBpbnZhbGlkIG5hbWVfLCB3aGljaCB3ZSBuZWVkIHRvIHJlcG9ydCBhcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHg4ODk0OiAvLyBBUlJBWV9CVUZGRVJfQklORElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHg4QjhEOiAvLyBDVVJSRU5UX1BST0dSQU1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDB4ODg5NTogLy8gRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHg4Q0E2OiAvLyBGUkFNRUJVRkZFUl9CSU5ESU5HIG9yIERSQVdfRlJBTUVCVUZGRVJfQklORElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHg4Q0E3OiAvLyBSRU5ERVJCVUZGRVJfQklORElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMHg4MDY5OiAvLyBURVhUVVJFX0JJTkRJTkdfMkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDB4ODVCNTogLy8gV2ViR0wgMiBHTF9WRVJURVhfQVJSQVlfQklORElORywgb3IgV2ViR0wgMSBleHRlbnNpb24gT0VTX3ZlcnRleF9hcnJheV9vYmplY3QgR0xfVkVSVEVYX0FSUkFZX0JJTkRJTkdfT0VTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAweDg1MTQ6IHsgLy8gVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAwKTsgLy8gR0xfSU5WQUxJRF9FTlVNXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogSEVBUDMyWygoKHApICsgKGkgKiA0KSkgPj4gMildID0gcmVzdWx0W2ldOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiBIRUFQRjMyWygoKHApICsgKGkgKiA0KSkgPj4gMildID0gcmVzdWx0W2ldOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBIRUFQOFsoKChwKSArIChpKSkgPj4gMCldID0gcmVzdWx0W2ldID8gMSA6IDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmVzdWx0Lm5hbWUgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAwKTsgLy8gR0xfSU5WQUxJRF9FTlVNXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyKCdHTF9JTlZBTElEX0VOVU0gaW4gZ2xHZXQnICsgdHlwZSArICd2OiBVbmtub3duIG9iamVjdCByZXR1cm5lZCBmcm9tIFdlYkdMIGdldFBhcmFtZXRlcignICsgbmFtZV8gKyAnKSEgKGVycm9yOiAnICsgZSArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAwKTsgLy8gR0xfSU5WQUxJRF9FTlVNXG4gICAgICAgICAgICAgICAgICAgIGVycignR0xfSU5WQUxJRF9FTlVNIGluIGdsR2V0JyArIHR5cGUgKyAndjogTmF0aXZlIGNvZGUgY2FsbGluZyBnbEdldCcgKyB0eXBlICsgJ3YoJyArIG5hbWVfICsgJykgYW5kIGl0IHJldHVybnMgJyArIHJlc3VsdCArICcgb2YgdHlwZSAnICsgdHlwZW9mIChyZXN1bHQpICsgJyEnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6IHdyaXRlSTUzVG9JNjQocCwgcmV0KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6IEhFQVAzMlsoKHApID4+IDIpXSA9IHJldDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IEhFQVBGMzJbKChwKSA+PiAyKV0gPSByZXQ7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OiBIRUFQOFsoKHApID4+IDApXSA9IHJldCA/IDEgOiAwOyBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldEJvb2xlYW52KG5hbWVfLCBwKSB7XG4gICAgICAgIGVtc2NyaXB0ZW5XZWJHTEdldChuYW1lXywgcCwgNCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0Qm9vbGVhbnYuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldEJ1ZmZlclBhcmFtZXRlcml2KHRhcmdldCwgdmFsdWUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAvLyBHTEVTMiBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHNwZWNpZnkgaG93IHRvIGJlaGF2ZSBpZiBkYXRhIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgZGF0YSA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygoZGF0YSkgPj4gMildID0gR0xjdHguZ2V0QnVmZmVyUGFyYW1ldGVyKHRhcmdldCwgdmFsdWUpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldEJ1ZmZlclBhcmFtZXRlcml2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0RXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnJvciA9IEdMY3R4LmdldEVycm9yKCkgfHwgR0wubGFzdEVycm9yO1xuICAgICAgICBHTC5sYXN0RXJyb3IgPSAwLypHTF9OT19FUlJPUiovO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0RXJyb3Iuc2lnID0gJ2knO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRGbG9hdHYobmFtZV8sIHApIHtcbiAgICAgICAgZW1zY3JpcHRlbldlYkdMR2V0KG5hbWVfLCBwLCAyKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRGbG9hdHYuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcml2KHRhcmdldCwgYXR0YWNobWVudCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gR0xjdHguZ2V0RnJhbWVidWZmZXJBdHRhY2htZW50UGFyYW1ldGVyKHRhcmdldCwgYXR0YWNobWVudCwgcG5hbWUpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgV2ViR0xSZW5kZXJidWZmZXIgfHxcbiAgICAgICAgICAgIHJlc3VsdCBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm5hbWUgfCAwO1xuICAgICAgICB9XG4gICAgICAgIEhFQVAzMlsoKHBhcmFtcykgPj4gMildID0gcmVzdWx0O1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcml2LnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldEludGVnZXJ2KG5hbWVfLCBwKSB7XG4gICAgICAgIGVtc2NyaXB0ZW5XZWJHTEdldChuYW1lXywgcCwgMCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0SW50ZWdlcnYuc2lnID0gJ3ZpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0sIG1heExlbmd0aCwgbGVuZ3RoLCBpbmZvTG9nKSB7XG4gICAgICAgIHZhciBsb2cgPSBHTGN0eC5nZXRQcm9ncmFtSW5mb0xvZyhHTC5wcm9ncmFtc1twcm9ncmFtXSk7XG4gICAgICAgIGlmIChsb2cgPT09IG51bGwpIGxvZyA9ICcodW5rbm93biBlcnJvciknO1xuICAgICAgICB2YXIgbnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgPSAobWF4TGVuZ3RoID4gMCAmJiBpbmZvTG9nKSA/IHN0cmluZ1RvVVRGOChsb2csIGluZm9Mb2csIG1heExlbmd0aCkgOiAwO1xuICAgICAgICBpZiAobGVuZ3RoKSBIRUFQMzJbKChsZW5ndGgpID4+IDIpXSA9IG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFByb2dyYW1JbmZvTG9nLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFByb2dyYW1pdihwcm9ncmFtLCBwbmFtZSwgcCkge1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHAgaXMgYSBudWxsIHBvaW50ZXIuIFNpbmNlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAvLyBpZiBwID09IG51bGwsIGlzc3VlIGEgR0wgZXJyb3IgdG8gbm90aWZ5IHVzZXIgYWJvdXQgaXQuXG4gICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMSAvKiBHTF9JTlZBTElEX1ZBTFVFICovKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9ncmFtID49IEdMLmNvdW50ZXIpIHtcbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbSA9IEdMLnByb2dyYW1zW3Byb2dyYW1dO1xuXG4gICAgICAgIGlmIChwbmFtZSA9PSAweDhCODQpIHsgLy8gR0xfSU5GT19MT0dfTEVOR1RIXG4gICAgICAgICAgICB2YXIgbG9nID0gR0xjdHguZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgICAgICAgICBpZiAobG9nID09PSBudWxsKSBsb2cgPSAnKHVua25vd24gZXJyb3IpJztcbiAgICAgICAgICAgIEhFQVAzMlsoKHApID4+IDIpXSA9IGxvZy5sZW5ndGggKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKHBuYW1lID09IDB4OEI4NyAvKiBHTF9BQ1RJVkVfVU5JRk9STV9NQVhfTEVOR1RIICovKSB7XG4gICAgICAgICAgICBpZiAoIXByb2dyYW0ubWF4VW5pZm9ybUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgR0xjdHguZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCAweDhCODYvKkdMX0FDVElWRV9VTklGT1JNUyovKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0ubWF4VW5pZm9ybUxlbmd0aCA9IE1hdGgubWF4KHByb2dyYW0ubWF4VW5pZm9ybUxlbmd0aCwgR0xjdHguZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKS5uYW1lLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhFQVAzMlsoKHApID4+IDIpXSA9IHByb2dyYW0ubWF4VW5pZm9ybUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChwbmFtZSA9PSAweDhCOEEgLyogR0xfQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIICovKSB7XG4gICAgICAgICAgICBpZiAoIXByb2dyYW0ubWF4QXR0cmlidXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBHTGN0eC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIDB4OEI4OS8qR0xfQUNUSVZFX0FUVFJJQlVURVMqLyk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLm1heEF0dHJpYnV0ZUxlbmd0aCA9IE1hdGgubWF4KHByb2dyYW0ubWF4QXR0cmlidXRlTGVuZ3RoLCBHTGN0eC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkubmFtZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQMzJbKChwKSA+PiAyKV0gPSBwcm9ncmFtLm1heEF0dHJpYnV0ZUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChwbmFtZSA9PSAweDhBMzUgLyogR0xfQUNUSVZFX1VOSUZPUk1fQkxPQ0tfTUFYX05BTUVfTEVOR1RIICovKSB7XG4gICAgICAgICAgICBpZiAoIXByb2dyYW0ubWF4VW5pZm9ybUJsb2NrTmFtZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgR0xjdHguZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCAweDhBMzYvKkdMX0FDVElWRV9VTklGT1JNX0JMT0NLUyovKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyYW0ubWF4VW5pZm9ybUJsb2NrTmFtZUxlbmd0aCA9IE1hdGgubWF4KHByb2dyYW0ubWF4VW5pZm9ybUJsb2NrTmFtZUxlbmd0aCwgR0xjdHguZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShwcm9ncmFtLCBpKS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQMzJbKChwKSA+PiAyKV0gPSBwcm9ncmFtLm1heFVuaWZvcm1CbG9ja05hbWVMZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBIRUFQMzJbKChwKSA+PiAyKV0gPSBHTGN0eC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFByb2dyYW1pdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0aTY0dkVYVChpZCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgLy8gR0xFUzIgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBzcGVjaWZ5IGhvdyB0byBiZWhhdmUgaWYgcGFyYW1zIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgcCA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gR0wucXVlcmllc1tpZF07XG4gICAgICAgIHZhciBwYXJhbTtcbiAgICAgICAge1xuICAgICAgICAgICAgcGFyYW0gPSBHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHRbJ2dldFF1ZXJ5T2JqZWN0RVhUJ10ocXVlcnksIHBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0ID0gcGFyYW0gPyAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlSTUzVG9JNjQocGFyYW1zLCByZXQpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0aTY0dkVYVC5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0aXZFWFQoaWQsIHBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBhcmFtcyBpcyBhIG51bGwgcG9pbnRlci4gU2luY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIGlmIHAgPT0gbnVsbCwgaXNzdWUgYSBHTCBlcnJvciB0byBub3RpZnkgdXNlciBhYm91dCBpdC5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeSA9IEdMLnF1ZXJpZXNbaWRdO1xuICAgICAgICB2YXIgcGFyYW0gPSBHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHRbJ2dldFF1ZXJ5T2JqZWN0RVhUJ10ocXVlcnksIHBuYW1lKTtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldCA9IHBhcmFtID8gMSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKChwYXJhbXMpID4+IDIpXSA9IHJldDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRRdWVyeU9iamVjdGl2RVhULnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3R1aTY0dkVYVChpZCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgLy8gR0xFUzIgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBzcGVjaWZ5IGhvdyB0byBiZWhhdmUgaWYgcGFyYW1zIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgcCA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gR0wucXVlcmllc1tpZF07XG4gICAgICAgIHZhciBwYXJhbTtcbiAgICAgICAge1xuICAgICAgICAgICAgcGFyYW0gPSBHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHRbJ2dldFF1ZXJ5T2JqZWN0RVhUJ10ocXVlcnksIHBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0ID0gcGFyYW0gPyAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlSTUzVG9JNjQocGFyYW1zLCByZXQpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0dWk2NHZFWFQuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRRdWVyeU9iamVjdHVpdkVYVChpZCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgLy8gR0xFUzIgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBzcGVjaWZ5IGhvdyB0byBiZWhhdmUgaWYgcGFyYW1zIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgcCA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gR0wucXVlcmllc1tpZF07XG4gICAgICAgIHZhciBwYXJhbSA9IEdMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dFsnZ2V0UXVlcnlPYmplY3RFWFQnXShxdWVyeSwgcG5hbWUpO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0ID0gcGFyYW0gPyAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIEhFQVAzMlsoKHBhcmFtcykgPj4gMildID0gcmV0O1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0dWl2RVhULnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0UXVlcnlpdkVYVCh0YXJnZXQsIHBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBhcmFtcyBpcyBhIG51bGwgcG9pbnRlci4gU2luY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIGlmIHAgPT0gbnVsbCwgaXNzdWUgYSBHTCBlcnJvciB0byBub3RpZnkgdXNlciBhYm91dCBpdC5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEhFQVAzMlsoKHBhcmFtcykgPj4gMildID0gR0xjdHguZGlzam9pbnRUaW1lclF1ZXJ5RXh0WydnZXRRdWVyeUVYVCddKHRhcmdldCwgcG5hbWUpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5aXZFWFQuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXJpdih0YXJnZXQsIHBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBhcmFtcyBpcyBhIG51bGwgcG9pbnRlci4gU2luY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIGlmIHBhcmFtcyA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygocGFyYW1zKSA+PiAyKV0gPSBHTGN0eC5nZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXIodGFyZ2V0LCBwbmFtZSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyaXYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJJbmZvTG9nKHNoYWRlciwgbWF4TGVuZ3RoLCBsZW5ndGgsIGluZm9Mb2cpIHtcbiAgICAgICAgdmFyIGxvZyA9IEdMY3R4LmdldFNoYWRlckluZm9Mb2coR0wuc2hhZGVyc1tzaGFkZXJdKTtcbiAgICAgICAgaWYgKGxvZyA9PT0gbnVsbCkgbG9nID0gJyh1bmtub3duIGVycm9yKSc7XG4gICAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IChtYXhMZW5ndGggPiAwICYmIGluZm9Mb2cpID8gc3RyaW5nVG9VVEY4KGxvZywgaW5mb0xvZywgbWF4TGVuZ3RoKSA6IDA7XG4gICAgICAgIGlmIChsZW5ndGgpIEhFQVAzMlsoKGxlbmd0aCkgPj4gMildID0gbnVtQnl0ZXNXcml0dGVuRXhjbE51bGw7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVySW5mb0xvZy5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoc2hhZGVyVHlwZSwgcHJlY2lzaW9uVHlwZSwgcmFuZ2UsIHByZWNpc2lvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gR0xjdHguZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KHNoYWRlclR5cGUsIHByZWNpc2lvblR5cGUpO1xuICAgICAgICBIRUFQMzJbKChyYW5nZSkgPj4gMildID0gcmVzdWx0LnJhbmdlTWluO1xuICAgICAgICBIRUFQMzJbKCgocmFuZ2UpICsgKDQpKSA+PiAyKV0gPSByZXN1bHQucmFuZ2VNYXg7XG4gICAgICAgIEhFQVAzMlsoKHByZWNpc2lvbikgPj4gMildID0gcmVzdWx0LnByZWNpc2lvbjtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVyU291cmNlKHNoYWRlciwgYnVmU2l6ZSwgbGVuZ3RoLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEdMY3R4LmdldFNoYWRlclNvdXJjZShHTC5zaGFkZXJzW3NoYWRlcl0pO1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuOyAvLyBJZiBhbiBlcnJvciBvY2N1cnMsIG5vdGhpbmcgd2lsbCBiZSB3cml0dGVuIHRvIGxlbmd0aCBvciBzb3VyY2UuXG4gICAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IChidWZTaXplID4gMCAmJiBzb3VyY2UpID8gc3RyaW5nVG9VVEY4KHJlc3VsdCwgc291cmNlLCBidWZTaXplKSA6IDA7XG4gICAgICAgIGlmIChsZW5ndGgpIEhFQVAzMlsoKGxlbmd0aCkgPj4gMildID0gbnVtQnl0ZXNXcml0dGVuRXhjbE51bGw7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVyU291cmNlLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFNoYWRlcml2KHNoYWRlciwgcG5hbWUsIHApIHtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICAvLyBHTEVTMiBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHNwZWNpZnkgaG93IHRvIGJlaGF2ZSBpZiBwIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgcCA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBuYW1lID09IDB4OEI4NCkgeyAvLyBHTF9JTkZPX0xPR19MRU5HVEhcbiAgICAgICAgICAgIHZhciBsb2cgPSBHTGN0eC5nZXRTaGFkZXJJbmZvTG9nKEdMLnNoYWRlcnNbc2hhZGVyXSk7XG4gICAgICAgICAgICBpZiAobG9nID09PSBudWxsKSBsb2cgPSAnKHVua25vd24gZXJyb3IpJztcbiAgICAgICAgICAgIC8vIFRoZSBHTEVTMiBzcGVjaWZpY2F0aW9uIHNheXMgdGhhdCBpZiB0aGUgc2hhZGVyIGhhcyBhbiBlbXB0eSBpbmZvIGxvZyxcbiAgICAgICAgICAgIC8vIGEgdmFsdWUgb2YgMCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSBsb2cgaGFzIGEgbnVsbCBjaGFyIGFwcGVuZGVkLlxuICAgICAgICAgICAgLy8gKEFuIGVtcHR5IHN0cmluZyBpcyBmYWxzZXksIHNvIHdlIGNhbiBqdXN0IGNoZWNrIHRoYXQgaW5zdGVhZCBvZlxuICAgICAgICAgICAgLy8gbG9va2luZyBhdCBsb2cubGVuZ3RoLilcbiAgICAgICAgICAgIHZhciBsb2dMZW5ndGggPSBsb2cgPyBsb2cubGVuZ3RoICsgMSA6IDA7XG4gICAgICAgICAgICBIRUFQMzJbKChwKSA+PiAyKV0gPSBsb2dMZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocG5hbWUgPT0gMHg4Qjg4KSB7IC8vIEdMX1NIQURFUl9TT1VSQ0VfTEVOR1RIXG4gICAgICAgICAgICB2YXIgc291cmNlID0gR0xjdHguZ2V0U2hhZGVyU291cmNlKEdMLnNoYWRlcnNbc2hhZGVyXSk7XG4gICAgICAgICAgICAvLyBzb3VyY2UgbWF5IGJlIGEgbnVsbCwgb3IgdGhlIGVtcHR5IHN0cmluZywgYm90aCBvZiB3aGljaCBhcmUgZmFsc2V5XG4gICAgICAgICAgICAvLyB2YWx1ZXMgdGhhdCB3ZSByZXBvcnQgYSAwIGxlbmd0aCBmb3IuXG4gICAgICAgICAgICB2YXIgc291cmNlTGVuZ3RoID0gc291cmNlID8gc291cmNlLmxlbmd0aCArIDEgOiAwO1xuICAgICAgICAgICAgSEVBUDMyWygocCkgPj4gMildID0gc291cmNlTGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgSEVBUDMyWygocCkgPj4gMildID0gR0xjdHguZ2V0U2hhZGVyUGFyYW1ldGVyKEdMLnNoYWRlcnNbc2hhZGVyXSwgcG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVyaXYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9OZXdVVEY4KGpzU3RyaW5nKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsZW5ndGhCeXRlc1VURjgoanNTdHJpbmcpICsgMTtcbiAgICAgICAgdmFyIGNTdHJpbmcgPSBfbWFsbG9jKGxlbmd0aCk7XG4gICAgICAgIHN0cmluZ1RvVVRGOChqc1N0cmluZywgY1N0cmluZywgbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNTdHJpbmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0U3RyaW5nKG5hbWVfKSB7XG4gICAgICAgIHZhciByZXQgPSBHTC5zdHJpbmdDYWNoZVtuYW1lX107XG4gICAgICAgIGlmICghcmV0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWVfKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAweDFGMDMgLyogR0xfRVhURU5TSU9OUyAqLzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHMgPSBHTGN0eC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgfHwgW107IC8vIC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCkgY2FuIHJldHVybiBudWxsIGlmIGNvbnRleHQgaXMgbG9zdCwgc28gY29lcmNlIHRvIGVtcHR5IGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBleHRzID0gZXh0cy5jb25jYXQoZXh0cy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFwiR0xfXCIgKyBlOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHN0cmluZ1RvTmV3VVRGOChleHRzLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgxRjAwIC8qIEdMX1ZFTkRPUiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4MUYwMSAvKiBHTF9SRU5ERVJFUiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDB4OTI0NSAvKiBVTk1BU0tFRF9WRU5ET1JfV0VCR0wgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAweDkyNDYgLyogVU5NQVNLRURfUkVOREVSRVJfV0VCR0wgKi86XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gR0xjdHguZ2V0UGFyYW1ldGVyKG5hbWVfKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMC8qR0xfSU5WQUxJRF9FTlVNKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHMgJiYgc3RyaW5nVG9OZXdVVEY4KHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMHgxRjAyIC8qIEdMX1ZFUlNJT04gKi86XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbFZlcnNpb24gPSBHTGN0eC5nZXRQYXJhbWV0ZXIoMHgxRjAyIC8qR0xfVkVSU0lPTiovKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIEdMRVMgdmVyc2lvbiBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGUgdmVyc2lvbiBvZiB0aGUgV2ViR0wgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbFZlcnNpb24gPSAnT3BlbkdMIEVTIDIuMCAoJyArIGdsVmVyc2lvbiArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXQgPSBzdHJpbmdUb05ld1VURjgoZ2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDhCOEMgLyogR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OICovOlxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2xzbFZlcnNpb24gPSBHTGN0eC5nZXRQYXJhbWV0ZXIoMHg4QjhDIC8qR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKi8pO1xuICAgICAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHRoZSB2ZXJzaW9uIG51bWJlciAnTi5NJyBmcm9tIHRoZSBzdHJpbmcgJ1dlYkdMIEdMU0wgRVMgTi5NIC4uLidcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcl9yZSA9IC9eV2ViR0wgR0xTTCBFUyAoWzAtOV1cXC5bMC05XVswLTldPykoPzokfCAuKikvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVyX251bSA9IGdsc2xWZXJzaW9uLm1hdGNoKHZlcl9yZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJfbnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyX251bVsxXS5sZW5ndGggPT0gMykgdmVyX251bVsxXSA9IHZlcl9udW1bMV0gKyAnMCc7IC8vIGVuc3VyZSBtaW5vciB2ZXJzaW9uIGhhcyAyIGRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xzbFZlcnNpb24gPSAnT3BlbkdMIEVTIEdMU0wgRVMgJyArIHZlcl9udW1bMV0gKyAnICgnICsgZ2xzbFZlcnNpb24gKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc3RyaW5nVG9OZXdVVEY4KGdsc2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDAvKkdMX0lOVkFMSURfRU5VTSovKTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdMLnN0cmluZ0NhY2hlW25hbWVfXSA9IHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFN0cmluZy5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRUZXhQYXJhbWV0ZXJmdih0YXJnZXQsIHBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBhcmFtcyBpcyBhIG51bGwgcG9pbnRlci4gU2luY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIGlmIHAgPT0gbnVsbCwgaXNzdWUgYSBHTCBlcnJvciB0byBub3RpZnkgdXNlciBhYm91dCBpdC5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEhFQVBGMzJbKChwYXJhbXMpID4+IDIpXSA9IEdMY3R4LmdldFRleFBhcmFtZXRlcih0YXJnZXQsIHBuYW1lKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRUZXhQYXJhbWV0ZXJmdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFRleFBhcmFtZXRlcml2KHRhcmdldCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgLy8gR0xFUzIgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBzcGVjaWZ5IGhvdyB0byBiZWhhdmUgaWYgcGFyYW1zIGlzIGEgbnVsbCBwb2ludGVyLiBTaW5jZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbWFrZSBzZW5zZVxuICAgICAgICAgICAgLy8gaWYgcCA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgSEVBUDMyWygocGFyYW1zKSA+PiAyKV0gPSBHTGN0eC5nZXRUZXhQYXJhbWV0ZXIodGFyZ2V0LCBwbmFtZSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0VGV4UGFyYW1ldGVyaXYuc2lnID0gJ3ZpaWknO1xuXG4gICAgLyoqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc30gKi9cbiAgICBmdW5jdGlvbiBqc3RvaV9xKHN0cikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyKTtcbiAgICB9XG5cbiAgICAvKiogQG5vaW5saW5lICovXG4gICAgZnVuY3Rpb24gd2ViZ2xHZXRMZWZ0QnJhY2VQb3MobmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZS5zbGljZSgtMSkgPT0gJ10nICYmIG5hbWUubGFzdEluZGV4T2YoJ1snKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2ViZ2xQcmVwYXJlVW5pZm9ybUxvY2F0aW9uc0JlZm9yZUZpcnN0VXNlKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIHVuaWZvcm1Mb2NzQnlJZCA9IHByb2dyYW0udW5pZm9ybUxvY3NCeUlkLCAvLyBNYXBzIEdMdWludCAtPiBXZWJHTFVuaWZvcm1Mb2NhdGlvblxuICAgICAgICAgICAgdW5pZm9ybVNpemVBbmRJZHNCeU5hbWUgPSBwcm9ncmFtLnVuaWZvcm1TaXplQW5kSWRzQnlOYW1lLCAvLyBNYXBzIG5hbWUgLT4gW3VuaWZvcm0gYXJyYXkgbGVuZ3RoLCBHTHVpbnRdXG4gICAgICAgICAgICBpLCBqO1xuXG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCB0aW1lIGludm9jYXRpb24gb2YgZ2xHZXRVbmlmb3JtTG9jYXRpb24gb24gdGhpcyBzaGFkZXIgcHJvZ3JhbTpcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBjYWNoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIGRpc2NvdmVyIHdoaWNoIHVuaWZvcm1zIGFyZSBhcnJheXMuXG4gICAgICAgIGlmICghdW5pZm9ybUxvY3NCeUlkKSB7XG4gICAgICAgICAgICAvLyBtYXBzIEdMaW50IGludGVnZXIgbG9jYXRpb25zIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uc1xuICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtTG9jc0J5SWQgPSB1bmlmb3JtTG9jc0J5SWQgPSB7fTtcbiAgICAgICAgICAgIC8vIG1hcHMgaW50ZWdlciBsb2NhdGlvbnMgYmFjayB0byB1bmlmb3JtIG5hbWUgc3RyaW5ncywgc28gdGhhdCB3ZSBjYW4gbGF6aWx5IGZldGNoIHVuaWZvcm0gYXJyYXkgbG9jYXRpb25zXG4gICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm1BcnJheU5hbWVzQnlJZCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgR0xjdHguZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCAweDhCODYvKkdMX0FDVElWRV9VTklGT1JNUyovKTsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBHTGN0eC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgICAgICAgICAgICAgIHZhciBubSA9IHUubmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgc3ogPSB1LnNpemU7XG4gICAgICAgICAgICAgICAgdmFyIGxiID0gd2ViZ2xHZXRMZWZ0QnJhY2VQb3Mobm0pO1xuICAgICAgICAgICAgICAgIHZhciBhcnJheU5hbWUgPSBsYiA+IDAgPyBubS5zbGljZSgwLCBsYikgOiBubTtcblxuICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBhIG5ldyBsb2NhdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBwcm9ncmFtLnVuaWZvcm1JZENvdW50ZXI7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtSWRDb3VudGVyICs9IHN6O1xuICAgICAgICAgICAgICAgIC8vIEVhZ2VybHkgZ2V0IHRoZSBsb2NhdGlvbiBvZiB0aGUgdW5pZm9ybUFycmF5WzBdIGJhc2UgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGluZGljZXMgPjAgd2lsbCBiZSBsZWZ0IGZvciBsYXp5IGV2YWx1YXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyBpbXByb3ZlIHBlcmZvcm1hbmNlLiBUaG9zZSBtYXkgbmV2ZXIgYmUgbmVlZGVkIHRvIGZldGNoLCBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhcHBsaWNhdGlvbiBmaWxscyBhcnJheXMgYWx3YXlzIGluIGZ1bGwgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG9mIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAgICB1bmlmb3JtU2l6ZUFuZElkc0J5TmFtZVthcnJheU5hbWVdID0gW3N6LCBpZF07XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBwbGFjZWhvbGRlciBpbnRlZ2VycyBpbiBwbGFjZSB0aGF0IGhpZ2hsaWdodCB0aGF0IHRoZXNlXG4gICAgICAgICAgICAgICAgLy8gPjAgaW5kZXggbG9jYXRpb25zIGFyZSBhcnJheSBpbmRpY2VzIHBlbmRpbmcgcG9wdWxhdGlvbi5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3o7ICsraikge1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtTG9jc0J5SWRbaWRdID0gajtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS51bmlmb3JtQXJyYXlOYW1lc0J5SWRbaWQrK10gPSBhcnJheU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpIHtcblxuICAgICAgICBuYW1lID0gVVRGOFRvU3RyaW5nKG5hbWUpO1xuXG4gICAgICAgIGlmIChwcm9ncmFtID0gR0wucHJvZ3JhbXNbcHJvZ3JhbV0pIHtcbiAgICAgICAgICAgIHdlYmdsUHJlcGFyZVVuaWZvcm1Mb2NhdGlvbnNCZWZvcmVGaXJzdFVzZShwcm9ncmFtKTtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtTG9jc0J5SWQgPSBwcm9ncmFtLnVuaWZvcm1Mb2NzQnlJZDsgLy8gTWFwcyBHTHVpbnQgLT4gV2ViR0xVbmlmb3JtTG9jYXRpb25cbiAgICAgICAgICAgIHZhciBhcnJheUluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtQmFzZU5hbWUgPSBuYW1lO1xuXG4gICAgICAgICAgICAvLyBJbnZhcmlhbnQ6IHdoZW4gcG9wdWxhdGluZyBpbnRlZ2VyIElEcyBmb3IgdW5pZm9ybSBsb2NhdGlvbnMsIHdlIG11c3QgbWFpbnRhaW4gdGhlIHByZWNvbmRpdGlvbiB0aGF0XG4gICAgICAgICAgICAvLyBhcnJheXMgcmVzaWRlIGluIGNvbnRpZ3VvdXMgYWRkcmVzc2VzLCBpLmUuIGZvciBhICd2ZWM0IGNvbG9yc1sxMF07JywgY29sb3JzWzRdIG11c3QgYmUgYXQgbG9jYXRpb24gY29sb3JzWzBdKzQuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB1c2VyIG1pZ2h0IGNhbGwgZ2xHZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJjb2xvcnNcIikgZm9yIGFuIGFycmF5LCBzbyB3ZSBjYW5ub3QgZGlzY292ZXIgYmFzZWQgb24gdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIGlucHV0IGFyZ3VtZW50cyB3aGV0aGVyIHRoZSB1bmlmb3JtIHdlIGFyZSBkZWFsaW5nIHdpdGggaXMgYW4gYXJyYXkuIFRoZSBvbmx5IHdheSB0byBkaXNjb3ZlciB3aGljaCB1bmlmb3JtcyBhcmUgYXJyYXlzXG4gICAgICAgICAgICAvLyBpcyB0byBlbnVtZXJhdGUgb3ZlciBhbGwgdGhlIGFjdGl2ZSB1bmlmb3JtcyBpbiB0aGUgcHJvZ3JhbS5cbiAgICAgICAgICAgIHZhciBsZWZ0QnJhY2UgPSB3ZWJnbEdldExlZnRCcmFjZVBvcyhuYW1lKTtcblxuICAgICAgICAgICAgLy8gSWYgdXNlciBwYXNzZWQgYW4gYXJyYXkgYWNjZXNzb3IgXCJbaW5kZXhdXCIsIHBhcnNlIHRoZSBhcnJheSBpbmRleCBvZmYgdGhlIGFjY2Vzc29yLlxuICAgICAgICAgICAgaWYgKGxlZnRCcmFjZSA+IDApIHtcbiAgICAgICAgICAgICAgICBhcnJheUluZGV4ID0ganN0b2lfcShuYW1lLnNsaWNlKGxlZnRCcmFjZSArIDEpKSA+Pj4gMDsgLy8gXCJpbmRleF1cIiwgY29lcmNlIHBhcnNlSW50KCddJykgd2l0aCA+Pj4wIHRvIHRyZWF0IFwiZm9vW11cIiBhcyBcImZvb1swXVwiIGFuZCBmb29bLTFdIGFzIHVuc2lnbmVkIG91dC1vZi1ib3VuZHMuXG4gICAgICAgICAgICAgICAgdW5pZm9ybUJhc2VOYW1lID0gbmFtZS5zbGljZSgwLCBsZWZ0QnJhY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYXZlIHdlIGNhY2hlZCB0aGUgbG9jYXRpb24gb2YgdGhpcyB1bmlmb3JtIGJlZm9yZT9cbiAgICAgICAgICAgIHZhciBzaXplQW5kSWQgPSBwcm9ncmFtLnVuaWZvcm1TaXplQW5kSWRzQnlOYW1lW3VuaWZvcm1CYXNlTmFtZV07IC8vIEEgcGFpciBbYXJyYXkgbGVuZ3RoLCBHTGludCBvZiB0aGUgdW5pZm9ybSBsb2NhdGlvbl1cblxuICAgICAgICAgICAgLy8gSWYgYW4gdW5pZm9ybSB3aXRoIHRoaXMgbmFtZSBleGlzdHMsIGFuZCBpZiBpdHMgaW5kZXggaXMgd2l0aGluIHRoZSBhcnJheSBsaW1pdHMgKGlmIGl0J3MgZXZlbiBhbiBhcnJheSksXG4gICAgICAgICAgICAvLyBxdWVyeSB0aGUgV2ViR0xsb2NhdGlvbiwgb3IgcmV0dXJuIGFuIGV4aXN0aW5nIGNhY2hlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgIGlmIChzaXplQW5kSWQgJiYgYXJyYXlJbmRleCA8IHNpemVBbmRJZFswXSkge1xuICAgICAgICAgICAgICAgIGFycmF5SW5kZXggKz0gc2l6ZUFuZElkWzFdOyAvLyBBZGQgdGhlIGJhc2UgbG9jYXRpb24gb2YgdGhlIHVuaWZvcm0gdG8gdGhlIGFycmF5IGluZGV4IG9mZnNldC5cbiAgICAgICAgICAgICAgICBpZiAoKHVuaWZvcm1Mb2NzQnlJZFthcnJheUluZGV4XSA9IHVuaWZvcm1Mb2NzQnlJZFthcnJheUluZGV4XSB8fCBHTGN0eC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheUluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE4uYi4gd2UgYXJlIGN1cnJlbnRseSB1bmFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBHTCBwcm9ncmFtIElEcyB0aGF0IG5ldmVyIGV4aXN0ZWQgdnMgR0wgcHJvZ3JhbSBJRHMgdGhhdCBoYXZlIGJlZW4gZGVsZXRlZCxcbiAgICAgICAgICAgIC8vIHNvIHJlcG9ydCBHTF9JTlZBTElEX1ZBTFVFIGluIGJvdGggY2FzZXMuXG4gICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMSAvKiBHTF9JTlZBTElEX1ZBTFVFICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0VW5pZm9ybUxvY2F0aW9uLnNpZyA9ICdpaWknO1xuXG4gICAgZnVuY3Rpb24gd2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgICAgdmFyIHAgPSBHTGN0eC5jdXJyZW50UHJvZ3JhbTtcblxuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgdmFyIHdlYmdsTG9jID0gcC51bmlmb3JtTG9jc0J5SWRbbG9jYXRpb25dO1xuICAgICAgICAgICAgLy8gcC51bmlmb3JtTG9jc0J5SWRbbG9jYXRpb25dIHN0b3JlcyBlaXRoZXIgYW4gaW50ZWdlciwgb3IgYSBXZWJHTFVuaWZvcm1Mb2NhdGlvbi5cblxuICAgICAgICAgICAgLy8gSWYgYW4gaW50ZWdlciwgd2UgaGF2ZSBub3QgeWV0IGJvdW5kIHRoZSBsb2NhdGlvbiwgc28gZG8gaXQgbm93LiBUaGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZXMgdGhlIGFycmF5IGluZGV4XG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYmluZCB0by5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2ViZ2xMb2MgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBwLnVuaWZvcm1Mb2NzQnlJZFtsb2NhdGlvbl0gPSB3ZWJnbExvYyA9IEdMY3R4LmdldFVuaWZvcm1Mb2NhdGlvbihwLCBwLnVuaWZvcm1BcnJheU5hbWVzQnlJZFtsb2NhdGlvbl0gKyAod2ViZ2xMb2MgPiAwID8gJ1snICsgd2ViZ2xMb2MgKyAnXScgOiAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWxzZSBhbiBhbHJlYWR5IGNhY2hlZCBXZWJHTFVuaWZvcm1Mb2NhdGlvbiwgcmV0dXJuIGl0LlxuICAgICAgICAgICAgcmV0dXJuIHdlYmdsTG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDIvKkdMX0lOVkFMSURfT1BFUkFUSU9OKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAc3VwcHJlc3N7Y2hlY2tUeXBlc30gKi9cbiAgICBmdW5jdGlvbiBlbXNjcmlwdGVuV2ViR0xHZXRVbmlmb3JtKHByb2dyYW0sIGxvY2F0aW9uLCBwYXJhbXMsIHR5cGUpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBhcmFtcyBpcyBhIG51bGwgcG9pbnRlci4gU2luY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IG1ha2Ugc2Vuc2VcbiAgICAgICAgICAgIC8vIGlmIHBhcmFtcyA9PSBudWxsLCBpc3N1ZSBhIEdMIGVycm9yIHRvIG5vdGlmeSB1c2VyIGFib3V0IGl0LlxuICAgICAgICAgICAgR0wucmVjb3JkRXJyb3IoMHg1MDEgLyogR0xfSU5WQUxJRF9WQUxVRSAqLyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3JhbSA9IEdMLnByb2dyYW1zW3Byb2dyYW1dO1xuICAgICAgICB3ZWJnbFByZXBhcmVVbmlmb3JtTG9jYXRpb25zQmVmb3JlRmlyc3RVc2UocHJvZ3JhbSk7XG4gICAgICAgIHZhciBkYXRhID0gR0xjdHguZ2V0VW5pZm9ybShwcm9ncmFtLCB3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ251bWJlcicgfHwgdHlwZW9mIGRhdGEgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IEhFQVAzMlsoKHBhcmFtcykgPj4gMildID0gZGF0YTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBIRUFQRjMyWygocGFyYW1zKSA+PiAyKV0gPSBkYXRhOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IEhFQVAzMlsoKChwYXJhbXMpICsgKGkgKiA0KSkgPj4gMildID0gZGF0YVtpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogSEVBUEYzMlsoKChwYXJhbXMpICsgKGkgKiA0KSkgPj4gMildID0gZGF0YVtpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0VW5pZm9ybWZ2KHByb2dyYW0sIGxvY2F0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgZW1zY3JpcHRlbldlYkdMR2V0VW5pZm9ybShwcm9ncmFtLCBsb2NhdGlvbiwgcGFyYW1zLCAyKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRVbmlmb3JtZnYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRVbmlmb3JtaXYocHJvZ3JhbSwgbG9jYXRpb24sIHBhcmFtcykge1xuICAgICAgICBlbXNjcmlwdGVuV2ViR0xHZXRVbmlmb3JtKHByb2dyYW0sIGxvY2F0aW9uLCBwYXJhbXMsIDApO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbEdldFVuaWZvcm1pdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEdldFZlcnRleEF0dHJpYlBvaW50ZXJ2KGluZGV4LCBwbmFtZSwgcG9pbnRlcikge1xuICAgICAgICBpZiAoIXBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIEdMRVMyIHNwZWNpZmljYXRpb24gZG9lcyBub3Qgc3BlY2lmeSBob3cgdG8gYmVoYXZlIGlmIHBvaW50ZXIgaXMgYSBudWxsIHBvaW50ZXIuIFNpbmNlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAvLyBpZiBwb2ludGVyID09IG51bGwsIGlzc3VlIGEgR0wgZXJyb3IgdG8gbm90aWZ5IHVzZXIgYWJvdXQgaXQuXG4gICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMSAvKiBHTF9JTlZBTElEX1ZBTFVFICovKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBIRUFQMzJbKChwb2ludGVyKSA+PiAyKV0gPSBHTGN0eC5nZXRWZXJ0ZXhBdHRyaWJPZmZzZXQoaW5kZXgsIHBuYW1lKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJQb2ludGVydi5zaWcgPSAndmlpaSc7XG5cbiAgICAvKiogQHN1cHByZXNze2NoZWNrVHlwZXN9ICovXG4gICAgZnVuY3Rpb24gZW1zY3JpcHRlbldlYkdMR2V0VmVydGV4QXR0cmliKGluZGV4LCBwbmFtZSwgcGFyYW1zLCB0eXBlKSB7XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBHTEVTMiBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IHNwZWNpZnkgaG93IHRvIGJlaGF2ZSBpZiBwYXJhbXMgaXMgYSBudWxsIHBvaW50ZXIuIFNpbmNlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtYWtlIHNlbnNlXG4gICAgICAgICAgICAvLyBpZiBwYXJhbXMgPT0gbnVsbCwgaXNzdWUgYSBHTCBlcnJvciB0byBub3RpZnkgdXNlciBhYm91dCBpdC5cbiAgICAgICAgICAgIEdMLnJlY29yZEVycm9yKDB4NTAxIC8qIEdMX0lOVkFMSURfVkFMVUUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gR0xjdHguZ2V0VmVydGV4QXR0cmliKGluZGV4LCBwbmFtZSk7XG4gICAgICAgIGlmIChwbmFtZSA9PSAweDg4OUYvKlZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkcqLykge1xuICAgICAgICAgICAgSEVBUDMyWygocGFyYW1zKSA+PiAyKV0gPSBkYXRhICYmIGRhdGFbXCJuYW1lXCJdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09ICdudW1iZXInIHx8IHR5cGVvZiBkYXRhID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBIRUFQMzJbKChwYXJhbXMpID4+IDIpXSA9IGRhdGE7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogSEVBUEYzMlsoKHBhcmFtcykgPj4gMildID0gZGF0YTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBIRUFQMzJbKChwYXJhbXMpID4+IDIpXSA9IE1hdGguZnJvdW5kKGRhdGEpOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IEhFQVAzMlsoKChwYXJhbXMpICsgKGkgKiA0KSkgPj4gMildID0gZGF0YVtpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogSEVBUEYzMlsoKChwYXJhbXMpICsgKGkgKiA0KSkgPj4gMildID0gZGF0YVtpXTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogSEVBUDMyWygoKHBhcmFtcykgKyAoaSAqIDQpKSA+PiAyKV0gPSBNYXRoLmZyb3VuZChkYXRhW2ldKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsR2V0VmVydGV4QXR0cmliZnYoaW5kZXgsIHBuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gTi5CLiBUaGlzIGZ1bmN0aW9uIG1heSBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgdmVydGV4IGF0dHJpYnV0ZSB3YXMgc3BlY2lmaWVkIHVzaW5nIHRoZSBmdW5jdGlvbiBnbFZlcnRleEF0dHJpYipmKCksXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgcmVzdWx0cyBhcmUgdW5kZWZpbmVkLiAoR0xFUzMgc3BlYyA2LjEuMTIpXG4gICAgICAgIGVtc2NyaXB0ZW5XZWJHTEdldFZlcnRleEF0dHJpYihpbmRleCwgcG5hbWUsIHBhcmFtcywgMik7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsR2V0VmVydGV4QXR0cmliZnYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJpdihpbmRleCwgcG5hbWUsIHBhcmFtcykge1xuICAgICAgICAvLyBOLkIuIFRoaXMgZnVuY3Rpb24gbWF5IG9ubHkgYmUgY2FsbGVkIGlmIHRoZSB2ZXJ0ZXggYXR0cmlidXRlIHdhcyBzcGVjaWZpZWQgdXNpbmcgdGhlIGZ1bmN0aW9uIGdsVmVydGV4QXR0cmliKmYoKSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSByZXN1bHRzIGFyZSB1bmRlZmluZWQuIChHTEVTMyBzcGVjIDYuMS4xMilcbiAgICAgICAgZW1zY3JpcHRlbldlYkdMR2V0VmVydGV4QXR0cmliKGluZGV4LCBwbmFtZSwgcGFyYW1zLCA1KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJpdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbEhpbnQoeDAsIHgxKSB7IEdMY3R4WydoaW50J10oeDAsIHgxKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xIaW50LnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xJc0J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIGIgPSBHTC5idWZmZXJzW2J1ZmZlcl07XG4gICAgICAgIGlmICghYikgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHTGN0eC5pc0J1ZmZlcihiKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc0J1ZmZlci5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xJc0VuYWJsZWQoeDApIHsgcmV0dXJuIEdMY3R4Wydpc0VuYWJsZWQnXSh4MCkgfVxuICAgIF9lbXNjcmlwdGVuX2dsSXNFbmFibGVkLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbElzRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgdmFyIGZiID0gR0wuZnJhbWVidWZmZXJzW2ZyYW1lYnVmZmVyXTtcbiAgICAgICAgaWYgKCFmYikgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHTGN0eC5pc0ZyYW1lYnVmZmVyKGZiKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc0ZyYW1lYnVmZmVyLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbElzUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0gPSBHTC5wcm9ncmFtc1twcm9ncmFtXTtcbiAgICAgICAgaWYgKCFwcm9ncmFtKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIEdMY3R4LmlzUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc1Byb2dyYW0uc2lnID0gJ2lpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsSXNRdWVyeUVYVChpZCkge1xuICAgICAgICB2YXIgcXVlcnkgPSBHTC5xdWVyaWVzW2lkXTtcbiAgICAgICAgaWYgKCFxdWVyeSkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHRbJ2lzUXVlcnlFWFQnXShxdWVyeSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsSXNRdWVyeUVYVC5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xJc1JlbmRlcmJ1ZmZlcihyZW5kZXJidWZmZXIpIHtcbiAgICAgICAgdmFyIHJiID0gR0wucmVuZGVyYnVmZmVyc1tyZW5kZXJidWZmZXJdO1xuICAgICAgICBpZiAoIXJiKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIEdMY3R4LmlzUmVuZGVyYnVmZmVyKHJiKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc1JlbmRlcmJ1ZmZlci5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xJc1NoYWRlcihzaGFkZXIpIHtcbiAgICAgICAgdmFyIHMgPSBHTC5zaGFkZXJzW3NoYWRlcl07XG4gICAgICAgIGlmICghcykgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHTGN0eC5pc1NoYWRlcihzKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc1NoYWRlci5zaWcgPSAnaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xJc1RleHR1cmUoaWQpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBHTC50ZXh0dXJlc1tpZF07XG4gICAgICAgIGlmICghdGV4dHVyZSkgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHTGN0eC5pc1RleHR1cmUodGV4dHVyZSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsSXNUZXh0dXJlLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbElzVmVydGV4QXJyYXlPRVMoYXJyYXkpIHtcblxuICAgICAgICB2YXIgdmFvID0gR0wudmFvc1thcnJheV07XG4gICAgICAgIGlmICghdmFvKSByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIEdMY3R4Wydpc1ZlcnRleEFycmF5J10odmFvKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xJc1ZlcnRleEFycmF5T0VTLnNpZyA9ICdpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbExpbmVXaWR0aCh4MCkgeyBHTGN0eFsnbGluZVdpZHRoJ10oeDApIH1cbiAgICBfZW1zY3JpcHRlbl9nbExpbmVXaWR0aC5zaWcgPSAndmYnO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xMaW5rUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0gPSBHTC5wcm9ncmFtc1twcm9ncmFtXTtcbiAgICAgICAgR0xjdHgubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIEludmFsaWRhdGUgZWFybGllciBjb21wdXRlZCB1bmlmb3JtLT5JRCBtYXBwaW5ncywgdGhvc2UgaGF2ZSBub3cgYmVjb21lIHN0YWxlXG4gICAgICAgIHByb2dyYW0udW5pZm9ybUxvY3NCeUlkID0gMDsgLy8gTWFyayBhcyBudWxsLWxpa2Ugc28gdGhhdCBnbEdldFVuaWZvcm1Mb2NhdGlvbigpIGtub3dzIHRvIHBvcHVsYXRlIHRoaXMgYWdhaW4uXG4gICAgICAgIHByb2dyYW0udW5pZm9ybVNpemVBbmRJZHNCeU5hbWUgPSB7fTtcblxuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbExpbmtQcm9ncmFtLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFBpeGVsU3RvcmVpKHBuYW1lLCBwYXJhbSkge1xuICAgICAgICBpZiAocG5hbWUgPT0gMHhDRjUgLyogR0xfVU5QQUNLX0FMSUdOTUVOVCAqLykge1xuICAgICAgICAgICAgR0wudW5wYWNrQWxpZ25tZW50ID0gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgR0xjdHgucGl4ZWxTdG9yZWkocG5hbWUsIHBhcmFtKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xQaXhlbFN0b3JlaS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsUG9seWdvbk9mZnNldCh4MCwgeDEpIHsgR0xjdHhbJ3BvbHlnb25PZmZzZXQnXSh4MCwgeDEpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFBvbHlnb25PZmZzZXQuc2lnID0gJ3ZmZic7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFF1ZXJ5Q291bnRlckVYVChpZCwgdGFyZ2V0KSB7XG4gICAgICAgIEdMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dFsncXVlcnlDb3VudGVyRVhUJ10oR0wucXVlcmllc1tpZF0sIHRhcmdldCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsUXVlcnlDb3VudGVyRVhULnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVVucGFja0FsaWduZWRJbWFnZVNpemUod2lkdGgsIGhlaWdodCwgc2l6ZVBlclBpeGVsLCBhbGlnbm1lbnQpIHtcbiAgICAgICAgZnVuY3Rpb24gcm91bmRlZFRvTmV4dE11bHRpcGxlT2YoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuICh4ICsgeSAtIDEpICYgLXk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsYWluUm93U2l6ZSA9IHdpZHRoICogc2l6ZVBlclBpeGVsO1xuICAgICAgICB2YXIgYWxpZ25lZFJvd1NpemUgPSByb3VuZGVkVG9OZXh0TXVsdGlwbGVPZihwbGFpblJvd1NpemUsIGFsaWdubWVudCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQgKiBhbGlnbmVkUm93U2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfX2NvbG9yQ2hhbm5lbHNJbkdsVGV4dHVyZUZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgLy8gTWljcm8tb3B0aW1pemF0aW9ucyBmb3Igc2l6ZTogbWFwIGZvcm1hdCB0byBzaXplIGJ5IHN1YnRyYWN0aW5nIHNtYWxsZXN0IGVudW0gdmFsdWUgKDB4MTkwMikgZnJvbSBhbGwgdmFsdWVzIGZpcnN0LlxuICAgICAgICAvLyBBbHNvIG9taXQgdGhlIG1vc3QgY29tbW9uIHNpemUgdmFsdWUgKDEpIGZyb20gdGhlIGxpc3QsIHdoaWNoIGlzIGFzc3VtZWQgYnkgZm9ybWF0cyBub3Qgb24gdGhlIGxpc3QuXG4gICAgICAgIHZhciBjb2xvckNoYW5uZWxzID0ge1xuICAgICAgICAgICAgLy8gMHgxOTAyIC8qIEdMX0RFUFRIX0NPTVBPTkVOVCAqLyAtIDB4MTkwMjogMSxcbiAgICAgICAgICAgIC8vIDB4MTkwNiAvKiBHTF9BTFBIQSAqLyAtIDB4MTkwMjogMSxcbiAgICAgICAgICAgIDU6IDMsXG4gICAgICAgICAgICA2OiA0LFxuICAgICAgICAgICAgLy8gMHgxOTA5IC8qIEdMX0xVTUlOQU5DRSAqLyAtIDB4MTkwMjogMSxcbiAgICAgICAgICAgIDg6IDIsXG4gICAgICAgICAgICAyOTUwMjogMyxcbiAgICAgICAgICAgIDI5NTA0OiA0LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29sb3JDaGFubmVsc1tmb3JtYXQgLSAweDE5MDJdIHx8IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGVhcE9iamVjdEZvcldlYkdMVHlwZSh0eXBlKSB7XG4gICAgICAgIC8vIE1pY3JvLW9wdGltaXphdGlvbiBmb3Igc2l6ZTogU3VidHJhY3QgbG93ZXN0IEdMIGVudW0gbnVtYmVyICgweDE0MDAvKiBHTF9CWVRFICovKSBmcm9tIHR5cGUgdG8gY29tcGFyZVxuICAgICAgICAvLyBzbWFsbGVyIHZhbHVlcyBmb3IgdGhlIGhlYXAsIGZvciBzaG9ydGVyIGdlbmVyYXRlZCBjb2RlIHNpemUuXG4gICAgICAgIC8vIEFsc28gdGhlIHR5cGUgSEVBUFUxNiBpcyBub3QgdGVzdGVkIGZvciBleHBsaWNpdGx5LCBidXQgYW55IHVucmVjb2duaXplZCB0eXBlIHdpbGwgcmV0dXJuIG91dCBIRUFQVTE2LlxuICAgICAgICAvLyAoc2luY2UgbW9zdCB0eXBlcyBhcmUgSEVBUFUxNilcbiAgICAgICAgdHlwZSAtPSAweDE0MDA7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gMSkgcmV0dXJuIEhFQVBVODtcblxuICAgICAgICBpZiAodHlwZSA9PSA0KSByZXR1cm4gSEVBUDMyO1xuXG4gICAgICAgIGlmICh0eXBlID09IDYpIHJldHVybiBIRUFQRjMyO1xuXG4gICAgICAgIGlmICh0eXBlID09IDVcbiAgICAgICAgICAgIHx8IHR5cGUgPT0gMjg5MjJcbiAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIEhFQVBVMzI7XG5cbiAgICAgICAgcmV0dXJuIEhFQVBVMTY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwKGhlYXApIHtcbiAgICAgICAgcmV0dXJuIDMxIC0gTWF0aC5jbHozMihoZWFwLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1zY3JpcHRlbldlYkdMR2V0VGV4UGl4ZWxEYXRhKHR5cGUsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgcGl4ZWxzLCBpbnRlcm5hbEZvcm1hdCkge1xuICAgICAgICB2YXIgaGVhcCA9IGhlYXBPYmplY3RGb3JXZWJHTFR5cGUodHlwZSk7XG4gICAgICAgIHZhciBzaGlmdCA9IGhlYXBBY2Nlc3NTaGlmdEZvcldlYkdMSGVhcChoZWFwKTtcbiAgICAgICAgdmFyIGJ5dGVTaXplID0gMSA8PCBzaGlmdDtcbiAgICAgICAgdmFyIHNpemVQZXJQaXhlbCA9IF9fY29sb3JDaGFubmVsc0luR2xUZXh0dXJlRm9ybWF0KGZvcm1hdCkgKiBieXRlU2l6ZTtcbiAgICAgICAgdmFyIGJ5dGVzID0gY29tcHV0ZVVucGFja0FsaWduZWRJbWFnZVNpemUod2lkdGgsIGhlaWdodCwgc2l6ZVBlclBpeGVsLCBHTC51bnBhY2tBbGlnbm1lbnQpO1xuICAgICAgICByZXR1cm4gaGVhcC5zdWJhcnJheShwaXhlbHMgPj4gc2hpZnQsIHBpeGVscyArIGJ5dGVzID4+IHNoaWZ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xSZWFkUGl4ZWxzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgcGl4ZWxzKSB7XG4gICAgICAgIHZhciBwaXhlbERhdGEgPSBlbXNjcmlwdGVuV2ViR0xHZXRUZXhQaXhlbERhdGEodHlwZSwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBwaXhlbHMsIGZvcm1hdCk7XG4gICAgICAgIGlmICghcGl4ZWxEYXRhKSB7XG4gICAgICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMC8qR0xfSU5WQUxJRF9FTlVNKi8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwaXhlbERhdGEpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFJlYWRQaXhlbHMuc2lnID0gJ3ZpaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsUmVsZWFzZVNoYWRlckNvbXBpbGVyKCkge1xuICAgICAgICAvLyBOT1AgKGFzIGFsbG93ZWQgYnkgR0xFUyAyLjAgc3BlYylcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xSZWxlYXNlU2hhZGVyQ29tcGlsZXIuc2lnID0gJ3YnO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xSZW5kZXJidWZmZXJTdG9yYWdlKHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4WydyZW5kZXJidWZmZXJTdG9yYWdlJ10oeDAsIHgxLCB4MiwgeDMpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFJlbmRlcmJ1ZmZlclN0b3JhZ2Uuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsU2FtcGxlQ292ZXJhZ2UodmFsdWUsIGludmVydCkge1xuICAgICAgICBHTGN0eC5zYW1wbGVDb3ZlcmFnZSh2YWx1ZSwgISFpbnZlcnQpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFNhbXBsZUNvdmVyYWdlLnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xTY2lzc29yKHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4WydzY2lzc29yJ10oeDAsIHgxLCB4MiwgeDMpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFNjaXNzb3Iuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsU2hhZGVyQmluYXJ5KCkge1xuICAgICAgICBHTC5yZWNvcmRFcnJvcigweDUwMC8qR0xfSU5WQUxJRF9FTlVNKi8pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFNoYWRlckJpbmFyeS5zaWcgPSAndic7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFNoYWRlclNvdXJjZShzaGFkZXIsIGNvdW50LCBzdHJpbmcsIGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gR0wuZ2V0U291cmNlKHNoYWRlciwgY291bnQsIHN0cmluZywgbGVuZ3RoKTtcblxuICAgICAgICBHTGN0eC5zaGFkZXJTb3VyY2UoR0wuc2hhZGVyc1tzaGFkZXJdLCBzb3VyY2UpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFNoYWRlclNvdXJjZS5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsRnVuYyh4MCwgeDEsIHgyKSB7IEdMY3R4WydzdGVuY2lsRnVuYyddKHgwLCB4MSwgeDIpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFN0ZW5jaWxGdW5jLnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsU3RlbmNpbEZ1bmNTZXBhcmF0ZSh4MCwgeDEsIHgyLCB4MykgeyBHTGN0eFsnc3RlbmNpbEZ1bmNTZXBhcmF0ZSddKHgwLCB4MSwgeDIsIHgzKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsRnVuY1NlcGFyYXRlLnNpZyA9ICd2aWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFN0ZW5jaWxNYXNrKHgwKSB7IEdMY3R4WydzdGVuY2lsTWFzayddKHgwKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsTWFzay5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsTWFza1NlcGFyYXRlKHgwLCB4MSkgeyBHTGN0eFsnc3RlbmNpbE1hc2tTZXBhcmF0ZSddKHgwLCB4MSkgfVxuICAgIF9lbXNjcmlwdGVuX2dsU3RlbmNpbE1hc2tTZXBhcmF0ZS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsU3RlbmNpbE9wKHgwLCB4MSwgeDIpIHsgR0xjdHhbJ3N0ZW5jaWxPcCddKHgwLCB4MSwgeDIpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFN0ZW5jaWxPcC5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFN0ZW5jaWxPcFNlcGFyYXRlKHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4WydzdGVuY2lsT3BTZXBhcmF0ZSddKHgwLCB4MSwgeDIsIHgzKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsT3BTZXBhcmF0ZS5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xUZXhJbWFnZTJEKHRhcmdldCwgbGV2ZWwsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBib3JkZXIsIGZvcm1hdCwgdHlwZSwgcGl4ZWxzKSB7XG4gICAgICAgIEdMY3R4LnRleEltYWdlMkQodGFyZ2V0LCBsZXZlbCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIGJvcmRlciwgZm9ybWF0LCB0eXBlLCBwaXhlbHMgPyBlbXNjcmlwdGVuV2ViR0xHZXRUZXhQaXhlbERhdGEodHlwZSwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBwaXhlbHMsIGludGVybmFsRm9ybWF0KSA6IG51bGwpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFRleEltYWdlMkQuc2lnID0gJ3ZpaWlpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJmKHgwLCB4MSwgeDIpIHsgR0xjdHhbJ3RleFBhcmFtZXRlcmYnXSh4MCwgeDEsIHgyKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJmLnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyZnYodGFyZ2V0LCBwbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IEhFQVBGMzJbKChwYXJhbXMpID4+IDIpXTtcbiAgICAgICAgR0xjdHgudGV4UGFyYW1ldGVyZih0YXJnZXQsIHBuYW1lLCBwYXJhbSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyZnYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJpKHgwLCB4MSwgeDIpIHsgR0xjdHhbJ3RleFBhcmFtZXRlcmknXSh4MCwgeDEsIHgyKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJpLnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyaXYodGFyZ2V0LCBwbmFtZSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXJhbSA9IEhFQVAzMlsoKHBhcmFtcykgPj4gMildO1xuICAgICAgICBHTGN0eC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgcG5hbWUsIHBhcmFtKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJpdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeG9mZnNldCwgeW9mZnNldCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwaXhlbHMpIHtcbiAgICAgICAgdmFyIHBpeGVsRGF0YSA9IG51bGw7XG4gICAgICAgIGlmIChwaXhlbHMpIHBpeGVsRGF0YSA9IGVtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YSh0eXBlLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIHBpeGVscywgMCk7XG4gICAgICAgIEdMY3R4LnRleFN1YkltYWdlMkQodGFyZ2V0LCBsZXZlbCwgeG9mZnNldCwgeW9mZnNldCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwaXhlbERhdGEpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFRleFN1YkltYWdlMkQuc2lnID0gJ3ZpaWlpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWYobG9jYXRpb24sIHYwKSB7XG4gICAgICAgIEdMY3R4LnVuaWZvcm0xZih3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHYwKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWYuc2lnID0gJ3ZpZic7XG5cbiAgICB2YXIgbWluaVRlbXBXZWJHTEZsb2F0QnVmZmVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTFmdihsb2NhdGlvbiwgY291bnQsIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGNvdW50IDw9IDI4OCkge1xuICAgICAgICAgICAgLy8gYXZvaWQgYWxsb2NhdGlvbiB3aGVuIHVwbG9hZGluZyBmZXcgZW5vdWdoIHVuaWZvcm1zXG4gICAgICAgICAgICB2YXIgdmlldyA9IG1pbmlUZW1wV2ViR0xGbG9hdEJ1ZmZlcnNbY291bnQgLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gSEVBUEYzMi5zdWJhcnJheSgodmFsdWUpID4+IDIsICh2YWx1ZSArIGNvdW50ICogNCkgPj4gMik7XG4gICAgICAgIH1cbiAgICAgICAgR0xjdHgudW5pZm9ybTFmdih3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHZpZXcpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm0xZnYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWkobG9jYXRpb24sIHYwKSB7XG4gICAgICAgIEdMY3R4LnVuaWZvcm0xaSh3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHYwKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWkuc2lnID0gJ3ZpaSc7XG5cbiAgICB2YXIgX19taW5pVGVtcFdlYkdMSW50QnVmZmVycyA9IFtdO1xuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTFpdihsb2NhdGlvbiwgY291bnQsIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGNvdW50IDw9IDI4OCkge1xuICAgICAgICAgICAgLy8gYXZvaWQgYWxsb2NhdGlvbiB3aGVuIHVwbG9hZGluZyBmZXcgZW5vdWdoIHVuaWZvcm1zXG4gICAgICAgICAgICB2YXIgdmlldyA9IF9fbWluaVRlbXBXZWJHTEludEJ1ZmZlcnNbY291bnQgLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQMzJbKCgodmFsdWUpICsgKDQgKiBpKSkgPj4gMildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBIRUFQMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDQpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm0xaXYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCB2aWV3KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWl2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTJmKGxvY2F0aW9uLCB2MCwgdjEpIHtcbiAgICAgICAgR0xjdHgudW5pZm9ybTJmKHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgdjAsIHYxKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmYuc2lnID0gJ3ZpZmYnO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmZ2KGxvY2F0aW9uLCBjb3VudCwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gMTQ0KSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbGxvY2F0aW9uIHdoZW4gdXBsb2FkaW5nIGZldyBlbm91Z2ggdW5pZm9ybXNcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbWluaVRlbXBXZWJHTEZsb2F0QnVmZmVyc1syICogY291bnQgLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMiAqIGNvdW50OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gSEVBUEYzMlsoKCh2YWx1ZSkgKyAoNCAqIGkpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMV0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSArIDQpKSA+PiAyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IEhFQVBGMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDgpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm0yZnYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCB2aWV3KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmZ2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTJpKGxvY2F0aW9uLCB2MCwgdjEpIHtcbiAgICAgICAgR0xjdHgudW5pZm9ybTJpKHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgdjAsIHYxKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmkuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMml2KGxvY2F0aW9uLCBjb3VudCwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gMTQ0KSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbGxvY2F0aW9uIHdoZW4gdXBsb2FkaW5nIGZldyBlbm91Z2ggdW5pZm9ybXNcbiAgICAgICAgICAgIHZhciB2aWV3ID0gX19taW5pVGVtcFdlYkdMSW50QnVmZmVyc1syICogY291bnQgLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMiAqIGNvdW50OyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gSEVBUDMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAxXSA9IEhFQVAzMlsoKCh2YWx1ZSkgKyAoNCAqIGkgKyA0KSkgPj4gMildO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBIRUFQMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDgpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm0yaXYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCB2aWV3KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMml2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTNmKGxvY2F0aW9uLCB2MCwgdjEsIHYyKSB7XG4gICAgICAgIEdMY3R4LnVuaWZvcm0zZih3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHYwLCB2MSwgdjIpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm0zZi5zaWcgPSAndmlmZmYnO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2Z2KGxvY2F0aW9uLCBjb3VudCwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gOTYpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIGFsbG9jYXRpb24gd2hlbiB1cGxvYWRpbmcgZmV3IGVub3VnaCB1bmlmb3Jtc1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzWzMgKiBjb3VudCAtIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzICogY291bnQ7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAxXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgNCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAyXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgOCkpID4+IDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gSEVBUEYzMi5zdWJhcnJheSgodmFsdWUpID4+IDIsICh2YWx1ZSArIGNvdW50ICogMTIpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm0zZnYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCB2aWV3KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2Z2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTNpKGxvY2F0aW9uLCB2MCwgdjEsIHYyKSB7XG4gICAgICAgIEdMY3R4LnVuaWZvcm0zaSh3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHYwLCB2MSwgdjIpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm0zaS5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2l2KGxvY2F0aW9uLCBjb3VudCwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gOTYpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIGFsbG9jYXRpb24gd2hlbiB1cGxvYWRpbmcgZmV3IGVub3VnaCB1bmlmb3Jtc1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBfX21pbmlUZW1wV2ViR0xJbnRCdWZmZXJzWzMgKiBjb3VudCAtIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzICogY291bnQ7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQMzJbKCgodmFsdWUpICsgKDQgKiBpKSkgPj4gMildO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDFdID0gSEVBUDMyWygoKHZhbHVlKSArICg0ICogaSArIDQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMl0gPSBIRUFQMzJbKCgodmFsdWUpICsgKDQgKiBpICsgOCkpID4+IDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gSEVBUDMyLnN1YmFycmF5KCh2YWx1ZSkgPj4gMiwgKHZhbHVlICsgY291bnQgKiAxMikgPj4gMik7XG4gICAgICAgIH1cbiAgICAgICAgR0xjdHgudW5pZm9ybTNpdih3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHZpZXcpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm0zaXYuc2lnID0gJ3ZpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGYobG9jYXRpb24sIHYwLCB2MSwgdjIsIHYzKSB7XG4gICAgICAgIEdMY3R4LnVuaWZvcm00Zih3ZWJnbEdldFVuaWZvcm1Mb2NhdGlvbihsb2NhdGlvbiksIHYwLCB2MSwgdjIsIHYzKTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGYuc2lnID0gJ3ZpZmZmZic7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFVuaWZvcm00ZnYobG9jYXRpb24sIGNvdW50LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChjb3VudCA8PSA3Mikge1xuICAgICAgICAgICAgLy8gYXZvaWQgYWxsb2NhdGlvbiB3aGVuIHVwbG9hZGluZyBmZXcgZW5vdWdoIHVuaWZvcm1zXG4gICAgICAgICAgICB2YXIgdmlldyA9IG1pbmlUZW1wV2ViR0xGbG9hdEJ1ZmZlcnNbNCAqIGNvdW50IC0gMV07XG4gICAgICAgICAgICAvLyBob2lzdCB0aGUgaGVhcCBvdXQgb2YgdGhlIGxvb3AgZm9yIHNpemUgYW5kIGZvciBwdGhyZWFkcytncm93dGguXG4gICAgICAgICAgICB2YXIgaGVhcCA9IEhFQVBGMzI7XG4gICAgICAgICAgICB2YWx1ZSA+Pj0gMjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAqIGNvdW50OyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHN0ID0gdmFsdWUgKyBpO1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBoZWFwW2RzdF07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMV0gPSBoZWFwW2RzdCArIDFdO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDJdID0gaGVhcFtkc3QgKyAyXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAzXSA9IGhlYXBbZHN0ICsgM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IEhFQVBGMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDE2KSA+PiAyKTtcbiAgICAgICAgfVxuICAgICAgICBHTGN0eC51bmlmb3JtNGZ2KHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgdmlldyk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTRmdi5zaWcgPSAndmlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFVuaWZvcm00aShsb2NhdGlvbiwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgICAgICAgR0xjdHgudW5pZm9ybTRpKHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgdjAsIHYxLCB2MiwgdjMpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm00aS5zaWcgPSAndmlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybTRpdihsb2NhdGlvbiwgY291bnQsIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKGNvdW50IDw9IDcyKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBhbGxvY2F0aW9uIHdoZW4gdXBsb2FkaW5nIGZldyBlbm91Z2ggdW5pZm9ybXNcbiAgICAgICAgICAgIHZhciB2aWV3ID0gX19taW5pVGVtcFdlYkdMSW50QnVmZmVyc1s0ICogY291bnQgLSAxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAqIGNvdW50OyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2aWV3W2ldID0gSEVBUDMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAxXSA9IEhFQVAzMlsoKCh2YWx1ZSkgKyAoNCAqIGkgKyA0KSkgPj4gMildO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDJdID0gSEVBUDMyWygoKHZhbHVlKSArICg0ICogaSArIDgpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgM10gPSBIRUFQMzJbKCgodmFsdWUpICsgKDQgKiBpICsgMTIpKSA+PiAyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IEhFQVAzMi5zdWJhcnJheSgodmFsdWUpID4+IDIsICh2YWx1ZSArIGNvdW50ICogMTYpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm00aXYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCB2aWV3KTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGl2LnNpZyA9ICd2aWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgY291bnQsIHRyYW5zcG9zZSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gNzIpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIGFsbG9jYXRpb24gd2hlbiB1cGxvYWRpbmcgZmV3IGVub3VnaCB1bmlmb3Jtc1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzWzQgKiBjb3VudCAtIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICogY291bnQ7IGkgKz0gNCkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAxXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgNCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAyXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgOCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAzXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgMTIpKSA+PiAyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IEhFQVBGMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDE2KSA+PiAyKTtcbiAgICAgICAgfVxuICAgICAgICBHTGN0eC51bmlmb3JtTWF0cml4MmZ2KHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgISF0cmFuc3Bvc2UsIHZpZXcpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm1NYXRyaXgyZnYuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgY291bnQsIHRyYW5zcG9zZSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoY291bnQgPD0gMzIpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIGFsbG9jYXRpb24gd2hlbiB1cGxvYWRpbmcgZmV3IGVub3VnaCB1bmlmb3Jtc1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzWzkgKiBjb3VudCAtIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA5ICogY291bnQ7IGkgKz0gOSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAxXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgNCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAyXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgOCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAzXSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgMTIpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgNF0gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSArIDE2KSkgPj4gMildO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDVdID0gSEVBUEYzMlsoKCh2YWx1ZSkgKyAoNCAqIGkgKyAyMCkpID4+IDIpXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyA2XSA9IEhFQVBGMzJbKCgodmFsdWUpICsgKDQgKiBpICsgMjQpKSA+PiAyKV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgN10gPSBIRUFQRjMyWygoKHZhbHVlKSArICg0ICogaSArIDI4KSkgPj4gMildO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDhdID0gSEVBUEYzMlsoKCh2YWx1ZSkgKyAoNCAqIGkgKyAzMikpID4+IDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gSEVBUEYzMi5zdWJhcnJheSgodmFsdWUpID4+IDIsICh2YWx1ZSArIGNvdW50ICogMzYpID4+IDIpO1xuICAgICAgICB9XG4gICAgICAgIEdMY3R4LnVuaWZvcm1NYXRyaXgzZnYod2ViZ2xHZXRVbmlmb3JtTG9jYXRpb24obG9jYXRpb24pLCAhIXRyYW5zcG9zZSwgdmlldyk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVW5pZm9ybU1hdHJpeDNmdi5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBjb3VudCwgdHJhbnNwb3NlLCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChjb3VudCA8PSAxOCkge1xuICAgICAgICAgICAgLy8gYXZvaWQgYWxsb2NhdGlvbiB3aGVuIHVwbG9hZGluZyBmZXcgZW5vdWdoIHVuaWZvcm1zXG4gICAgICAgICAgICB2YXIgdmlldyA9IG1pbmlUZW1wV2ViR0xGbG9hdEJ1ZmZlcnNbMTYgKiBjb3VudCAtIDFdO1xuICAgICAgICAgICAgLy8gaG9pc3QgdGhlIGhlYXAgb3V0IG9mIHRoZSBsb29wIGZvciBzaXplIGFuZCBmb3IgcHRocmVhZHMrZ3Jvd3RoLlxuICAgICAgICAgICAgdmFyIGhlYXAgPSBIRUFQRjMyO1xuICAgICAgICAgICAgdmFsdWUgPj49IDI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2ICogY291bnQ7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHN0ID0gdmFsdWUgKyBpO1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBoZWFwW2RzdF07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMV0gPSBoZWFwW2RzdCArIDFdO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDJdID0gaGVhcFtkc3QgKyAyXTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyAzXSA9IGhlYXBbZHN0ICsgM107XG4gICAgICAgICAgICAgICAgdmlld1tpICsgNF0gPSBoZWFwW2RzdCArIDRdO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDVdID0gaGVhcFtkc3QgKyA1XTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyA2XSA9IGhlYXBbZHN0ICsgNl07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgN10gPSBoZWFwW2RzdCArIDddO1xuICAgICAgICAgICAgICAgIHZpZXdbaSArIDhdID0gaGVhcFtkc3QgKyA4XTtcbiAgICAgICAgICAgICAgICB2aWV3W2kgKyA5XSA9IGhlYXBbZHN0ICsgOV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTBdID0gaGVhcFtkc3QgKyAxMF07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTFdID0gaGVhcFtkc3QgKyAxMV07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTJdID0gaGVhcFtkc3QgKyAxMl07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTNdID0gaGVhcFtkc3QgKyAxM107XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTRdID0gaGVhcFtkc3QgKyAxNF07XG4gICAgICAgICAgICAgICAgdmlld1tpICsgMTVdID0gaGVhcFtkc3QgKyAxNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IEhFQVBGMzIuc3ViYXJyYXkoKHZhbHVlKSA+PiAyLCAodmFsdWUgKyBjb3VudCAqIDY0KSA+PiAyKTtcbiAgICAgICAgfVxuICAgICAgICBHTGN0eC51bmlmb3JtTWF0cml4NGZ2KHdlYmdsR2V0VW5pZm9ybUxvY2F0aW9uKGxvY2F0aW9uKSwgISF0cmFuc3Bvc2UsIHZpZXcpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFVuaWZvcm1NYXRyaXg0ZnYuc2lnID0gJ3ZpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVXNlUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW0gPSBHTC5wcm9ncmFtc1twcm9ncmFtXTtcbiAgICAgICAgR0xjdHgudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjdXJyZW50bHkgYWN0aXZlIHByb2dyYW0gc28gdGhhdCB3ZSBjYW4gYWNjZXNzIHRoZSB1bmlmb3JtXG4gICAgICAgIC8vIG1hcHBpbmcgdGFibGUgb2YgdGhhdCBwcm9ncmFtLlxuICAgICAgICBHTGN0eC5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVXNlUHJvZ3JhbS5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xWYWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgICBHTGN0eC52YWxpZGF0ZVByb2dyYW0oR0wucHJvZ3JhbXNbcHJvZ3JhbV0pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFZhbGlkYXRlUHJvZ3JhbS5zaWcgPSAndmknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIxZih4MCwgeDEpIHsgR0xjdHhbJ3ZlcnRleEF0dHJpYjFmJ10oeDAsIHgxKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIxZi5zaWcgPSAndmlmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliMWZ2KGluZGV4LCB2KSB7XG5cbiAgICAgICAgR0xjdHgudmVydGV4QXR0cmliMWYoaW5kZXgsIEhFQVBGMzJbdiA+PiAyXSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliMWZ2LnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIyZih4MCwgeDEsIHgyKSB7IEdMY3R4Wyd2ZXJ0ZXhBdHRyaWIyZiddKHgwLCB4MSwgeDIpIH1cbiAgICBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjJmLnNpZyA9ICd2aWZmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliMmZ2KGluZGV4LCB2KSB7XG5cbiAgICAgICAgR0xjdHgudmVydGV4QXR0cmliMmYoaW5kZXgsIEhFQVBGMzJbdiA+PiAyXSwgSEVBUEYzMlt2ICsgNCA+PiAyXSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliMmZ2LnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIzZih4MCwgeDEsIHgyLCB4MykgeyBHTGN0eFsndmVydGV4QXR0cmliM2YnXSh4MCwgeDEsIHgyLCB4MykgfVxuICAgIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2Yuc2lnID0gJ3ZpZmZmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2Z2KGluZGV4LCB2KSB7XG5cbiAgICAgICAgR0xjdHgudmVydGV4QXR0cmliM2YoaW5kZXgsIEhFQVBGMzJbdiA+PiAyXSwgSEVBUEYzMlt2ICsgNCA+PiAyXSwgSEVBUEYzMlt2ICsgOCA+PiAyXSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2Z2LnNpZyA9ICd2aWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWI0Zih4MCwgeDEsIHgyLCB4MywgeDQpIHsgR0xjdHhbJ3ZlcnRleEF0dHJpYjRmJ10oeDAsIHgxLCB4MiwgeDMsIHg0KSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWI0Zi5zaWcgPSAndmlmZmZmJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliNGZ2KGluZGV4LCB2KSB7XG5cbiAgICAgICAgR0xjdHgudmVydGV4QXR0cmliNGYoaW5kZXgsIEhFQVBGMzJbdiA+PiAyXSwgSEVBUEYzMlt2ICsgNCA+PiAyXSwgSEVBUEYzMlt2ICsgOCA+PiAyXSwgSEVBUEYzMlt2ICsgMTIgPj4gMl0pO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjRmdi5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGluZGV4LCBkaXZpc29yKSB7XG4gICAgICAgIEdMY3R4Wyd2ZXJ0ZXhBdHRyaWJEaXZpc29yJ10oaW5kZXgsIGRpdmlzb3IpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRS5zaWcgPSAndmlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBwdHIpIHtcbiAgICAgICAgR0xjdHgudmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgISFub3JtYWxpemVkLCBzdHJpZGUsIHB0cik7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliUG9pbnRlci5zaWcgPSAndmlpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9nbFZpZXdwb3J0KHgwLCB4MSwgeDIsIHgzKSB7IEdMY3R4Wyd2aWV3cG9ydCddKHgwLCB4MSwgeDIsIHgzKSB9XG4gICAgX2Vtc2NyaXB0ZW5fZ2xWaWV3cG9ydC5zaWcgPSAndmlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5faGFzX2FzeW5jaWZ5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LCBzcmMsIG51bSkge1xuICAgICAgICBIRUFQVTguY29weVdpdGhpbihkZXN0LCBzcmMsIHNyYyArIG51bSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9SZXF1ZXN0RnVsbHNjcmVlbih0YXJnZXQsIHN0cmF0ZWd5KSB7XG4gICAgICAgIGlmICghSlNFdmVudHMuZnVsbHNjcmVlbkVuYWJsZWQoKSkgcmV0dXJuIC0xO1xuICAgICAgICB0YXJnZXQgPSBmaW5kRXZlbnRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybiAtNDtcblxuICAgICAgICBpZiAoIXRhcmdldC5yZXF1ZXN0RnVsbHNjcmVlblxuICAgICAgICAgICAgJiYgIXRhcmdldC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlblxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAtMztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW5QZXJmb3JtUmVxdWVzdHMgPSBKU0V2ZW50cy5jYW5QZXJmb3JtRXZlbnRIYW5kbGVyUmVxdWVzdHMoKTtcblxuICAgICAgICAvLyBRdWV1ZSB0aGlzIGZ1bmN0aW9uIGNhbGwgaWYgd2UncmUgbm90IGN1cnJlbnRseSBpbiBhbiBldmVudCBoYW5kbGVyIGFuZCB0aGUgdXNlciBzYXcgaXQgYXBwcm9wcmlhdGUgdG8gZG8gc28uXG4gICAgICAgIGlmICghY2FuUGVyZm9ybVJlcXVlc3RzKSB7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kuZGVmZXJVbnRpbEluRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgSlNFdmVudHMuZGVmZXJDYWxsKF9KU0V2ZW50c19yZXF1ZXN0RnVsbHNjcmVlbiwgMSAvKiBwcmlvcml0eSBvdmVyIHBvaW50ZXIgbG9jayAqLywgW3RhcmdldCwgc3RyYXRlZ3ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9KU0V2ZW50c19yZXF1ZXN0RnVsbHNjcmVlbih0YXJnZXQsIHN0cmF0ZWd5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVxdWVzdF9mdWxsc2NyZWVuX3N0cmF0ZWd5KHRhcmdldCwgZGVmZXJVbnRpbEluRXZlbnRIYW5kbGVyLCBmdWxsc2NyZWVuU3RyYXRlZ3kpIHtcbiAgICAgICAgdmFyIHN0cmF0ZWd5ID0ge1xuICAgICAgICAgICAgc2NhbGVNb2RlOiBIRUFQMzJbKChmdWxsc2NyZWVuU3RyYXRlZ3kpID4+IDIpXSxcbiAgICAgICAgICAgIGNhbnZhc1Jlc29sdXRpb25TY2FsZU1vZGU6IEhFQVAzMlsoKChmdWxsc2NyZWVuU3RyYXRlZ3kpICsgKDQpKSA+PiAyKV0sXG4gICAgICAgICAgICBmaWx0ZXJpbmdNb2RlOiBIRUFQMzJbKCgoZnVsbHNjcmVlblN0cmF0ZWd5KSArICg4KSkgPj4gMildLFxuICAgICAgICAgICAgZGVmZXJVbnRpbEluRXZlbnRIYW5kbGVyOiBkZWZlclVudGlsSW5FdmVudEhhbmRsZXIsXG4gICAgICAgICAgICBjYW52YXNSZXNpemVkQ2FsbGJhY2s6IEhFQVAzMlsoKChmdWxsc2NyZWVuU3RyYXRlZ3kpICsgKDEyKSkgPj4gMildLFxuICAgICAgICAgICAgY2FudmFzUmVzaXplZENhbGxiYWNrVXNlckRhdGE6IEhFQVAzMlsoKChmdWxsc2NyZWVuU3RyYXRlZ3kpICsgKDE2KSkgPj4gMildXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRvUmVxdWVzdEZ1bGxzY3JlZW4odGFyZ2V0LCBzdHJhdGVneSk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3JlcXVlc3RfZnVsbHNjcmVlbl9zdHJhdGVneS5zaWcgPSAnaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXF1ZXN0X3BvaW50ZXJsb2NrKHRhcmdldCwgZGVmZXJVbnRpbEluRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRhcmdldCA9IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuIC00O1xuICAgICAgICBpZiAoIXRhcmdldC5yZXF1ZXN0UG9pbnRlckxvY2tcbiAgICAgICAgICAgICYmICF0YXJnZXQubXNSZXF1ZXN0UG9pbnRlckxvY2tcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FuUGVyZm9ybVJlcXVlc3RzID0gSlNFdmVudHMuY2FuUGVyZm9ybUV2ZW50SGFuZGxlclJlcXVlc3RzKCk7XG5cbiAgICAgICAgLy8gUXVldWUgdGhpcyBmdW5jdGlvbiBjYWxsIGlmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaW4gYW4gZXZlbnQgaGFuZGxlciBhbmQgdGhlIHVzZXIgc2F3IGl0IGFwcHJvcHJpYXRlIHRvIGRvIHNvLlxuICAgICAgICBpZiAoIWNhblBlcmZvcm1SZXF1ZXN0cykge1xuICAgICAgICAgICAgaWYgKGRlZmVyVW50aWxJbkV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIEpTRXZlbnRzLmRlZmVyQ2FsbChyZXF1ZXN0UG9pbnRlckxvY2ssIDIgLyogcHJpb3JpdHkgYmVsb3cgZnVsbHNjcmVlbiAqLywgW3RhcmdldF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWVzdFBvaW50ZXJMb2NrKHRhcmdldCk7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3JlcXVlc3RfcG9pbnRlcmxvY2suc2lnID0gJ2lpaSc7XG5cbiAgICBmdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeShyZXF1ZXN0ZWRTaXplKSB7XG4gICAgICAgIGFib3J0KCdDYW5ub3QgZW5sYXJnZSBtZW1vcnkgYXJyYXlzIHRvIHNpemUgJyArIHJlcXVlc3RlZFNpemUgKyAnIGJ5dGVzIChPT00pLiBFaXRoZXIgKDEpIGNvbXBpbGUgd2l0aCAgLXMgSU5JVElBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICcgKyBIRUFQOC5sZW5ndGggKyAnLCAoMikgY29tcGlsZSB3aXRoICAtcyBBTExPV19NRU1PUllfR1JPV1RIPTEgIHdoaWNoIGFsbG93cyBpbmNyZWFzaW5nIHRoZSBzaXplIGF0IHJ1bnRpbWUsIG9yICgzKSBpZiB5b3Ugd2FudCBtYWxsb2MgdG8gcmV0dXJuIE5VTEwgKDApIGluc3RlYWQgb2YgdGhpcyBhYm9ydCwgY29tcGlsZSB3aXRoICAtcyBBQk9SVElOR19NQUxMT0M9MCAnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gICAgICAgIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuICAgICAgICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeShyZXF1ZXN0ZWRTaXplKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zYW1wbGVfZ2FtZXBhZF9kYXRhKCkge1xuICAgICAgICByZXR1cm4gKEpTRXZlbnRzLmxhc3RHYW1lcGFkU3RhdGUgPSAobmF2aWdhdG9yLmdldEdhbWVwYWRzID8gbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkgOiAobmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzID8gbmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzKCkgOiBudWxsKSkpXG4gICAgICAgICAgICA/IDAgOiAtMTtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2FtcGxlX2dhbWVwYWRfZGF0YS5zaWcgPSAnaSc7XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlckJlZm9yZVVubG9hZEV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCBldmVudFR5cGVJZCwgZXZlbnRUeXBlU3RyaW5nKSB7XG4gICAgICAgIHZhciBiZWZvcmVVbmxvYWRFdmVudEhhbmRsZXJGdW5jID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2IHx8IGV2ZW50O1xuXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGFsd2F5cyBjYWxsZWQgb24gdGhlIG1haW4gYnJvd3NlciB0aHJlYWQsIHNpbmNlIGl0IG5lZWRzIHN5bmNocm9ub3VzbHkgcmV0dXJuIGEgdmFsdWUhXG4gICAgICAgICAgICB2YXIgY29uZmlybWF0aW9uTWVzc2FnZSA9IGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIDAsIHVzZXJEYXRhKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25maXJtYXRpb25NZXNzYWdlID0gVVRGOFRvU3RyaW5nKGNvbmZpcm1hdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbk1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICAgIHRhcmdldDogZmluZEV2ZW50VGFyZ2V0KHRhcmdldCksXG4gICAgICAgICAgICBldmVudFR5cGVTdHJpbmc6IGV2ZW50VHlwZVN0cmluZyxcbiAgICAgICAgICAgIGNhbGxiYWNrZnVuYzogY2FsbGJhY2tmdW5jLFxuICAgICAgICAgICAgaGFuZGxlckZ1bmM6IGJlZm9yZVVubG9hZEV2ZW50SGFuZGxlckZ1bmMsXG4gICAgICAgICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgICAgIH07XG4gICAgICAgIEpTRXZlbnRzLnJlZ2lzdGVyT3JSZW1vdmVIYW5kbGVyKGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9iZWZvcmV1bmxvYWRfY2FsbGJhY2tfb25fdGhyZWFkKHVzZXJEYXRhLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9uYmVmb3JldW5sb2FkID09ICd1bmRlZmluZWQnKSByZXR1cm4gLTE7XG4gICAgICAgIC8vIGJlZm9yZXVubG9hZCBjYWxsYmFjayBjYW4gb25seSBiZSByZWdpc3RlcmVkIG9uIHRoZSBtYWluIGJyb3dzZXIgdGhyZWFkLCBiZWNhdXNlIHRoZSBwYWdlIHdpbGwgZ28gYXdheSBpbW1lZGlhdGVseSBhZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgaGFuZGxlcixcbiAgICAgICAgLy8gYW5kIHRoZXJlIGlzIG5vIHRpbWUgdG8gc3RhcnQgcHJveHlpbmcgaXQgYW55d2hlcmUuXG4gICAgICAgIGlmICh0YXJnZXRUaHJlYWQgIT09IDEpIHJldHVybiAtNTtcbiAgICAgICAgcmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrKDIsIHVzZXJEYXRhLCB0cnVlLCBjYWxsYmFja2Z1bmMsIDI4LCBcImJlZm9yZXVubG9hZFwiKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF9iZWZvcmV1bmxvYWRfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWknO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGb2N1c0V2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCBldmVudFR5cGVJZCwgZXZlbnRUeXBlU3RyaW5nLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgaWYgKCFKU0V2ZW50cy5mb2N1c0V2ZW50KSBKU0V2ZW50cy5mb2N1c0V2ZW50ID0gX21hbGxvYygyNTYpO1xuXG4gICAgICAgIHZhciBmb2N1c0V2ZW50SGFuZGxlckZ1bmMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXYgfHwgZXZlbnQ7XG5cbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IEpTRXZlbnRzLmdldE5vZGVOYW1lRm9yVGFyZ2V0KGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBpZCA9IGUudGFyZ2V0LmlkID8gZS50YXJnZXQuaWQgOiAnJztcblxuICAgICAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBKU0V2ZW50cy5mb2N1c0V2ZW50O1xuICAgICAgICAgICAgc3RyaW5nVG9VVEY4KG5vZGVOYW1lLCBmb2N1c0V2ZW50ICsgMCwgMTI4KTtcbiAgICAgICAgICAgIHN0cmluZ1RvVVRGOChpZCwgZm9jdXNFdmVudCArIDEyOCwgMTI4KTtcblxuICAgICAgICAgICAgaWYgKGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIGZvY3VzRXZlbnQsIHVzZXJEYXRhKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpLFxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiBmb2N1c0V2ZW50SGFuZGxlckZ1bmMsXG4gICAgICAgICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgICAgIH07XG4gICAgICAgIEpTRXZlbnRzLnJlZ2lzdGVyT3JSZW1vdmVIYW5kbGVyKGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9ibHVyX2NhbGxiYWNrX29uX3RocmVhZCh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICByZWdpc3RlckZvY3VzRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDEyLCBcImJsdXJcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF9ibHVyX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2VsZW1lbnRfY3NzX3NpemUodGFyZ2V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldCA9IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuIC00O1xuXG4gICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfZWxlbWVudF9jc3Nfc2l6ZS5zaWcgPSAnaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfZm9jdXNfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMTMsIFwiZm9jdXNcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF9mb2N1c19jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBmaWxsRnVsbHNjcmVlbkNoYW5nZUV2ZW50RGF0YShldmVudFN0cnVjdCkge1xuICAgICAgICB2YXIgZnVsbHNjcmVlbkVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICB2YXIgaXNGdWxsc2NyZWVuID0gISFmdWxsc2NyZWVuRWxlbWVudDtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgYm9vbGVhbiB0byBIRUFQMzIgd2l0aCBleHBlY3RlZCB0eXBlIGNvZXJjaW9uLlxuICAgICAgICAvKiogQHN1cHByZXNze2NoZWNrVHlwZXN9ICovXG4gICAgICAgIEhFQVAzMlsoKGV2ZW50U3RydWN0KSA+PiAyKV0gPSBpc0Z1bGxzY3JlZW47XG4gICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCkgKyAoNCkpID4+IDIpXSA9IEpTRXZlbnRzLmZ1bGxzY3JlZW5FbmFibGVkKCk7XG4gICAgICAgIC8vIElmIHRyYW5zaXRpb25pbmcgdG8gZnVsbHNjcmVlbiwgcmVwb3J0IGluZm8gYWJvdXQgdGhlIGVsZW1lbnQgdGhhdCBpcyBub3cgZnVsbHNjcmVlbi5cbiAgICAgICAgLy8gSWYgdHJhbnNpdGlvbmluZyB0byB3aW5kb3dlZCBtb2RlLCByZXBvcnQgaW5mbyBhYm91dCB0aGUgZWxlbWVudCB0aGF0IGp1c3Qgd2FzIGZ1bGxzY3JlZW4uXG4gICAgICAgIHZhciByZXBvcnRlZEVsZW1lbnQgPSBpc0Z1bGxzY3JlZW4gPyBmdWxsc2NyZWVuRWxlbWVudCA6IEpTRXZlbnRzLnByZXZpb3VzRnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IEpTRXZlbnRzLmdldE5vZGVOYW1lRm9yVGFyZ2V0KHJlcG9ydGVkRWxlbWVudCk7XG4gICAgICAgIHZhciBpZCA9IChyZXBvcnRlZEVsZW1lbnQgJiYgcmVwb3J0ZWRFbGVtZW50LmlkKSA/IHJlcG9ydGVkRWxlbWVudC5pZCA6ICcnO1xuICAgICAgICBzdHJpbmdUb1VURjgobm9kZU5hbWUsIGV2ZW50U3RydWN0ICsgOCwgMTI4KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KGlkLCBldmVudFN0cnVjdCArIDEzNiwgMTI4KTtcbiAgICAgICAgSEVBUDMyWygoKGV2ZW50U3RydWN0KSArICgyNjQpKSA+PiAyKV0gPSByZXBvcnRlZEVsZW1lbnQgPyByZXBvcnRlZEVsZW1lbnQuY2xpZW50V2lkdGggOiAwO1xuICAgICAgICBIRUFQMzJbKCgoZXZlbnRTdHJ1Y3QpICsgKDI2OCkpID4+IDIpXSA9IHJlcG9ydGVkRWxlbWVudCA/IHJlcG9ydGVkRWxlbWVudC5jbGllbnRIZWlnaHQgOiAwO1xuICAgICAgICBIRUFQMzJbKCgoZXZlbnRTdHJ1Y3QpICsgKDI3MikpID4+IDIpXSA9IHNjcmVlbi53aWR0aDtcbiAgICAgICAgSEVBUDMyWygoKGV2ZW50U3RydWN0KSArICgyNzYpKSA+PiAyKV0gPSBzY3JlZW4uaGVpZ2h0O1xuICAgICAgICBpZiAoaXNGdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBKU0V2ZW50cy5wcmV2aW91c0Z1bGxzY3JlZW5FbGVtZW50ID0gZnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIGV2ZW50VHlwZUlkLCBldmVudFR5cGVTdHJpbmcsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIUpTRXZlbnRzLmZ1bGxzY3JlZW5DaGFuZ2VFdmVudCkgSlNFdmVudHMuZnVsbHNjcmVlbkNoYW5nZUV2ZW50ID0gX21hbGxvYygyODApO1xuXG4gICAgICAgIHZhciBmdWxsc2NyZWVuQ2hhbmdlRXZlbnRoYW5kbGVyRnVuYyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGUgPSBldiB8fCBldmVudDtcblxuICAgICAgICAgICAgdmFyIGZ1bGxzY3JlZW5DaGFuZ2VFdmVudCA9IEpTRXZlbnRzLmZ1bGxzY3JlZW5DaGFuZ2VFdmVudDtcblxuICAgICAgICAgICAgZmlsbEZ1bGxzY3JlZW5DaGFuZ2VFdmVudERhdGEoZnVsbHNjcmVlbkNoYW5nZUV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIGZ1bGxzY3JlZW5DaGFuZ2VFdmVudCwgdXNlckRhdGEpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiBmdWxsc2NyZWVuQ2hhbmdlRXZlbnRoYW5kbGVyRnVuYyxcbiAgICAgICAgICAgIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgSlNFdmVudHMucmVnaXN0ZXJPclJlbW92ZUhhbmRsZXIoZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2Z1bGxzY3JlZW5jaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIGlmICghSlNFdmVudHMuZnVsbHNjcmVlbkVuYWJsZWQoKSkgcmV0dXJuIC0xO1xuICAgICAgICB0YXJnZXQgPSBmaW5kRXZlbnRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybiAtNDtcbiAgICAgICAgcmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDE5LCBcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGFyZ2V0VGhyZWFkKTtcblxuICAgICAgICAvLyBVbnByZWZpeGVkIEZ1bGxzY3JlZW4gQVBJIHNoaXBwZWQgaW4gQ2hyb21pdW0gNzEgKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM4MzgxMylcbiAgICAgICAgLy8gQXMgb2YgU2FmYXJpIDEzLjAuMyBvbiBtYWNPUyBDYXRhbGluYSAxMC4xNS4xIHN0aWxsIHNoaXBzIHdpdGggcHJlZml4ZWQgd2Via2l0ZnVsbHNjcmVlbmNoYW5nZS4gVE9ETzogcmV2aXNpdCB0aGlzIGNoZWNrIG9uY2UgU2FmYXJpIHNoaXBzIHVucHJlZml4ZWQgdmVyc2lvbi5cbiAgICAgICAgcmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDE5LCBcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGFyZ2V0VGhyZWFkKTtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X2Z1bGxzY3JlZW5jaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJHYW1lcGFkRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIGV2ZW50VHlwZUlkLCBldmVudFR5cGVTdHJpbmcsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIUpTRXZlbnRzLmdhbWVwYWRFdmVudCkgSlNFdmVudHMuZ2FtZXBhZEV2ZW50ID0gX21hbGxvYygxNDMyKTtcblxuICAgICAgICB2YXIgZ2FtZXBhZEV2ZW50SGFuZGxlckZ1bmMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXYgfHwgZXZlbnQ7XG5cbiAgICAgICAgICAgIHZhciBnYW1lcGFkRXZlbnQgPSBKU0V2ZW50cy5nYW1lcGFkRXZlbnQ7XG4gICAgICAgICAgICBmaWxsR2FtZXBhZEV2ZW50RGF0YShnYW1lcGFkRXZlbnQsIGVbXCJnYW1lcGFkXCJdKTtcblxuICAgICAgICAgICAgaWYgKGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIGdhbWVwYWRFdmVudCwgdXNlckRhdGEpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICAgIHRhcmdldDogZmluZEV2ZW50VGFyZ2V0KHRhcmdldCksXG4gICAgICAgICAgICBhbGxvd3NEZWZlcnJlZENhbGxzOiB0cnVlLFxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiBnYW1lcGFkRXZlbnRIYW5kbGVyRnVuYyxcbiAgICAgICAgICAgIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgSlNFdmVudHMucmVnaXN0ZXJPclJlbW92ZUhhbmRsZXIoZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2dhbWVwYWRjb25uZWN0ZWRfY2FsbGJhY2tfb25fdGhyZWFkKHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5nZXRHYW1lcGFkcyAmJiAhbmF2aWdhdG9yLndlYmtpdEdldEdhbWVwYWRzKSByZXR1cm4gLTE7XG4gICAgICAgIHJlZ2lzdGVyR2FtZXBhZEV2ZW50Q2FsbGJhY2soMiwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMjYsIFwiZ2FtZXBhZGNvbm5lY3RlZFwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X2dhbWVwYWRjb25uZWN0ZWRfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGRpc2Nvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWQodXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLmdldEdhbWVwYWRzICYmICFuYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHMpIHJldHVybiAtMTtcbiAgICAgICAgcmVnaXN0ZXJHYW1lcGFkRXZlbnRDYWxsYmFjaygyLCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAyNywgXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGRpc2Nvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpJztcblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyS2V5RXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIGV2ZW50VHlwZUlkLCBldmVudFR5cGVTdHJpbmcsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIUpTRXZlbnRzLmtleUV2ZW50KSBKU0V2ZW50cy5rZXlFdmVudCA9IF9tYWxsb2MoMTc2KTtcblxuICAgICAgICB2YXIga2V5RXZlbnRIYW5kbGVyRnVuYyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBhc3NlcnQoZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlFdmVudERhdGEgPSBKU0V2ZW50cy5rZXlFdmVudDtcbiAgICAgICAgICAgIEhFQVBGNjRbKChrZXlFdmVudERhdGEpID4+IDMpXSA9IGUudGltZVN0YW1wO1xuXG4gICAgICAgICAgICB2YXIgaWR4ID0ga2V5RXZlbnREYXRhID4+IDI7XG5cbiAgICAgICAgICAgIEhFQVAzMltpZHggKyAyXSA9IGUubG9jYXRpb247XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgM10gPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgNF0gPSBlLnNoaWZ0S2V5O1xuICAgICAgICAgICAgSEVBUDMyW2lkeCArIDVdID0gZS5hbHRLZXk7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgNl0gPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgN10gPSBlLnJlcGVhdDtcbiAgICAgICAgICAgIEhFQVAzMltpZHggKyA4XSA9IGUuY2hhckNvZGU7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgOV0gPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgMTBdID0gZS53aGljaDtcbiAgICAgICAgICAgIHN0cmluZ1RvVVRGOChlLmtleSB8fCAnJywga2V5RXZlbnREYXRhICsgNDQsIDMyKTtcbiAgICAgICAgICAgIHN0cmluZ1RvVVRGOChlLmNvZGUgfHwgJycsIGtleUV2ZW50RGF0YSArIDc2LCAzMik7XG4gICAgICAgICAgICBzdHJpbmdUb1VURjgoZS5jaGFyIHx8ICcnLCBrZXlFdmVudERhdGEgKyAxMDgsIDMyKTtcbiAgICAgICAgICAgIHN0cmluZ1RvVVRGOChlLmxvY2FsZSB8fCAnJywga2V5RXZlbnREYXRhICsgMTQwLCAzMik7XG5cbiAgICAgICAgICAgIGlmIChnZXRXYXNtVGFibGVFbnRyeShjYWxsYmFja2Z1bmMpKGV2ZW50VHlwZUlkLCBrZXlFdmVudERhdGEsIHVzZXJEYXRhKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpLFxuICAgICAgICAgICAgYWxsb3dzRGVmZXJyZWRDYWxsczogdHJ1ZSxcbiAgICAgICAgICAgIGV2ZW50VHlwZVN0cmluZzogZXZlbnRUeXBlU3RyaW5nLFxuICAgICAgICAgICAgY2FsbGJhY2tmdW5jOiBjYWxsYmFja2Z1bmMsXG4gICAgICAgICAgICBoYW5kbGVyRnVuYzoga2V5RXZlbnRIYW5kbGVyRnVuYyxcbiAgICAgICAgICAgIHVzZUNhcHR1cmU6IHVzZUNhcHR1cmVcbiAgICAgICAgfTtcbiAgICAgICAgSlNFdmVudHMucmVnaXN0ZXJPclJlbW92ZUhhbmRsZXIoZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2tleWRvd25fY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyS2V5RXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDIsIFwia2V5ZG93blwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X2tleWRvd25fY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2tleXByZXNzX2NhbGxiYWNrX29uX3RocmVhZCh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICByZWdpc3RlcktleUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAxLCBcImtleXByZXNzXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfa2V5cHJlc3NfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X2tleXVwX2NhbGxiYWNrX29uX3RocmVhZCh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICByZWdpc3RlcktleUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAzLCBcImtleXVwXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfa2V5dXBfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gZmlsbE1vdXNlRXZlbnREYXRhKGV2ZW50U3RydWN0LCBlLCB0YXJnZXQpIHtcbiAgICAgICAgYXNzZXJ0KGV2ZW50U3RydWN0ICUgNCA9PSAwKTtcbiAgICAgICAgSEVBUEY2NFsoKGV2ZW50U3RydWN0KSA+PiAzKV0gPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgdmFyIGlkeCA9IGV2ZW50U3RydWN0ID4+IDI7XG4gICAgICAgIEhFQVAzMltpZHggKyAyXSA9IGUuc2NyZWVuWDtcbiAgICAgICAgSEVBUDMyW2lkeCArIDNdID0gZS5zY3JlZW5ZO1xuICAgICAgICBIRUFQMzJbaWR4ICsgNF0gPSBlLmNsaWVudFg7XG4gICAgICAgIEhFQVAzMltpZHggKyA1XSA9IGUuY2xpZW50WTtcbiAgICAgICAgSEVBUDMyW2lkeCArIDZdID0gZS5jdHJsS2V5O1xuICAgICAgICBIRUFQMzJbaWR4ICsgN10gPSBlLnNoaWZ0S2V5O1xuICAgICAgICBIRUFQMzJbaWR4ICsgOF0gPSBlLmFsdEtleTtcbiAgICAgICAgSEVBUDMyW2lkeCArIDldID0gZS5tZXRhS2V5O1xuICAgICAgICBIRUFQMTZbaWR4ICogMiArIDIwXSA9IGUuYnV0dG9uO1xuICAgICAgICBIRUFQMTZbaWR4ICogMiArIDIxXSA9IGUuYnV0dG9ucztcblxuICAgICAgICBIRUFQMzJbaWR4ICsgMTFdID0gZVtcIm1vdmVtZW50WFwiXVxuICAgICAgICAgICAgO1xuXG4gICAgICAgIEhFQVAzMltpZHggKyAxMl0gPSBlW1wibW92ZW1lbnRZXCJdXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgICAgICAgSEVBUDMyW2lkeCArIDEzXSA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgICAgSEVBUDMyW2lkeCArIDE0XSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgZXZlbnRUeXBlSWQsIGV2ZW50VHlwZVN0cmluZywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIGlmICghSlNFdmVudHMubW91c2VFdmVudCkgSlNFdmVudHMubW91c2VFdmVudCA9IF9tYWxsb2MoNzIpO1xuICAgICAgICB0YXJnZXQgPSBmaW5kRXZlbnRUYXJnZXQodGFyZ2V0KTtcblxuICAgICAgICB2YXIgbW91c2VFdmVudEhhbmRsZXJGdW5jID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2IHx8IGV2ZW50O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBNYWtlIHRoaXMgYWNjZXNzIHRocmVhZCBzYWZlLCBvciB0aGlzIGNvdWxkIHVwZGF0ZSBsaXZlIHdoaWxlIGFwcCBpcyByZWFkaW5nIGl0LlxuICAgICAgICAgICAgZmlsbE1vdXNlRXZlbnREYXRhKEpTRXZlbnRzLm1vdXNlRXZlbnQsIGUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmIChnZXRXYXNtVGFibGVFbnRyeShjYWxsYmFja2Z1bmMpKGV2ZW50VHlwZUlkLCBKU0V2ZW50cy5tb3VzZUV2ZW50LCB1c2VyRGF0YSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBhbGxvd3NEZWZlcnJlZENhbGxzOiBldmVudFR5cGVTdHJpbmcgIT0gJ21vdXNlbW92ZScgJiYgZXZlbnRUeXBlU3RyaW5nICE9ICdtb3VzZWVudGVyJyAmJiBldmVudFR5cGVTdHJpbmcgIT0gJ21vdXNlbGVhdmUnLCAvLyBNb3VzZSBtb3ZlIGV2ZW50cyBkbyBub3QgYWxsb3cgZnVsbHNjcmVlbi9wb2ludGVyIGxvY2sgcmVxdWVzdHMgdG8gYmUgaGFuZGxlZCBpbiB0aGVtIVxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiBtb3VzZUV2ZW50SGFuZGxlckZ1bmMsXG4gICAgICAgICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgICAgIH07XG4gICAgICAgIEpTRXZlbnRzLnJlZ2lzdGVyT3JSZW1vdmVIYW5kbGVyKGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgNSwgXCJtb3VzZWRvd25cIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X21vdXNlZW50ZXJfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMzMsIFwibW91c2VlbnRlclwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X21vdXNlZW50ZXJfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X21vdXNlbGVhdmVfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMzQsIFwibW91c2VsZWF2ZVwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X21vdXNlbGVhdmVfY2FsbGJhY2tfb25fdGhyZWFkLnNpZyA9ICdpaWlpaWknO1xuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X21vdXNlbW92ZV9jYWxsYmFja19vbl90aHJlYWQodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgcmVnaXN0ZXJNb3VzZUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCA4LCBcIm1vdXNlbW92ZVwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X21vdXNlbW92ZV9jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfbW91c2V1cF9jYWxsYmFja19vbl90aHJlYWQodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgcmVnaXN0ZXJNb3VzZUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCA2LCBcIm1vdXNldXBcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF9tb3VzZXVwX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIGZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YShldmVudFN0cnVjdCkge1xuICAgICAgICB2YXIgcG9pbnRlckxvY2tFbGVtZW50ID0gZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50IHx8IGRvY3VtZW50Lm1velBvaW50ZXJMb2NrRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubXNQb2ludGVyTG9ja0VsZW1lbnQ7XG4gICAgICAgIHZhciBpc1BvaW50ZXJsb2NrZWQgPSAhIXBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgICAgLy8gQXNzaWduaW5nIGEgYm9vbGVhbiB0byBIRUFQMzIgd2l0aCBleHBlY3RlZCB0eXBlIGNvZXJjaW9uLlxuICAgICAgICAvKiogQHN1cHByZXNze2NoZWNrVHlwZXN9ICovXG4gICAgICAgIEhFQVAzMlsoKGV2ZW50U3RydWN0KSA+PiAyKV0gPSBpc1BvaW50ZXJsb2NrZWQ7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IEpTRXZlbnRzLmdldE5vZGVOYW1lRm9yVGFyZ2V0KHBvaW50ZXJMb2NrRWxlbWVudCk7XG4gICAgICAgIHZhciBpZCA9IChwb2ludGVyTG9ja0VsZW1lbnQgJiYgcG9pbnRlckxvY2tFbGVtZW50LmlkKSA/IHBvaW50ZXJMb2NrRWxlbWVudC5pZCA6ICcnO1xuICAgICAgICBzdHJpbmdUb1VURjgobm9kZU5hbWUsIGV2ZW50U3RydWN0ICsgNCwgMTI4KTtcbiAgICAgICAgc3RyaW5nVG9VVEY4KGlkLCBldmVudFN0cnVjdCArIDEzMiwgMTI4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJQb2ludGVybG9ja0NoYW5nZUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCBldmVudFR5cGVJZCwgZXZlbnRUeXBlU3RyaW5nLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgaWYgKCFKU0V2ZW50cy5wb2ludGVybG9ja0NoYW5nZUV2ZW50KSBKU0V2ZW50cy5wb2ludGVybG9ja0NoYW5nZUV2ZW50ID0gX21hbGxvYygyNjApO1xuXG4gICAgICAgIHZhciBwb2ludGVybG9ja0NoYW5nZUV2ZW50SGFuZGxlckZ1bmMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXYgfHwgZXZlbnQ7XG5cbiAgICAgICAgICAgIHZhciBwb2ludGVybG9ja0NoYW5nZUV2ZW50ID0gSlNFdmVudHMucG9pbnRlcmxvY2tDaGFuZ2VFdmVudDtcbiAgICAgICAgICAgIGZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YShwb2ludGVybG9ja0NoYW5nZUV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIHBvaW50ZXJsb2NrQ2hhbmdlRXZlbnQsIHVzZXJEYXRhKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGV2ZW50VHlwZVN0cmluZzogZXZlbnRUeXBlU3RyaW5nLFxuICAgICAgICAgICAgY2FsbGJhY2tmdW5jOiBjYWxsYmFja2Z1bmMsXG4gICAgICAgICAgICBoYW5kbGVyRnVuYzogcG9pbnRlcmxvY2tDaGFuZ2VFdmVudEhhbmRsZXJGdW5jLFxuICAgICAgICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgICAgICB9O1xuICAgICAgICBKU0V2ZW50cy5yZWdpc3Rlck9yUmVtb3ZlSGFuZGxlcihldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICAvKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfcG9pbnRlcmxvY2tjaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIC8vIFRPRE86IEN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGluIHB0aHJlYWRzIG9yIGluIC0tcHJveHktdG8td29ya2VyIG1vZGUuIChJbiBwdGhyZWFkcyBtb2RlLCBkb2N1bWVudCBvYmplY3QgaXMgbm90IGRlZmluZWQpXG4gICAgICAgIGlmICghZG9jdW1lbnQgfHwgIWRvY3VtZW50LmJvZHkgfHwgKCFkb2N1bWVudC5ib2R5LnJlcXVlc3RQb2ludGVyTG9jayAmJiAhZG9jdW1lbnQuYm9keS5tb3pSZXF1ZXN0UG9pbnRlckxvY2sgJiYgIWRvY3VtZW50LmJvZHkud2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrICYmICFkb2N1bWVudC5ib2R5Lm1zUmVxdWVzdFBvaW50ZXJMb2NrKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gZmluZEV2ZW50VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm4gLTQ7XG4gICAgICAgIHJlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMjAsIFwicG9pbnRlcmxvY2tjaGFuZ2VcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmVnaXN0ZXJQb2ludGVybG9ja0NoYW5nZUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAyMCwgXCJtb3pwb2ludGVybG9ja2NoYW5nZVwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZWdpc3RlclBvaW50ZXJsb2NrQ2hhbmdlRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDIwLCBcIndlYmtpdHBvaW50ZXJsb2NrY2hhbmdlXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMjAsIFwibXNwb2ludGVybG9ja2NoYW5nZVwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X3BvaW50ZXJsb2NrY2hhbmdlX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVWlFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgZXZlbnRUeXBlSWQsIGV2ZW50VHlwZVN0cmluZywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIGlmICghSlNFdmVudHMudWlFdmVudCkgSlNFdmVudHMudWlFdmVudCA9IF9tYWxsb2MoMzYpO1xuXG4gICAgICAgIHRhcmdldCA9IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpO1xuXG4gICAgICAgIHZhciB1aUV2ZW50SGFuZGxlckZ1bmMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXYgfHwgZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgIT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgdGFrZSB1aSBldmVudHMgc3VjaCBhcyBzY3JvbGwgdmlhIGEgJ2J1YmJsZWQnIHJvdXRlLCBidXQgYWx3YXlzIGZyb20gdGhlIGRpcmVjdCBlbGVtZW50IHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3YXMgdGFyZ2V0ZWQuIE90aGVyd2lzZSBlLmcuIGlmIGFwcCBsb2dzIGEgbWVzc2FnZSBpbiByZXNwb25zZSB0byBhIHBhZ2Ugc2Nyb2xsLCB0aGUgRW1zY3JpcHRlbiBsb2dcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGJveCBjb3VsZCBjYXVzZSB0byBzY3JvbGwsIGdlbmVyYXRpbmcgYSBuZXcgKGJ1YmJsZWQpIHNjcm9sbCBtZXNzYWdlLCBjYXVzaW5nIGEgbmV3IGxvZyBwcmludCxcbiAgICAgICAgICAgICAgICAvLyBjYXVzaW5nIGEgbmV3IHNjcm9sbCwgZXRjLi5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHk7IC8vIFRha2UgZG9jdW1lbnQuYm9keSB0byBhIHZhcmlhYmxlLCBDbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG91dGxpbmUgYWNjZXNzIHRvIGl0IG9uIGl0cyBvd24uXG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgYSBwYWdlIHVubG9hZCAnYm9keScgY2FuIGJlIG51bGwsIHdpdGggXCJDYW5ub3QgcmVhZCBwcm9wZXJ0eSAnY2xpZW50V2lkdGgnIG9mIG51bGxcIiBiZWluZyB0aHJvd25cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWlFdmVudCA9IEpTRXZlbnRzLnVpRXZlbnQ7XG4gICAgICAgICAgICBIRUFQMzJbKCh1aUV2ZW50KSA+PiAyKV0gPSBlLmRldGFpbDtcbiAgICAgICAgICAgIEhFQVAzMlsoKCh1aUV2ZW50KSArICg0KSkgPj4gMildID0gYi5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIEhFQVAzMlsoKCh1aUV2ZW50KSArICg4KSkgPj4gMildID0gYi5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBIRUFQMzJbKCgodWlFdmVudCkgKyAoMTIpKSA+PiAyKV0gPSBpbm5lcldpZHRoO1xuICAgICAgICAgICAgSEVBUDMyWygoKHVpRXZlbnQpICsgKDE2KSkgPj4gMildID0gaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgICBIRUFQMzJbKCgodWlFdmVudCkgKyAoMjApKSA+PiAyKV0gPSBvdXRlcldpZHRoO1xuICAgICAgICAgICAgSEVBUDMyWygoKHVpRXZlbnQpICsgKDI0KSkgPj4gMildID0gb3V0ZXJIZWlnaHQ7XG4gICAgICAgICAgICBIRUFQMzJbKCgodWlFdmVudCkgKyAoMjgpKSA+PiAyKV0gPSBwYWdlWE9mZnNldDtcbiAgICAgICAgICAgIEhFQVAzMlsoKCh1aUV2ZW50KSArICgzMikpID4+IDIpXSA9IHBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGdldFdhc21UYWJsZUVudHJ5KGNhbGxiYWNrZnVuYykoZXZlbnRUeXBlSWQsIHVpRXZlbnQsIHVzZXJEYXRhKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGV2ZW50VHlwZVN0cmluZzogZXZlbnRUeXBlU3RyaW5nLFxuICAgICAgICAgICAgY2FsbGJhY2tmdW5jOiBjYWxsYmFja2Z1bmMsXG4gICAgICAgICAgICBoYW5kbGVyRnVuYzogdWlFdmVudEhhbmRsZXJGdW5jLFxuICAgICAgICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgICAgICB9O1xuICAgICAgICBKU0V2ZW50cy5yZWdpc3Rlck9yUmVtb3ZlSGFuZGxlcihldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfcmVzaXplX2NhbGxiYWNrX29uX3RocmVhZCh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICByZWdpc3RlclVpRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDEwLCBcInJlc2l6ZVwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X3Jlc2l6ZV9jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiByZWdpc3RlclRvdWNoRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIGV2ZW50VHlwZUlkLCBldmVudFR5cGVTdHJpbmcsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIUpTRXZlbnRzLnRvdWNoRXZlbnQpIEpTRXZlbnRzLnRvdWNoRXZlbnQgPSBfbWFsbG9jKDE2OTYpO1xuXG4gICAgICAgIHRhcmdldCA9IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpO1xuXG4gICAgICAgIHZhciB0b3VjaEV2ZW50SGFuZGxlckZ1bmMgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgYXNzZXJ0KGUpO1xuICAgICAgICAgICAgdmFyIHQsIHRvdWNoZXMgPSB7fSwgZXQgPSBlLnRvdWNoZXM7XG4gICAgICAgICAgICAvLyBUbyBlYXNlIG1hcnNoYWxsaW5nIGRpZmZlcmVudCBraW5kcyBvZiB0b3VjaGVzIHRoYXQgYnJvd3NlciByZXBvcnRzIChhbGwgdG91Y2hlcyBhcmUgbGlzdGVkIGluIGUudG91Y2hlcywgXG4gICAgICAgICAgICAvLyBvbmx5IGNoYW5nZWQgdG91Y2hlcyBpbiBlLmNoYW5nZWRUb3VjaGVzLCBhbmQgdG91Y2hlcyBvbiB0YXJnZXQgYXQgYS50YXJnZXRUb3VjaGVzKSwgbWFyayBhIGJvb2xlYW4gaW5cbiAgICAgICAgICAgIC8vIGVhY2ggVG91Y2ggb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGxhdGVyIGxvb3Agb25seSBvbmNlIG92ZXIgYWxsIHRvdWNoZXMgd2Ugc2VlIHRvIG1hcnNoYWxsIG92ZXIgdG8gV2FzbS5cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHQgPSBldFtpXTtcbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyIG1pZ2h0IHJlY3ljbGUgdGhlIGdlbmVyYXRlZCBUb3VjaCBvYmplY3RzIGJldHdlZW4gZWFjaCBmcmFtZSAoRmlyZWZveCBvbiBBbmRyb2lkKSwgc28gcmVzZXQgYW55XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlZC90YXJnZXQgc3RhdGVzIHdlIG1heSBoYXZlIHNldCBmcm9tIHByZXZpb3VzIGZyYW1lLlxuICAgICAgICAgICAgICAgIHQuaXNDaGFuZ2VkID0gdC5vblRhcmdldCA9IDA7XG4gICAgICAgICAgICAgICAgdG91Y2hlc1t0LmlkZW50aWZpZXJdID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgd2hpY2ggdG91Y2hlcyBhcmUgcGFydCBvZiB0aGUgY2hhbmdlZFRvdWNoZXMgbGlzdC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHQgPSBlLmNoYW5nZWRUb3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgIHQuaXNDaGFuZ2VkID0gMTtcbiAgICAgICAgICAgICAgICB0b3VjaGVzW3QuaWRlbnRpZmllcl0gPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFyayB3aGljaCB0b3VjaGVzIGFyZSBwYXJ0IG9mIHRoZSB0YXJnZXRUb3VjaGVzIGxpc3QuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUudGFyZ2V0VG91Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRvdWNoZXNbZS50YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdLm9uVGFyZ2V0ID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSBKU0V2ZW50cy50b3VjaEV2ZW50O1xuICAgICAgICAgICAgSEVBUEY2NFsoKHRvdWNoRXZlbnQpID4+IDMpXSA9IGUudGltZVN0YW1wO1xuICAgICAgICAgICAgdmFyIGlkeCA9IHRvdWNoRXZlbnQgPj4gMjsgLy8gUHJlLXNoaWZ0IHRoZSBwdHIgdG8gaW5kZXggdG8gSEVBUDMyIHRvIHNhdmUgY29kZSBzaXplXG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgM10gPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgNF0gPSBlLnNoaWZ0S2V5O1xuICAgICAgICAgICAgSEVBUDMyW2lkeCArIDVdID0gZS5hbHRLZXk7XG4gICAgICAgICAgICBIRUFQMzJbaWR4ICsgNl0gPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICBpZHggKz0gNzsgLy8gQWR2YW5jZSB0byB0aGUgc3RhcnQgb2YgdGhlIHRvdWNoIGFycmF5LlxuICAgICAgICAgICAgdmFyIHRhcmdldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBudW1Ub3VjaGVzID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdG91Y2hlcykge1xuICAgICAgICAgICAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgIEhFQVAzMltpZHggKyAwXSA9IHQuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBIRUFQMzJbaWR4ICsgMV0gPSB0LnNjcmVlblg7XG4gICAgICAgICAgICAgICAgSEVBUDMyW2lkeCArIDJdID0gdC5zY3JlZW5ZO1xuICAgICAgICAgICAgICAgIEhFQVAzMltpZHggKyAzXSA9IHQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBIRUFQMzJbaWR4ICsgNF0gPSB0LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgSEVBUDMyW2lkeCArIDVdID0gdC5wYWdlWDtcbiAgICAgICAgICAgICAgICBIRUFQMzJbaWR4ICsgNl0gPSB0LnBhZ2VZO1xuICAgICAgICAgICAgICAgIEhFQVAzMltpZHggKyA3XSA9IHQuaXNDaGFuZ2VkO1xuICAgICAgICAgICAgICAgIEhFQVAzMltpZHggKyA4XSA9IHQub25UYXJnZXQ7XG4gICAgICAgICAgICAgICAgSEVBUDMyW2lkeCArIDldID0gdC5jbGllbnRYIC0gdGFyZ2V0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgIEhFQVAzMltpZHggKyAxMF0gPSB0LmNsaWVudFkgLSB0YXJnZXRSZWN0LnRvcDtcblxuICAgICAgICAgICAgICAgIGlkeCArPSAxMztcblxuICAgICAgICAgICAgICAgIGlmICgrK251bVRvdWNoZXMgPiAzMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIRUFQMzJbKCgodG91Y2hFdmVudCkgKyAoOCkpID4+IDIpXSA9IG51bVRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmIChnZXRXYXNtVGFibGVFbnRyeShjYWxsYmFja2Z1bmMpKGV2ZW50VHlwZUlkLCB0b3VjaEV2ZW50LCB1c2VyRGF0YSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBhbGxvd3NEZWZlcnJlZENhbGxzOiBldmVudFR5cGVTdHJpbmcgPT0gJ3RvdWNoc3RhcnQnIHx8IGV2ZW50VHlwZVN0cmluZyA9PSAndG91Y2hlbmQnLFxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiB0b3VjaEV2ZW50SGFuZGxlckZ1bmMsXG4gICAgICAgICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgICAgIH07XG4gICAgICAgIEpTRXZlbnRzLnJlZ2lzdGVyT3JSZW1vdmVIYW5kbGVyKGV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF90b3VjaGNhbmNlbF9jYWxsYmFja19vbl90aHJlYWQodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgcmVnaXN0ZXJUb3VjaEV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAyNSwgXCJ0b3VjaGNhbmNlbFwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoY2FuY2VsX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF90b3VjaGVuZF9jYWxsYmFja19vbl90aHJlYWQodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgcmVnaXN0ZXJUb3VjaEV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAyMywgXCJ0b3VjaGVuZFwiLCB0YXJnZXRUaHJlYWQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoZW5kX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF90b3VjaG1vdmVfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHJlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgMjQsIFwidG91Y2htb3ZlXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfdG91Y2htb3ZlX2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF90b3VjaHN0YXJ0X2NhbGxiYWNrX29uX3RocmVhZCh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICByZWdpc3RlclRvdWNoRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDIyLCBcInRvdWNoc3RhcnRcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF90b3VjaHN0YXJ0X2NhbGxiYWNrX29uX3RocmVhZC5zaWcgPSAnaWlpaWlpJztcblxuICAgIGZ1bmN0aW9uIGZpbGxWaXNpYmlsaXR5Q2hhbmdlRXZlbnREYXRhKGV2ZW50U3RydWN0KSB7XG4gICAgICAgIHZhciB2aXNpYmlsaXR5U3RhdGVzID0gW1wiaGlkZGVuXCIsIFwidmlzaWJsZVwiLCBcInByZXJlbmRlclwiLCBcInVubG9hZGVkXCJdO1xuICAgICAgICB2YXIgdmlzaWJpbGl0eVN0YXRlID0gdmlzaWJpbGl0eVN0YXRlcy5pbmRleE9mKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG5cbiAgICAgICAgLy8gQXNzaWduaW5nIGEgYm9vbGVhbiB0byBIRUFQMzIgd2l0aCBleHBlY3RlZCB0eXBlIGNvZXJjaW9uLlxuICAgICAgICAvKiogQHN1cHByZXNze2NoZWNrVHlwZXN9ICovXG4gICAgICAgIEhFQVAzMlsoKGV2ZW50U3RydWN0KSA+PiAyKV0gPSBkb2N1bWVudC5oaWRkZW47XG4gICAgICAgIEhFQVAzMlsoKChldmVudFN0cnVjdCkgKyAoNCkpID4+IDIpXSA9IHZpc2liaWxpdHlTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2xlZXAoKSB7XG4gICAgICAgIHRocm93ICdQbGVhc2UgY29tcGlsZSB5b3VyIHByb2dyYW0gd2l0aCBhc3luYyBzdXBwb3J0IGluIG9yZGVyIHRvIHVzZSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBsaWtlIGVtc2NyaXB0ZW5fc2xlZXAnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUV2ZW50Q2FsbGJhY2sodGFyZ2V0LCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCBldmVudFR5cGVJZCwgZXZlbnRUeXBlU3RyaW5nLCB0YXJnZXRUaHJlYWQpIHtcbiAgICAgICAgaWYgKCFKU0V2ZW50cy52aXNpYmlsaXR5Q2hhbmdlRXZlbnQpIEpTRXZlbnRzLnZpc2liaWxpdHlDaGFuZ2VFdmVudCA9IF9tYWxsb2MoIDggKTtcbiAgICBcbiAgICAgICAgdmFyIHZpc2liaWxpdHlDaGFuZ2VFdmVudEhhbmRsZXJGdW5jID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICB2YXIgZSA9IGV2IHx8IGV2ZW50O1xuICAgIFxuICAgICAgICAgIHZhciB2aXNpYmlsaXR5Q2hhbmdlRXZlbnQgPSBKU0V2ZW50cy52aXNpYmlsaXR5Q2hhbmdlRXZlbnQ7XG4gICAgXG4gICAgICAgICAgZmlsbFZpc2liaWxpdHlDaGFuZ2VFdmVudERhdGEodmlzaWJpbGl0eUNoYW5nZUV2ZW50KTtcbiAgICBcbiAgICAgICAgICBpZiAoZ2V0V2FzbVRhYmxlRW50cnkoY2FsbGJhY2tmdW5jKShldmVudFR5cGVJZCwgdmlzaWJpbGl0eUNoYW5nZUV2ZW50LCB1c2VyRGF0YSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IHtcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICBldmVudFR5cGVTdHJpbmc6IGV2ZW50VHlwZVN0cmluZyxcbiAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICBoYW5kbGVyRnVuYzogdmlzaWJpbGl0eUNoYW5nZUV2ZW50SGFuZGxlckZ1bmMsXG4gICAgICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgICAgICB9O1xuICAgICAgICBKU0V2ZW50cy5yZWdpc3Rlck9yUmVtb3ZlSGFuZGxlcihldmVudEhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X3Zpc2liaWxpdHljaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkKHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIHRhcmdldFRocmVhZCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxIVE1MVGFyZ2V0c1sxXSkge1xuICAgICAgICAgICAgcmV0dXJuIC00O1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUV2ZW50Q2FsbGJhY2soc3BlY2lhbEhUTUxUYXJnZXRzWzFdLCB1c2VyRGF0YSwgdXNlQ2FwdHVyZSwgY2FsbGJhY2tmdW5jLCAyMSwgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRhcmdldFRocmVhZCk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfdmlzaWJpbGl0eWNoYW5nZV9jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpJztcblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyV2hlZWxFdmVudENhbGxiYWNrKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgZXZlbnRUeXBlSWQsIGV2ZW50VHlwZVN0cmluZywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIGlmICghSlNFdmVudHMud2hlZWxFdmVudCkgSlNFdmVudHMud2hlZWxFdmVudCA9IF9tYWxsb2MoMTA0KTtcblxuICAgICAgICAvLyBUaGUgRE9NIExldmVsIDMgZXZlbnRzIHNwZWMgZXZlbnQgJ3doZWVsJ1xuICAgICAgICB2YXIgd2hlZWxIYW5kbGVyRnVuYyA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGUgPSBldiB8fCBldmVudDtcbiAgICAgICAgICAgIHZhciB3aGVlbEV2ZW50ID0gSlNFdmVudHMud2hlZWxFdmVudDtcbiAgICAgICAgICAgIGZpbGxNb3VzZUV2ZW50RGF0YSh3aGVlbEV2ZW50LCBlLCB0YXJnZXQpO1xuICAgICAgICAgICAgSEVBUEY2NFsoKCh3aGVlbEV2ZW50KSArICg3MikpID4+IDMpXSA9IGVbXCJkZWx0YVhcIl07XG4gICAgICAgICAgICBIRUFQRjY0WygoKHdoZWVsRXZlbnQpICsgKDgwKSkgPj4gMyldID0gZVtcImRlbHRhWVwiXTtcbiAgICAgICAgICAgIEhFQVBGNjRbKCgod2hlZWxFdmVudCkgKyAoODgpKSA+PiAzKV0gPSBlW1wiZGVsdGFaXCJdO1xuICAgICAgICAgICAgSEVBUDMyWygoKHdoZWVsRXZlbnQpICsgKDk2KSkgPj4gMildID0gZVtcImRlbHRhTW9kZVwiXTtcbiAgICAgICAgICAgIGlmIChnZXRXYXNtVGFibGVFbnRyeShjYWxsYmFja2Z1bmMpKGV2ZW50VHlwZUlkLCB3aGVlbEV2ZW50LCB1c2VyRGF0YSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBhbGxvd3NEZWZlcnJlZENhbGxzOiB0cnVlLFxuICAgICAgICAgICAgZXZlbnRUeXBlU3RyaW5nOiBldmVudFR5cGVTdHJpbmcsXG4gICAgICAgICAgICBjYWxsYmFja2Z1bmM6IGNhbGxiYWNrZnVuYyxcbiAgICAgICAgICAgIGhhbmRsZXJGdW5jOiB3aGVlbEhhbmRsZXJGdW5jLFxuICAgICAgICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgICAgICB9O1xuICAgICAgICBKU0V2ZW50cy5yZWdpc3Rlck9yUmVtb3ZlSGFuZGxlcihldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfd2hlZWxfY2FsbGJhY2tfb25fdGhyZWFkKHRhcmdldCwgdXNlckRhdGEsIHVzZUNhcHR1cmUsIGNhbGxiYWNrZnVuYywgdGFyZ2V0VGhyZWFkKSB7XG4gICAgICAgIHRhcmdldCA9IGZpbmRFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldC5vbndoZWVsICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZWdpc3RlcldoZWVsRXZlbnRDYWxsYmFjayh0YXJnZXQsIHVzZXJEYXRhLCB1c2VDYXB0dXJlLCBjYWxsYmFja2Z1bmMsIDksIFwid2hlZWxcIiwgdGFyZ2V0VGhyZWFkKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9lbXNjcmlwdGVuX3NldF93aGVlbF9jYWxsYmFja19vbl90aHJlYWQuc2lnID0gJ2lpaWlpaSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfd2luZG93X3RpdGxlKHRpdGxlKSB7XG4gICAgICAgIHNldFdpbmRvd1RpdGxlKFVURjhUb1N0cmluZyh0aXRsZSkpO1xuICAgIH1cbiAgICBfZW1zY3JpcHRlbl9zZXRfd2luZG93X3RpdGxlLnNpZyA9ICd2aSc7XG5cbiAgICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfbWFpbl9sb29wX3RpbWluZyhtb2RlLCB2YWx1ZSkge1xuICAgICAgICBCcm93c2VyLm1haW5Mb29wLnRpbWluZ01vZGUgPSBtb2RlO1xuICAgICAgICBCcm93c2VyLm1haW5Mb29wLnRpbWluZ1ZhbHVlID0gdmFsdWU7XG4gICAgXG4gICAgICAgIGlmICghQnJvd3Nlci5tYWluTG9vcC5mdW5jKSB7XG4gICAgICAgICAgZXJyKCdlbXNjcmlwdGVuX3NldF9tYWluX2xvb3BfdGltaW5nOiBDYW5ub3Qgc2V0IHRpbWluZyBtb2RlIGZvciBtYWluIGxvb3Agc2luY2UgYSBtYWluIGxvb3AgZG9lcyBub3QgZXhpc3QhIENhbGwgZW1zY3JpcHRlbl9zZXRfbWFpbl9sb29wIGZpcnN0IHRvIHNldCBvbmUgdXAuJyk7XG4gICAgICAgICAgcmV0dXJuIDE7IC8vIFJldHVybiBub24temVybyBvbiBmYWlsdXJlLCBjYW4ndCBzZXQgdGltaW5nIG1vZGUgd2hlbiB0aGVyZSBpcyBubyBtYWluIGxvb3AuXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCFCcm93c2VyLm1haW5Mb29wLnJ1bm5pbmcpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlID09IDAgLypFTV9USU1JTkdfU0VUVElNRU9VVCovKSB7XG4gICAgICAgICAgQnJvd3Nlci5tYWluTG9vcC5zY2hlZHVsZXIgPSBmdW5jdGlvbiBCcm93c2VyX21haW5Mb29wX3NjaGVkdWxlcl9zZXRUaW1lb3V0KCkge1xuICAgICAgICAgICAgdmFyIHRpbWVVbnRpbE5leHRUaWNrID0gTWF0aC5tYXgoMCwgQnJvd3Nlci5tYWluTG9vcC50aWNrU3RhcnRUaW1lICsgdmFsdWUgLSBfZW1zY3JpcHRlbl9nZXRfbm93KCkpfDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KEJyb3dzZXIubWFpbkxvb3AucnVubmVyLCB0aW1lVW50aWxOZXh0VGljayk7IC8vIGRvaW5nIHRoaXMgZWFjaCB0aW1lIG1lYW5zIHRoYXQgb24gZXhjZXB0aW9uLCB3ZSBzdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLm1ldGhvZCA9ICd0aW1lb3V0JztcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IDEgLypFTV9USU1JTkdfUkFGKi8pIHtcbiAgICAgICAgICBCcm93c2VyLm1haW5Mb29wLnNjaGVkdWxlciA9IGZ1bmN0aW9uIEJyb3dzZXJfbWFpbkxvb3Bfc2NoZWR1bGVyX3JBRigpIHtcbiAgICAgICAgICAgIEJyb3dzZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKEJyb3dzZXIubWFpbkxvb3AucnVubmVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEJyb3dzZXIubWFpbkxvb3AubWV0aG9kID0gJ3JBRic7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PSAyIC8qRU1fVElNSU5HX1NFVElNTUVESUFURSovKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEVtdWxhdGUgc2V0SW1tZWRpYXRlLiAobm90ZTogbm90IGEgY29tcGxldGUgcG9seWZpbGwsIHdlIGRvbid0IGVtdWxhdGUgY2xlYXJJbW1lZGlhdGUoKSB0byBrZWVwIGNvZGUgc2l6ZSB0byBtaW5pbXVtLCBzaW5jZSBub3QgbmVlZGVkKVxuICAgICAgICAgICAgdmFyIHNldEltbWVkaWF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbXNjcmlwdGVuTWFpbkxvb3BNZXNzYWdlSWQgPSAnc2V0aW1tZWRpYXRlJztcbiAgICAgICAgICAgIHZhciBCcm93c2VyX3NldEltbWVkaWF0ZV9tZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uKC8qKiBAdHlwZSB7RXZlbnR9ICovIGV2ZW50KSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gY2FsbGVkIGluIGN1cnJlbnQgdGhyZWFkIG9yIFdvcmtlciwgdGhlIG1haW4gbG9vcCBJRCBpcyBzdHJ1Y3R1cmVkIHNsaWdodGx5IGRpZmZlcmVudCB0byBhY2NvbW1vZGF0ZSBmb3IgLS1wcm94eS10by13b3JrZXIgcnVudGltZSBsaXN0ZW5pbmcgdG8gV29ya2VyIGV2ZW50cyxcbiAgICAgICAgICAgICAgLy8gc28gY2hlY2sgZm9yIGJvdGggY2FzZXMuXG4gICAgICAgICAgICAgIGlmIChldmVudC5kYXRhID09PSBlbXNjcmlwdGVuTWFpbkxvb3BNZXNzYWdlSWQgfHwgZXZlbnQuZGF0YS50YXJnZXQgPT09IGVtc2NyaXB0ZW5NYWluTG9vcE1lc3NhZ2VJZCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZXMuc2hpZnQoKSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBCcm93c2VyX3NldEltbWVkaWF0ZV9tZXNzYWdlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUgPSAvKiogQHR5cGV7ZnVuY3Rpb24oZnVuY3Rpb24oKTogPywgLi4uPyk6IG51bWJlcn0gKi8oZnVuY3Rpb24gQnJvd3Nlcl9lbXVsYXRlZF9zZXRJbW1lZGlhdGUoZnVuYykge1xuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGVzLnB1c2goZnVuYyk7XG4gICAgICAgICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoTW9kdWxlWydzZXRJbW1lZGlhdGVzJ10gPT09IHVuZGVmaW5lZCkgTW9kdWxlWydzZXRJbW1lZGlhdGVzJ10gPSBbXTtcbiAgICAgICAgICAgICAgICBNb2R1bGVbJ3NldEltbWVkaWF0ZXMnXS5wdXNoKGZ1bmMpO1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0YXJnZXQ6IGVtc2NyaXB0ZW5NYWluTG9vcE1lc3NhZ2VJZH0pOyAvLyBJbiAtLXByb3h5LXRvLXdvcmtlciwgcm91dGUgdGhlIG1lc3NhZ2UgdmlhIHByb3h5Q2xpZW50LmpzXG4gICAgICAgICAgICAgIH0gZWxzZSBwb3N0TWVzc2FnZShlbXNjcmlwdGVuTWFpbkxvb3BNZXNzYWdlSWQsIFwiKlwiKTsgLy8gT24gdGhlIG1haW4gdGhyZWFkLCBjYW4ganVzdCBzZW5kIHRoZSBtZXNzYWdlIHRvIGl0c2VsZi5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIEJyb3dzZXIubWFpbkxvb3Auc2NoZWR1bGVyID0gZnVuY3Rpb24gQnJvd3Nlcl9tYWluTG9vcF9zY2hlZHVsZXJfc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKEJyb3dzZXIubWFpbkxvb3AucnVubmVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIEJyb3dzZXIubWFpbkxvb3AubWV0aG9kID0gJ2ltbWVkaWF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgX2Vtc2NyaXB0ZW5fc2V0X21haW5fbG9vcF90aW1pbmcuc2lnID0gJ2lpaSc7XG5cbiAgICB2YXIgc2RsX2Z1bmN0aW9ucyA9IHtcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dldF9udW1fZ2FtZXBhZHNcIjogX2Vtc2NyaXB0ZW5fZ2V0X251bV9nYW1lcGFkcyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dldF9zY3JlZW5fc2l6ZVwiOiBfZW1zY3JpcHRlbl9nZXRfc2NyZWVuX3NpemUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEFjdGl2ZVRleHR1cmVcIjogX2Vtc2NyaXB0ZW5fZ2xBY3RpdmVUZXh0dXJlLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xBdHRhY2hTaGFkZXJcIjogX2Vtc2NyaXB0ZW5fZ2xBdHRhY2hTaGFkZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJlZ2luUXVlcnlFWFRcIjogX2Vtc2NyaXB0ZW5fZ2xCZWdpblF1ZXJ5RVhULFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCaW5kQXR0cmliTG9jYXRpb25cIjogX2Vtc2NyaXB0ZW5fZ2xCaW5kQXR0cmliTG9jYXRpb24sXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJpbmRCdWZmZXJcIjogX2Vtc2NyaXB0ZW5fZ2xCaW5kQnVmZmVyLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCaW5kRnJhbWVidWZmZXJcIjogX2Vtc2NyaXB0ZW5fZ2xCaW5kRnJhbWVidWZmZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJpbmRSZW5kZXJidWZmZXJcIjogX2Vtc2NyaXB0ZW5fZ2xCaW5kUmVuZGVyYnVmZmVyLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCaW5kVGV4dHVyZVwiOiBfZW1zY3JpcHRlbl9nbEJpbmRUZXh0dXJlLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCaW5kVmVydGV4QXJyYXlPRVNcIjogX2Vtc2NyaXB0ZW5fZ2xCaW5kVmVydGV4QXJyYXlPRVMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJsZW5kQ29sb3JcIjogX2Vtc2NyaXB0ZW5fZ2xCbGVuZENvbG9yLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCbGVuZEVxdWF0aW9uXCI6IF9lbXNjcmlwdGVuX2dsQmxlbmRFcXVhdGlvbixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsQmxlbmRFcXVhdGlvblNlcGFyYXRlXCI6IF9lbXNjcmlwdGVuX2dsQmxlbmRFcXVhdGlvblNlcGFyYXRlLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCbGVuZEZ1bmNcIjogX2Vtc2NyaXB0ZW5fZ2xCbGVuZEZ1bmMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJsZW5kRnVuY1NlcGFyYXRlXCI6IF9lbXNjcmlwdGVuX2dsQmxlbmRGdW5jU2VwYXJhdGUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEJ1ZmZlckRhdGFcIjogX2Vtc2NyaXB0ZW5fZ2xCdWZmZXJEYXRhLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xCdWZmZXJTdWJEYXRhXCI6IF9lbXNjcmlwdGVuX2dsQnVmZmVyU3ViRGF0YSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsQ2hlY2tGcmFtZWJ1ZmZlclN0YXR1c1wiOiBfZW1zY3JpcHRlbl9nbENoZWNrRnJhbWVidWZmZXJTdGF0dXMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENsZWFyXCI6IF9lbXNjcmlwdGVuX2dsQ2xlYXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENsZWFyQ29sb3JcIjogX2Vtc2NyaXB0ZW5fZ2xDbGVhckNvbG9yLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xDbGVhckRlcHRoZlwiOiBfZW1zY3JpcHRlbl9nbENsZWFyRGVwdGhmLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xDbGVhclN0ZW5jaWxcIjogX2Vtc2NyaXB0ZW5fZ2xDbGVhclN0ZW5jaWwsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENvbG9yTWFza1wiOiBfZW1zY3JpcHRlbl9nbENvbG9yTWFzayxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsQ29tcGlsZVNoYWRlclwiOiBfZW1zY3JpcHRlbl9nbENvbXBpbGVTaGFkZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENvbXByZXNzZWRUZXhJbWFnZTJEXCI6IF9lbXNjcmlwdGVuX2dsQ29tcHJlc3NlZFRleEltYWdlMkQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENvbXByZXNzZWRUZXhTdWJJbWFnZTJEXCI6IF9lbXNjcmlwdGVuX2dsQ29tcHJlc3NlZFRleFN1YkltYWdlMkQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENvcHlUZXhJbWFnZTJEXCI6IF9lbXNjcmlwdGVuX2dsQ29weVRleEltYWdlMkQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENvcHlUZXhTdWJJbWFnZTJEXCI6IF9lbXNjcmlwdGVuX2dsQ29weVRleFN1YkltYWdlMkQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbENyZWF0ZVByb2dyYW1cIjogX2Vtc2NyaXB0ZW5fZ2xDcmVhdGVQcm9ncmFtLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xDcmVhdGVTaGFkZXJcIjogX2Vtc2NyaXB0ZW5fZ2xDcmVhdGVTaGFkZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEN1bGxGYWNlXCI6IF9lbXNjcmlwdGVuX2dsQ3VsbEZhY2UsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbERlbGV0ZUJ1ZmZlcnNcIjogX2Vtc2NyaXB0ZW5fZ2xEZWxldGVCdWZmZXJzLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEZWxldGVGcmFtZWJ1ZmZlcnNcIjogX2Vtc2NyaXB0ZW5fZ2xEZWxldGVGcmFtZWJ1ZmZlcnMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbERlbGV0ZVByb2dyYW1cIjogX2Vtc2NyaXB0ZW5fZ2xEZWxldGVQcm9ncmFtLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEZWxldGVRdWVyaWVzRVhUXCI6IF9lbXNjcmlwdGVuX2dsRGVsZXRlUXVlcmllc0VYVCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGVsZXRlUmVuZGVyYnVmZmVyc1wiOiBfZW1zY3JpcHRlbl9nbERlbGV0ZVJlbmRlcmJ1ZmZlcnMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbERlbGV0ZVNoYWRlclwiOiBfZW1zY3JpcHRlbl9nbERlbGV0ZVNoYWRlcixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGVsZXRlVGV4dHVyZXNcIjogX2Vtc2NyaXB0ZW5fZ2xEZWxldGVUZXh0dXJlcyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGVsZXRlVmVydGV4QXJyYXlzT0VTXCI6IF9lbXNjcmlwdGVuX2dsRGVsZXRlVmVydGV4QXJyYXlzT0VTLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEZXB0aEZ1bmNcIjogX2Vtc2NyaXB0ZW5fZ2xEZXB0aEZ1bmMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbERlcHRoTWFza1wiOiBfZW1zY3JpcHRlbl9nbERlcHRoTWFzayxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGVwdGhSYW5nZWZcIjogX2Vtc2NyaXB0ZW5fZ2xEZXB0aFJhbmdlZixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGV0YWNoU2hhZGVyXCI6IF9lbXNjcmlwdGVuX2dsRGV0YWNoU2hhZGVyLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEaXNhYmxlXCI6IF9lbXNjcmlwdGVuX2dsRGlzYWJsZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRGlzYWJsZVZlcnRleEF0dHJpYkFycmF5XCI6IF9lbXNjcmlwdGVuX2dsRGlzYWJsZVZlcnRleEF0dHJpYkFycmF5LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEcmF3QXJyYXlzXCI6IF9lbXNjcmlwdGVuX2dsRHJhd0FycmF5cyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRHJhd0FycmF5c0luc3RhbmNlZEFOR0xFXCI6IF9lbXNjcmlwdGVuX2dsRHJhd0FycmF5c0luc3RhbmNlZEFOR0xFLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEcmF3QnVmZmVyc1dFQkdMXCI6IF9lbXNjcmlwdGVuX2dsRHJhd0J1ZmZlcnNXRUJHTCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRHJhd0VsZW1lbnRzXCI6IF9lbXNjcmlwdGVuX2dsRHJhd0VsZW1lbnRzLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xEcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRVwiOiBfZW1zY3JpcHRlbl9nbERyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xFbmFibGVcIjogX2Vtc2NyaXB0ZW5fZ2xFbmFibGUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEVuYWJsZVZlcnRleEF0dHJpYkFycmF5XCI6IF9lbXNjcmlwdGVuX2dsRW5hYmxlVmVydGV4QXR0cmliQXJyYXksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEVuZFF1ZXJ5RVhUXCI6IF9lbXNjcmlwdGVuX2dsRW5kUXVlcnlFWFQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEZpbmlzaFwiOiBfZW1zY3JpcHRlbl9nbEZpbmlzaCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRmx1c2hcIjogX2Vtc2NyaXB0ZW5fZ2xGbHVzaCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRnJhbWVidWZmZXJSZW5kZXJidWZmZXJcIjogX2Vtc2NyaXB0ZW5fZ2xGcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRnJhbWVidWZmZXJUZXh0dXJlMkRcIjogX2Vtc2NyaXB0ZW5fZ2xGcmFtZWJ1ZmZlclRleHR1cmUyRCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsRnJvbnRGYWNlXCI6IF9lbXNjcmlwdGVuX2dsRnJvbnRGYWNlLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZW5CdWZmZXJzXCI6IF9lbXNjcmlwdGVuX2dsR2VuQnVmZmVycyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2VuRnJhbWVidWZmZXJzXCI6IF9lbXNjcmlwdGVuX2dsR2VuRnJhbWVidWZmZXJzLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZW5RdWVyaWVzRVhUXCI6IF9lbXNjcmlwdGVuX2dsR2VuUXVlcmllc0VYVCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2VuUmVuZGVyYnVmZmVyc1wiOiBfZW1zY3JpcHRlbl9nbEdlblJlbmRlcmJ1ZmZlcnMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdlblRleHR1cmVzXCI6IF9lbXNjcmlwdGVuX2dsR2VuVGV4dHVyZXMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdlblZlcnRleEFycmF5c09FU1wiOiBfZW1zY3JpcHRlbl9nbEdlblZlcnRleEFycmF5c09FUyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2VuZXJhdGVNaXBtYXBcIjogX2Vtc2NyaXB0ZW5fZ2xHZW5lcmF0ZU1pcG1hcCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0QWN0aXZlQXR0cmliXCI6IF9lbXNjcmlwdGVuX2dsR2V0QWN0aXZlQXR0cmliLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRBY3RpdmVVbmlmb3JtXCI6IF9lbXNjcmlwdGVuX2dsR2V0QWN0aXZlVW5pZm9ybSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0QXR0YWNoZWRTaGFkZXJzXCI6IF9lbXNjcmlwdGVuX2dsR2V0QXR0YWNoZWRTaGFkZXJzLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRBdHRyaWJMb2NhdGlvblwiOiBfZW1zY3JpcHRlbl9nbEdldEF0dHJpYkxvY2F0aW9uLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRCb29sZWFudlwiOiBfZW1zY3JpcHRlbl9nbEdldEJvb2xlYW52LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRCdWZmZXJQYXJhbWV0ZXJpdlwiOiBfZW1zY3JpcHRlbl9nbEdldEJ1ZmZlclBhcmFtZXRlcml2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRFcnJvclwiOiBfZW1zY3JpcHRlbl9nbEdldEVycm9yLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRGbG9hdHZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRGbG9hdHYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldEZyYW1lYnVmZmVyQXR0YWNobWVudFBhcmFtZXRlcml2XCI6IF9lbXNjcmlwdGVuX2dsR2V0RnJhbWVidWZmZXJBdHRhY2htZW50UGFyYW1ldGVyaXYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldEludGVnZXJ2XCI6IF9lbXNjcmlwdGVuX2dsR2V0SW50ZWdlcnYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFByb2dyYW1JbmZvTG9nXCI6IF9lbXNjcmlwdGVuX2dsR2V0UHJvZ3JhbUluZm9Mb2csXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFByb2dyYW1pdlwiOiBfZW1zY3JpcHRlbl9nbEdldFByb2dyYW1pdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3RpNjR2RVhUXCI6IF9lbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3RpNjR2RVhULFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRRdWVyeU9iamVjdGl2RVhUXCI6IF9lbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3RpdkVYVCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3R1aTY0dkVYVFwiOiBfZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0dWk2NHZFWFQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFF1ZXJ5T2JqZWN0dWl2RVhUXCI6IF9lbXNjcmlwdGVuX2dsR2V0UXVlcnlPYmplY3R1aXZFWFQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFF1ZXJ5aXZFWFRcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRRdWVyeWl2RVhULFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRSZW5kZXJidWZmZXJQYXJhbWV0ZXJpdlwiOiBfZW1zY3JpcHRlbl9nbEdldFJlbmRlcmJ1ZmZlclBhcmFtZXRlcml2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJJbmZvTG9nXCI6IF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVySW5mb0xvZyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XCI6IF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJTb3VyY2VcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFNoYWRlcml2XCI6IF9lbXNjcmlwdGVuX2dsR2V0U2hhZGVyaXYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFN0cmluZ1wiOiBfZW1zY3JpcHRlbl9nbEdldFN0cmluZyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VGV4UGFyYW1ldGVyZnZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRUZXhQYXJhbWV0ZXJmdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VGV4UGFyYW1ldGVyaXZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRUZXhQYXJhbWV0ZXJpdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VW5pZm9ybUxvY2F0aW9uXCI6IF9lbXNjcmlwdGVuX2dsR2V0VW5pZm9ybUxvY2F0aW9uLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xHZXRVbmlmb3JtZnZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRVbmlmb3JtZnYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbEdldFVuaWZvcm1pdlwiOiBfZW1zY3JpcHRlbl9nbEdldFVuaWZvcm1pdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VmVydGV4QXR0cmliUG9pbnRlcnZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJQb2ludGVydixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VmVydGV4QXR0cmliZnZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJmdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsR2V0VmVydGV4QXR0cmliaXZcIjogX2Vtc2NyaXB0ZW5fZ2xHZXRWZXJ0ZXhBdHRyaWJpdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsSGludFwiOiBfZW1zY3JpcHRlbl9nbEhpbnQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzQnVmZmVyXCI6IF9lbXNjcmlwdGVuX2dsSXNCdWZmZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzRW5hYmxlZFwiOiBfZW1zY3JpcHRlbl9nbElzRW5hYmxlZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsSXNGcmFtZWJ1ZmZlclwiOiBfZW1zY3JpcHRlbl9nbElzRnJhbWVidWZmZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzUHJvZ3JhbVwiOiBfZW1zY3JpcHRlbl9nbElzUHJvZ3JhbSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsSXNRdWVyeUVYVFwiOiBfZW1zY3JpcHRlbl9nbElzUXVlcnlFWFQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzUmVuZGVyYnVmZmVyXCI6IF9lbXNjcmlwdGVuX2dsSXNSZW5kZXJidWZmZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzU2hhZGVyXCI6IF9lbXNjcmlwdGVuX2dsSXNTaGFkZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbElzVGV4dHVyZVwiOiBfZW1zY3JpcHRlbl9nbElzVGV4dHVyZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsSXNWZXJ0ZXhBcnJheU9FU1wiOiBfZW1zY3JpcHRlbl9nbElzVmVydGV4QXJyYXlPRVMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbExpbmVXaWR0aFwiOiBfZW1zY3JpcHRlbl9nbExpbmVXaWR0aCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsTGlua1Byb2dyYW1cIjogX2Vtc2NyaXB0ZW5fZ2xMaW5rUHJvZ3JhbSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsUGl4ZWxTdG9yZWlcIjogX2Vtc2NyaXB0ZW5fZ2xQaXhlbFN0b3JlaSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsUG9seWdvbk9mZnNldFwiOiBfZW1zY3JpcHRlbl9nbFBvbHlnb25PZmZzZXQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFF1ZXJ5Q291bnRlckVYVFwiOiBfZW1zY3JpcHRlbl9nbFF1ZXJ5Q291bnRlckVYVCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsUmVhZFBpeGVsc1wiOiBfZW1zY3JpcHRlbl9nbFJlYWRQaXhlbHMsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFJlbGVhc2VTaGFkZXJDb21waWxlclwiOiBfZW1zY3JpcHRlbl9nbFJlbGVhc2VTaGFkZXJDb21waWxlcixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsUmVuZGVyYnVmZmVyU3RvcmFnZVwiOiBfZW1zY3JpcHRlbl9nbFJlbmRlcmJ1ZmZlclN0b3JhZ2UsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFNhbXBsZUNvdmVyYWdlXCI6IF9lbXNjcmlwdGVuX2dsU2FtcGxlQ292ZXJhZ2UsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFNjaXNzb3JcIjogX2Vtc2NyaXB0ZW5fZ2xTY2lzc29yLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xTaGFkZXJCaW5hcnlcIjogX2Vtc2NyaXB0ZW5fZ2xTaGFkZXJCaW5hcnksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFNoYWRlclNvdXJjZVwiOiBfZW1zY3JpcHRlbl9nbFNoYWRlclNvdXJjZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsU3RlbmNpbEZ1bmNcIjogX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsRnVuYyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsU3RlbmNpbEZ1bmNTZXBhcmF0ZVwiOiBfZW1zY3JpcHRlbl9nbFN0ZW5jaWxGdW5jU2VwYXJhdGUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFN0ZW5jaWxNYXNrXCI6IF9lbXNjcmlwdGVuX2dsU3RlbmNpbE1hc2ssXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFN0ZW5jaWxNYXNrU2VwYXJhdGVcIjogX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsTWFza1NlcGFyYXRlLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xTdGVuY2lsT3BcIjogX2Vtc2NyaXB0ZW5fZ2xTdGVuY2lsT3AsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFN0ZW5jaWxPcFNlcGFyYXRlXCI6IF9lbXNjcmlwdGVuX2dsU3RlbmNpbE9wU2VwYXJhdGUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFRleEltYWdlMkRcIjogX2Vtc2NyaXB0ZW5fZ2xUZXhJbWFnZTJELFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJmXCI6IF9lbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyZixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyZnZcIjogX2Vtc2NyaXB0ZW5fZ2xUZXhQYXJhbWV0ZXJmdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyaVwiOiBfZW1zY3JpcHRlbl9nbFRleFBhcmFtZXRlcmksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFRleFBhcmFtZXRlcml2XCI6IF9lbXNjcmlwdGVuX2dsVGV4UGFyYW1ldGVyaXYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFRleFN1YkltYWdlMkRcIjogX2Vtc2NyaXB0ZW5fZ2xUZXhTdWJJbWFnZTJELFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtMWZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0xZnZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWZ2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtMWlcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0xaXZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMWl2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtMmZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0yZnZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmZ2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtMmlcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMmksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0yaXZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtMml2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtM2ZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2YsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0zZnZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2Z2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtM2lcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2ksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm0zaXZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtM2l2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtNGZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm00ZnZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGZ2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtNGlcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGksXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm00aXZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtNGl2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVbmlmb3JtTWF0cml4MmZ2XCI6IF9lbXNjcmlwdGVuX2dsVW5pZm9ybU1hdHJpeDJmdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVW5pZm9ybU1hdHJpeDNmdlwiOiBfZW1zY3JpcHRlbl9nbFVuaWZvcm1NYXRyaXgzZnYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFVuaWZvcm1NYXRyaXg0ZnZcIjogX2Vtc2NyaXB0ZW5fZ2xVbmlmb3JtTWF0cml4NGZ2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xVc2VQcm9ncmFtXCI6IF9lbXNjcmlwdGVuX2dsVXNlUHJvZ3JhbSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVmFsaWRhdGVQcm9ncmFtXCI6IF9lbXNjcmlwdGVuX2dsVmFsaWRhdGVQcm9ncmFtLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIxZlwiOiBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjFmLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIxZnZcIjogX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIxZnYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjJmXCI6IF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliMmYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjJmdlwiOiBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjJmdixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2ZcIjogX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWIzZixcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2Z2XCI6IF9lbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliM2Z2LFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWI0ZlwiOiBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYjRmLFxuICAgICAgICBcImVtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWI0ZnZcIjogX2Vtc2NyaXB0ZW5fZ2xWZXJ0ZXhBdHRyaWI0ZnYsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRVwiOiBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dsVmVydGV4QXR0cmliUG9pbnRlclwiOiBfZW1zY3JpcHRlbl9nbFZlcnRleEF0dHJpYlBvaW50ZXIsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nbFZpZXdwb3J0XCI6IF9lbXNjcmlwdGVuX2dsVmlld3BvcnQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9oYXNfYXN5bmNpZnlcIjogX2Vtc2NyaXB0ZW5faGFzX2FzeW5jaWZ5LFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2xlZXBcIjogX2Vtc2NyaXB0ZW5fc2xlZXAsXG4gICAgICAgIFwiZWdsQmluZEFQSVwiOiBfZWdsQmluZEFQSSxcbiAgICAgICAgXCJlZ2xDaG9vc2VDb25maWdcIjogX2VnbENob29zZUNvbmZpZyxcbiAgICAgICAgXCJlZ2xDcmVhdGVDb250ZXh0XCI6IF9lZ2xDcmVhdGVDb250ZXh0LFxuICAgICAgICBcImVnbENyZWF0ZVdpbmRvd1N1cmZhY2VcIjogX2VnbENyZWF0ZVdpbmRvd1N1cmZhY2UsXG4gICAgICAgIFwiZWdsRGVzdHJveUNvbnRleHRcIjogX2VnbERlc3Ryb3lDb250ZXh0LFxuICAgICAgICBcImVnbERlc3Ryb3lTdXJmYWNlXCI6IF9lZ2xEZXN0cm95U3VyZmFjZSxcbiAgICAgICAgXCJlZ2xHZXRDb25maWdBdHRyaWJcIjogX2VnbEdldENvbmZpZ0F0dHJpYixcbiAgICAgICAgXCJlZ2xHZXREaXNwbGF5XCI6IF9lZ2xHZXREaXNwbGF5LFxuICAgICAgICBcImVnbEdldEVycm9yXCI6IF9lZ2xHZXRFcnJvcixcbiAgICAgICAgXCJlZ2xJbml0aWFsaXplXCI6IF9lZ2xJbml0aWFsaXplLFxuICAgICAgICBcImVnbE1ha2VDdXJyZW50XCI6IF9lZ2xNYWtlQ3VycmVudCxcbiAgICAgICAgXCJlZ2xRdWVyeVN0cmluZ1wiOiBfZWdsUXVlcnlTdHJpbmcsXG4gICAgICAgIFwiZWdsU3dhcEJ1ZmZlcnNcIjogX2VnbFN3YXBCdWZmZXJzLFxuICAgICAgICBcImVnbFN3YXBJbnRlcnZhbFwiOiBfZWdsU3dhcEludGVydmFsLFxuICAgICAgICBcImVnbFRlcm1pbmF0ZVwiOiBfZWdsVGVybWluYXRlLFxuICAgICAgICBcImVnbFdhaXRHTFwiOiBfZWdsV2FpdEdMLFxuICAgICAgICBcImVnbFdhaXROYXRpdmVcIjogX2VnbFdhaXROYXRpdmUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9hc21fY29uc3RfaW50XCI6IF9lbXNjcmlwdGVuX2FzbV9jb25zdF9pbnQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfYmVmb3JldW5sb2FkX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfYmVmb3JldW5sb2FkX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9ibHVyX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfYmx1cl9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZVwiOiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9lbGVtZW50X2Nzc19zaXplXCI6IF9lbXNjcmlwdGVuX3NldF9lbGVtZW50X2Nzc19zaXplLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2ZvY3VzX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfZm9jdXNfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2Z1bGxzY3JlZW5jaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9mdWxsc2NyZWVuY2hhbmdlX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9nYW1lcGFkY29ubmVjdGVkX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGNvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGRpc2Nvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2dhbWVwYWRkaXNjb25uZWN0ZWRfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2tleWRvd25fY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9rZXlkb3duX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9rZXlwcmVzc19jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2tleXByZXNzX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9rZXl1cF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2tleXVwX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X21vdXNlZW50ZXJfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9tb3VzZWVudGVyX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZWxlYXZlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2VsZWF2ZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfbW91c2Vtb3ZlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2Vtb3ZlX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZXVwX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2V1cF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfcG9pbnRlcmxvY2tjaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9wb2ludGVybG9ja2NoYW5nZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfcmVzaXplX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfcmVzaXplX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaGNhbmNlbF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoY2FuY2VsX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaGVuZF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoZW5kX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaG1vdmVfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF90b3VjaG1vdmVfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X3RvdWNoc3RhcnRfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF90b3VjaHN0YXJ0X2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF92aXNpYmlsaXR5Y2hhbmdlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfdmlzaWJpbGl0eWNoYW5nZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfd2hlZWxfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF93aGVlbF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zYW1wbGVfZ2FtZXBhZF9kYXRhXCI6IF9lbXNjcmlwdGVuX3NhbXBsZV9nYW1lcGFkX2RhdGEsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfYmVmb3JldW5sb2FkX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfYmVmb3JldW5sb2FkX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9ibHVyX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfYmx1cl9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZVwiOiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9lbGVtZW50X2Nzc19zaXplXCI6IF9lbXNjcmlwdGVuX3NldF9lbGVtZW50X2Nzc19zaXplLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2ZvY3VzX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfZm9jdXNfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2Z1bGxzY3JlZW5jaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9mdWxsc2NyZWVuY2hhbmdlX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9nYW1lcGFkY29ubmVjdGVkX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGNvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfZ2FtZXBhZGRpc2Nvbm5lY3RlZF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2dhbWVwYWRkaXNjb25uZWN0ZWRfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X2tleWRvd25fY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9rZXlkb3duX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9rZXlwcmVzc19jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2tleXByZXNzX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9rZXl1cF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X2tleXVwX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9tb3VzZWRvd25fY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X21vdXNlZW50ZXJfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9tb3VzZWVudGVyX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZWxlYXZlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2VsZWF2ZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfbW91c2Vtb3ZlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2Vtb3ZlX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF9tb3VzZXVwX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfbW91c2V1cF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfcG9pbnRlcmxvY2tjaGFuZ2VfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF9wb2ludGVybG9ja2NoYW5nZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfcmVzaXplX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfcmVzaXplX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaGNhbmNlbF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoY2FuY2VsX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaGVuZF9jYWxsYmFja19vbl90aHJlYWRcIjogX2Vtc2NyaXB0ZW5fc2V0X3RvdWNoZW5kX2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF90b3VjaG1vdmVfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF90b3VjaG1vdmVfY2FsbGJhY2tfb25fdGhyZWFkLFxuICAgICAgICBcImVtc2NyaXB0ZW5fc2V0X3RvdWNoc3RhcnRfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF90b3VjaHN0YXJ0X2NhbGxiYWNrX29uX3RocmVhZCxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3NldF92aXNpYmlsaXR5Y2hhbmdlX2NhbGxiYWNrX29uX3RocmVhZFwiOiBfZW1zY3JpcHRlbl9zZXRfdmlzaWJpbGl0eWNoYW5nZV9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfd2hlZWxfY2FsbGJhY2tfb25fdGhyZWFkXCI6IF9lbXNjcmlwdGVuX3NldF93aGVlbF9jYWxsYmFja19vbl90aHJlYWQsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9zZXRfd2luZG93X3RpdGxlXCI6IF9lbXNjcmlwdGVuX3NldF93aW5kb3dfdGl0bGUsXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nZXRfZ2FtZXBhZF9zdGF0dXNcIjogX2Vtc2NyaXB0ZW5fZ2V0X2dhbWVwYWRfc3RhdHVzLFxuICAgICAgICBcImVtc2NyaXB0ZW5fcmVxdWVzdF9mdWxsc2NyZWVuX3N0cmF0ZWd5XCI6IF9lbXNjcmlwdGVuX3JlcXVlc3RfZnVsbHNjcmVlbl9zdHJhdGVneSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX3JlcXVlc3RfcG9pbnRlcmxvY2tcIjogX2Vtc2NyaXB0ZW5fcmVxdWVzdF9wb2ludGVybG9jayxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2V4aXRfcG9pbnRlcmxvY2tcIjogX2Vtc2NyaXB0ZW5fZXhpdF9wb2ludGVybG9jayxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dldF9kZXZpY2VfcGl4ZWxfcmF0aW9cIjogX2Vtc2NyaXB0ZW5fZ2V0X2RldmljZV9waXhlbF9yYXRpbyxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2V4aXRfZnVsbHNjcmVlblwiOiBfZW1zY3JpcHRlbl9leGl0X2Z1bGxzY3JlZW4sXG4gICAgICAgIFwiZW1zY3JpcHRlbl9leGl0X3BvaW50ZXJsb2NrXCI6IF9lbXNjcmlwdGVuX2V4aXRfcG9pbnRlcmxvY2ssXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nZXRfZGV2aWNlX3BpeGVsX3JhdGlvXCI6IF9lbXNjcmlwdGVuX2dldF9kZXZpY2VfcGl4ZWxfcmF0aW8sXG4gICAgICAgIFwiZW1zY3JpcHRlbl9nZXRfZWxlbWVudF9jc3Nfc2l6ZVwiOiBfZW1zY3JpcHRlbl9nZXRfZWxlbWVudF9jc3Nfc2l6ZSxcbiAgICAgICAgXCJlbXNjcmlwdGVuX2dldF9nYW1lcGFkX3N0YXR1c1wiOiBfZW1zY3JpcHRlbl9nZXRfZ2FtZXBhZF9zdGF0dXMsXG5cbiAgICB9XG4gICAgcmV0dXJuIHNkbF9mdW5jdGlvbnM7XG59XG5leHBvcnQgeyBTRExfTU9EVUxFIH07IiwiLy9pbXBvcnQge0hFQVBVOCwgYXNtTGlicmFyeUFyZywgd3JpdGVBcnJheVRvTWVtb3J5LCBpbml0UnVudGltZSwgc3RhY2tDaGVja0luaXQsIE1vZHVsZSwgd2FzbVRhYmxlLCB3YXNtTWVtb3J5LCBzdHJpbmdUb1VURjgsIHN0YWNrQWxsb2N9IGZyb20gJy4vcGxheWVyJ1xuaW1wb3J0IHsgQ29tbW9uIH0gZnJvbSBcIi4vY29tbW9uXCJcbmltcG9ydCB7IE1vZHVsZSwgbG9jYXRpb24gfSBmcm9tIFwiLi9jb3JlLWNvZGVyLmpzXCJcbmltcG9ydCB7IGZpbGVpbyB9IGZyb20gXCIuL21lbWlvXCJcblxuY2xhc3MgVW5pdmVyc2FsQXVkaW8gZXh0ZW5kcyBIVE1MQXVkaW9FbGVtZW50IHtcbiAgICB1c2luZzogc3RyaW5nO1xuICAgIGNvbW1vbjogQ29tbW9uO1xuICAgIG1lbW9yeTogVWludDhBcnJheTtcblxuICAgIHdpdGg6IHN0cmluZztcblxuICAgIGluc3RhbmNlOiBhbnk7XG4gICAgZW50cnk6IGFueTtcbiAgICBtb2R1bGU6IGFueTtcbiAgICBpbzogZmlsZWlvO1xuXG4gICAgcHJpdmF0ZSBfZGVjb2RpbmdQcm9taXNlOiBQcm9taXNlPFN0cmluZz47XG5cbiAgICBnZXQgZGVjb2RpbmdQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RpbmdQcm9taXNlO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgdXNpbmdfYXR0cmlidXRlID0gc2VsZi5nZXRBdHRyaWJ1dGUoXCJ1c2luZ1wiKTtcbiAgICAgICAgY29uc3Qgd2l0aF9hdHRyaWJ1dGUgPSBzZWxmLmdldEF0dHJpYnV0ZShcIndpdGhcIikuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGFyZ3M6IGFueSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhdHRzID0gdGhpcy5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGgsIGFyciA9IFtdOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IGF0dHNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgICBhcmdzW25vZGVOYW1lXSA9IGF0dHNbaV0ubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYXRpb24udXNpbmcgPSB1c2luZ19hdHRyaWJ1dGU7XG4gICAgICAgIGxvY2F0aW9uLndpdGggPSB3aXRoX2F0dHJpYnV0ZTtcbiAgICAgICAgdGhpcy5pbyA9IG5ldyBmaWxlaW8oKTtcblxuICAgICAgICB0aGlzLl9kZWNvZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgobWFpbl9yZXNvbHZlLCBfbWFpbl9yZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJ3cml0ZWdlbi53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcImZpbGVvdXQud2FzbVwiKTtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJmaWxlaW4ud2FzbVwiKTtcbiAgICAgICAgICAgIG5ldyAoTW9kdWxlIGFzIGFueSkoe1xuICAgICAgICAgICAgICAgIGR5bmFtaWNMaWJyYXJpZXM6IHdpdGhfYXR0cmlidXRlXG4gICAgICAgICAgICB9KS50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgc2VsZi5pby5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgICAgICAgICAgc2VsZi5lbnRyeSA9IHNlbGYubW9kdWxlLl9jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXJfaW4gPSBzZWxmLmlvLm1ha2VfZmlsZWlvKHNlbGYuc3JjLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyX291dCA9IHNlbGYuaW8ubWFrZV9maWxlaW8oXCJvdXQud2F2XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhcmdzW1wiaW9faW5cIl0gPSBidWZmZXJfaW4uZmlsZV9pbztcbiAgICAgICAgICAgICAgICBhcmdzW1wiaW9fb3V0XCJdID0gYnVmZmVyX291dC5maWxlX2lvO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IGlucHV0IGZpbHRlcnNcbiAgICAgICAgICAgICAgICBhcmdzW1wiZmlsdGVyc1wiXSA9IHNlbGYubW9kdWxlLmZpbHRlcl9lbnRyaWVzLm1hcChlbnRyeSA9PiBzZWxmLm1vZHVsZVtcIl9cIiArIGVudHJ5XSgwKSk7XG5cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChzZWxmLmlvLmZldGNoX3Byb21pc2VzKS50aGVuKHJlc19mZXRjaCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHNlbGYuaW8uYnVmZmVyX3Byb21pc2VzKS50aGVuKHJlc19idWZmZXIgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGpzb24gdG8gc3RyaW5nIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbl9hcmdzID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5fYXJncyA9IChqc29uX2FyZ3MubGVuZ3RoIDw8IDIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0cl9hcmdzID0gc2VsZi5tb2R1bGUuc3RhY2tBbGxvYyhsZW5fYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZS5zdHJpbmdUb1VURjgoanNvbl9hcmdzLCBwdHJfYXJncywgbGVuX2FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHNldCBmdW5jdGlvbiBhbmQgZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZS5fc2V0KHNlbGYuZW50cnksIHB0cl9hcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaGFzQXR0cmlidXRlKFwiY29ubmVjdGlvbnNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKFwiY29ubmVjdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldF9hcmdzID0gSlNPTi5zdHJpbmdpZnkocHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZXRfYXJnc19sZW4gPSAoZ2V0X2FyZ3MubGVuZ3RoIDw8IDIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0cl9nZXRfYXJncyA9IHNlbGYubW9kdWxlLnN0YWNrQWxsb2MoZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2R1bGUuc3RyaW5nVG9VVEY4KGdldF9hcmdzLCBwdHJfZ2V0X2FyZ3MsIGdldF9hcmdzX2xlbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHB0cl9kYXRhID0gc2VsZi5tb2R1bGUuX2dldChzZWxmLmVudHJ5LCBwdHJfZ2V0X2FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbl9yZXMgPSBzZWxmLm1vZHVsZS5VVEY4VG9TdHJpbmcocHRyX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbl9yZXNfcGFyc2VkID0gSlNPTi5wYXJzZShqc29uX3Jlcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyX291dC5idWZmZXJfdThdLCB7dHlwZSA6IFwiYXVkaW8vd2F2ZVwifSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9yZXNvbHZlKHNlbGYuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lOiBzdHJpbmcsIG9sZFZhbHVlOiBzdHJpbmcsIG5ld1ZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSkgcmV0dXJuO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NyYyc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1c2luZyc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3aXRoJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydzcmMnLCAndXNpbmcnLCAnd2l0aCddOyB9XG59XG5cbmV4cG9ydCB7IFVuaXZlcnNhbEF1ZGlvIH0iLCJpbXBvcnQgeyBDb21tb24gfSBmcm9tIFwiLi9jb21tb25cIlxuaW1wb3J0IHsgTW9kdWxlLCBsb2NhdGlvbiB9IGZyb20gXCIuL2NvcmUtcGxheWVyLmpzXCJcblxuY2xhc3MgVW5pdmVyc2FsQ2FudmFzIGV4dGVuZHMgSFRNTENhbnZhc0VsZW1lbnQge1xuICAgIHVzaW5nOiBzdHJpbmc7XG4gICAgY29tbW9uOiBDb21tb247XG4gICAgbWVtb3J5OiBVaW50OEFycmF5O1xuXG4gICAgd2l0aDogc3RyaW5nO1xuXG4gICAgaW5zdGFuY2U6IGFueTtcbiAgICBlbnRyeTogYW55O1xuICAgIG1vZHVsZTogYW55O1xuICAgIHNyYzogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBfZGVjb2RpbmdQcm9taXNlOiBQcm9taXNlPFN0cmluZz47XG5cbiAgICBnZXQgZGVjb2RpbmdQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RpbmdQcm9taXNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBmbHVzaF9pbWFnZShfZW50cnk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXMgYXMgYW55O1xuXG4gICAgICAgIGNvbnN0IGdldF9hcmdzID0gSlNPTi5zdHJpbmdpZnkoW1xuICAgICAgICAgICAgXCJnZXRJbWFnZVwiLCBcImdldFNpemVcIiwgXCJnZXRXaWR0aFwiLCBcImdldEhlaWdodFwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBnZXRfYXJnc19sZW4gPSAoZ2V0X2FyZ3MubGVuZ3RoIDw8IDIpICsgMTtcbiAgICAgICAgY29uc3QgcHRyX2dldF9hcmdzID0gc2VsZi5pbnN0YW5jZS5zdGFja0FsbG9jKGdldF9hcmdzX2xlbik7XG5cbiAgICAgICAgc2VsZi5pbnN0YW5jZS5zdHJpbmdUb1VURjgoZ2V0X2FyZ3MsIHB0cl9nZXRfYXJncywgZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICBjb25zdCBwdHJfZGF0YSA9IHNlbGYuaW5zdGFuY2UuX2dldChzZWxmLmVudHJ5LCBwdHJfZ2V0X2FyZ3MpO1xuXG4gICAgICAgIGNvbnN0IGpzb24gPSBzZWxmLmluc3RhbmNlLlVURjhUb1N0cmluZyhwdHJfZGF0YSk7XG4gICAgICAgIGNvbnN0IGpzb25fcGFyc2VkID0gSlNPTi5wYXJzZShqc29uKTtcblxuICAgICAgICBpZiAoanNvbl9wYXJzZWQuZ2V0SW1hZ2UgPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGltYWdlID0gc2VsZi5pbnN0YW5jZS5IRUFQVTguc2xpY2UoanNvbl9wYXJzZWQuZ2V0SW1hZ2UsIGpzb25fcGFyc2VkLmdldEltYWdlICsganNvbl9wYXJzZWQuZ2V0U2l6ZSk7XG5cbiAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoanNvbl9wYXJzZWQuZ2V0V2lkdGgsIGpzb25fcGFyc2VkLmdldEhlaWdodCk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywganNvbl9wYXJzZWQuZ2V0V2lkdGgpO1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBqc29uX3BhcnNlZC5nZXRIZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciB0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gaW1hZ2VbdF07XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGltYWdlW3QgKyAxXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gaW1hZ2VbdCArIDJdO1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSAyNTU7XG5cbiAgICAgICAgICAgIHQgKz0gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICBzZWxmLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH0pXG4gICAgfVxuXG5cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHVzaW5nX2F0dHJpYnV0ZSA9IHNlbGYuZ2V0QXR0cmlidXRlKFwidXNpbmdcIik7XG4gICAgICAgIGNvbnN0IHdpdGhfYXR0cmlidXRlID0gc2VsZi5nZXRBdHRyaWJ1dGUoXCJ3aXRoXCIpLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBhcmdzOiBhbnkgPSB7fTtcbiAgICAgICAgdGhpcy5zcmMgPSBzZWxmLmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhdHRzID0gdGhpcy5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGgsIGFyciA9IFtdOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IGF0dHNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgICBhcmdzW25vZGVOYW1lXSA9IGF0dHNbaV0ubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYXRpb24udXNpbmcgPSB1c2luZ19hdHRyaWJ1dGU7XG4gICAgICAgIGxvY2F0aW9uLndpdGggPSB3aXRoX2F0dHJpYnV0ZTtcblxuICAgICAgICB0aGlzLl9kZWNvZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgobWFpbl9yZXNvbHZlLCBfbWFpbl9yZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJ3cml0ZWdlbi53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcInJmaW1nLndhc21cIik7XG4gICAgICAgICAgICB3aXRoX2F0dHJpYnV0ZS5wdXNoKFwiY29tcG9zZS53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcInBuZ2VuYy53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcImZpbGVvdXQud2FzbVwiKTtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJmaWxlaW4ud2FzbVwiKTtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJzZGxfb3V0Lndhc21cIik7XG4gICAgICAgICAgICB3aXRoX2F0dHJpYnV0ZS5wdXNoKFwiYW91dC53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcImh0dHBpbi53YXNtXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXcgKE1vZHVsZSBhcyBhbnkpKHtcbiAgICAgICAgICAgICAgICBkeW5hbWljTGlicmFyaWVzOiB3aXRoX2F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBjYW52YXM6dGhpc1xuICAgICAgICAgICAgfSkudGhlbihtb2R1bGUgPT4ge1xuICAgICAgICAgICAgICAgIG1vZHVsZVsnY2FudmFzJ10gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgIHNlbGYuZW50cnkgPSBzZWxmLm1vZHVsZS5fY29uc3RydWN0b3IoKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBpbnB1dCBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgYXJnc1tcImZpbHRlcnNcIl0gPSBzZWxmLm1vZHVsZS5maWx0ZXJfZW50cmllcy5tYXAoZW50cnkgPT4gc2VsZi5tb2R1bGVbXCJfXCIgKyBlbnRyeV0oMCkpO1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJtb2R1bGVzXCJdID0gc2VsZi5tb2R1bGUubW9kdWxlX2VudHJpZXMubWFwKGVudHJ5ID0+IHNlbGYubW9kdWxlW1wiX1wiICsgZW50cnldKCkpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQganNvbiB0byBzdHJpbmcgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX2FyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbl9hcmdzID0gKGpzb25fYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2FyZ3MgPSBzZWxmLm1vZHVsZS5zdGFja0FsbG9jKGxlbl9hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLnN0cmluZ1RvVVRGOChqc29uX2FyZ3MsIHB0cl9hcmdzLCBsZW5fYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgc2V0IGZ1bmN0aW9uIGFuZCBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLl9zZXQoc2VsZi5lbnRyeSwgcHRyX2FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNBdHRyaWJ1dGUoXCJjb25uZWN0aW9uc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goXCJjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0X2FyZ3MgPSBKU09OLnN0cmluZ2lmeShwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldF9hcmdzX2xlbiA9IChnZXRfYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2dldF9hcmdzID0gc2VsZi5tb2R1bGUuc3RhY2tBbGxvYyhnZXRfYXJnc19sZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZS5zdHJpbmdUb1VURjgoZ2V0X2FyZ3MsIHB0cl9nZXRfYXJncywgZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2RhdGEgPSBzZWxmLm1vZHVsZS5fZ2V0KHNlbGYuZW50cnksIHB0cl9nZXRfYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3JlcyA9IHNlbGYubW9kdWxlLlVURjhUb1N0cmluZyhwdHJfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3Jlc19wYXJzZWQgPSBKU09OLnBhcnNlKGpzb25fcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsbCgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLl9ydW4oc2VsZi5lbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzcmMnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXNpbmcnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnc3JjJywgJ3VzaW5nJywgJ3dpdGgnXTsgfVxufVxuXG5leHBvcnQgeyBVbml2ZXJzYWxDYW52YXMgfSIsImltcG9ydCB7IENvbW1vbiB9IGZyb20gXCIuL2NvbW1vblwiXG5pbXBvcnQgeyBNb2R1bGUsIGxvY2F0aW9uIH0gZnJvbSBcIi4vY29yZS1jb2Rlci5qc1wiXG5pbXBvcnQge2ZpbGVpb30gZnJvbSBcIi4vbWVtaW9cIlxuXG4vL2RlY2xhcmUgdmFyIE1vZHVsZTogYW55O1xuXG5jbGFzcyBVbml2ZXJzYWxJbWFnZSBleHRlbmRzIEhUTUxJbWFnZUVsZW1lbnQge1xuICAgIHVzaW5nOiBzdHJpbmc7XG4gICAgY29tbW9uOiBDb21tb247XG4gICAgbWVtb3J5OiBVaW50OEFycmF5O1xuXG4gICAgd2l0aDogc3RyaW5nO1xuXG4gICAgaW5zdGFuY2U6IGFueTtcbiAgICBlbnRyeTogYW55O1xuICAgIG1vZHVsZTogYW55O1xuICAgIGlvOiBmaWxlaW87XG5cbiAgICBwcml2YXRlIF9kZWNvZGluZ1Byb21pc2U6IFByb21pc2U8U3RyaW5nPjtcblxuICAgIGdldCBkZWNvZGluZ1Byb21pc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGluZ1Byb21pc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGZsdXNoX2ltYWdlKF9lbnRyeTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcyBhcyBhbnk7XG5cbiAgICAgICAgY29uc3QgZ2V0X2FyZ3MgPSBKU09OLnN0cmluZ2lmeShbXG4gICAgICAgICAgICBcImdldEltYWdlXCIsIFwiZ2V0U2l6ZVwiLCBcImdldFdpZHRoXCIsIFwiZ2V0SGVpZ2h0XCJcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGdldF9hcmdzX2xlbiA9IChnZXRfYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICBjb25zdCBwdHJfZ2V0X2FyZ3MgPSBzZWxmLmluc3RhbmNlLnN0YWNrQWxsb2MoZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICBzZWxmLmluc3RhbmNlLnN0cmluZ1RvVVRGOChnZXRfYXJncywgcHRyX2dldF9hcmdzLCBnZXRfYXJnc19sZW4pO1xuXG4gICAgICAgIGNvbnN0IHB0cl9kYXRhID0gc2VsZi5pbnN0YW5jZS5fZ2V0KHNlbGYuZW50cnksIHB0cl9nZXRfYXJncyk7XG5cbiAgICAgICAgY29uc3QganNvbiA9IHNlbGYuaW5zdGFuY2UuVVRGOFRvU3RyaW5nKHB0cl9kYXRhKTtcbiAgICAgICAgY29uc3QganNvbl9wYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pO1xuXG4gICAgICAgIGlmIChqc29uX3BhcnNlZC5nZXRJbWFnZSA9PSAwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgaW1hZ2UgPSBzZWxmLmluc3RhbmNlLkhFQVBVOC5zbGljZShqc29uX3BhcnNlZC5nZXRJbWFnZSwganNvbl9wYXJzZWQuZ2V0SW1hZ2UgKyBqc29uX3BhcnNlZC5nZXRTaXplKTtcblxuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YShqc29uX3BhcnNlZC5nZXRXaWR0aCwganNvbl9wYXJzZWQuZ2V0SGVpZ2h0KTtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBqc29uX3BhcnNlZC5nZXRXaWR0aCk7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGpzb25fcGFyc2VkLmdldEhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHQgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBpbWFnZVt0XTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gaW1hZ2VbdCArIDFdO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBpbWFnZVt0ICsgMl07XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IDI1NTtcblxuICAgICAgICAgICAgdCArPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIHNlbGYuc3Jjc2V0ID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgfSlcbiAgICB9XG5cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgdXNpbmdfYXR0cmlidXRlID0gc2VsZi5nZXRBdHRyaWJ1dGUoXCJ1c2luZ1wiKTtcbiAgICAgICAgY29uc3Qgd2l0aF9hdHRyaWJ1dGUgPSBzZWxmLmdldEF0dHJpYnV0ZShcIndpdGhcIikuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGFyZ3M6IGFueSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhdHRzID0gdGhpcy5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGgsIGFyciA9IFtdOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IGF0dHNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgICBhcmdzW25vZGVOYW1lXSA9IGF0dHNbaV0ubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYXRpb24udXNpbmcgPSB1c2luZ19hdHRyaWJ1dGU7XG4gICAgICAgIGxvY2F0aW9uLndpdGggPSB3aXRoX2F0dHJpYnV0ZTtcbiAgICAgICAgdGhpcy5pbyA9IG5ldyBmaWxlaW8oKTtcblxuICAgICAgICB0aGlzLl9kZWNvZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgobWFpbl9yZXNvbHZlLCBfbWFpbl9yZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJ3cml0ZWdlbi53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcInJmaW1nLndhc21cIik7XG4gICAgICAgICAgICB3aXRoX2F0dHJpYnV0ZS5wdXNoKFwicG5nZW5jLndhc21cIik7XG4gICAgICAgICAgICB3aXRoX2F0dHJpYnV0ZS5wdXNoKFwiZmlsZW91dC53YXNtXCIpO1xuICAgICAgICAgICAgd2l0aF9hdHRyaWJ1dGUucHVzaChcImZpbGVpbi53YXNtXCIpO1xuICAgICAgICAgICAgbmV3IChNb2R1bGUgYXMgYW55KSh7XG4gICAgICAgICAgICAgICAgZHluYW1pY0xpYnJhcmllczogd2l0aF9hdHRyaWJ1dGVcbiAgICAgICAgICAgIH0pLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmlvLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmVudHJ5ID0gc2VsZi5tb2R1bGUuX2NvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcl9pbiA9IHNlbGYuaW8ubWFrZV9maWxlaW8oc2VsZi5zcmMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXJfb3V0ID0gc2VsZi5pby5tYWtlX2ZpbGVpbyhcIm91dC5wbmdcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJpb19pblwiXSA9IGJ1ZmZlcl9pbi5maWxlX2lvO1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJpb19vdXRcIl0gPSBidWZmZXJfb3V0LmZpbGVfaW87XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgaW5wdXQgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJmaWx0ZXJzXCJdID0gc2VsZi5tb2R1bGUuZmlsdGVyX2VudHJpZXMubWFwKGVudHJ5ID0+IHNlbGYubW9kdWxlW1wiX1wiICsgZW50cnldKDApKTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHNlbGYuaW8uZmV0Y2hfcHJvbWlzZXMpLnRoZW4ocmVzX2ZldGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoc2VsZi5pby5idWZmZXJfcHJvbWlzZXMpLnRoZW4ocmVzX2J1ZmZlciA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQganNvbiB0byBzdHJpbmcgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX2FyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbl9hcmdzID0gKGpzb25fYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2FyZ3MgPSBzZWxmLm1vZHVsZS5zdGFja0FsbG9jKGxlbl9hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLnN0cmluZ1RvVVRGOChqc29uX2FyZ3MsIHB0cl9hcmdzLCBsZW5fYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgc2V0IGZ1bmN0aW9uIGFuZCBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLl9zZXQoc2VsZi5lbnRyeSwgcHRyX2FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNBdHRyaWJ1dGUoXCJjb25uZWN0aW9uc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goXCJjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0X2FyZ3MgPSBKU09OLnN0cmluZ2lmeShwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldF9hcmdzX2xlbiA9IChnZXRfYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2dldF9hcmdzID0gc2VsZi5tb2R1bGUuc3RhY2tBbGxvYyhnZXRfYXJnc19sZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZS5zdHJpbmdUb1VURjgoZ2V0X2FyZ3MsIHB0cl9nZXRfYXJncywgZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2RhdGEgPSBzZWxmLm1vZHVsZS5fZ2V0KHNlbGYuZW50cnksIHB0cl9nZXRfYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3JlcyA9IHNlbGYubW9kdWxlLlVURjhUb1N0cmluZyhwdHJfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3Jlc19wYXJzZWQgPSBKU09OLnBhcnNlKGpzb25fcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJfb3V0LmJ1ZmZlcl91OF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zcmNzZXQgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbl9yZXNvbHZlKHNlbGYuc3Jjc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzcmMnOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3JjIGhhcyBjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXNpbmcnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnc3JjJywgJ3VzaW5nJywgJ3dpdGgnXTsgfVxufVxuXG5leHBvcnQgeyBVbml2ZXJzYWxJbWFnZSB9IiwiLy9pbXBvcnQge0hFQVBVOCwgYXNtTGlicmFyeUFyZywgd3JpdGVBcnJheVRvTWVtb3J5LCBpbml0UnVudGltZSwgc3RhY2tDaGVja0luaXQsIE1vZHVsZSwgd2FzbVRhYmxlLCB3YXNtTWVtb3J5LCBzdHJpbmdUb1VURjgsIHN0YWNrQWxsb2N9IGZyb20gJy4vcGxheWVyJ1xuaW1wb3J0IHsgQ29tbW9uIH0gZnJvbSBcIi4vY29tbW9uXCJcbmltcG9ydCB7IE1vZHVsZSwgbG9jYXRpb24gfSBmcm9tIFwiLi9jb3JlLWNvZGVyLmpzXCJcbmltcG9ydCB7IGZpbGVpbyB9IGZyb20gXCIuL21lbWlvXCJcblxuY2xhc3MgVW5pdmVyc2FsVmlkZW8gZXh0ZW5kcyBIVE1MVmlkZW9FbGVtZW50IHtcbiAgICB1c2luZzogc3RyaW5nO1xuICAgIGNvbW1vbjogQ29tbW9uO1xuICAgIG1lbW9yeTogVWludDhBcnJheTtcblxuICAgIHdpdGg6IHN0cmluZztcblxuICAgIGluc3RhbmNlOiBhbnk7XG4gICAgZW50cnk6IGFueTtcbiAgICBtb2R1bGU6IGFueTtcbiAgICBpbzogZmlsZWlvO1xuXG4gICAgcHJpdmF0ZSBfZGVjb2RpbmdQcm9taXNlOiBQcm9taXNlPFN0cmluZz47XG5cbiAgICBnZXQgZGVjb2RpbmdQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RpbmdQcm9taXNlO1xuICAgIH1cblxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgdXNpbmdfYXR0cmlidXRlID0gc2VsZi5nZXRBdHRyaWJ1dGUoXCJ1c2luZ1wiKTtcbiAgICAgICAgY29uc3Qgd2l0aF9hdHRyaWJ1dGUgPSBzZWxmLmdldEF0dHJpYnV0ZShcIndpdGhcIikuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGFyZ3M6IGFueSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhdHRzID0gdGhpcy5hdHRyaWJ1dGVzLCBuID0gYXR0cy5sZW5ndGgsIGFyciA9IFtdOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IGF0dHNbaV0ubm9kZU5hbWU7XG4gICAgICAgICAgICBhcmdzW25vZGVOYW1lXSA9IGF0dHNbaV0ubm9kZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYXRpb24udXNpbmcgPSB1c2luZ19hdHRyaWJ1dGU7XG4gICAgICAgIGxvY2F0aW9uLndpdGggPSB3aXRoX2F0dHJpYnV0ZTtcbiAgICAgICAgdGhpcy5pbyA9IG5ldyBmaWxlaW8oKTtcblxuICAgICAgICB0aGlzLl9kZWNvZGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgobWFpbl9yZXNvbHZlLCBfbWFpbl9yZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdpdGhfYXR0cmlidXRlLnB1c2goXCJ3cml0ZWdlbi53YXNtXCIpO1xuICAgICAgICAgICAgbmV3IChNb2R1bGUgYXMgYW55KSh7XG4gICAgICAgICAgICAgICAgZHluYW1pY0xpYnJhcmllczogd2l0aF9hdHRyaWJ1dGVcbiAgICAgICAgICAgIH0pLnRoZW4obW9kdWxlID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmlvLm1vZHVsZSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBzZWxmLmVudHJ5ID0gc2VsZi5tb2R1bGUuX2NvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcl9pbiA9IHNlbGYuaW8ubWFrZV9maWxlaW8oc2VsZi5zcmMsIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXJfb3V0ID0gc2VsZi5pby5tYWtlX2ZpbGVpbyhcIm91dC5tcDRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJpb19pblwiXSA9IGJ1ZmZlcl9pbi5maWxlX2lvO1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJpb19vdXRcIl0gPSBidWZmZXJfb3V0LmZpbGVfaW87XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgaW5wdXQgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGFyZ3NbXCJmaWx0ZXJzXCJdID0gc2VsZi5tb2R1bGUuZmlsdGVyX2VudHJpZXMubWFwKGVudHJ5ID0+IHNlbGYubW9kdWxlW1wiX1wiICsgZW50cnldKDApKTtcblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHNlbGYuaW8uZmV0Y2hfcHJvbWlzZXMpLnRoZW4ocmVzX2ZldGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoc2VsZi5pby5idWZmZXJfcHJvbWlzZXMpLnRoZW4ocmVzX2J1ZmZlciA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQganNvbiB0byBzdHJpbmcgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX2FyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbl9hcmdzID0gKGpzb25fYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2FyZ3MgPSBzZWxmLm1vZHVsZS5zdGFja0FsbG9jKGxlbl9hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLnN0cmluZ1RvVVRGOChqc29uX2FyZ3MsIHB0cl9hcmdzLCBsZW5fYXJncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgc2V0IGZ1bmN0aW9uIGFuZCBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubW9kdWxlLl9zZXQoc2VsZi5lbnRyeSwgcHRyX2FyZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNBdHRyaWJ1dGUoXCJjb25uZWN0aW9uc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goXCJjb25uZWN0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2V0X2FyZ3MgPSBKU09OLnN0cmluZ2lmeShwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldF9hcmdzX2xlbiA9IChnZXRfYXJncy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2dldF9hcmdzID0gc2VsZi5tb2R1bGUuc3RhY2tBbGxvYyhnZXRfYXJnc19sZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1vZHVsZS5zdHJpbmdUb1VURjgoZ2V0X2FyZ3MsIHB0cl9nZXRfYXJncywgZ2V0X2FyZ3NfbGVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHRyX2RhdGEgPSBzZWxmLm1vZHVsZS5fZ2V0KHNlbGYuZW50cnksIHB0cl9nZXRfYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3JlcyA9IHNlbGYubW9kdWxlLlVURjhUb1N0cmluZyhwdHJfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBqc29uX3Jlc19wYXJzZWQgPSBKU09OLnBhcnNlKGpzb25fcmVzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJfb3V0LmJ1ZmZlcl91OF0sIHt0eXBlIDogXCJ2aWRlby9tcDRcIn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5fcmVzb2x2ZShzZWxmLnNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdzcmMnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXNpbmcnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2l0aCc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnc3JjJywgJ3VzaW5nJywgJ3dpdGgnXTsgfVxufVxuXG5leHBvcnQgeyBVbml2ZXJzYWxWaWRlbyB9IiwiaW1wb3J0IHsgbWVtaW8gfSBmcm9tIFwiLi9jb3JlLWNvZGVyLmpzXCJcblxuY2xhc3MgYnVmZmVyIHtcbiAgICBidWZmZXI6QXJyYXlCdWZmZXI7XG4gICAgYnVmZmVyX3U4OlVpbnQ4QXJyYXk7XG4gICAgZmlsZV9pbzpzdHJpbmc7XG4gICAgcDpudW1iZXIgPSAwO1xuICAgIG5iX3JlZnM6bnVtYmVyID0gMDtcbiAgICBzcmM6c3RyaW5nO1xuICAgIHNyY19wdHI6YW55O1xuICAgIHdyaXRlIDogQm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHNyYzpzdHJpbmcsIHNyY19wdHI6YW55LCB3cml0ZTpCb29sZWFuKSB7XG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgICB0aGlzLnNyY19wdHIgPSBzcmNfcHRyO1xuICAgICAgICB0aGlzLndyaXRlID0gd3JpdGU7XG4gICAgfVxuXG4gICAgb3Blbihtb2RlOnN0cmluZyl7XG4gICAgICAgIHN3aXRjaChtb2RlWzBdKXtcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJfdTggPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJfdTggPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNpemUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyX3U4Lmxlbmd0aDtcbiAgICB9XG59XG5cbmNsYXNzIGZpbGVpb3tcbiAgICBmZXRjaF9wcm9taXNlczpQcm9taXNlPFJlc3BvbnNlPltdPSBuZXcgQXJyYXkoKTtcbiAgICBidWZmZXJfcHJvbWlzZXM6UHJvbWlzZTxBcnJheUJ1ZmZlcj5bXT0gbmV3IEFycmF5KCk7XG4gICAgaW9fY3R4czpidWZmZXJbXT0gbmV3IEFycmF5KCk7XG4gICAgbW9kdWxlOmFueTtcbiAgICByZWFkOmFueTtcbiAgICB3cml0ZTphbnk7XG4gICAgc2Vlazphbnk7XG4gICAgdGVsbDphbnk7XG4gICAgZW9mOmFueTtcbiAgICBwcmludGY6YW55O1xuICAgIG9wZW46YW55O1xuICAgIHJlYWRvbmx5IFNFRUtfU0VUID0gMDtcbiAgICByZWFkb25seSBTRUVLX0NVUiA9IDE7XG4gICAgcmVhZG9ubHkgU0VFS19FTkQgPSAyO1xuXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVJTygpO1xuICAgIH1cblxuICAgIGNyZWF0ZUlPKCl7XG4gICAgICAgIHRoaXMucmVhZCA9IGZ1bmN0aW9uIChmaWxlaW8sIGJ1ZmZlciwgYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlvY3R4X2lkID0gdGhpcy5tb2R1bGUuX2dmX2ZpbGVpb19nZXRfdWR0YShmaWxlaW8pO1xuICAgICAgICAgICAgY29uc3QgbWVtID0gdGhpcy5pb19jdHhzW2lvY3R4X2lkXTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlYWRpbmcgZnJvbSBcIittZW0ucCtcIiB0byBcIisgKG1lbS5wK2J5dGVzKSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gbWVtLmJ1ZmZlcl91OC5sZW5ndGggLSBtZW0ucDtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoYnl0ZXMgPiByZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZHVsZS5IRUFQVTguc2V0KG1lbS5idWZmZXJfdTguc2xpY2UobWVtLnAsIG1lbS5wICsgcmVtYWluaW5nKSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBtZW0ucCArPSByZW1haW5pbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm1vZHVsZS5IRUFQVTguc2V0KG1lbS5idWZmZXJfdTguc2xpY2UobWVtLnAsIG1lbS5wICsgYnl0ZXMpLCBidWZmZXIpO1xuICAgICAgICAgICAgbWVtLnAgKz0gYnl0ZXM7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnJlYWQuc2lnID0gWydpJywgJ2knLCAnaScsJ2knXTtcblxuICAgICAgICB0aGlzLndyaXRlID0gZnVuY3Rpb24gKGZpbGVpbywgYnVmZmVyLCBieXRlcykge1xuICAgICAgICAgICAgY29uc3QgaW9jdHhfaWQgPSB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX2dldF91ZHRhKGZpbGVpbyk7XG4gICAgICAgICAgICBjb25zdCBtZW0gPSB0aGlzLmlvX2N0eHNbaW9jdHhfaWRdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwid3JpdGUgZnJvbSBcIittZW0ucCtcIiB0byBcIisgKG1lbS5wK2J5dGVzKSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gbWVtLmJ1ZmZlcl91OC5sZW5ndGggLSBtZW0ucDtcblxuICAgICAgICAgICAgaWYgKGJ5dGVzID4gcmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld19zaXplID0gYnl0ZXMgKyBtZW0uYnVmZmVyX3U4Lmxlbmd0aCAtIHJlbWFpbmluZztcbiAgICAgICAgICAgICAgICBsZXQgb2xkX2J1ZmZlciA9IG1lbS5idWZmZXJfdTg7XG4gICAgICAgICAgICAgICAgbWVtLmJ1ZmZlcl91OCA9IG5ldyBVaW50OEFycmF5KG5ld19zaXplKTtcbiAgICAgICAgICAgICAgICBtZW0uYnVmZmVyX3U4LnNldChvbGRfYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbWVtLmJ1ZmZlcl91OC5zZXQodGhpcy5tb2R1bGUuSEVBUFU4LnNsaWNlKGJ1ZmZlciwgYnVmZmVyICtieXRlcyksIG1lbS5wKTtcbiAgICAgICAgICAgIG1lbS5wICs9IGJ5dGVzO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMud3JpdGUuc2lnID0gWydpJywgJ2knLCAnaScsJ2knXTtcblxuICAgICAgICB0aGlzLnNlZWsgPSBmdW5jdGlvbiAoZmlsZWlvLCBvZmZzZXQsIHdoZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgaW9jdHhfaWQgPSB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX2dldF91ZHRhKGZpbGVpbyk7XG4gICAgICAgICAgICBjb25zdCBtZW0gPSB0aGlzLmlvX2N0eHNbaW9jdHhfaWRdO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic2VlayBmcm9tIFwiK29mZnNldCtcIiB3aXRoIFwiKyB3aGVuY2UpO1xuICAgICAgICAgICAgc3dpdGNoICh3aGVuY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU0VFS19TRVQ6XG4gICAgICAgICAgICAgICAgICAgIG1lbS5wID0gTnVtYmVyKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TRUVLX0NVUjpcbiAgICAgICAgICAgICAgICAgICAgbWVtLnAgKz0gTnVtYmVyKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TRUVLX0VORDpcbiAgICAgICAgICAgICAgICAgICAgbWVtLnAgPSBtZW0uYnVmZmVyX3U4Lmxlbmd0aCArIE51bWJlcihvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2Vlay5zaWcgPSBbJ2knLCAnaScsICdqJywnaSddO1xuXG4gICAgICAgIHRoaXMudGVsbCA9IGZ1bmN0aW9uIChmaWxlaW8pIHtcbiAgICAgICAgICAgIGNvbnN0IGlvY3R4X2lkID0gdGhpcy5tb2R1bGUuX2dmX2ZpbGVpb19nZXRfdWR0YShmaWxlaW8pO1xuICAgICAgICAgICAgY29uc3QgbWVtID0gdGhpcy5pb19jdHhzW2lvY3R4X2lkXTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRlbGwgOiBcIiArIG1lbS5wKTtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQobWVtLnApO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGVsbC5zaWcgPSBbJ2onLCAnaSddO1xuXG4gICAgICAgIHRoaXMuZW9mID0gZnVuY3Rpb24gKGZpbGVpbykge1xuICAgICAgICAgICAgY29uc3QgaW9jdHhfaWQgPSB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX2dldF91ZHRhKGZpbGVpbyk7XG4gICAgICAgICAgICBjb25zdCBtZW0gPSB0aGlzLmlvX2N0eHNbaW9jdHhfaWRdO1xuXG4gICAgICAgICAgICAvKmlmKG1lbS5wID09IG1lbS5idWZmZXJfdTgubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVvZiAgOiB0cnVlXCIpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlb2YgIDogZmFsc2VcIik7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG1lbS5wID09IG1lbS5idWZmZXJfdTgubGVuZ3RoO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZW9mLnNpZyA9IFsnaScsICdpJ107XG5cbiAgICAgICAgdGhpcy5wcmludGYgPSBmdW5jdGlvbiAoZmlsZWlvLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJpbnRmICBcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1lbWlvIHByaW50ZiBoYXMgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaW50Zi5zaWcgPSBbJ2knLCdpJywnaScsICdpJ107XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAoZmlsZWlvX3JlZiwgdXJsX3B0ciwgbW9kZV9wdHIsIG91dF9lcnIpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJvcGVuICBcIik7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZHVsZS5VVEY4VG9TdHJpbmcobW9kZV9wdHIpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5tb2R1bGUuVVRGOFRvU3RyaW5nKHVybF9wdHIpO1xuICAgICAgICAgICAgY29uc3QgaW9jdHhfaWQgPSB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX2dldF91ZHRhKGZpbGVpb19yZWYpO1xuICAgICAgICAgICAgY29uc3QgY3VyX2J1ZmZlciA9IHRoaXMuaW9fY3R4c1tpb2N0eF9pZF07XG5cbiAgICAgICAgICAgIHRoaXMubW9kdWxlLkhFQVAzMlsoKG91dF9lcnIpPj4yKV0gPSAwOyAvL0dGX09LXG5cbiAgICAgICAgICAgIGlmIChtb2RlID09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICBjdXJfYnVmZmVyLm5iX3JlZnMrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZWlvX3JlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJ1bnJlZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJfYnVmZmVyLm5iX3JlZnMpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIGN1cl9idWZmZXIubmJfcmVmcy0tO1xuICAgICAgICAgICAgICAgIGlmIChjdXJfYnVmZmVyLm5iX3JlZnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlaW9fcmVmO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlLkhFQVA4W3VybF0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZSA9PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cmxfcHRyKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoX3B0ciA9IHRoaXMubW9kdWxlLl9nZl91cmxfY29uY2F0ZW5hdGUoY3VyX2J1ZmZlci5zcmNfcHRyLCB1cmxfcHRyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5tb2R1bGUuVVRGOFRvU3RyaW5nKHBhdGhfcHRyKTtcblxuICAgICAgICAgICAgICAgIGxldCBuZXdfYnVmZmVyID0gbmV3IGJ1ZmZlcihwYXRoLCBwYXRoX3B0ciwgY3VyX2J1ZmZlci5pc19pbnB1dCk7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcl9pZHggPSB0aGlzLmlvX2N0eHMucHVzaChuZXdfYnVmZmVyKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGdmaW8gPSB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX25ldyhwYXRoX3B0ciwgYnVmZmVyX2lkeCAtIDEsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4udmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlZWsudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWQudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlLnZhbHVlLCBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZWxsLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVvZi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmludGYudmFsdWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBnZmlvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9kZSA9PSBcInByb2JlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubW9kdWxlLl9nZl9maWxlX2V4aXN0cyh1cmxfcHRyKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlLkhFQVAzMlsoKG91dF9lcnIpPj4yKV0gPSAtMTI7IC8vR0ZfVVJMX0VSUk9SXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXVybF9wdHIpIHtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJfYnVmZmVyLm5iX3JlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pb19jdHhzLnNwbGljZShpb2N0eF9pZCwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZmlsZSBoYW5kbGUgbm90IG9wZW5lZCwgd2UgY2FuIHVzZSB0aGUgY3VycmVudCBnZmlvXG4gICAgICAgICAgICBpZiAoIWN1cl9idWZmZXIuYnVmZmVyX3U4ICYmIHVybC5zdGFydHNXaXRoKFwiZ2ZpbzovL1wiKSB8fCB1cmwgPT0gY3VyX2J1ZmZlci5zcmMgKSB7XG4gICAgICAgICAgICAgICAgY3VyX2J1ZmZlci5vcGVuKG1vZGUpO1xuXG4gICAgICAgICAgICAgICAgLy9pbiB0ZXN0IG1vZGUgd2Ugd2FudCB0byB1c2Ugb3VyIGZ0ZWxsIGFuZCBmc2VlayB3cmFwcGVyc1xuICAgICAgICAgICAgICAgIGlmIChtb2RlWzBdID09ICdyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZHVsZS5fZ2ZfZmlsZWlvX3NldF9zdGF0c191MzIoZmlsZWlvX3JlZiwgY3VyX2J1ZmZlci5zaXplKCksY3VyX2J1ZmZlci5zaXplKCksIDEsIDApOyAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZWlvX3JlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdmaW89IG51bGw7XG4gICAgICAgICAgICBsZXQgaW9jdHg9IG51bGw7XG4gICAgICAgICAgICBsZXQgaW9jdHhfaWR4PSAwO1xuICAgICAgICAgICAgbGV0IG5vX2NvbmNhdGVuYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV3X2J1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8IHRoaXMuaW9fY3R4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlvY3R4ID0gdGhpcy5pb19jdHhzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpb2N0eC5zcmMgPT0gdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpb2N0eC5idWZmZXJfdTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vX2NvbmNhdGVuYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlvY3R4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpb2N0eF9pZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW9jdHggPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlvY3R4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhdGhfcHRyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoXCJnZmlvOi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub19jb25jYXRlbmF0ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoX3B0ciA9IHRoaXMubW9kdWxlLl9nZl9zdHJkdXAodXJsX3B0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhfcHRyID0gdGhpcy5tb2R1bGUuX2dmX3VybF9jb25jYXRlbmF0ZShjdXJfYnVmZmVyLnNyY19wdHIsIHVybF9wdHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoX3B0ciA9IHRoaXMubW9kdWxlLmdmX3N0cmR1cChjdXJfYnVmZmVyLnNyY19wdHIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld19idWZmZXIgPSBuZXcgYnVmZmVyKHVybCwgcGF0aF9wdHIsIGN1cl9idWZmZXIuaXNfaW5wdXQpO1xuICAgICAgICAgICAgICAgIG5ld19idWZmZXIuYnVmZmVyID0gY3VyX2J1ZmZlci5idWZmZXI7XG4gICAgICAgICAgICAgICAgbmV3X2J1ZmZlci5vcGVuKG1vZGUpO1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXJfaWR4ID0gdGhpcy5pb19jdHhzLnB1c2gobmV3X2J1ZmZlcik7XG4gICAgICAgICAgICAgICAgZ2ZpbyA9IHRoaXMubW9kdWxlLl9nZl9maWxlaW9fbmV3KHBhdGhfcHRyLCBidWZmZXJfaWR4IC0gMSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vlay52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZC52YWx1ZSwgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGUudmFsdWUsIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbGwudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW9mLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW50Zi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVbMF0gPT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlLl9nZl9maWxlaW9fc2V0X3N0YXRzX3UzMihmaWxlaW9fcmVmLCBjdXJfYnVmZmVyLnNpemUoKSxjdXJfYnVmZmVyLnNpemUoKSwgMSwgMCk7ICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2ZpbztcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZW4uc2lnID0gWydpJywnaScsJ2knLCdpJywgJ2knXTtcbiAgICAgICAgbWVtaW8ucHVzaCh0aGlzLnJlYWQsIHRoaXMud3JpdGUsIHRoaXMub3BlbiwgdGhpcy5zZWVrLCB0aGlzLnRlbGwsdGhpcy5lb2YsdGhpcy5wcmludGYsIHRoaXMub3BlbilcbiAgICB9XG5cbiAgICBtYWtlX2ZpbGVpbyAoc3JjIDogc3RyaW5nLCBpc19pbnB1dCA6IEJvb2xlYW4pe1xuXG4gICAgICAgIGNvbnN0IGxlbl9zb3VyY2Vfc3RyID0gKHNyYy5sZW5ndGggPDwgMikgKyAxO1xuICAgICAgICBjb25zdCBwdHJfc291cmNlX3N0ciA9IHRoaXMubW9kdWxlLnN0YWNrQWxsb2MobGVuX3NvdXJjZV9zdHIpO1xuICAgICAgICB0aGlzLm1vZHVsZS5zdHJpbmdUb1VURjgoc3JjLCBwdHJfc291cmNlX3N0ciwgbGVuX3NvdXJjZV9zdHIpO1xuXG4gICAgICAgIGxldCBuZXdfYnVmZmVyID0gbmV3IGJ1ZmZlcihzcmMsIHB0cl9zb3VyY2Vfc3RyLCBpc19pbnB1dCk7XG4gICAgICAgIGxldCBidWZmZXJfaWR4ID0gdGhpcy5pb19jdHhzLnB1c2gobmV3X2J1ZmZlcik7XG4gICAgXG4gICAgICAgIGNvbnN0IGZpbyA9IHRoaXMubW9kdWxlLl9nZl9maWxlaW9fbmV3KHB0cl9zb3VyY2Vfc3RyLCBidWZmZXJfaWR4IC0gMSwgXG4gICAgICAgICAgICB0aGlzLm9wZW4udmFsdWUsIFxuICAgICAgICAgICAgdGhpcy5zZWVrLnZhbHVlLCBcbiAgICAgICAgICAgIHRoaXMucmVhZC52YWx1ZSwgXG4gICAgICAgICAgICB0aGlzLndyaXRlLnZhbHVlLCBcbiAgICAgICAgICAgIHRoaXMudGVsbC52YWx1ZSxcbiAgICAgICAgICAgIHRoaXMuZW9mLnZhbHVlLFxuICAgICAgICAgICAgdGhpcy5wcmludGYudmFsdWUpO1xuXG4gICAgICAgIGNvbnN0IGZpb191cmxfcHRyID0gdGhpcy5tb2R1bGUuX2dmX2ZpbGVpb191cmwoZmlvKTtcblxuICAgICAgICBpZiAoaXNfaW5wdXQpe1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hfcHJvbWlzZSA9IGZldGNoKHNyYyk7XG4gICAgICAgICAgICB0aGlzLmZldGNoX3Byb21pc2VzLnB1c2goZmV0Y2hfcHJvbWlzZSk7XG4gICAgICAgICAgICBmZXRjaF9wcm9taXNlLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcl9wcm9taXNlID0gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcl9wcm9taXNlcy5wdXNoKGJ1ZmZlcl9wcm9taXNlKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcl9wcm9taXNlLnRoZW4oIGJ1ZmZlciA9PntcbiAgICAgICAgICAgICAgICAgICAgbmV3X2J1ZmZlci5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbmV3X2J1ZmZlci5maWxlX2lvID0gdGhpcy5tb2R1bGUuVVRGOFRvU3RyaW5nKGZpb191cmxfcHRyKTtcbiAgICAgICAgcmV0dXJuIG5ld19idWZmZXI7XG4gICAgfVxufVxuXG5leHBvcnQge2ZpbGVpb31cbiIsInZhciBtYXAgPSB7XG5cdFwiLi9sb2dcIjogXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2hvdC9sb2cuanNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3Qgc3luYyBeXFxcXC5cXFxcL2xvZyRcIjsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZE8gPSB7fTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG1vZHVsZSk7XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgJ2V4cG9ydHMnLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRzZXQ6ICgpID0+IHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRVMgTW9kdWxlcyBtYXkgbm90IGFzc2lnbiBtb2R1bGUuZXhwb3J0cyBvciBleHBvcnRzLiosIFVzZSBFU00gZXhwb3J0IHN5bnRheCwgaW5zdGVhZDogJyArIG1vZHVsZS5pZCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCIvL2ltcG9ydCB7VW5pdmVyc2FsQ2FudmFzfSBmcm9tIFwiLi9VQ2FudmFzXCJcbmltcG9ydCB7VW5pdmVyc2FsSW1hZ2V9IGZyb20gXCIuL1VJbWFnZVwiXG5pbXBvcnQge1VuaXZlcnNhbEF1ZGlvfSBmcm9tIFwiLi9VQXVkaW9cIlxuaW1wb3J0IHtVbml2ZXJzYWxWaWRlb30gZnJvbSBcIi4vVVZpZGVvXCJcbmltcG9ydCB7VW5pdmVyc2FsQ2FudmFzfSBmcm9tIFwiLi9VQ2FudmFzXCJcblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ3VuaXZlcnNhbC1pbWcnKSkge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgndW5pdmVyc2FsLWltZycsIFVuaXZlcnNhbEltYWdlLCB7IGV4dGVuZHM6ICdpbWcnIH0pO1xufVxuXG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldCgndW5pdmVyc2FsLWF1ZGlvJykpIHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUoJ3VuaXZlcnNhbC1hdWRpbycsIFVuaXZlcnNhbEF1ZGlvLCB7IGV4dGVuZHM6ICdhdWRpbycgfSk7XG59XG5cbmlmICghY3VzdG9tRWxlbWVudHMuZ2V0KCd1bml2ZXJzYWwtdmlkZW8nKSkge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgndW5pdmVyc2FsLXZpZGVvJywgVW5pdmVyc2FsVmlkZW8sIHsgZXh0ZW5kczogJ3ZpZGVvJyB9KTtcbn1cblxuaWYgKCFjdXN0b21FbGVtZW50cy5nZXQoJ3VuaXZlcnNhbC1jYW52YXMnKSkge1xuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgndW5pdmVyc2FsLWNhbnZhcycsIFVuaXZlcnNhbENhbnZhcywgeyBleHRlbmRzOiAnY2FudmFzJyB9KTtcbn0iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxuLyogZXNsaW50IHByZWZlci1kZXN0cnVjdHVyaW5nOiBvZmYgKi9cblxudmFyIHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcblxudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbnZhciBvdmVybGF5ID0gcmVxdWlyZSgnLi9vdmVybGF5Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nLFxuICAgIHNldExvZ0xldmVsID0gX3JlcXVpcmUuc2V0TG9nTGV2ZWw7XG5cbnZhciBzZW5kTWVzc2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMvc2VuZE1lc3NhZ2UnKTtcblxudmFyIHJlbG9hZEFwcCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVsb2FkQXBwJyk7XG5cbnZhciBjcmVhdGVTb2NrZXRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVNvY2tldFVybCcpO1xuXG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIGN1cnJlbnRIYXNoOiAnJ1xufTtcbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBob3RSZWxvYWQ6IHRydWUsXG4gIGxpdmVSZWxvYWQ6IGZhbHNlLFxuICBpbml0aWFsOiB0cnVlLFxuICB1c2VXYXJuaW5nT3ZlcmxheTogZmFsc2UsXG4gIHVzZUVycm9yT3ZlcmxheTogZmFsc2UsXG4gIHVzZVByb2dyZXNzOiBmYWxzZVxufTtcbnZhciBzb2NrZXRVcmwgPSBjcmVhdGVTb2NrZXRVcmwoX19yZXNvdXJjZVF1ZXJ5KTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIG9wdGlvbnMuaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xufVxuXG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBvcHRpb25zLmhvdCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBMaXZlIFJlbG9hZGluZyBlbmFibGVkLicpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTsgLy8gZml4ZXMgIzEwNDIuIG92ZXJsYXkgZG9lc24ndCBjbGVhciBpZiBlcnJvcnMgYXJlIGZpeGVkIGJ1dCB3YXJuaW5ncyByZW1haW4uXG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMuY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcbiAgJ3N0aWxsLW9rJzogZnVuY3Rpb24gc3RpbGxPaygpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gTm90aGluZyBjaGFuZ2VkLicpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcblxuICAgIGlmIChob3RDdHgua2V5cygpLmluZGV4T2YoJy4vbG9nJykgIT09IC0xKSB7XG4gICAgICBob3RDdHgoJy4vbG9nJykuc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH1cblxuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLnVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy51c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdQcm9ncmVzcycsIGRhdGEpO1xuICB9LFxuICBvazogZnVuY3Rpb24gb2soKSB7XG4gICAgc2VuZE1lc3NhZ2UoJ09rJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZyk7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnV2FybmluZ3MnLCBzdHJpcHBlZFdhcm5pbmdzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX3dhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2koZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF9lcnJvcnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIERpc2Nvbm5lY3RlZCEnKTtcbiAgICBzZW5kTWVzc2FnZSgnQ2xvc2UnKTtcbiAgfVxufTtcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TWVzc2FnZSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9